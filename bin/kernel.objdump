
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <kernel_start>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 66                	in     $0x66,%al
  10000d:	90                   	nop
  10000e:	66 90                	xchg   %ax,%ax

00100010 <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaKernelDev 1.01"

void init(struct multiboot_info* mb_info) {
  100010:	55                   	push   %ebp
  100011:	89 e5                	mov    %esp,%ebp
  100013:	83 ec 28             	sub    $0x28,%esp
  100016:	8b 45 08             	mov    0x8(%ebp),%eax
  100019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	clrscr();
  10001c:	e8 af 04 00 00       	call   1004d0 <clrscr>
	pmm_init(mb_info);
  100021:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100024:	89 04 24             	mov    %eax,(%esp)
  100027:	e8 14 27 00 00       	call   102740 <pmm_init>
  10002c:	8d 05 98 80 10 00    	lea    0x108098,%eax
  100032:	8d 0d bb 80 10 00    	lea    0x1080bb,%ecx

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100038:	89 04 24             	mov    %eax,(%esp)
  10003b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10003f:	e8 0c 05 00 00       	call   100550 <kprintf>
  100044:	8d 0d cf 80 10 00    	lea    0x1080cf,%ecx
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10004a:	89 0c 24             	mov    %ecx,(%esp)
  10004d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100050:	e8 fb 04 00 00       	call   100550 <kprintf>
  100055:	8d 0d 0e 81 10 00    	lea    0x10810e,%ecx

	kprintf("Initializing GDT...\n");
  10005b:	89 0c 24             	mov    %ecx,(%esp)
  10005e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100061:	e8 ea 04 00 00       	call   100550 <kprintf>

	init_gdt();
  100066:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100069:	e8 b2 0a 00 00       	call   100b20 <init_gdt>
  10006e:	8d 05 23 81 10 00    	lea    0x108123,%eax

	kprintf("Initializing IDT...\n");
  100074:	89 04 24             	mov    %eax,(%esp)
  100077:	e8 d4 04 00 00       	call   100550 <kprintf>
  10007c:	8d 0d 38 81 10 00    	lea    0x108138,%ecx

	init_idt();
  100082:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100085:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100088:	e8 b3 0c 00 00       	call   100d40 <init_idt>

	kprintf("Initializing in-kernel-Drivers...\n");
  10008d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100090:	89 04 24             	mov    %eax,(%esp)
  100093:	e8 b8 04 00 00       	call   100550 <kprintf>

	init_drivers();
  100098:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10009b:	e8 30 00 00 00       	call   1000d0 <init_drivers>
  1000a0:	8d 05 5b 81 10 00    	lea    0x10815b,%eax

	kprintf("Initializing Kernel...\n");
  1000a6:	89 04 24             	mov    %eax,(%esp)
  1000a9:	e8 a2 04 00 00       	call   100550 <kprintf>

	pmm_print_stats();
  1000ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1000b1:	e8 9a 24 00 00       	call   102550 <pmm_print_stats>

	kernel_main(mb_info);
  1000b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000b9:	89 04 24             	mov    %eax,(%esp)
  1000bc:	e8 af 21 00 00       	call   102270 <kernel_main>

	return;
  1000c1:	83 c4 28             	add    $0x28,%esp
  1000c4:	5d                   	pop    %ebp
  1000c5:	c3                   	ret    
  1000c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1000cd:	00 00 00 

001000d0 <init_drivers>:
#ifndef DRVINIT_H
#define DRVINIT_H

#include "keyboard.h"

static inline void init_drivers() {
  1000d0:	55                   	push   %ebp
  1000d1:	89 e5                	mov    %esp,%ebp
    init_keyboard_drv();
  1000d3:	83 ec 08             	sub    $0x8,%esp
  1000d6:	e8 05 02 00 00       	call   1002e0 <init_keyboard_drv>
}
  1000db:	83 c4 08             	add    $0x8,%esp
  1000de:	5d                   	pop    %ebp
  1000df:	c3                   	ret    

001000e0 <translate_scancode>:

static uint8_t buffer[4096];
static int bfindex = 0;

uint8_t translate_scancode(int set, uint16_t scancode)
{
  1000e0:	55                   	push   %ebp
  1000e1:	89 e5                	mov    %esp,%ebp
  1000e3:	83 ec 28             	sub    $0x28,%esp
  1000e6:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  1000ea:	66 89 c1             	mov    %ax,%cx
  1000ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1000f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1000f3:	66 89 4d fa          	mov    %cx,-0x6(%ebp)
  uint8_t keycode = 0;
  1000f7:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)

  switch (set) {
  1000fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000fe:	89 c2                	mov    %eax,%edx
  100100:	83 ea 02             	sub    $0x2,%edx
  100103:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100106:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100109:	0f 84 4f 00 00 00    	je     10015e <translate_scancode+0x7e>
  10010f:	e9 00 00 00 00       	jmp    100114 <translate_scancode+0x34>
  100114:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100117:	83 e8 01             	sub    $0x1,%eax
  10011a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10011d:	0f 84 28 00 00 00    	je     10014b <translate_scancode+0x6b>
  100123:	e9 00 00 00 00       	jmp    100128 <translate_scancode+0x48>
  100128:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10012b:	85 c0                	test   %eax,%eax
  10012d:	0f 85 54 00 00 00    	jne    100187 <translate_scancode+0xa7>
  100133:	e9 00 00 00 00       	jmp    100138 <translate_scancode+0x58>
    case 0:
      keycode = sc_to_kc[0][scancode];
  100138:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10013c:	8a 0c 05 00 70 10 00 	mov    0x107000(,%eax,1),%cl
  100143:	88 4d f9             	mov    %cl,-0x7(%ebp)
      break;
  100146:	e9 3c 00 00 00       	jmp    100187 <translate_scancode+0xa7>
    case 1:
      keycode = sc_to_kc[1][scancode];
  10014b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10014f:	8a 0c 05 80 70 10 00 	mov    0x107080(,%eax,1),%cl
  100156:	88 4d f9             	mov    %cl,-0x7(%ebp)
      break;
  100159:	e9 29 00 00 00       	jmp    100187 <translate_scancode+0xa7>
    case 2:
      switch (scancode) {
  10015e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100162:	2d 1d 45 00 00       	sub    $0x451d,%eax
  100167:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10016a:	0f 85 0e 00 00 00    	jne    10017e <translate_scancode+0x9e>
  100170:	e9 00 00 00 00       	jmp    100175 <translate_scancode+0x95>
        case 0x451D:
          keycode = 119;
  100175:	c6 45 f9 77          	movb   $0x77,-0x7(%ebp)
          break;
  100179:	e9 04 00 00 00       	jmp    100182 <translate_scancode+0xa2>

        default:
          keycode = 0x0;	
  10017e:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)
      };
      break;
  100182:	e9 00 00 00 00       	jmp    100187 <translate_scancode+0xa7>
  }

  if (keycode == 0) {
  100187:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  10018b:	3d 00 00 00 00       	cmp    $0x0,%eax
  100190:	0f 85 20 00 00 00    	jne    1001b6 <translate_scancode+0xd6>
  100196:	8d 05 73 81 10 00    	lea    0x108173,%eax
      kprintf("kbc: Unbekannter Scancode: 0x%x (%d)\n", scancode, set);
  10019c:	0f b7 4d fa          	movzwl -0x6(%ebp),%ecx
  1001a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1001a3:	89 04 24             	mov    %eax,(%esp)
  1001a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1001aa:	89 54 24 08          	mov    %edx,0x8(%esp)
  1001ae:	e8 9d 03 00 00       	call   100550 <kprintf>
  1001b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }

  return keycode;
  1001b6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  1001ba:	83 c4 28             	add    $0x28,%esp
  1001bd:	5d                   	pop    %ebp
  1001be:	c3                   	ret    
  1001bf:	90                   	nop

001001c0 <keyboard_handler>:
}

void keyboard_handler() {    
  1001c0:	55                   	push   %ebp
  1001c1:	89 e5                	mov    %esp,%ebp
  return;
  1001c3:	5d                   	pop    %ebp
  1001c4:	c3                   	ret    
  1001c5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1001cc:	00 00 00 00 

001001d0 <getc>:
		//buffer[bfindex] = keycode;
		//bfindex++;	
	}
}

char getc() {
  1001d0:	55                   	push   %ebp
  1001d1:	89 e5                	mov    %esp,%ebp
	char ret = buffer[0];
  1001d3:	83 ec 08             	sub    $0x8,%esp
  1001d6:	a0 0a 90 10 00       	mov    0x10900a,%al
  1001db:	88 45 ff             	mov    %al,-0x1(%ebp)
	
	int i;
	for(i = 0; i < bfindex; i++) {
  1001de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001e8:	3b 05 0c a0 10 00    	cmp    0x10a00c,%eax
  1001ee:	0f 8d 24 00 00 00    	jge    100218 <getc+0x48>
		buffer[i] = buffer[i+1];	
  1001f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001f7:	8a 0c 05 0b 90 10 00 	mov    0x10900b(,%eax,1),%cl
  1001fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100201:	88 0c 05 0a 90 10 00 	mov    %cl,0x10900a(,%eax,1)

char getc() {
	char ret = buffer[0];
	
	int i;
	for(i = 0; i < bfindex; i++) {
  100208:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10020b:	05 01 00 00 00       	add    $0x1,%eax
  100210:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100213:	e9 cd ff ff ff       	jmp    1001e5 <getc+0x15>
		buffer[i] = buffer[i+1];	
	}
	bfindex--;
  100218:	a1 0c a0 10 00       	mov    0x10a00c,%eax
  10021d:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100222:	a3 0c a0 10 00       	mov    %eax,0x10a00c

	return ret;
  100227:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  10022b:	83 c4 08             	add    $0x8,%esp
  10022e:	5d                   	pop    %ebp
  10022f:	c3                   	ret    

00100230 <send_command>:
}

void send_command(uint8_t command) {
  100230:	55                   	push   %ebp
  100231:	89 e5                	mov    %esp,%ebp
  100233:	83 ec 18             	sub    $0x18,%esp
  100236:	8a 45 08             	mov    0x8(%ebp),%al
  100239:	88 45 ff             	mov    %al,-0x1(%ebp)
  10023c:	b8 64 00 00 00       	mov    $0x64,%eax
	while((inb(0x64) & 0x2)) { }
  100241:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100248:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10024b:	e8 40 00 00 00       	call   100290 <inb>
  100250:	0f b6 c8             	movzbl %al,%ecx
  100253:	81 e1 02 00 00 00    	and    $0x2,%ecx
  100259:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  10025f:	0f 84 05 00 00 00    	je     10026a <send_command+0x3a>
  100265:	e9 d2 ff ff ff       	jmp    10023c <send_command+0xc>
  10026a:	b8 60 00 00 00       	mov    $0x60,%eax
	outb(0x60, command);
  10026f:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100276:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  10027a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10027e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100281:	e8 2a 00 00 00       	call   1002b0 <outb>
}
  100286:	83 c4 18             	add    $0x18,%esp
  100289:	5d                   	pop    %ebp
  10028a:	c3                   	ret    
  10028b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00100290 <inb>:
    uint16_t result;
    asm volatile ("inw %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline uint8_t inb(uint16_t _port) {
  100290:	55                   	push   %ebp
  100291:	89 e5                	mov    %esp,%ebp
  100293:	50                   	push   %eax
  100294:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100298:	66 89 c1             	mov    %ax,%cx
  10029b:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
    uint8_t result;
    asm volatile ("inb %1, %0" : "=a" (result) : "Nd" (_port));
  10029f:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1002a3:	ec                   	in     (%dx),%al
  1002a4:	88 45 fd             	mov    %al,-0x3(%ebp)
    return result;
  1002a7:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  1002ab:	83 c4 04             	add    $0x4,%esp
  1002ae:	5d                   	pop    %ebp
  1002af:	c3                   	ret    

001002b0 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  1002b0:	55                   	push   %ebp
  1002b1:	89 e5                	mov    %esp,%ebp
  1002b3:	50                   	push   %eax
  1002b4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1002b8:	66 89 c1             	mov    %ax,%cx
  1002bb:	8a 55 0c             	mov    0xc(%ebp),%dl
  1002be:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  1002c2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  1002c5:	8a 45 fd             	mov    -0x3(%ebp),%al
  1002c8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1002cc:	ee                   	out    %al,(%dx)
}
  1002cd:	83 c4 04             	add    $0x4,%esp
  1002d0:	5d                   	pop    %ebp
  1002d1:	c3                   	ret    
  1002d2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1002d9:	1f 84 00 00 00 00 00 

001002e0 <init_keyboard_drv>:

void init_keyboard_drv() {
  1002e0:	55                   	push   %ebp
  1002e1:	89 e5                	mov    %esp,%ebp
  1002e3:	83 ec 28             	sub    $0x28,%esp
  1002e6:	b8 21 00 00 00       	mov    $0x21,%eax
  1002eb:	8d 0d c0 01 10 00    	lea    0x1001c0,%ecx
	register_intr_handler(0x21, &keyboard_handler);
  1002f1:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1002f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1002fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1002ff:	e8 6c 16 00 00       	call   101970 <register_intr_handler>
  100304:	b8 64 00 00 00       	mov    $0x64,%eax

	while(inb(0x64) & 0x1) {
  100309:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100310:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100313:	e8 78 ff ff ff       	call   100290 <inb>
  100318:	0f b6 c8             	movzbl %al,%ecx
  10031b:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100321:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100327:	0f 84 1c 00 00 00    	je     100349 <init_keyboard_drv+0x69>
  10032d:	b8 60 00 00 00       	mov    $0x60,%eax
		inb(0x60);
  100332:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100339:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10033c:	e8 4f ff ff ff       	call   100290 <inb>
	}
  100341:	88 45 f3             	mov    %al,-0xd(%ebp)
  100344:	e9 bb ff ff ff       	jmp    100304 <init_keyboard_drv+0x24>
  100349:	b8 f4 00 00 00       	mov    $0xf4,%eax

	send_command(0xF4);
  10034e:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp)
  100355:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100358:	e8 d3 fe ff ff       	call   100230 <send_command>

	init_done = 1;
  10035d:	c7 05 10 a0 10 00 01 	movl   $0x1,0x10a010
  100364:	00 00 00 
}
  100367:	83 c4 28             	add    $0x28,%esp
  10036a:	5d                   	pop    %ebp
  10036b:	c3                   	ret    
  10036c:	66 90                	xchg   %ax,%ax
  10036e:	66 90                	xchg   %ax,%ax

00100370 <show_cod>:
#include "catofdeath.h"

void show_cod(struct cpu_state* cpu, char* fstr) {
  100370:	55                   	push   %ebp
  100371:	89 e5                	mov    %esp,%ebp
  100373:	56                   	push   %esi
  100374:	83 ec 24             	sub    $0x24,%esp
  100377:	8b 45 0c             	mov    0xc(%ebp),%eax
  10037a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10037d:	ba 04 00 00 00       	mov    $0x4,%edx
  100382:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100385:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
  100388:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10038f:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100392:	e8 99 01 00 00       	call   100530 <setclr>
    kprintf(fstr);
  100397:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10039a:	89 04 24             	mov    %eax,(%esp)
  10039d:	e8 ae 01 00 00       	call   100550 <kprintf>
  1003a2:	8d 0d 99 81 10 00    	lea    0x108199,%ecx
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  1003a8:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1003ab:	8b 52 1c             	mov    0x1c(%edx),%edx
  1003ae:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1003b1:	8b 76 20             	mov    0x20(%esi),%esi
  1003b4:	89 0c 24             	mov    %ecx,(%esp)
  1003b7:	89 54 24 04          	mov    %edx,0x4(%esp)
  1003bb:	89 74 24 08          	mov    %esi,0x8(%esp)
  1003bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1003c2:	e8 89 01 00 00       	call   100550 <kprintf>
    show_dump(cpu);
  1003c7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1003ca:	89 0c 24             	mov    %ecx,(%esp)
  1003cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1003d0:	e8 0b 00 00 00       	call   1003e0 <show_dump>

    while (1) {
        asm volatile("cli; hlt");
  1003d5:	fa                   	cli    
  1003d6:	f4                   	hlt    
    }
  1003d7:	e9 f9 ff ff ff       	jmp    1003d5 <show_cod+0x65>
  1003dc:	0f 1f 40 00          	nopl   0x0(%eax)

001003e0 <show_dump>:
}

void show_dump(struct cpu_state* cpu) {
  1003e0:	55                   	push   %ebp
  1003e1:	89 e5                	mov    %esp,%ebp
  1003e3:	53                   	push   %ebx
  1003e4:	57                   	push   %edi
  1003e5:	56                   	push   %esi
  1003e6:	83 ec 2c             	sub    $0x2c,%esp
  1003e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1003ec:	8d 0d be 81 10 00    	lea    0x1081be,%ecx
  1003f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  1003f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1003f8:	8b 00                	mov    (%eax),%eax
  1003fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1003fd:	8b 52 04             	mov    0x4(%edx),%edx
  100400:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100403:	8b 76 08             	mov    0x8(%esi),%esi
  100406:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100409:	8b 7f 0c             	mov    0xc(%edi),%edi
  10040c:	89 0c 24             	mov    %ecx,(%esp)
  10040f:	89 44 24 04          	mov    %eax,0x4(%esp)
  100413:	89 54 24 08          	mov    %edx,0x8(%esp)
  100417:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10041b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10041f:	e8 2c 01 00 00       	call   100550 <kprintf>
  100424:	8d 0d df 81 10 00    	lea    0x1081df,%ecx
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  10042a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10042d:	8b 52 10             	mov    0x10(%edx),%edx
  100430:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100433:	8b 76 14             	mov    0x14(%esi),%esi
  100436:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100439:	8b 7f 18             	mov    0x18(%edi),%edi
  10043c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10043f:	8b 5b 24             	mov    0x24(%ebx),%ebx
  100442:	89 0c 24             	mov    %ecx,(%esp)
  100445:	89 54 24 04          	mov    %edx,0x4(%esp)
  100449:	89 74 24 08          	mov    %esi,0x8(%esp)
  10044d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  100451:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  100455:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100458:	e8 f3 00 00 00       	call   100550 <kprintf>
  10045d:	8d 0d 00 82 10 00    	lea    0x108200,%ecx
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
  100463:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100466:	8b 52 28             	mov    0x28(%edx),%edx
  100469:	8b 75 f0             	mov    -0x10(%ebp),%esi
  10046c:	8b 76 2c             	mov    0x2c(%esi),%esi
  10046f:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100472:	8b 7f 30             	mov    0x30(%edi),%edi
  100475:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  100478:	8b 5b 34             	mov    0x34(%ebx),%ebx
  10047b:	89 0c 24             	mov    %ecx,(%esp)
  10047e:	89 54 24 04          	mov    %edx,0x4(%esp)
  100482:	89 74 24 08          	mov    %esi,0x8(%esp)
  100486:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10048a:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10048e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100491:	e8 ba 00 00 00       	call   100550 <kprintf>
  100496:	8d 0d 22 82 10 00    	lea    0x108222,%ecx
            cpu->esp, cpu->ss);

    uint32_t cr2 = 0;
  10049c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  1004a3:	0f 20 d2             	mov    %cr2,%edx
  1004a6:	89 55 ec             	mov    %edx,-0x14(%ebp)

    kprintf("CR2: %x \n", cr2);
  1004a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1004ac:	89 0c 24             	mov    %ecx,(%esp)
  1004af:	89 54 24 04          	mov    %edx,0x4(%esp)
  1004b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1004b6:	e8 95 00 00 00       	call   100550 <kprintf>
}
  1004bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1004be:	83 c4 2c             	add    $0x2c,%esp
  1004c1:	5e                   	pop    %esi
  1004c2:	5f                   	pop    %edi
  1004c3:	5b                   	pop    %ebx
  1004c4:	5d                   	pop    %ebp
  1004c5:	c3                   	ret    
  1004c6:	66 90                	xchg   %ax,%ax
  1004c8:	66 90                	xchg   %ax,%ax
  1004ca:	66 90                	xchg   %ax,%ax
  1004cc:	66 90                	xchg   %ax,%ax
  1004ce:	66 90                	xchg   %ax,%ax

001004d0 <clrscr>:
        x /= base;
    } while (x);
    kputs(p);
}

void clrscr(void) {
  1004d0:	55                   	push   %ebp
  1004d1:	89 e5                	mov    %esp,%ebp
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  1004d3:	50                   	push   %eax
  1004d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1004db:	81 7d fc a0 0f 00 00 	cmpl   $0xfa0,-0x4(%ebp)
  1004e2:	0f 8d 1d 00 00 00    	jge    100505 <clrscr+0x35>
        video[i] = 0;
  1004e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004eb:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  1004f1:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    kputs(p);
}

void clrscr(void) {
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  1004f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004f8:	05 01 00 00 00       	add    $0x1,%eax
  1004fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100500:	e9 d6 ff ff ff       	jmp    1004db <clrscr+0xb>
        video[i] = 0;
    }

    color = 0x07;
  100505:	c6 05 04 71 10 00 07 	movb   $0x7,0x107104

    x = y = 0;
  10050c:	c7 05 14 a0 10 00 00 	movl   $0x0,0x10a014
  100513:	00 00 00 
  100516:	c7 05 18 a0 10 00 00 	movl   $0x0,0x10a018
  10051d:	00 00 00 
}
  100520:	83 c4 04             	add    $0x4,%esp
  100523:	5d                   	pop    %ebp
  100524:	c3                   	ret    
  100525:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10052c:	00 00 00 00 

00100530 <setclr>:

void setclr(char clr) {
  100530:	55                   	push   %ebp
  100531:	89 e5                	mov    %esp,%ebp
  100533:	50                   	push   %eax
  100534:	8a 45 08             	mov    0x8(%ebp),%al
  100537:	88 45 ff             	mov    %al,-0x1(%ebp)
    color = clr;
  10053a:	8a 45 ff             	mov    -0x1(%ebp),%al
  10053d:	a2 04 71 10 00       	mov    %al,0x107104
}
  100542:	83 c4 04             	add    $0x4,%esp
  100545:	5d                   	pop    %ebp
  100546:	c3                   	ret    
  100547:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10054e:	00 00 

00100550 <kprintf>:

int kprintf(const char* fmt, ...) {
  100550:	55                   	push   %ebp
  100551:	89 e5                	mov    %esp,%ebp
  100553:	83 ec 58             	sub    $0x58,%esp
  100556:	8b 45 08             	mov    0x8(%ebp),%eax
  100559:	8d 4d f8             	lea    -0x8(%ebp),%ecx
  10055c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10055f:	8d 45 0c             	lea    0xc(%ebp),%eax
    va_list ap;
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
  100562:	89 01                	mov    %eax,(%ecx)
    kprintf_res = 0;
  100564:	c7 05 1c a0 10 00 00 	movl   $0x0,0x10a01c
  10056b:	00 00 00 
    while (*fmt) {
  10056e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100571:	80 38 00             	cmpb   $0x0,(%eax)
  100574:	0f 84 dd 01 00 00    	je     100757 <kprintf+0x207>
        if (*fmt == '%') {
  10057a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10057d:	0f be 00             	movsbl (%eax),%eax
  100580:	3d 25 00 00 00       	cmp    $0x25,%eax
  100585:	0f 85 ae 01 00 00    	jne    100739 <kprintf+0x1e9>
            fmt++;
  10058b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10058e:	89 c1                	mov    %eax,%ecx
  100590:	41                   	inc    %ecx
  100591:	89 4d fc             	mov    %ecx,-0x4(%ebp)
            switch (*fmt) {
  100594:	0f be 40 01          	movsbl 0x1(%eax),%eax
  100598:	89 c1                	mov    %eax,%ecx
  10059a:	83 e9 24             	sub    $0x24,%ecx
  10059d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1005a0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1005a3:	0f 8f 15 00 00 00    	jg     1005be <kprintf+0x6e>
  1005a9:	e9 00 00 00 00       	jmp    1005ae <kprintf+0x5e>
  1005ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005b1:	85 c0                	test   %eax,%eax
  1005b3:	0f 84 54 01 00 00    	je     10070d <kprintf+0x1bd>
  1005b9:	e9 54 01 00 00       	jmp    100712 <kprintf+0x1c2>
  1005be:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005c1:	83 e8 62             	sub    $0x62,%eax
  1005c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1005c7:	0f 8f 19 00 00 00    	jg     1005e6 <kprintf+0x96>
  1005cd:	e9 00 00 00 00       	jmp    1005d2 <kprintf+0x82>
  1005d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005d5:	83 e8 25             	sub    $0x25,%eax
  1005d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1005db:	0f 84 13 01 00 00    	je     1006f4 <kprintf+0x1a4>
  1005e1:	e9 2c 01 00 00       	jmp    100712 <kprintf+0x1c2>
  1005e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005e9:	83 e8 6f             	sub    $0x6f,%eax
  1005ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1005ef:	0f 8f 2d 00 00 00    	jg     100622 <kprintf+0xd2>
  1005f5:	e9 00 00 00 00       	jmp    1005fa <kprintf+0xaa>
  1005fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005fd:	83 e8 63             	sub    $0x63,%eax
  100600:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100603:	0f 84 c5 00 00 00    	je     1006ce <kprintf+0x17e>
  100609:	e9 00 00 00 00       	jmp    10060e <kprintf+0xbe>
  10060e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100611:	83 e8 64             	sub    $0x64,%eax
  100614:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100617:	0f 84 4b 00 00 00    	je     100668 <kprintf+0x118>
  10061d:	e9 f0 00 00 00       	jmp    100712 <kprintf+0x1c2>
  100622:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100625:	83 c0 90             	add    $0xffffff90,%eax
  100628:	89 c1                	mov    %eax,%ecx
  10062a:	83 e9 08             	sub    $0x8,%ecx
  10062d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100630:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  100633:	0f 87 d9 00 00 00    	ja     100712 <kprintf+0x1c2>
  100639:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10063c:	8b 0c 85 00 80 10 00 	mov    0x108000(,%eax,4),%ecx
  100643:	ff e1                	jmp    *%ecx
            case 's':
                s = va_arg(ap, char*);
  100645:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100648:	89 c1                	mov    %eax,%ecx
  10064a:	81 c1 04 00 00 00    	add    $0x4,%ecx
  100650:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100653:	8b 00                	mov    (%eax),%eax
  100655:	89 45 f4             	mov    %eax,-0xc(%ebp)
                kputs(s);
  100658:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10065b:	89 04 24             	mov    %eax,(%esp)
  10065e:	e8 0d 01 00 00       	call   100770 <kputs>
                break;
  100663:	e9 cc 00 00 00       	jmp    100734 <kprintf+0x1e4>
  100668:	b8 0a 00 00 00       	mov    $0xa,%eax
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
  10066d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100670:	89 ca                	mov    %ecx,%edx
  100672:	81 c2 04 00 00 00    	add    $0x4,%edx
  100678:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10067b:	8b 09                	mov    (%ecx),%ecx
  10067d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 10);
  100680:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100683:	89 0c 24             	mov    %ecx,(%esp)
  100686:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  10068d:	00 
  10068e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  100691:	e8 1a 01 00 00       	call   1007b0 <kputn>
                break;
  100696:	e9 99 00 00 00       	jmp    100734 <kprintf+0x1e4>
  10069b:	b8 10 00 00 00       	mov    $0x10,%eax
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
  1006a0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1006a3:	89 ca                	mov    %ecx,%edx
  1006a5:	81 c2 04 00 00 00    	add    $0x4,%edx
  1006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1006ae:	8b 09                	mov    (%ecx),%ecx
  1006b0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 16);
  1006b3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1006b6:	89 0c 24             	mov    %ecx,(%esp)
  1006b9:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  1006c0:	00 
  1006c1:	89 45 c0             	mov    %eax,-0x40(%ebp)
  1006c4:	e8 e7 00 00 00       	call   1007b0 <kputn>
                break;
  1006c9:	e9 66 00 00 00       	jmp    100734 <kprintf+0x1e4>
            case 'c':
                c = va_arg(ap, int);
  1006ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1006d1:	89 c1                	mov    %eax,%ecx
  1006d3:	81 c1 04 00 00 00    	add    $0x4,%ecx
  1006d9:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1006dc:	8b 00                	mov    (%eax),%eax
  1006de:	88 c2                	mov    %al,%dl
  1006e0:	88 55 ef             	mov    %dl,-0x11(%ebp)
                kputc(c);
  1006e3:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  1006e7:	89 04 24             	mov    %eax,(%esp)
  1006ea:	e8 61 01 00 00       	call   100850 <kputc>
                break;
  1006ef:	e9 40 00 00 00       	jmp    100734 <kprintf+0x1e4>
  1006f4:	b8 25 00 00 00       	mov    $0x25,%eax
            case '%':
                kputc('%');
  1006f9:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100700:	89 45 bc             	mov    %eax,-0x44(%ebp)
  100703:	e8 48 01 00 00       	call   100850 <kputc>
                break;
  100708:	e9 27 00 00 00       	jmp    100734 <kprintf+0x1e4>
            case '\0':
                goto out;
  10070d:	e9 4a 00 00 00       	jmp    10075c <kprintf+0x20c>
  100712:	b8 25 00 00 00       	mov    $0x25,%eax
            default:
                kputc('%');
  100717:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10071e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100721:	e8 2a 01 00 00       	call   100850 <kputc>
                kputc(*fmt);
  100726:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100729:	0f be 00             	movsbl (%eax),%eax
  10072c:	89 04 24             	mov    %eax,(%esp)
  10072f:	e8 1c 01 00 00       	call   100850 <kputc>
                break;
            }
        } else {
  100734:	e9 0e 00 00 00       	jmp    100747 <kprintf+0x1f7>
            kputc(*fmt);
  100739:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10073c:	0f be 00             	movsbl (%eax),%eax
  10073f:	89 04 24             	mov    %eax,(%esp)
  100742:	e8 09 01 00 00       	call   100850 <kputc>
        }

        fmt++;
  100747:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10074a:	05 01 00 00 00       	add    $0x1,%eax
  10074f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  100752:	e9 17 fe ff ff       	jmp    10056e <kprintf+0x1e>
  100757:	e9 00 00 00 00       	jmp    10075c <kprintf+0x20c>

    out:
    va_end(ap);

    return kprintf_res;
  10075c:	a1 1c a0 10 00       	mov    0x10a01c,%eax
  100761:	83 c4 58             	add    $0x58,%esp
  100764:	5d                   	pop    %ebp
  100765:	c3                   	ret    
  100766:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10076d:	00 00 00 

00100770 <kputs>:

    x++;
    kprintf_res++;
}

static void kputs(const char* s) {
  100770:	55                   	push   %ebp
  100771:	89 e5                	mov    %esp,%ebp
  100773:	83 ec 08             	sub    $0x8,%esp
  100776:	8b 45 08             	mov    0x8(%ebp),%eax
  100779:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*s) {
  10077c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10077f:	80 38 00             	cmpb   $0x0,(%eax)
  100782:	0f 84 1e 00 00 00    	je     1007a6 <kputs+0x36>
        kputc(*s++);
  100788:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10078b:	89 c1                	mov    %eax,%ecx
  10078d:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100793:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  100796:	0f be 00             	movsbl (%eax),%eax
  100799:	89 04 24             	mov    %eax,(%esp)
  10079c:	e8 af 00 00 00       	call   100850 <kputc>
    }
  1007a1:	e9 d6 ff ff ff       	jmp    10077c <kputs+0xc>
}
  1007a6:	83 c4 08             	add    $0x8,%esp
  1007a9:	5d                   	pop    %ebp
  1007aa:	c3                   	ret    
  1007ab:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001007b0 <kputn>:

static void kputn(unsigned long x, int base) {
  1007b0:	55                   	push   %ebp
  1007b1:	89 e5                	mov    %esp,%ebp
  1007b3:	56                   	push   %esi
  1007b4:	83 ec 64             	sub    $0x64,%esp
  1007b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1007ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1007bd:	8d 15 2c 82 10 00    	lea    0x10822c,%edx
  1007c3:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1007c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  1007c9:	89 55 ac             	mov    %edx,-0x54(%ebp)
    char* p;

    if (base > 36) {
  1007cc:	81 7d f4 24 00 00 00 	cmpl   $0x24,-0xc(%ebp)
  1007d3:	0f 8e 05 00 00 00    	jle    1007de <kputn+0x2e>
        return;
  1007d9:	e9 5d 00 00 00       	jmp    10083b <kputn+0x8b>
  1007de:	8d 45 b3             	lea    -0x4d(%ebp),%eax
    }

    p = buf + 64;
  1007e1:	05 40 00 00 00       	add    $0x40,%eax
  1007e6:	89 45 a8             	mov    %eax,-0x58(%ebp)
    *p = '\0';
  1007e9:	8b 45 a8             	mov    -0x58(%ebp),%eax
  1007ec:	c6 00 00             	movb   $0x0,(%eax)
    do {
        *--p = digits[x % base];
  1007ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1007f2:	31 d2                	xor    %edx,%edx
  1007f4:	f7 75 f4             	divl   -0xc(%ebp)
  1007f7:	8b 45 ac             	mov    -0x54(%ebp),%eax
  1007fa:	8a 0c 10             	mov    (%eax,%edx,1),%cl
  1007fd:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100800:	89 c2                	mov    %eax,%edx
  100802:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
  100808:	89 55 a8             	mov    %edx,-0x58(%ebp)
  10080b:	88 48 ff             	mov    %cl,-0x1(%eax)
        x /= base;
  10080e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100811:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100814:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  100817:	89 d0                	mov    %edx,%eax
  100819:	31 d2                	xor    %edx,%edx
  10081b:	8b 75 a4             	mov    -0x5c(%ebp),%esi
  10081e:	f7 f6                	div    %esi
  100820:	89 45 f8             	mov    %eax,-0x8(%ebp)
    } while (x);
  100823:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10082a:	0f 85 bf ff ff ff    	jne    1007ef <kputn+0x3f>
    kputs(p);
  100830:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100833:	89 04 24             	mov    %eax,(%esp)
  100836:	e8 35 ff ff ff       	call   100770 <kputs>
}
  10083b:	83 c4 64             	add    $0x64,%esp
  10083e:	5e                   	pop    %esi
  10083f:	5d                   	pop    %ebp
  100840:	c3                   	ret    
  100841:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  100848:	0f 1f 84 00 00 00 00 
  10084f:	00 

00100850 <kputc>:
static int kprintf_res = 0;
static char color = 0x07;

static char* video = (char*) 0xb8000;

static void kputc(char c) {
  100850:	55                   	push   %ebp
  100851:	89 e5                	mov    %esp,%ebp
  100853:	83 ec 08             	sub    $0x8,%esp
  100856:	8a 45 08             	mov    0x8(%ebp),%al
  100859:	88 45 ff             	mov    %al,-0x1(%ebp)
    if(ramfs_vga_writers()) {
  10085c:	e8 9f 30 00 00       	call   103900 <ramfs_vga_writers>
  100861:	3d 00 00 00 00       	cmp    $0x0,%eax
  100866:	0f 84 05 00 00 00    	je     100871 <kputc+0x21>
        //TODO write to stdout;
        return;
  10086c:	e9 3f 01 00 00       	jmp    1009b0 <kputc+0x160>
    }

    if ((c == '\n') || (x > 79)) {
  100871:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  100875:	3d 0a 00 00 00       	cmp    $0xa,%eax
  10087a:	0f 84 10 00 00 00    	je     100890 <kputc+0x40>
  100880:	81 3d 18 a0 10 00 4f 	cmpl   $0x4f,0x10a018
  100887:	00 00 00 
  10088a:	0f 8e 19 00 00 00    	jle    1008a9 <kputc+0x59>
        x = 0;
  100890:	c7 05 18 a0 10 00 00 	movl   $0x0,0x10a018
  100897:	00 00 00 
        y++;
  10089a:	a1 14 a0 10 00       	mov    0x10a014,%eax
  10089f:	05 01 00 00 00       	add    $0x1,%eax
  1008a4:	a3 14 a0 10 00       	mov    %eax,0x10a014
    }

    if (c == '\n') {
  1008a9:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  1008ad:	3d 0a 00 00 00       	cmp    $0xa,%eax
  1008b2:	0f 85 05 00 00 00    	jne    1008bd <kputc+0x6d>
        return;
  1008b8:	e9 f3 00 00 00       	jmp    1009b0 <kputc+0x160>
    }

    if (y > 24) {
  1008bd:	81 3d 14 a0 10 00 18 	cmpl   $0x18,0x10a014
  1008c4:	00 00 00 
  1008c7:	0f 8e 7e 00 00 00    	jle    10094b <kputc+0xfb>
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  1008cd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1008d4:	81 7d f8 00 0f 00 00 	cmpl   $0xf00,-0x8(%ebp)
  1008db:	0f 8d 2c 00 00 00    	jge    10090d <kputc+0xbd>
            video[i] = video[i + 160];
  1008e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1008e4:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  1008ea:	8a 94 01 a0 00 00 00 	mov    0xa0(%ecx,%eax,1),%dl
  1008f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1008f4:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  1008fa:	88 14 01             	mov    %dl,(%ecx,%eax,1)
        return;
    }

    if (y > 24) {
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  1008fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100900:	05 01 00 00 00       	add    $0x1,%eax
  100905:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100908:	e9 c7 ff ff ff       	jmp    1008d4 <kputc+0x84>
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  10090d:	e9 00 00 00 00       	jmp    100912 <kputc+0xc2>
  100912:	81 7d f8 a0 0f 00 00 	cmpl   $0xfa0,-0x8(%ebp)
  100919:	0f 8d 1d 00 00 00    	jge    10093c <kputc+0xec>
            video[i] = 0;
  10091f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100922:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  100928:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  10092c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10092f:	05 01 00 00 00       	add    $0x1,%eax
  100934:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100937:	e9 d6 ff ff ff       	jmp    100912 <kputc+0xc2>
            video[i] = 0;
        }
        y--;
  10093c:	a1 14 a0 10 00       	mov    0x10a014,%eax
  100941:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100946:	a3 14 a0 10 00       	mov    %eax,0x10a014
    }

    video[2 * (y * 80 + x)] = c;
  10094b:	8a 45 ff             	mov    -0x1(%ebp),%al
  10094e:	69 0d 14 a0 10 00 50 	imul   $0x50,0x10a014,%ecx
  100955:	00 00 00 
  100958:	03 0d 18 a0 10 00    	add    0x10a018,%ecx
  10095e:	c1 e1 01             	shl    $0x1,%ecx
  100961:	8b 15 00 71 10 00    	mov    0x107100,%edx
  100967:	88 04 0a             	mov    %al,(%edx,%ecx,1)
    video[2 * (y * 80 + x) + 1] = color;
  10096a:	a0 04 71 10 00       	mov    0x107104,%al
  10096f:	69 0d 14 a0 10 00 50 	imul   $0x50,0x10a014,%ecx
  100976:	00 00 00 
  100979:	03 0d 18 a0 10 00    	add    0x10a018,%ecx
  10097f:	c1 e1 01             	shl    $0x1,%ecx
  100982:	8b 15 00 71 10 00    	mov    0x107100,%edx
  100988:	88 44 0a 01          	mov    %al,0x1(%edx,%ecx,1)

    x++;
  10098c:	8b 0d 18 a0 10 00    	mov    0x10a018,%ecx
  100992:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100998:	89 0d 18 a0 10 00    	mov    %ecx,0x10a018
    kprintf_res++;
  10099e:	8b 0d 1c a0 10 00    	mov    0x10a01c,%ecx
  1009a4:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1009aa:	89 0d 1c a0 10 00    	mov    %ecx,0x10a01c
}
  1009b0:	83 c4 08             	add    $0x8,%esp
  1009b3:	5d                   	pop    %ebp
  1009b4:	c3                   	ret    
  1009b5:	66 90                	xchg   %ax,%ax
  1009b7:	66 90                	xchg   %ax,%ax
  1009b9:	66 90                	xchg   %ax,%ax
  1009bb:	66 90                	xchg   %ax,%ax
  1009bd:	66 90                	xchg   %ax,%ax
  1009bf:	90                   	nop

001009c0 <load_gdt>:

#define GDT_ENTRIES 6

uint64_t gdt[GDT_ENTRIES];

void load_gdt() {
  1009c0:	55                   	push   %ebp
  1009c1:	89 e5                	mov    %esp,%ebp
	struct {
  1009c3:	83 ec 08             	sub    $0x8,%esp
  1009c6:	a1 24 80 10 00       	mov    0x108024,%eax
  1009cb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1009ce:	66 8b 0d 28 80 10 00 	mov    0x108028,%cx
  1009d5:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
		uint16_t limit;
		void* pointer;
	}__attribute__((packed)) gdtp = { .limit = GDT_ENTRIES * 8 - 1, .pointer =
			gdt, };

	asm volatile("lgdt %0" : : "m" (gdtp));
  1009d9:	0f 01 55 f8          	lgdtl  -0x8(%ebp)

	asm ("mov $0x10, %ax");
  1009dd:	66 b8 10 00          	mov    $0x10,%ax
	asm ("mov %ax, %ds");
  1009e1:	66 8e d8             	mov    %ax,%ds
	asm ("mov %ax, %es");
  1009e4:	66 8e c0             	mov    %ax,%es
	asm ("mov %ax, %fs");
  1009e7:	66 8e e0             	mov    %ax,%fs
	asm ("mov %ax, %gs");
  1009ea:	66 8e e8             	mov    %ax,%gs
	asm ("mov %ax, %ss");
  1009ed:	66 8e d0             	mov    %ax,%ss
	//asm ("ljmp $0x8, $.1");
	//asm (".1:");
}
  1009f0:	83 c4 08             	add    $0x8,%esp
  1009f3:	5d                   	pop    %ebp
  1009f4:	c3                   	ret    
  1009f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1009fc:	00 00 00 00 

00100a00 <set_gdt_entry>:

void set_gdt_entry(int i, unsigned int base, unsigned int limit, int flags) {
  100a00:	55                   	push   %ebp
  100a01:	89 e5                	mov    %esp,%ebp
  100a03:	56                   	push   %esi
  100a04:	83 ec 10             	sub    $0x10,%esp
  100a07:	8b 45 14             	mov    0x14(%ebp),%eax
  100a0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100a0d:	8b 55 0c             	mov    0xc(%ebp),%edx
  100a10:	8b 75 08             	mov    0x8(%ebp),%esi
  100a13:	89 75 f8             	mov    %esi,-0x8(%ebp)
  100a16:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100a19:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100a1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gdt[i] = limit & 0xffffLL;
  100a1f:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  100a23:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100a26:	89 04 cd 60 a4 12 00 	mov    %eax,0x12a460(,%ecx,8)
  100a2d:	c7 04 cd 64 a4 12 00 	movl   $0x0,0x12a464(,%ecx,8)
  100a34:	00 00 00 00 
	gdt[i] |= (base & 0xffffffLL) << 16;
  100a38:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100a3b:	25 ff ff ff 00       	and    $0xffffff,%eax
  100a40:	89 c1                	mov    %eax,%ecx
  100a42:	c1 e1 10             	shl    $0x10,%ecx
  100a45:	c1 e8 10             	shr    $0x10,%eax
  100a48:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100a4b:	8b 34 d5 64 a4 12 00 	mov    0x12a464(,%edx,8),%esi
  100a52:	09 f0                	or     %esi,%eax
  100a54:	8b 34 d5 60 a4 12 00 	mov    0x12a460(,%edx,8),%esi
  100a5b:	09 ce                	or     %ecx,%esi
  100a5d:	89 04 d5 64 a4 12 00 	mov    %eax,0x12a464(,%edx,8)
  100a64:	89 34 d5 60 a4 12 00 	mov    %esi,0x12a460(,%edx,8)
	gdt[i] |= (flags & 0xffLL) << 40;
  100a6b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100a6f:	c1 e0 08             	shl    $0x8,%eax
  100a72:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100a75:	8b 14 cd 60 a4 12 00 	mov    0x12a460(,%ecx,8),%edx
  100a7c:	8b 34 cd 64 a4 12 00 	mov    0x12a464(,%ecx,8),%esi
  100a83:	09 c6                	or     %eax,%esi
  100a85:	89 14 cd 60 a4 12 00 	mov    %edx,0x12a460(,%ecx,8)
  100a8c:	89 34 cd 64 a4 12 00 	mov    %esi,0x12a464(,%ecx,8)
	gdt[i] |= ((limit >> 16) & 0xfLL) << 48;
  100a93:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  100a97:	83 e0 0f             	and    $0xf,%eax
  100a9a:	c1 e0 10             	shl    $0x10,%eax
  100a9d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100aa0:	8b 14 cd 60 a4 12 00 	mov    0x12a460(,%ecx,8),%edx
  100aa7:	8b 34 cd 64 a4 12 00 	mov    0x12a464(,%ecx,8),%esi
  100aae:	09 c6                	or     %eax,%esi
  100ab0:	89 14 cd 60 a4 12 00 	mov    %edx,0x12a460(,%ecx,8)
  100ab7:	89 34 cd 64 a4 12 00 	mov    %esi,0x12a464(,%ecx,8)
	gdt[i] |= ((flags >> 8) & 0xffLL) << 52;
  100abe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100ac1:	c1 e0 0c             	shl    $0xc,%eax
  100ac4:	25 00 00 f0 0f       	and    $0xff00000,%eax
  100ac9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100acc:	8b 14 cd 60 a4 12 00 	mov    0x12a460(,%ecx,8),%edx
  100ad3:	8b 34 cd 64 a4 12 00 	mov    0x12a464(,%ecx,8),%esi
  100ada:	09 c6                	or     %eax,%esi
  100adc:	89 14 cd 60 a4 12 00 	mov    %edx,0x12a460(,%ecx,8)
  100ae3:	89 34 cd 64 a4 12 00 	mov    %esi,0x12a464(,%ecx,8)
	gdt[i] |= ((base >> 24) & 0xffLL) << 56;
  100aea:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100aee:	c1 e0 18             	shl    $0x18,%eax
  100af1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100af4:	8b 14 cd 60 a4 12 00 	mov    0x12a460(,%ecx,8),%edx
  100afb:	8b 34 cd 64 a4 12 00 	mov    0x12a464(,%ecx,8),%esi
  100b02:	09 c6                	or     %eax,%esi
  100b04:	89 14 cd 60 a4 12 00 	mov    %edx,0x12a460(,%ecx,8)
  100b0b:	89 34 cd 64 a4 12 00 	mov    %esi,0x12a464(,%ecx,8)
}
  100b12:	83 c4 10             	add    $0x10,%esp
  100b15:	5e                   	pop    %esi
  100b16:	5d                   	pop    %ebp
  100b17:	c3                   	ret    
  100b18:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  100b1f:	00 

00100b20 <init_gdt>:

void init_gdt(void) {
  100b20:	55                   	push   %ebp
  100b21:	89 e5                	mov    %esp,%ebp
  100b23:	56                   	push   %esi
  100b24:	83 ec 54             	sub    $0x54,%esp
  100b27:	b8 00 00 00 00       	mov    $0x0,%eax
	set_gdt_entry(0, 0, 0, 0);
  100b2c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100b33:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100b3a:	00 
  100b3b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100b42:	00 
  100b43:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100b4a:	00 
  100b4b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100b4e:	e8 ad fe ff ff       	call   100a00 <set_gdt_entry>
  100b53:	b8 01 00 00 00       	mov    $0x1,%eax
  100b58:	b9 00 00 00 00       	mov    $0x0,%ecx
  100b5d:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100b62:	be 9a 0c 00 00       	mov    $0xc9a,%esi
	set_gdt_entry(1, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100b67:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100b6e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100b75:	00 
  100b76:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100b7d:	00 
  100b7e:	c7 44 24 0c 9a 0c 00 	movl   $0xc9a,0xc(%esp)
  100b85:	00 
  100b86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100b89:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100b8c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100b8f:	89 75 e8             	mov    %esi,-0x18(%ebp)
  100b92:	e8 69 fe ff ff       	call   100a00 <set_gdt_entry>
  100b97:	b8 02 00 00 00       	mov    $0x2,%eax
  100b9c:	b9 00 00 00 00       	mov    $0x0,%ecx
  100ba1:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100ba6:	be 92 0c 00 00       	mov    $0xc92,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(2, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100bab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100bb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100bb9:	00 
  100bba:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100bc1:	00 
  100bc2:	c7 44 24 0c 92 0c 00 	movl   $0xc92,0xc(%esp)
  100bc9:	00 
  100bca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100bcd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  100bd0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  100bd3:	89 75 d8             	mov    %esi,-0x28(%ebp)
  100bd6:	e8 25 fe ff ff       	call   100a00 <set_gdt_entry>
  100bdb:	b8 03 00 00 00       	mov    $0x3,%eax
  100be0:	b9 00 00 00 00       	mov    $0x0,%ecx
  100be5:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100bea:	be fa 0c 00 00       	mov    $0xcfa,%esi
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(3, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100bef:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  100bf6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100bfd:	00 
  100bfe:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100c05:	00 
  100c06:	c7 44 24 0c fa 0c 00 	movl   $0xcfa,0xc(%esp)
  100c0d:	00 
  100c0e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100c11:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  100c14:	89 55 cc             	mov    %edx,-0x34(%ebp)
  100c17:	89 75 c8             	mov    %esi,-0x38(%ebp)
  100c1a:	e8 e1 fd ff ff       	call   100a00 <set_gdt_entry>
  100c1f:	b8 04 00 00 00       	mov    $0x4,%eax
  100c24:	b9 00 00 00 00       	mov    $0x0,%ecx
  100c29:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100c2e:	be f2 0c 00 00       	mov    $0xcf2,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);
	set_gdt_entry(4, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100c33:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  100c3a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100c41:	00 
  100c42:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100c49:	00 
  100c4a:	c7 44 24 0c f2 0c 00 	movl   $0xcf2,0xc(%esp)
  100c51:	00 
  100c52:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  100c55:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  100c58:	89 55 bc             	mov    %edx,-0x44(%ebp)
  100c5b:	89 75 b8             	mov    %esi,-0x48(%ebp)
  100c5e:	e8 9d fd ff ff       	call   100a00 <set_gdt_entry>
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	load_gdt();
  100c63:	e8 58 fd ff ff       	call   1009c0 <load_gdt>
}
  100c68:	83 c4 54             	add    $0x54,%esp
  100c6b:	5e                   	pop    %esi
  100c6c:	5d                   	pop    %ebp
  100c6d:	c3                   	ret    
  100c6e:	66 90                	xchg   %ax,%ax

00100c70 <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  100c70:	55                   	push   %ebp
  100c71:	89 e5                	mov    %esp,%ebp
  100c73:	53                   	push   %ebx
  100c74:	57                   	push   %edi
  100c75:	56                   	push   %esi
  100c76:	83 ec 10             	sub    $0x10,%esp
  100c79:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  100c7d:	66 89 c1             	mov    %ax,%cx
  100c80:	8a 55 14             	mov    0x14(%ebp),%dl
  100c83:	8b 45 0c             	mov    0xc(%ebp),%eax
  100c86:	8b 75 08             	mov    0x8(%ebp),%esi
  100c89:	89 75 f0             	mov    %esi,-0x10(%ebp)
  100c8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100c8f:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  100c93:	88 55 e9             	mov    %dl,-0x17(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  100c96:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100c99:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	idt[i] = handler & 0xffffLL;
  100c9c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  100ca0:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100ca3:	89 04 f5 20 a0 10 00 	mov    %eax,0x10a020(,%esi,8)
  100caa:	c7 04 f5 24 a0 10 00 	movl   $0x0,0x10a024(,%esi,8)
  100cb1:	00 00 00 00 
	idt[i] |= (selector & 0xffffLL) << 16;
  100cb5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
  100cb9:	c1 e0 10             	shl    $0x10,%eax
  100cbc:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100cbf:	8b 3c f5 24 a0 10 00 	mov    0x10a024(,%esi,8),%edi
  100cc6:	8b 1c f5 20 a0 10 00 	mov    0x10a020(,%esi,8),%ebx
  100ccd:	09 c3                	or     %eax,%ebx
  100ccf:	89 3c f5 24 a0 10 00 	mov    %edi,0x10a024(,%esi,8)
  100cd6:	89 1c f5 20 a0 10 00 	mov    %ebx,0x10a020(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  100cdd:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  100ce1:	c1 e0 08             	shl    $0x8,%eax
  100ce4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100ce7:	8b 3c f5 20 a0 10 00 	mov    0x10a020(,%esi,8),%edi
  100cee:	8b 1c f5 24 a0 10 00 	mov    0x10a024(,%esi,8),%ebx
  100cf5:	09 c3                	or     %eax,%ebx
  100cf7:	89 3c f5 20 a0 10 00 	mov    %edi,0x10a020(,%esi,8)
  100cfe:	89 1c f5 24 a0 10 00 	mov    %ebx,0x10a024(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  100d05:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  100d09:	c1 e0 10             	shl    $0x10,%eax
  100d0c:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100d0f:	8b 3c f5 20 a0 10 00 	mov    0x10a020(,%esi,8),%edi
  100d16:	8b 1c f5 24 a0 10 00 	mov    0x10a024(,%esi,8),%ebx
  100d1d:	09 c3                	or     %eax,%ebx
  100d1f:	89 3c f5 20 a0 10 00 	mov    %edi,0x10a020(,%esi,8)
  100d26:	89 1c f5 24 a0 10 00 	mov    %ebx,0x10a024(,%esi,8)
}
  100d2d:	83 c4 10             	add    $0x10,%esp
  100d30:	5e                   	pop    %esi
  100d31:	5f                   	pop    %edi
  100d32:	5b                   	pop    %ebx
  100d33:	5d                   	pop    %ebp
  100d34:	c3                   	ret    
  100d35:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  100d3c:	00 00 00 00 

00100d40 <init_idt>:

void init_idt() {
  100d40:	55                   	push   %ebp
  100d41:	89 e5                	mov    %esp,%ebp
	struct {
  100d43:	56                   	push   %esi
  100d44:	81 ec 34 02 00 00    	sub    $0x234,%esp
  100d4a:	a1 2a 80 10 00       	mov    0x10802a,%eax
  100d4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100d52:	66 8b 0d 2e 80 10 00 	mov    0x10802e,%cx
  100d59:	66 89 4d f4          	mov    %cx,-0xc(%ebp)
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;
  100d5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  100d64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100d6b:	81 7d ec 40 00 00 00 	cmpl   $0x40,-0x14(%ebp)
  100d72:	0f 8d 1e 00 00 00    	jge    100d96 <init_idt+0x56>
		handler_set[i] = 0;
  100d78:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100d7b:	c7 04 85 20 a2 10 00 	movl   $0x0,0x10a220(,%eax,4)
  100d82:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  100d86:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100d89:	05 01 00 00 00       	add    $0x1,%eax
  100d8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100d91:	e9 d5 ff ff ff       	jmp    100d6b <init_idt+0x2b>
  100d96:	b8 20 00 00 00       	mov    $0x20,%eax
  100d9b:	b9 11 00 00 00       	mov    $0x11,%ecx
		handler_set[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  100da0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  100da7:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  100dae:	00 
  100daf:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100db2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100db5:	e8 86 0b 00 00       	call   101940 <outb>
  100dba:	b8 21 00 00 00       	mov    $0x21,%eax
  100dbf:	b9 20 00 00 00       	mov    $0x20,%ecx
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  100dc4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100dcb:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  100dd2:	00 
  100dd3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100dd6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  100dd9:	e8 62 0b 00 00       	call   101940 <outb>
  100dde:	b8 21 00 00 00       	mov    $0x21,%eax
  100de3:	b9 04 00 00 00       	mov    $0x4,%ecx
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  100de8:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100def:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  100df6:	00 
  100df7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100dfa:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  100dfd:	e8 3e 0b 00 00       	call   101940 <outb>
  100e02:	b8 21 00 00 00       	mov    $0x21,%eax
  100e07:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0x21, 0x01); // ICW 4
  100e0c:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100e13:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100e1a:	00 
  100e1b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100e1e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  100e21:	e8 1a 0b 00 00       	call   101940 <outb>
  100e26:	b8 a0 00 00 00       	mov    $0xa0,%eax
  100e2b:	b9 11 00 00 00       	mov    $0x11,%ecx

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  100e30:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  100e37:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  100e3e:	00 
  100e3f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  100e42:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  100e45:	e8 f6 0a 00 00       	call   101940 <outb>
  100e4a:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100e4f:	b9 28 00 00 00       	mov    $0x28,%ecx
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  100e54:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100e5b:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  100e62:	00 
  100e63:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100e66:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  100e69:	e8 d2 0a 00 00       	call   101940 <outb>
  100e6e:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100e73:	b9 02 00 00 00       	mov    $0x2,%ecx
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  100e78:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100e7f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  100e86:	00 
  100e87:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100e8a:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  100e8d:	e8 ae 0a 00 00       	call   101940 <outb>
  100e92:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100e97:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0xa1, 0x01); // ICW 4
  100e9c:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100ea3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100eaa:	00 
  100eab:	89 45 b0             	mov    %eax,-0x50(%ebp)
  100eae:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  100eb1:	e8 8a 0a 00 00       	call   101940 <outb>
  100eb6:	b8 20 00 00 00       	mov    $0x20,%eax
  100ebb:	b9 00 00 00 00       	mov    $0x0,%ecx

	outb(0x20, 0x0);
  100ec0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  100ec7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ece:	00 
  100ecf:	89 45 a8             	mov    %eax,-0x58(%ebp)
  100ed2:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  100ed5:	e8 66 0a 00 00       	call   101940 <outb>
  100eda:	b8 a0 00 00 00       	mov    $0xa0,%eax
  100edf:	b9 00 00 00 00       	mov    $0x0,%ecx
	outb(0xa0, 0x0);
  100ee4:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  100eeb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ef2:	00 
  100ef3:	89 45 a0             	mov    %eax,-0x60(%ebp)
  100ef6:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  100ef9:	e8 42 0a 00 00       	call   101940 <outb>
  100efe:	b8 00 00 00 00       	mov    $0x0,%eax
  100f03:	8d 0d 14 1b 10 00    	lea    0x101b14,%ecx
  100f09:	ba 08 00 00 00       	mov    $0x8,%edx
  100f0e:	be 8e 00 00 00       	mov    $0x8e,%esi

	idt_set_entry(0, intr_stub_0, 0x8,
  100f13:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100f1a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f1e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100f25:	00 
  100f26:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100f2d:	00 
  100f2e:	89 45 98             	mov    %eax,-0x68(%ebp)
  100f31:	89 75 94             	mov    %esi,-0x6c(%ebp)
  100f34:	89 55 90             	mov    %edx,-0x70(%ebp)
  100f37:	e8 34 fd ff ff       	call   100c70 <idt_set_entry>
  100f3c:	b8 01 00 00 00       	mov    $0x1,%eax
  100f41:	8d 0d 1d 1b 10 00    	lea    0x101b1d,%ecx
  100f47:	ba 08 00 00 00       	mov    $0x8,%edx
  100f4c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  100f51:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f58:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f5c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100f63:	00 
  100f64:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100f6b:	00 
  100f6c:	89 45 8c             	mov    %eax,-0x74(%ebp)
  100f6f:	89 75 88             	mov    %esi,-0x78(%ebp)
  100f72:	89 55 84             	mov    %edx,-0x7c(%ebp)
  100f75:	e8 f6 fc ff ff       	call   100c70 <idt_set_entry>
  100f7a:	b8 02 00 00 00       	mov    $0x2,%eax
  100f7f:	8d 0d 26 1b 10 00    	lea    0x101b26,%ecx
  100f85:	ba 08 00 00 00       	mov    $0x8,%edx
  100f8a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  100f8f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100f96:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f9a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100fa1:	00 
  100fa2:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100fa9:	00 
  100faa:	89 45 80             	mov    %eax,-0x80(%ebp)
  100fad:	89 b5 7c ff ff ff    	mov    %esi,-0x84(%ebp)
  100fb3:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
  100fb9:	e8 b2 fc ff ff       	call   100c70 <idt_set_entry>
  100fbe:	b8 03 00 00 00       	mov    $0x3,%eax
  100fc3:	8d 0d 2f 1b 10 00    	lea    0x101b2f,%ecx
  100fc9:	ba 08 00 00 00       	mov    $0x8,%edx
  100fce:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  100fd3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  100fda:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100fde:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100fe5:	00 
  100fe6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100fed:	00 
  100fee:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  100ff4:	89 b5 70 ff ff ff    	mov    %esi,-0x90(%ebp)
  100ffa:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  101000:	e8 6b fc ff ff       	call   100c70 <idt_set_entry>
  101005:	b8 04 00 00 00       	mov    $0x4,%eax
  10100a:	8d 0d 38 1b 10 00    	lea    0x101b38,%ecx
  101010:	ba 08 00 00 00       	mov    $0x8,%edx
  101015:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  10101a:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  101021:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101025:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10102c:	00 
  10102d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101034:	00 
  101035:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  10103b:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
  101041:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
  101047:	e8 24 fc ff ff       	call   100c70 <idt_set_entry>
  10104c:	b8 05 00 00 00       	mov    $0x5,%eax
  101051:	8d 0d 41 1b 10 00    	lea    0x101b41,%ecx
  101057:	ba 08 00 00 00       	mov    $0x8,%edx
  10105c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  101061:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101068:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10106c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101073:	00 
  101074:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10107b:	00 
  10107c:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  101082:	89 b5 58 ff ff ff    	mov    %esi,-0xa8(%ebp)
  101088:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
  10108e:	e8 dd fb ff ff       	call   100c70 <idt_set_entry>
  101093:	b8 06 00 00 00       	mov    $0x6,%eax
  101098:	8d 0d 4a 1b 10 00    	lea    0x101b4a,%ecx
  10109e:	ba 08 00 00 00       	mov    $0x8,%edx
  1010a3:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  1010a8:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1010af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1010b3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1010ba:	00 
  1010bb:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1010c2:	00 
  1010c3:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  1010c9:	89 b5 4c ff ff ff    	mov    %esi,-0xb4(%ebp)
  1010cf:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
  1010d5:	e8 96 fb ff ff       	call   100c70 <idt_set_entry>
  1010da:	b8 07 00 00 00       	mov    $0x7,%eax
  1010df:	8d 0d 53 1b 10 00    	lea    0x101b53,%ecx
  1010e5:	ba 08 00 00 00       	mov    $0x8,%edx
  1010ea:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  1010ef:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  1010f6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1010fa:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101101:	00 
  101102:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101109:	00 
  10110a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  101110:	89 b5 40 ff ff ff    	mov    %esi,-0xc0(%ebp)
  101116:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
  10111c:	e8 4f fb ff ff       	call   100c70 <idt_set_entry>
  101121:	b8 08 00 00 00       	mov    $0x8,%eax
  101126:	8d 0d 5c 1b 10 00    	lea    0x101b5c,%ecx
  10112c:	ba 8e 00 00 00       	mov    $0x8e,%edx
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  101131:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  101138:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10113c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101143:	00 
  101144:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10114b:	00 
  10114c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
  101152:	89 95 34 ff ff ff    	mov    %edx,-0xcc(%ebp)
  101158:	e8 13 fb ff ff       	call   100c70 <idt_set_entry>
  10115d:	b8 09 00 00 00       	mov    $0x9,%eax
  101162:	8d 0d 63 1b 10 00    	lea    0x101b63,%ecx
  101168:	ba 08 00 00 00       	mov    $0x8,%edx
  10116d:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  101172:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  101179:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10117d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101184:	00 
  101185:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10118c:	00 
  10118d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
  101193:	89 b5 2c ff ff ff    	mov    %esi,-0xd4(%ebp)
  101199:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%ebp)
  10119f:	e8 cc fa ff ff       	call   100c70 <idt_set_entry>
  1011a4:	b8 0a 00 00 00       	mov    $0xa,%eax
  1011a9:	8d 0d 6c 1b 10 00    	lea    0x101b6c,%ecx
  1011af:	ba 08 00 00 00       	mov    $0x8,%edx
  1011b4:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  1011b9:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1011c0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1011c4:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1011cb:	00 
  1011cc:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1011d3:	00 
  1011d4:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  1011da:	89 b5 20 ff ff ff    	mov    %esi,-0xe0(%ebp)
  1011e0:	89 95 1c ff ff ff    	mov    %edx,-0xe4(%ebp)
  1011e6:	e8 85 fa ff ff       	call   100c70 <idt_set_entry>
  1011eb:	b8 0b 00 00 00       	mov    $0xb,%eax
  1011f0:	8d 0d 73 1b 10 00    	lea    0x101b73,%ecx
  1011f6:	ba 08 00 00 00       	mov    $0x8,%edx
  1011fb:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  101200:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  101207:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10120b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101212:	00 
  101213:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10121a:	00 
  10121b:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  101221:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%ebp)
  101227:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
  10122d:	e8 3e fa ff ff       	call   100c70 <idt_set_entry>
  101232:	b8 0c 00 00 00       	mov    $0xc,%eax
  101237:	8d 0d 7a 1b 10 00    	lea    0x101b7a,%ecx
  10123d:	ba 08 00 00 00       	mov    $0x8,%edx
  101242:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  101247:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10124e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101252:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101259:	00 
  10125a:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101261:	00 
  101262:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  101268:	89 b5 08 ff ff ff    	mov    %esi,-0xf8(%ebp)
  10126e:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
  101274:	e8 f7 f9 ff ff       	call   100c70 <idt_set_entry>
  101279:	b8 0d 00 00 00       	mov    $0xd,%eax
  10127e:	8d 0d 81 1b 10 00    	lea    0x101b81,%ecx
  101284:	ba 08 00 00 00       	mov    $0x8,%edx
  101289:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  10128e:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  101295:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101299:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1012a0:	00 
  1012a1:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1012a8:	00 
  1012a9:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
  1012af:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
  1012b5:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
  1012bb:	e8 b0 f9 ff ff       	call   100c70 <idt_set_entry>
  1012c0:	b8 0e 00 00 00       	mov    $0xe,%eax
  1012c5:	8d 0d 88 1b 10 00    	lea    0x101b88,%ecx
  1012cb:	ba 08 00 00 00       	mov    $0x8,%edx
  1012d0:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  1012d5:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  1012dc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1012e0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1012e7:	00 
  1012e8:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1012ef:	00 
  1012f0:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
  1012f6:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
  1012fc:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
  101302:	e8 69 f9 ff ff       	call   100c70 <idt_set_entry>
  101307:	b8 0f 00 00 00       	mov    $0xf,%eax
  10130c:	8d 0d 8c 1b 10 00    	lea    0x101b8c,%ecx
  101312:	ba 08 00 00 00       	mov    $0x8,%edx
  101317:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  10131c:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  101323:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101327:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10132e:	00 
  10132f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101336:	00 
  101337:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
  10133d:	89 b5 e4 fe ff ff    	mov    %esi,-0x11c(%ebp)
  101343:	89 95 e0 fe ff ff    	mov    %edx,-0x120(%ebp)
  101349:	e8 22 f9 ff ff       	call   100c70 <idt_set_entry>
  10134e:	b8 10 00 00 00       	mov    $0x10,%eax
  101353:	8d 0d 92 1b 10 00    	lea    0x101b92,%ecx
  101359:	ba 08 00 00 00       	mov    $0x8,%edx
  10135e:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  101363:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10136a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10136e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101375:	00 
  101376:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10137d:	00 
  10137e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
  101384:	89 b5 d8 fe ff ff    	mov    %esi,-0x128(%ebp)
  10138a:	89 95 d4 fe ff ff    	mov    %edx,-0x12c(%ebp)
  101390:	e8 db f8 ff ff       	call   100c70 <idt_set_entry>
  101395:	b8 11 00 00 00       	mov    $0x11,%eax
  10139a:	8d 0d 98 1b 10 00    	lea    0x101b98,%ecx
  1013a0:	ba 08 00 00 00       	mov    $0x8,%edx
  1013a5:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  1013aa:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  1013b1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1013b5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1013bc:	00 
  1013bd:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1013c4:	00 
  1013c5:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
  1013cb:	89 b5 cc fe ff ff    	mov    %esi,-0x134(%ebp)
  1013d1:	89 95 c8 fe ff ff    	mov    %edx,-0x138(%ebp)
  1013d7:	e8 94 f8 ff ff       	call   100c70 <idt_set_entry>
  1013dc:	b8 12 00 00 00       	mov    $0x12,%eax
  1013e1:	8d 0d 9c 1b 10 00    	lea    0x101b9c,%ecx
  1013e7:	ba 08 00 00 00       	mov    $0x8,%edx
  1013ec:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  1013f1:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  1013f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1013fc:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101403:	00 
  101404:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10140b:	00 
  10140c:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  101412:	89 b5 c0 fe ff ff    	mov    %esi,-0x140(%ebp)
  101418:	89 95 bc fe ff ff    	mov    %edx,-0x144(%ebp)
  10141e:	e8 4d f8 ff ff       	call   100c70 <idt_set_entry>
  101423:	b8 20 00 00 00       	mov    $0x20,%eax
  101428:	8d 0d a2 1b 10 00    	lea    0x101ba2,%ecx
  10142e:	ba 08 00 00 00       	mov    $0x8,%edx
  101433:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  101438:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10143f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101443:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10144a:	00 
  10144b:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101452:	00 
  101453:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
  101459:	89 b5 b4 fe ff ff    	mov    %esi,-0x14c(%ebp)
  10145f:	89 95 b0 fe ff ff    	mov    %edx,-0x150(%ebp)
  101465:	e8 06 f8 ff ff       	call   100c70 <idt_set_entry>
  10146a:	b8 21 00 00 00       	mov    $0x21,%eax
  10146f:	8d 0d a8 1b 10 00    	lea    0x101ba8,%ecx
  101475:	ba 08 00 00 00       	mov    $0x8,%edx
  10147a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  10147f:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101486:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10148a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101491:	00 
  101492:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101499:	00 
  10149a:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
  1014a0:	89 b5 a8 fe ff ff    	mov    %esi,-0x158(%ebp)
  1014a6:	89 95 a4 fe ff ff    	mov    %edx,-0x15c(%ebp)
  1014ac:	e8 bf f7 ff ff       	call   100c70 <idt_set_entry>
  1014b1:	b8 22 00 00 00       	mov    $0x22,%eax
  1014b6:	8d 0d ae 1b 10 00    	lea    0x101bae,%ecx
  1014bc:	ba 08 00 00 00       	mov    $0x8,%edx
  1014c1:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  1014c6:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1014cd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014d1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014d8:	00 
  1014d9:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014e0:	00 
  1014e1:	89 85 a0 fe ff ff    	mov    %eax,-0x160(%ebp)
  1014e7:	89 b5 9c fe ff ff    	mov    %esi,-0x164(%ebp)
  1014ed:	89 95 98 fe ff ff    	mov    %edx,-0x168(%ebp)
  1014f3:	e8 78 f7 ff ff       	call   100c70 <idt_set_entry>
  1014f8:	b8 23 00 00 00       	mov    $0x23,%eax
  1014fd:	8d 0d b4 1b 10 00    	lea    0x101bb4,%ecx
  101503:	ba 08 00 00 00       	mov    $0x8,%edx
  101508:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  10150d:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  101514:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101518:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10151f:	00 
  101520:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101527:	00 
  101528:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
  10152e:	89 b5 90 fe ff ff    	mov    %esi,-0x170(%ebp)
  101534:	89 95 8c fe ff ff    	mov    %edx,-0x174(%ebp)
  10153a:	e8 31 f7 ff ff       	call   100c70 <idt_set_entry>
  10153f:	b8 24 00 00 00       	mov    $0x24,%eax
  101544:	8d 0d ba 1b 10 00    	lea    0x101bba,%ecx
  10154a:	ba 08 00 00 00       	mov    $0x8,%edx
  10154f:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  101554:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  10155b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10155f:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101566:	00 
  101567:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10156e:	00 
  10156f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
  101575:	89 b5 84 fe ff ff    	mov    %esi,-0x17c(%ebp)
  10157b:	89 95 80 fe ff ff    	mov    %edx,-0x180(%ebp)
  101581:	e8 ea f6 ff ff       	call   100c70 <idt_set_entry>
  101586:	b8 25 00 00 00       	mov    $0x25,%eax
  10158b:	8d 0d c0 1b 10 00    	lea    0x101bc0,%ecx
  101591:	ba 08 00 00 00       	mov    $0x8,%edx
  101596:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  10159b:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  1015a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015a6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1015ad:	00 
  1015ae:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015b5:	00 
  1015b6:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
  1015bc:	89 b5 78 fe ff ff    	mov    %esi,-0x188(%ebp)
  1015c2:	89 95 74 fe ff ff    	mov    %edx,-0x18c(%ebp)
  1015c8:	e8 a3 f6 ff ff       	call   100c70 <idt_set_entry>
  1015cd:	b8 26 00 00 00       	mov    $0x26,%eax
  1015d2:	8d 0d c6 1b 10 00    	lea    0x101bc6,%ecx
  1015d8:	ba 08 00 00 00       	mov    $0x8,%edx
  1015dd:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  1015e2:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  1015e9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015ed:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1015f4:	00 
  1015f5:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015fc:	00 
  1015fd:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
  101603:	89 b5 6c fe ff ff    	mov    %esi,-0x194(%ebp)
  101609:	89 95 68 fe ff ff    	mov    %edx,-0x198(%ebp)
  10160f:	e8 5c f6 ff ff       	call   100c70 <idt_set_entry>
  101614:	b8 27 00 00 00       	mov    $0x27,%eax
  101619:	8d 0d cc 1b 10 00    	lea    0x101bcc,%ecx
  10161f:	ba 08 00 00 00       	mov    $0x8,%edx
  101624:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  101629:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
  101630:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101634:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10163b:	00 
  10163c:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101643:	00 
  101644:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%ebp)
  10164a:	89 b5 60 fe ff ff    	mov    %esi,-0x1a0(%ebp)
  101650:	89 95 5c fe ff ff    	mov    %edx,-0x1a4(%ebp)
  101656:	e8 15 f6 ff ff       	call   100c70 <idt_set_entry>
  10165b:	b8 28 00 00 00       	mov    $0x28,%eax
  101660:	8d 0d d2 1b 10 00    	lea    0x101bd2,%ecx
  101666:	ba 08 00 00 00       	mov    $0x8,%edx
  10166b:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  101670:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  101677:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10167b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101682:	00 
  101683:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10168a:	00 
  10168b:	89 85 58 fe ff ff    	mov    %eax,-0x1a8(%ebp)
  101691:	89 b5 54 fe ff ff    	mov    %esi,-0x1ac(%ebp)
  101697:	89 95 50 fe ff ff    	mov    %edx,-0x1b0(%ebp)
  10169d:	e8 ce f5 ff ff       	call   100c70 <idt_set_entry>
  1016a2:	b8 29 00 00 00       	mov    $0x29,%eax
  1016a7:	8d 0d d8 1b 10 00    	lea    0x101bd8,%ecx
  1016ad:	ba 08 00 00 00       	mov    $0x8,%edx
  1016b2:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  1016b7:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
  1016be:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016c2:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1016c9:	00 
  1016ca:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1016d1:	00 
  1016d2:	89 85 4c fe ff ff    	mov    %eax,-0x1b4(%ebp)
  1016d8:	89 b5 48 fe ff ff    	mov    %esi,-0x1b8(%ebp)
  1016de:	89 95 44 fe ff ff    	mov    %edx,-0x1bc(%ebp)
  1016e4:	e8 87 f5 ff ff       	call   100c70 <idt_set_entry>
  1016e9:	b8 2a 00 00 00       	mov    $0x2a,%eax
  1016ee:	8d 0d de 1b 10 00    	lea    0x101bde,%ecx
  1016f4:	ba 08 00 00 00       	mov    $0x8,%edx
  1016f9:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  1016fe:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
  101705:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101709:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101710:	00 
  101711:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101718:	00 
  101719:	89 85 40 fe ff ff    	mov    %eax,-0x1c0(%ebp)
  10171f:	89 b5 3c fe ff ff    	mov    %esi,-0x1c4(%ebp)
  101725:	89 95 38 fe ff ff    	mov    %edx,-0x1c8(%ebp)
  10172b:	e8 40 f5 ff ff       	call   100c70 <idt_set_entry>
  101730:	b8 2b 00 00 00       	mov    $0x2b,%eax
  101735:	8d 0d e4 1b 10 00    	lea    0x101be4,%ecx
  10173b:	ba 08 00 00 00       	mov    $0x8,%edx
  101740:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  101745:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  10174c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101750:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101757:	00 
  101758:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10175f:	00 
  101760:	89 85 34 fe ff ff    	mov    %eax,-0x1cc(%ebp)
  101766:	89 b5 30 fe ff ff    	mov    %esi,-0x1d0(%ebp)
  10176c:	89 95 2c fe ff ff    	mov    %edx,-0x1d4(%ebp)
  101772:	e8 f9 f4 ff ff       	call   100c70 <idt_set_entry>
  101777:	b8 2c 00 00 00       	mov    $0x2c,%eax
  10177c:	8d 0d ea 1b 10 00    	lea    0x101bea,%ecx
  101782:	ba 08 00 00 00       	mov    $0x8,%edx
  101787:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  10178c:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  101793:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101797:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10179e:	00 
  10179f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017a6:	00 
  1017a7:	89 85 28 fe ff ff    	mov    %eax,-0x1d8(%ebp)
  1017ad:	89 b5 24 fe ff ff    	mov    %esi,-0x1dc(%ebp)
  1017b3:	89 95 20 fe ff ff    	mov    %edx,-0x1e0(%ebp)
  1017b9:	e8 b2 f4 ff ff       	call   100c70 <idt_set_entry>
  1017be:	b8 2d 00 00 00       	mov    $0x2d,%eax
  1017c3:	8d 0d f0 1b 10 00    	lea    0x101bf0,%ecx
  1017c9:	ba 08 00 00 00       	mov    $0x8,%edx
  1017ce:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  1017d3:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  1017da:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1017de:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017e5:	00 
  1017e6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017ed:	00 
  1017ee:	89 85 1c fe ff ff    	mov    %eax,-0x1e4(%ebp)
  1017f4:	89 b5 18 fe ff ff    	mov    %esi,-0x1e8(%ebp)
  1017fa:	89 95 14 fe ff ff    	mov    %edx,-0x1ec(%ebp)
  101800:	e8 6b f4 ff ff       	call   100c70 <idt_set_entry>
  101805:	b8 2e 00 00 00       	mov    $0x2e,%eax
  10180a:	8d 0d f6 1b 10 00    	lea    0x101bf6,%ecx
  101810:	ba 08 00 00 00       	mov    $0x8,%edx
  101815:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  10181a:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
  101821:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101825:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10182c:	00 
  10182d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101834:	00 
  101835:	89 85 10 fe ff ff    	mov    %eax,-0x1f0(%ebp)
  10183b:	89 b5 0c fe ff ff    	mov    %esi,-0x1f4(%ebp)
  101841:	89 95 08 fe ff ff    	mov    %edx,-0x1f8(%ebp)
  101847:	e8 24 f4 ff ff       	call   100c70 <idt_set_entry>
  10184c:	b8 2f 00 00 00       	mov    $0x2f,%eax
  101851:	8d 0d fc 1b 10 00    	lea    0x101bfc,%ecx
  101857:	ba 08 00 00 00       	mov    $0x8,%edx
  10185c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  101861:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
  101868:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10186c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101873:	00 
  101874:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10187b:	00 
  10187c:	89 85 04 fe ff ff    	mov    %eax,-0x1fc(%ebp)
  101882:	89 b5 00 fe ff ff    	mov    %esi,-0x200(%ebp)
  101888:	89 95 fc fd ff ff    	mov    %edx,-0x204(%ebp)
  10188e:	e8 dd f3 ff ff       	call   100c70 <idt_set_entry>
  101893:	b8 30 00 00 00       	mov    $0x30,%eax
  101898:	8d 0d 02 1c 10 00    	lea    0x101c02,%ecx
  10189e:	ba 08 00 00 00       	mov    $0x8,%edx
  1018a3:	be ee 00 00 00       	mov    $0xee,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  1018a8:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  1018af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018b3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1018ba:	00 
  1018bb:	c7 44 24 0c ee 00 00 	movl   $0xee,0xc(%esp)
  1018c2:	00 
  1018c3:	89 85 f8 fd ff ff    	mov    %eax,-0x208(%ebp)
  1018c9:	89 b5 f4 fd ff ff    	mov    %esi,-0x20c(%ebp)
  1018cf:	89 95 f0 fd ff ff    	mov    %edx,-0x210(%ebp)
  1018d5:	e8 96 f3 ff ff       	call   100c70 <idt_set_entry>
  1018da:	b8 05 00 00 00       	mov    $0x5,%eax
  1018df:	8d 0d 08 71 10 00    	lea    0x107108,%ecx
  1018e5:	ba 80 00 00 00       	mov    $0x80,%edx
  1018ea:	be e9 00 00 00       	mov    $0xe9,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  1018ef:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  1018f6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018fa:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  101901:	00 
  101902:	c7 44 24 0c e9 00 00 	movl   $0xe9,0xc(%esp)
  101909:	00 
  10190a:	89 85 ec fd ff ff    	mov    %eax,-0x214(%ebp)
  101910:	89 b5 e8 fd ff ff    	mov    %esi,-0x218(%ebp)
  101916:	89 95 e4 fd ff ff    	mov    %edx,-0x21c(%ebp)
  10191c:	e8 df f0 ff ff       	call   100a00 <set_gdt_entry>
  101921:	b8 28 00 00 00       	mov    $0x28,%eax
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101926:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  101929:	0f 01 5d f0          	lidtl  -0x10(%ebp)
	asm volatile("sti");
  10192d:	fb                   	sti    
}
  10192e:	81 c4 34 02 00 00    	add    $0x234,%esp
  101934:	5e                   	pop    %esi
  101935:	5d                   	pop    %ebp
  101936:	c3                   	ret    
  101937:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10193e:	00 00 

00101940 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  101940:	55                   	push   %ebp
  101941:	89 e5                	mov    %esp,%ebp
  101943:	50                   	push   %eax
  101944:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  101948:	66 89 c1             	mov    %ax,%cx
  10194b:	8a 55 0c             	mov    0xc(%ebp),%dl
  10194e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  101952:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  101955:	8a 45 fd             	mov    -0x3(%ebp),%al
  101958:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  10195c:	ee                   	out    %al,(%dx)
}
  10195d:	83 c4 04             	add    $0x4,%esp
  101960:	5d                   	pop    %ebp
  101961:	c3                   	ret    
  101962:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101969:	1f 84 00 00 00 00 00 

00101970 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  101970:	55                   	push   %ebp
  101971:	89 e5                	mov    %esp,%ebp
  101973:	83 ec 08             	sub    $0x8,%esp
  101976:	8b 45 0c             	mov    0xc(%ebp),%eax
  101979:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10197c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10197f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	handlers[i] = fn;
  101982:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101985:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101988:	89 04 8d 20 a3 10 00 	mov    %eax,0x10a320(,%ecx,4)
	handler_set[i] = 1;
  10198f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101992:	c7 04 85 20 a2 10 00 	movl   $0x1,0x10a220(,%eax,4)
  101999:	01 00 00 00 
}
  10199d:	83 c4 08             	add    $0x8,%esp
  1019a0:	5d                   	pop    %ebp
  1019a1:	c3                   	ret    
  1019a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1019a9:	1f 84 00 00 00 00 00 

001019b0 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  1019b0:	55                   	push   %ebp
  1019b1:	89 e5                	mov    %esp,%ebp
  1019b3:	83 ec 28             	sub    $0x28,%esp
  1019b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1019b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	struct cpu_state* new_cpu = cpu;
  1019bc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1019bf:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (cpu->intr <= 0x1f) {
  1019c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1019c5:	81 78 1c 1f 00 00 00 	cmpl   $0x1f,0x1c(%eax)
  1019cc:	0f 87 3d 00 00 00    	ja     101a0f <handle_interrupt+0x5f>
		if (!isSchedulingEnabled()) {
  1019d2:	e8 49 1f 00 00       	call   103920 <isSchedulingEnabled>
  1019d7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1019dc:	0f 85 1a 00 00 00    	jne    1019fc <handle_interrupt+0x4c>
  1019e2:	8d 05 51 82 10 00    	lea    0x108251,%eax
			show_cod(cpu, "Kernel PANIC!");
  1019e8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1019eb:	89 0c 24             	mov    %ecx,(%esp)
  1019ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  1019f2:	e8 79 e9 ff ff       	call   100370 <show_cod>
		} else {
  1019f7:	e9 0e 00 00 00       	jmp    101a0a <handle_interrupt+0x5a>
			schedule_exception(cpu);
  1019fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1019ff:	89 04 24             	mov    %eax,(%esp)
  101a02:	e8 89 20 00 00       	call   103a90 <schedule_exception>
  101a07:	89 45 f4             	mov    %eax,-0xc(%ebp)
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  101a0a:	e9 fc 00 00 00       	jmp    101b0b <handle_interrupt+0x15b>
  101a0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a12:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101a19:	0f 82 a7 00 00 00    	jb     101ac6 <handle_interrupt+0x116>
  101a1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a22:	81 78 1c 2f 00 00 00 	cmpl   $0x2f,0x1c(%eax)
  101a29:	0f 87 97 00 00 00    	ja     101ac6 <handle_interrupt+0x116>
		if (cpu->intr >= 0x28) {
  101a2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a32:	81 78 1c 28 00 00 00 	cmpl   $0x28,0x1c(%eax)
  101a39:	0f 82 24 00 00 00    	jb     101a63 <handle_interrupt+0xb3>
  101a3f:	b8 a0 00 00 00       	mov    $0xa0,%eax
  101a44:	b9 20 00 00 00       	mov    $0x20,%ecx
			outb(0xa0, 0x20);
  101a49:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  101a50:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101a57:	00 
  101a58:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101a5b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  101a5e:	e8 dd fe ff ff       	call   101940 <outb>
		}
		if (cpu->intr == 0x20) {
  101a63:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a66:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101a6d:	0f 85 0e 00 00 00    	jne    101a81 <handle_interrupt+0xd1>
			new_cpu = schedule(cpu);
  101a73:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a76:	89 04 24             	mov    %eax,(%esp)
  101a79:	e8 92 24 00 00       	call   103f10 <schedule>
  101a7e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  101a81:	b8 20 00 00 00       	mov    $0x20,%eax
		}
		outb(0x20, 0x20);
  101a86:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  101a8d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101a94:	00 
  101a95:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101a98:	e8 a3 fe ff ff       	call   101940 <outb>
		if (handler_set[cpu->intr]) {
  101a9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101aa0:	8b 40 1c             	mov    0x1c(%eax),%eax
  101aa3:	81 3c 85 20 a2 10 00 	cmpl   $0x0,0x10a220(,%eax,4)
  101aaa:	00 00 00 00 
  101aae:	0f 84 0d 00 00 00    	je     101ac1 <handle_interrupt+0x111>
			handlers[cpu->intr]();
  101ab4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ab7:	8b 40 1c             	mov    0x1c(%eax),%eax
  101aba:	ff 14 85 20 a3 10 00 	call   *0x10a320(,%eax,4)
		}
	} else if (cpu->intr == 0x30) {
  101ac1:	e9 40 00 00 00       	jmp    101b06 <handle_interrupt+0x156>
  101ac6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ac9:	81 78 1c 30 00 00 00 	cmpl   $0x30,0x1c(%eax)
  101ad0:	0f 85 13 00 00 00    	jne    101ae9 <handle_interrupt+0x139>
		new_cpu = syscall(new_cpu);
  101ad6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ad9:	89 04 24             	mov    %eax,(%esp)
  101adc:	e8 5f 01 00 00       	call   101c40 <syscall>
  101ae1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	} else {
  101ae4:	e9 18 00 00 00       	jmp    101b01 <handle_interrupt+0x151>
  101ae9:	8d 05 5f 82 10 00    	lea    0x10825f,%eax
		kprintf("Unbekannter Interrupt\n");
  101aef:	89 04 24             	mov    %eax,(%esp)
  101af2:	e8 59 ea ff ff       	call   100550 <kprintf>
  101af7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		while (1) {
			// Prozessor anhalten
			asm volatile("cli; hlt");
  101afa:	fa                   	cli    
  101afb:	f4                   	hlt    
		}
  101afc:	e9 f9 ff ff ff       	jmp    101afa <handle_interrupt+0x14a>
  101b01:	e9 00 00 00 00       	jmp    101b06 <handle_interrupt+0x156>
  101b06:	e9 00 00 00 00       	jmp    101b0b <handle_interrupt+0x15b>
	}

	return new_cpu;
  101b0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101b0e:	83 c4 28             	add    $0x28,%esp
  101b11:	5d                   	pop    %ebp
  101b12:	c3                   	ret    
  101b13:	90                   	nop

00101b14 <intr_stub_0>:
  101b14:	6a 00                	push   $0x0
  101b16:	6a 00                	push   $0x0
  101b18:	e9 eb 00 00 00       	jmp    101c08 <intr_common_handler>

00101b1d <intr_stub_1>:
  101b1d:	6a 00                	push   $0x0
  101b1f:	6a 01                	push   $0x1
  101b21:	e9 e2 00 00 00       	jmp    101c08 <intr_common_handler>

00101b26 <intr_stub_2>:
  101b26:	6a 00                	push   $0x0
  101b28:	6a 02                	push   $0x2
  101b2a:	e9 d9 00 00 00       	jmp    101c08 <intr_common_handler>

00101b2f <intr_stub_3>:
  101b2f:	6a 00                	push   $0x0
  101b31:	6a 03                	push   $0x3
  101b33:	e9 d0 00 00 00       	jmp    101c08 <intr_common_handler>

00101b38 <intr_stub_4>:
  101b38:	6a 00                	push   $0x0
  101b3a:	6a 04                	push   $0x4
  101b3c:	e9 c7 00 00 00       	jmp    101c08 <intr_common_handler>

00101b41 <intr_stub_5>:
  101b41:	6a 00                	push   $0x0
  101b43:	6a 05                	push   $0x5
  101b45:	e9 be 00 00 00       	jmp    101c08 <intr_common_handler>

00101b4a <intr_stub_6>:
  101b4a:	6a 00                	push   $0x0
  101b4c:	6a 06                	push   $0x6
  101b4e:	e9 b5 00 00 00       	jmp    101c08 <intr_common_handler>

00101b53 <intr_stub_7>:
  101b53:	6a 00                	push   $0x0
  101b55:	6a 07                	push   $0x7
  101b57:	e9 ac 00 00 00       	jmp    101c08 <intr_common_handler>

00101b5c <intr_stub_8>:
  101b5c:	6a 08                	push   $0x8
  101b5e:	e9 a5 00 00 00       	jmp    101c08 <intr_common_handler>

00101b63 <intr_stub_9>:
  101b63:	6a 00                	push   $0x0
  101b65:	6a 09                	push   $0x9
  101b67:	e9 9c 00 00 00       	jmp    101c08 <intr_common_handler>

00101b6c <intr_stub_10>:
  101b6c:	6a 0a                	push   $0xa
  101b6e:	e9 95 00 00 00       	jmp    101c08 <intr_common_handler>

00101b73 <intr_stub_11>:
  101b73:	6a 0b                	push   $0xb
  101b75:	e9 8e 00 00 00       	jmp    101c08 <intr_common_handler>

00101b7a <intr_stub_12>:
  101b7a:	6a 0c                	push   $0xc
  101b7c:	e9 87 00 00 00       	jmp    101c08 <intr_common_handler>

00101b81 <intr_stub_13>:
  101b81:	6a 0d                	push   $0xd
  101b83:	e9 80 00 00 00       	jmp    101c08 <intr_common_handler>

00101b88 <intr_stub_14>:
  101b88:	6a 0e                	push   $0xe
  101b8a:	eb 7c                	jmp    101c08 <intr_common_handler>

00101b8c <intr_stub_15>:
  101b8c:	6a 00                	push   $0x0
  101b8e:	6a 0f                	push   $0xf
  101b90:	eb 76                	jmp    101c08 <intr_common_handler>

00101b92 <intr_stub_16>:
  101b92:	6a 00                	push   $0x0
  101b94:	6a 10                	push   $0x10
  101b96:	eb 70                	jmp    101c08 <intr_common_handler>

00101b98 <intr_stub_17>:
  101b98:	6a 11                	push   $0x11
  101b9a:	eb 6c                	jmp    101c08 <intr_common_handler>

00101b9c <intr_stub_18>:
  101b9c:	6a 00                	push   $0x0
  101b9e:	6a 12                	push   $0x12
  101ba0:	eb 66                	jmp    101c08 <intr_common_handler>

00101ba2 <intr_stub_32>:
  101ba2:	6a 00                	push   $0x0
  101ba4:	6a 20                	push   $0x20
  101ba6:	eb 60                	jmp    101c08 <intr_common_handler>

00101ba8 <intr_stub_33>:
  101ba8:	6a 00                	push   $0x0
  101baa:	6a 21                	push   $0x21
  101bac:	eb 5a                	jmp    101c08 <intr_common_handler>

00101bae <intr_stub_34>:
  101bae:	6a 00                	push   $0x0
  101bb0:	6a 22                	push   $0x22
  101bb2:	eb 54                	jmp    101c08 <intr_common_handler>

00101bb4 <intr_stub_35>:
  101bb4:	6a 00                	push   $0x0
  101bb6:	6a 23                	push   $0x23
  101bb8:	eb 4e                	jmp    101c08 <intr_common_handler>

00101bba <intr_stub_36>:
  101bba:	6a 00                	push   $0x0
  101bbc:	6a 24                	push   $0x24
  101bbe:	eb 48                	jmp    101c08 <intr_common_handler>

00101bc0 <intr_stub_37>:
  101bc0:	6a 00                	push   $0x0
  101bc2:	6a 25                	push   $0x25
  101bc4:	eb 42                	jmp    101c08 <intr_common_handler>

00101bc6 <intr_stub_38>:
  101bc6:	6a 00                	push   $0x0
  101bc8:	6a 26                	push   $0x26
  101bca:	eb 3c                	jmp    101c08 <intr_common_handler>

00101bcc <intr_stub_39>:
  101bcc:	6a 00                	push   $0x0
  101bce:	6a 27                	push   $0x27
  101bd0:	eb 36                	jmp    101c08 <intr_common_handler>

00101bd2 <intr_stub_40>:
  101bd2:	6a 00                	push   $0x0
  101bd4:	6a 28                	push   $0x28
  101bd6:	eb 30                	jmp    101c08 <intr_common_handler>

00101bd8 <intr_stub_41>:
  101bd8:	6a 00                	push   $0x0
  101bda:	6a 29                	push   $0x29
  101bdc:	eb 2a                	jmp    101c08 <intr_common_handler>

00101bde <intr_stub_42>:
  101bde:	6a 00                	push   $0x0
  101be0:	6a 2a                	push   $0x2a
  101be2:	eb 24                	jmp    101c08 <intr_common_handler>

00101be4 <intr_stub_43>:
  101be4:	6a 00                	push   $0x0
  101be6:	6a 2b                	push   $0x2b
  101be8:	eb 1e                	jmp    101c08 <intr_common_handler>

00101bea <intr_stub_44>:
  101bea:	6a 00                	push   $0x0
  101bec:	6a 2c                	push   $0x2c
  101bee:	eb 18                	jmp    101c08 <intr_common_handler>

00101bf0 <intr_stub_45>:
  101bf0:	6a 00                	push   $0x0
  101bf2:	6a 2d                	push   $0x2d
  101bf4:	eb 12                	jmp    101c08 <intr_common_handler>

00101bf6 <intr_stub_46>:
  101bf6:	6a 00                	push   $0x0
  101bf8:	6a 2e                	push   $0x2e
  101bfa:	eb 0c                	jmp    101c08 <intr_common_handler>

00101bfc <intr_stub_47>:
  101bfc:	6a 00                	push   $0x0
  101bfe:	6a 2f                	push   $0x2f
  101c00:	eb 06                	jmp    101c08 <intr_common_handler>

00101c02 <intr_stub_48>:
  101c02:	6a 00                	push   $0x0
  101c04:	6a 30                	push   $0x30
  101c06:	eb 00                	jmp    101c08 <intr_common_handler>

00101c08 <intr_common_handler>:
  101c08:	55                   	push   %ebp
  101c09:	57                   	push   %edi
  101c0a:	56                   	push   %esi
  101c0b:	52                   	push   %edx
  101c0c:	51                   	push   %ecx
  101c0d:	53                   	push   %ebx
  101c0e:	50                   	push   %eax
  101c0f:	54                   	push   %esp
  101c10:	66 b8 10 00          	mov    $0x10,%ax
  101c14:	66 8e d8             	mov    %ax,%ds
  101c17:	66 8e c0             	mov    %ax,%es
  101c1a:	e8 91 fd ff ff       	call   1019b0 <handle_interrupt>
  101c1f:	89 c4                	mov    %eax,%esp
  101c21:	66 b8 23 00          	mov    $0x23,%ax
  101c25:	66 8e d8             	mov    %ax,%ds
  101c28:	66 8e c0             	mov    %ax,%es
  101c2b:	58                   	pop    %eax
  101c2c:	5b                   	pop    %ebx
  101c2d:	59                   	pop    %ecx
  101c2e:	5a                   	pop    %edx
  101c2f:	5e                   	pop    %esi
  101c30:	5f                   	pop    %edi
  101c31:	5d                   	pop    %ebp
  101c32:	83 c4 08             	add    $0x8,%esp
  101c35:	cf                   	iret   
  101c36:	66 90                	xchg   %ax,%ax
  101c38:	66 90                	xchg   %ax,%ax
  101c3a:	66 90                	xchg   %ax,%ax
  101c3c:	66 90                	xchg   %ax,%ax
  101c3e:	66 90                	xchg   %ax,%ax

00101c40 <syscall>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct cpu_state* syscall(struct cpu_state* cpu) {
  101c40:	55                   	push   %ebp
  101c41:	89 e5                	mov    %esp,%ebp
  101c43:	56                   	push   %esi
  101c44:	81 ec d4 00 00 00    	sub    $0xd4,%esp
  101c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  101c4d:	89 45 f8             	mov    %eax,-0x8(%ebp)
	switch (cpu->eax) {
  101c50:	8b 00                	mov    (%eax),%eax
  101c52:	89 c1                	mov    %eax,%ecx
  101c54:	81 e9 c8 00 00 00    	sub    $0xc8,%ecx
  101c5a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  101c5d:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  101c60:	0f 8f 26 00 00 00    	jg     101c8c <syscall+0x4c>
  101c66:	e9 00 00 00 00       	jmp    101c6b <syscall+0x2b>
  101c6b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  101c6e:	48                   	dec    %eax
  101c6f:	89 c1                	mov    %eax,%ecx
  101c71:	83 e9 14             	sub    $0x14,%ecx
  101c74:	89 45 ac             	mov    %eax,-0x54(%ebp)
  101c77:	89 4d a8             	mov    %ecx,-0x58(%ebp)
  101c7a:	0f 87 bf 05 00 00    	ja     10223f <syscall+0x5ff>
  101c80:	8b 45 ac             	mov    -0x54(%ebp),%eax
  101c83:	8b 0c 85 44 80 10 00 	mov    0x108044(,%eax,4),%ecx
  101c8a:	ff e1                	jmp    *%ecx
  101c8c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  101c8f:	05 37 ff ff ff       	add    $0xffffff37,%eax
  101c94:	89 c1                	mov    %eax,%ecx
  101c96:	83 e9 04             	sub    $0x4,%ecx
  101c99:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  101c9c:	89 4d a0             	mov    %ecx,-0x60(%ebp)
  101c9f:	0f 87 9a 05 00 00    	ja     10223f <syscall+0x5ff>
  101ca5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  101ca8:	8b 0c 85 30 80 10 00 	mov    0x108030(,%eax,4),%ecx
  101caf:	ff e1                	jmp    *%ecx
	case 1: /* exit */
		cpu = terminate_current(cpu);
  101cb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101cb4:	89 04 24             	mov    %eax,(%esp)
  101cb7:	e8 04 1f 00 00       	call   103bc0 <terminate_current>
  101cbc:	89 45 f8             	mov    %eax,-0x8(%ebp)
		break;
  101cbf:	e9 98 05 00 00       	jmp    10225c <syscall+0x61c>

	case 2: /* fork */
	{
		save_cpu_state(cpu);
  101cc4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101cc7:	89 04 24             	mov    %eax,(%esp)
  101cca:	e8 01 22 00 00       	call   103ed0 <save_cpu_state>

		uint32_t forkpdir = vmm_fork_current();
  101ccf:	e8 7c 3b 00 00       	call   105850 <vmm_fork_current>
  101cd4:	b9 00 00 00 00       	mov    $0x0,%ecx
  101cd9:	89 45 f4             	mov    %eax,-0xc(%ebp)

		struct task* ntask = init_task(forkpdir, 0);
  101cdc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101cdf:	89 04 24             	mov    %eax,(%esp)
  101ce2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101ce9:	00 
  101cea:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  101ced:	e8 1e 20 00 00       	call   103d10 <init_task>
  101cf2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		fork_task_state(ntask);
  101cf5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cf8:	89 04 24             	mov    %eax,(%esp)
  101cfb:	e8 90 1f 00 00       	call   103c90 <fork_task_state>

		cpu->eax = ntask->PID;
  101d00:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101d03:	8b 00                	mov    (%eax),%eax
  101d05:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101d08:	89 01                	mov    %eax,(%ecx)
	}
        break;
  101d0a:	e9 4d 05 00 00       	jmp    10225c <syscall+0x61c>

    case 3: /* exec */
    {
        save_cpu_state(cpu);
  101d0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d12:	89 04 24             	mov    %eax,(%esp)
  101d15:	e8 b6 21 00 00       	call   103ed0 <save_cpu_state>
        vfs_exec((char*) cpu->ebx, (char**) cpu->ecx, get_current_task());
  101d1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d1d:	8b 40 04             	mov    0x4(%eax),%eax
  101d20:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101d23:	8b 49 08             	mov    0x8(%ecx),%ecx
  101d26:	89 45 98             	mov    %eax,-0x68(%ebp)
  101d29:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
  101d2c:	e8 ff 1b 00 00       	call   103930 <get_current_task>
  101d31:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  101d34:	89 0c 24             	mov    %ecx,(%esp)
  101d37:	8b 55 94             	mov    -0x6c(%ebp),%edx
  101d3a:	89 54 24 04          	mov    %edx,0x4(%esp)
  101d3e:	89 44 24 08          	mov    %eax,0x8(%esp)
  101d42:	e8 29 35 00 00       	call   105270 <vfs_exec>
        cpu = get_current_task()->cpuState;
  101d47:	e8 e4 1b 00 00       	call   103930 <get_current_task>
  101d4c:	8b 40 04             	mov    0x4(%eax),%eax
  101d4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
        break;
  101d52:	e9 05 05 00 00       	jmp    10225c <syscall+0x61c>

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  101d57:	e8 d4 1b 00 00       	call   103930 <get_current_task>
  101d5c:	8b 40 18             	mov    0x18(%eax),%eax
  101d5f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101d62:	89 01                	mov    %eax,(%ecx)
    }
        break;
  101d64:	e9 f3 04 00 00       	jmp    10225c <syscall+0x61c>

	case 10: /* fopen */
	{
	    char* name = strclone((char*) cpu->ebx);
  101d69:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d6c:	8b 40 04             	mov    0x4(%eax),%eax
  101d6f:	89 04 24             	mov    %eax,(%esp)
  101d72:	e8 d9 2b 00 00       	call   104950 <strclone>
  101d77:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  101d7a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d7d:	8b 40 08             	mov    0x8(%eax),%eax
  101d80:	89 45 e8             	mov    %eax,-0x18(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  101d83:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101d86:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  101d89:	89 04 24             	mov    %eax,(%esp)
  101d8c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d90:	e8 4b 31 00 00       	call   104ee0 <vfs_open>
  101d95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    if(handle) {
  101d98:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  101d9f:	0f 84 1b 00 00 00    	je     101dc0 <syscall+0x180>
	        register_handle(handle);
  101da5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101da8:	89 04 24             	mov    %eax,(%esp)
  101dab:	e8 90 1b 00 00       	call   103940 <register_handle>
	        cpu->eax = (uint32_t) handle;
  101db0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101db3:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101db6:	89 0a                	mov    %ecx,(%edx)
	    }
  101db8:	89 45 90             	mov    %eax,-0x70(%ebp)
  101dbb:	e9 09 00 00 00       	jmp    101dc9 <syscall+0x189>
	    else
	    {
	        cpu->eax = 0;
  101dc0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101dc3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }

	    free(name);
  101dc9:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101dcc:	89 04 24             	mov    %eax,(%esp)
  101dcf:	e8 dc 25 00 00       	call   1043b0 <free>
	}
	    break;
  101dd4:	e9 83 04 00 00       	jmp    10225c <syscall+0x61c>

	case 11: /* fclose */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  101dd9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ddc:	8b 40 04             	mov    0x4(%eax),%eax
  101ddf:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    if(!unregister_handle(handle)) {
  101de2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101de5:	89 04 24             	mov    %eax,(%esp)
  101de8:	e8 b3 1b 00 00       	call   1039a0 <unregister_handle>
  101ded:	3d 00 00 00 00       	cmp    $0x0,%eax
  101df2:	0f 85 1c 00 00 00    	jne    101e14 <syscall+0x1d4>
	        vfs_close(handle);
  101df8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101dfb:	89 04 24             	mov    %eax,(%esp)
  101dfe:	e8 5d 31 00 00       	call   104f60 <vfs_close>

	        cpu->eax = 0;
  101e03:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e06:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	    }
  101e0c:	89 45 8c             	mov    %eax,-0x74(%ebp)
  101e0f:	e9 09 00 00 00       	jmp    101e1d <syscall+0x1dd>
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  101e14:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e17:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  101e1d:	e9 3a 04 00 00       	jmp    10225c <syscall+0x61c>

	case 12: /* fwrite */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  101e22:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e25:	8b 40 04             	mov    0x4(%eax),%eax
  101e28:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    if(handle != 0) {
  101e2b:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  101e32:	0f 84 39 00 00 00    	je     101e71 <syscall+0x231>
  101e38:	b8 01 00 00 00       	mov    $0x1,%eax
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  101e3d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  101e40:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101e43:	8b 52 08             	mov    0x8(%edx),%edx
  101e46:	8b 75 f8             	mov    -0x8(%ebp),%esi
  101e49:	8b 76 0c             	mov    0xc(%esi),%esi
  101e4c:	89 0c 24             	mov    %ecx,(%esp)
  101e4f:	89 54 24 04          	mov    %edx,0x4(%esp)
  101e53:	89 74 24 08          	mov    %esi,0x8(%esp)
  101e57:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  101e5e:	00 
  101e5f:	89 45 88             	mov    %eax,-0x78(%ebp)
  101e62:	e8 29 32 00 00       	call   105090 <vfs_write>
  101e67:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e6a:	89 01                	mov    %eax,(%ecx)
	    }
  101e6c:	e9 09 00 00 00       	jmp    101e7a <syscall+0x23a>
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  101e71:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e74:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  101e7a:	e9 dd 03 00 00       	jmp    10225c <syscall+0x61c>

	case 13: /* fread */
	{
        struct res_handle* handle = (void*) cpu->ebx;
  101e7f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e82:	8b 40 04             	mov    0x4(%eax),%eax
  101e85:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(handle != 0) {
  101e88:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  101e8f:	0f 84 39 00 00 00    	je     101ece <syscall+0x28e>
  101e95:	b8 01 00 00 00       	mov    $0x1,%eax
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  101e9a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101e9d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101ea0:	8b 52 08             	mov    0x8(%edx),%edx
  101ea3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  101ea6:	8b 76 0c             	mov    0xc(%esi),%esi
  101ea9:	89 0c 24             	mov    %ecx,(%esp)
  101eac:	89 54 24 04          	mov    %edx,0x4(%esp)
  101eb0:	89 74 24 08          	mov    %esi,0x8(%esp)
  101eb4:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  101ebb:	00 
  101ebc:	89 45 84             	mov    %eax,-0x7c(%ebp)
  101ebf:	e8 ec 30 00 00       	call   104fb0 <vfs_read>
  101ec4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101ec7:	89 01                	mov    %eax,(%ecx)
        }
  101ec9:	e9 09 00 00 00       	jmp    101ed7 <syscall+0x297>
        else
        {
            cpu->eax = RW_ERR_VFS;
  101ece:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ed1:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  101ed7:	e9 80 03 00 00       	jmp    10225c <syscall+0x61c>

	case 14: /* fmkfifo */
	{
        char* name = strclone((char*) cpu->ebx);
  101edc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101edf:	8b 40 04             	mov    0x4(%eax),%eax
  101ee2:	89 04 24             	mov    %eax,(%esp)
  101ee5:	e8 66 2a 00 00       	call   104950 <strclone>
  101eea:	8d 4d d0             	lea    -0x30(%ebp),%ecx
  101eed:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){65536});
  101ef0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101ef3:	89 4d 80             	mov    %ecx,-0x80(%ebp)
  101ef6:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  101efc:	e8 7f 14 00 00       	call   103380 <ramfs_fifo_driver_struct>
  101f01:	c7 45 d0 00 00 01 00 	movl   $0x10000,-0x30(%ebp)
  101f08:	8b 8d 7c ff ff ff    	mov    -0x84(%ebp),%ecx
  101f0e:	89 0c 24             	mov    %ecx,(%esp)
  101f11:	89 44 24 04          	mov    %eax,0x4(%esp)
  101f15:	8b 45 80             	mov    -0x80(%ebp),%eax
  101f18:	89 44 24 08          	mov    %eax,0x8(%esp)
  101f1c:	e8 4f 2e 00 00       	call   104d70 <vfs_create_kfile>
  101f21:	b9 03 00 00 00       	mov    $0x3,%ecx

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  101f26:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  101f29:	89 14 24             	mov    %edx,(%esp)
  101f2c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  101f33:	00 
  101f34:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  101f3a:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%ebp)
  101f40:	e8 9b 2f 00 00       	call   104ee0 <vfs_open>
  101f45:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(handle) {
  101f48:	81 7d cc 00 00 00 00 	cmpl   $0x0,-0x34(%ebp)
  101f4f:	0f 84 1e 00 00 00    	je     101f73 <syscall+0x333>
            register_handle(handle);
  101f55:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101f58:	89 04 24             	mov    %eax,(%esp)
  101f5b:	e8 e0 19 00 00       	call   103940 <register_handle>
            cpu->eax = (uint32_t) handle;
  101f60:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  101f63:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101f66:	89 0a                	mov    %ecx,(%edx)
        }
  101f68:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
  101f6e:	e9 09 00 00 00       	jmp    101f7c <syscall+0x33c>
        else
        {
            cpu->eax = 0;
  101f73:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        free(name);
  101f7c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101f7f:	89 04 24             	mov    %eax,(%esp)
  101f82:	e8 29 24 00 00       	call   1043b0 <free>
	}
	    break;
  101f87:	e9 d0 02 00 00       	jmp    10225c <syscall+0x61c>

	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  101f8c:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	    switch(cpu->ebx) {
  101f93:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f96:	8b 40 04             	mov    0x4(%eax),%eax
  101f99:	89 c1                	mov    %eax,%ecx
  101f9b:	83 e9 02             	sub    $0x2,%ecx
  101f9e:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
  101fa4:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
  101faa:	0f 84 52 00 00 00    	je     102002 <syscall+0x3c2>
  101fb0:	e9 00 00 00 00       	jmp    101fb5 <syscall+0x375>
  101fb5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  101fbb:	83 e8 01             	sub    $0x1,%eax
  101fbe:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  101fc4:	0f 84 28 00 00 00    	je     101ff2 <syscall+0x3b2>
  101fca:	e9 00 00 00 00       	jmp    101fcf <syscall+0x38f>
  101fcf:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  101fd5:	85 c0                	test   %eax,%eax
  101fd7:	0f 85 35 00 00 00    	jne    102012 <syscall+0x3d2>
  101fdd:	e9 00 00 00 00       	jmp    101fe2 <syscall+0x3a2>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
  101fe2:	e8 49 19 00 00       	call   103930 <get_current_task>
  101fe7:	8b 40 1c             	mov    0x1c(%eax),%eax
  101fea:	89 45 c8             	mov    %eax,-0x38(%ebp)
	        break;
  101fed:	e9 2b 00 00 00       	jmp    10201d <syscall+0x3dd>
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  101ff2:	e8 39 19 00 00       	call   103930 <get_current_task>
  101ff7:	8b 40 24             	mov    0x24(%eax),%eax
  101ffa:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
  101ffd:	e9 1b 00 00 00       	jmp    10201d <syscall+0x3dd>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  102002:	e8 29 19 00 00       	call   103930 <get_current_task>
  102007:	8b 40 20             	mov    0x20(%eax),%eax
  10200a:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
  10200d:	e9 0b 00 00 00       	jmp    10201d <syscall+0x3dd>
        default:
            handle = get_current_task()->stdout;
  102012:	e8 19 19 00 00       	call   103930 <get_current_task>
  102017:	8b 40 1c             	mov    0x1c(%eax),%eax
  10201a:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
	    }

	    cpu->eax = (uint32_t) handle;
  10201d:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102020:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102023:	89 01                	mov    %eax,(%ecx)
	}
	    break;
  102025:	e9 32 02 00 00       	jmp    10225c <syscall+0x61c>

	case 21: /* fopenpmhandle */
	{
	    char* path = strclone((char*)cpu->ecx);
  10202a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10202d:	8b 40 08             	mov    0x8(%eax),%eax
  102030:	89 04 24             	mov    %eax,(%esp)
  102033:	e8 18 29 00 00       	call   104950 <strclone>
  102038:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  10203b:	c7 45 bc 02 00 00 00 	movl   $0x2,-0x44(%ebp)

	    if(cpu->ebx == PMID_STDIN) {
  102042:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102045:	81 78 04 01 00 00 00 	cmpl   $0x1,0x4(%eax)
  10204c:	0f 85 07 00 00 00    	jne    102059 <syscall+0x419>
	        fm = FM_READ;
  102052:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
	    }

	    open = vfs_open(path, fm);
  102059:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10205c:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  10205f:	89 04 24             	mov    %eax,(%esp)
  102062:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102066:	e8 75 2e 00 00       	call   104ee0 <vfs_open>
  10206b:	89 45 c0             	mov    %eax,-0x40(%ebp)

	    free(path);
  10206e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  102071:	89 04 24             	mov    %eax,(%esp)
  102074:	e8 37 23 00 00       	call   1043b0 <free>

	    if(!open) {
  102079:	81 7d c0 00 00 00 00 	cmpl   $0x0,-0x40(%ebp)
  102080:	0f 85 0e 00 00 00    	jne    102094 <syscall+0x454>
	        cpu->eax = (uint32_t) -1;
  102086:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102089:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	        break;
  10208f:	e9 c8 01 00 00       	jmp    10225c <syscall+0x61c>
	    }

	    struct res_handle* oldhandle = 0;
  102094:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

        switch(cpu->ebx) {
  10209b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10209e:	8b 40 04             	mov    0x4(%eax),%eax
  1020a1:	89 c1                	mov    %eax,%ecx
  1020a3:	83 e9 02             	sub    $0x2,%ecx
  1020a6:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
  1020ac:	89 8d 5c ff ff ff    	mov    %ecx,-0xa4(%ebp)
  1020b2:	0f 84 80 00 00 00    	je     102138 <syscall+0x4f8>
  1020b8:	e9 00 00 00 00       	jmp    1020bd <syscall+0x47d>
  1020bd:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1020c3:	83 e8 01             	sub    $0x1,%eax
  1020c6:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
  1020cc:	0f 84 3f 00 00 00    	je     102111 <syscall+0x4d1>
  1020d2:	e9 00 00 00 00       	jmp    1020d7 <syscall+0x497>
  1020d7:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1020dd:	85 c0                	test   %eax,%eax
  1020df:	0f 85 7a 00 00 00    	jne    10215f <syscall+0x51f>
  1020e5:	e9 00 00 00 00       	jmp    1020ea <syscall+0x4aa>
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  1020ea:	e8 41 18 00 00       	call   103930 <get_current_task>
  1020ef:	8b 40 1c             	mov    0x1c(%eax),%eax
  1020f2:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdout = open;
  1020f5:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1020f8:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  1020fe:	e8 2d 18 00 00       	call   103930 <get_current_task>
  102103:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
  102109:	89 48 1c             	mov    %ecx,0x1c(%eax)
            break;
  10210c:	e9 70 00 00 00       	jmp    102181 <syscall+0x541>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  102111:	e8 1a 18 00 00       	call   103930 <get_current_task>
  102116:	8b 40 24             	mov    0x24(%eax),%eax
  102119:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdin = open;
  10211c:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10211f:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  102125:	e8 06 18 00 00       	call   103930 <get_current_task>
  10212a:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
  102130:	89 48 24             	mov    %ecx,0x24(%eax)
            break;
  102133:	e9 49 00 00 00       	jmp    102181 <syscall+0x541>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  102138:	e8 f3 17 00 00       	call   103930 <get_current_task>
  10213d:	8b 40 20             	mov    0x20(%eax),%eax
  102140:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stderr = open;
  102143:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102146:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
  10214c:	e8 df 17 00 00       	call   103930 <get_current_task>
  102151:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
  102157:	89 48 20             	mov    %ecx,0x20(%eax)
            break;
  10215a:	e9 22 00 00 00       	jmp    102181 <syscall+0x541>
        default:
            oldhandle = get_current_task()->stdout;
  10215f:	e8 cc 17 00 00       	call   103930 <get_current_task>
  102164:	8b 40 1c             	mov    0x1c(%eax),%eax
  102167:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdout = open;
  10216a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10216d:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
  102173:	e8 b8 17 00 00       	call   103930 <get_current_task>
  102178:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
  10217e:	89 48 1c             	mov    %ecx,0x1c(%eax)
            break;
        }

        if(oldhandle != 0) {
  102181:	81 7d b8 00 00 00 00 	cmpl   $0x0,-0x48(%ebp)
  102188:	0f 84 11 00 00 00    	je     10219f <syscall+0x55f>
            vfs_close(oldhandle);
  10218e:	8b 45 b8             	mov    -0x48(%ebp),%eax
  102191:	89 04 24             	mov    %eax,(%esp)
  102194:	e8 c7 2d 00 00       	call   104f60 <vfs_close>
  102199:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
        }

        cpu->eax = 0;
  10219f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1021a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	    break;
  1021a8:	e9 af 00 00 00       	jmp    10225c <syscall+0x61c>
  1021ad:	8d 05 76 82 10 00    	lea    0x108276,%eax

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  1021b3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1021b6:	8b 49 04             	mov    0x4(%ecx),%ecx
  1021b9:	89 04 24             	mov    %eax,(%esp)
  1021bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1021c0:	e8 8b e3 ff ff       	call   100550 <kprintf>
  1021c5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1021c8:	89 01                	mov    %eax,(%ecx)
		break;
  1021ca:	e9 8d 00 00 00       	jmp    10225c <syscall+0x61c>
  1021cf:	8d 05 79 82 10 00    	lea    0x108279,%eax

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  1021d5:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1021d8:	8b 49 04             	mov    0x4(%ecx),%ecx
  1021db:	89 04 24             	mov    %eax,(%esp)
  1021de:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1021e2:	e8 69 e3 ff ff       	call   100550 <kprintf>
  1021e7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1021ea:	89 01                	mov    %eax,(%ecx)
		break;
  1021ec:	e9 6b 00 00 00       	jmp    10225c <syscall+0x61c>

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  1021f1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1021f4:	8b 40 04             	mov    0x4(%eax),%eax
  1021f7:	89 04 24             	mov    %eax,(%esp)
  1021fa:	e8 a1 3e 00 00       	call   1060a0 <vmm_alloc_ucont>
  1021ff:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102202:	89 01                	mov    %eax,(%ecx)
		break;
  102204:	e9 53 00 00 00       	jmp    10225c <syscall+0x61c>

	case 204: /* vmm_free */
		cpu->eax = 0;
  102209:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10220c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  102212:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102215:	81 78 04 00 10 40 20 	cmpl   $0x20401000,0x4(%eax)
  10221c:	0f 82 0e 00 00 00    	jb     102230 <syscall+0x5f0>
			vmm_free((void*) cpu->ebx);
  102222:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102225:	8b 40 04             	mov    0x4(%eax),%eax
  102228:	89 04 24             	mov    %eax,(%esp)
  10222b:	e8 e0 3c 00 00       	call   105f10 <vmm_free>
		}
		break;
  102230:	e9 27 00 00 00       	jmp    10225c <syscall+0x61c>

	case 205: /* pmm_print_stats */
		pmm_print_stats();
  102235:	e8 16 03 00 00       	call   102550 <pmm_print_stats>
		break;
  10223a:	e9 1d 00 00 00       	jmp    10225c <syscall+0x61c>
  10223f:	8d 05 7c 82 10 00    	lea    0x10827c,%eax

	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  102245:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102248:	8b 09                	mov    (%ecx),%ecx
  10224a:	89 04 24             	mov    %eax,(%esp)
  10224d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102251:	e8 fa e2 ff ff       	call   100550 <kprintf>
  102256:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		break;
	}

	return cpu;
  10225c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10225f:	81 c4 d4 00 00 00    	add    $0xd4,%esp
  102265:	5e                   	pop    %esi
  102266:	5d                   	pop    %ebp
  102267:	c3                   	ret    
  102268:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10226f:	00 

00102270 <kernel_main>:
}

void kernel_main(struct multiboot_info* mb_info) {
  102270:	55                   	push   %ebp
  102271:	89 e5                	mov    %esp,%ebp
  102273:	57                   	push   %edi
  102274:	56                   	push   %esi
  102275:	83 ec 50             	sub    $0x50,%esp
  102278:	8b 45 08             	mov    0x8(%ebp),%eax
  10227b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t kernel_init_pdir = vmm_init();
  10227e:	e8 1d 41 00 00       	call   1063a0 <vmm_init>
  102283:	8d 0d 92 82 10 00    	lea    0x108292,%ecx
  102289:	89 45 f0             	mov    %eax,-0x10(%ebp)

    kprintf("Initializing vfs...\n");
  10228c:	89 0c 24             	mov    %ecx,(%esp)
  10228f:	e8 bc e2 ff ff       	call   100550 <kprintf>

    vfs_init_root();
  102294:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102297:	e8 14 33 00 00       	call   1055b0 <vfs_init_root>
  10229c:	b8 00 00 00 00       	mov    $0x0,%eax
    ramfs_fifo_init();
  1022a1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1022a4:	e8 37 0b 00 00       	call   102de0 <ramfs_fifo_init>
    ramfs_block_init();
  1022a9:	e8 82 06 00 00       	call   102930 <ramfs_block_init>

    map_address_active((uint32_t) mb_info,
  1022ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022b1:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1022b4:	89 04 24             	mov    %eax,(%esp)
  1022b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1022bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1022c2:	00 
  1022c3:	e8 c8 3c 00 00       	call   105f90 <map_address_active>
  1022c8:	b8 00 00 00 00       	mov    $0x0,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  1022cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1022d0:	8b 49 18             	mov    0x18(%ecx),%ecx
  1022d3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1022d6:	8b 52 18             	mov    0x18(%edx),%edx
  1022d9:	89 0c 24             	mov    %ecx,(%esp)
  1022dc:	89 54 24 04          	mov    %edx,0x4(%esp)
  1022e0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1022e7:	00 
  1022e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1022eb:	e8 a0 3c 00 00       	call   105f90 <map_address_active>
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  1022f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022f3:	8b 00                	mov    (%eax),%eax
  1022f5:	25 08 00 00 00       	and    $0x8,%eax
  1022fa:	3d 00 00 00 00       	cmp    $0x0,%eax
  1022ff:	0f 84 aa 00 00 00    	je     1023af <kernel_main+0x13f>
  102305:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  10230a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10230d:	8b 49 18             	mov    0x18(%ecx),%ecx
  102310:	8b 09                	mov    (%ecx),%ecx
  102312:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102315:	8b 52 18             	mov    0x18(%edx),%edx
  102318:	8b 12                	mov    (%edx),%edx
  10231a:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10231d:	8b 76 18             	mov    0x18(%esi),%esi
  102320:	8b 76 04             	mov    0x4(%esi),%esi
  102323:	8b 7d f4             	mov    -0xc(%ebp),%edi
  102326:	8b 7f 18             	mov    0x18(%edi),%edi
  102329:	8b 3f                	mov    (%edi),%edi
  10232b:	29 fe                	sub    %edi,%esi
  10232d:	89 0c 24             	mov    %ecx,(%esp)
  102330:	89 54 24 04          	mov    %edx,0x4(%esp)
  102334:	89 74 24 08          	mov    %esi,0x8(%esp)
  102338:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10233f:	00 
  102340:	89 45 e0             	mov    %eax,-0x20(%ebp)
  102343:	e8 b8 3c 00 00       	call   106000 <vmm_map_range>
  102348:	8d 05 a7 82 10 00    	lea    0x1082a7,%eax
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  10234e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102351:	8b 49 18             	mov    0x18(%ecx),%ecx
  102354:	8b 49 04             	mov    0x4(%ecx),%ecx
  102357:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10235a:	8b 52 18             	mov    0x18(%edx),%edx
  10235d:	8b 12                	mov    (%edx),%edx
  10235f:	29 d1                	sub    %edx,%ecx
  102361:	89 04 24             	mov    %eax,(%esp)
  102364:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102368:	e8 e3 e1 ff ff       	call   100550 <kprintf>
  10236d:	8d 0d e7 82 10 00    	lea    0x1082e7,%ecx
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);
  102373:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102376:	8b 52 18             	mov    0x18(%edx),%edx
  102379:	8b 12                	mov    (%edx),%edx
  10237b:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10237e:	8b 76 18             	mov    0x18(%esi),%esi
  102381:	8b 76 04             	mov    0x4(%esi),%esi
  102384:	89 0c 24             	mov    %ecx,(%esp)
  102387:	89 54 24 04          	mov    %edx,0x4(%esp)
  10238b:	89 74 24 08          	mov    %esi,0x8(%esp)
  10238f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102392:	e8 b9 e1 ff ff       	call   100550 <kprintf>

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  102397:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10239a:	8b 49 18             	mov    0x18(%ecx),%ecx
  10239d:	8b 09                	mov    (%ecx),%ecx
  10239f:	89 0c 24             	mov    %ecx,(%esp)
  1023a2:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1023a5:	e8 e6 0f 00 00       	call   103390 <tar_load_ramfs>
    } else {
  1023aa:	e9 11 00 00 00       	jmp    1023c0 <kernel_main+0x150>
  1023af:	8d 05 01 83 10 00    	lea    0x108301,%eax
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  1023b5:	89 04 24             	mov    %eax,(%esp)
  1023b8:	e8 93 e1 ff ff       	call   100550 <kprintf>
  1023bd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1023c0:	8d 05 33 83 10 00    	lea    0x108333,%eax
    }

    kprintf("[kernel_res] Creating /dev/vga\n");
  1023c6:	89 04 24             	mov    %eax,(%esp)
  1023c9:	e8 82 e1 ff ff       	call   100550 <kprintf>
  1023ce:	8d 0d 53 83 10 00    	lea    0x108353,%ecx
  1023d4:	ba 00 00 00 00       	mov    $0x0,%edx
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  1023d9:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1023dc:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  1023df:	89 55 c8             	mov    %edx,-0x38(%ebp)
  1023e2:	e8 09 15 00 00       	call   1038f0 <ramfs_vga_driver_struct>
  1023e7:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  1023ea:	89 0c 24             	mov    %ecx,(%esp)
  1023ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  1023f1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1023f8:	00 
  1023f9:	e8 72 29 00 00       	call   104d70 <vfs_create_kfile>
  1023fe:	8d 0d 5c 83 10 00    	lea    0x10835c,%ecx

    if(vfs_exists("/ibin/init")) {
  102404:	89 0c 24             	mov    %ecx,(%esp)
  102407:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  10240a:	e8 d1 2d 00 00       	call   1051e0 <vfs_exists>
  10240f:	3d 00 00 00 00       	cmp    $0x0,%eax
  102414:	0f 84 3c 00 00 00    	je     102456 <kernel_main+0x1e6>
  10241a:	8d 05 67 83 10 00    	lea    0x108367,%eax
        kprintf("[init] /ibin/init found. Executing...\n");
  102420:	89 04 24             	mov    %eax,(%esp)
  102423:	e8 28 e1 ff ff       	call   100550 <kprintf>
  102428:	8d 0d 5c 83 10 00    	lea    0x10835c,%ecx
  10242e:	ba 00 00 00 00       	mov    $0x0,%edx

        vfs_exec("/ibin/init", 0, 0);
  102433:	89 0c 24             	mov    %ecx,(%esp)
  102436:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10243d:	00 
  10243e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102445:	00 
  102446:	89 45 c0             	mov    %eax,-0x40(%ebp)
  102449:	89 55 bc             	mov    %edx,-0x44(%ebp)
  10244c:	e8 1f 2e 00 00       	call   105270 <vfs_exec>
        enableScheduling();
  102451:	e8 ba 14 00 00       	call   103910 <enableScheduling>
    }

	while(1);
  102456:	e9 00 00 00 00       	jmp    10245b <kernel_main+0x1eb>
  10245b:	e9 fb ff ff ff       	jmp    10245b <kernel_main+0x1eb>

00102460 <pmm_alloc>:
#define BITMAP_SIZE 32768

uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
  102460:	55                   	push   %ebp
  102461:	89 e5                	mov    %esp,%ebp
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102463:	56                   	push   %esi
  102464:	83 ec 10             	sub    $0x10,%esp
  102467:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10246e:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102475:	0f 8d b7 00 00 00    	jge    102532 <pmm_alloc+0xd2>
		if (allocatable[i]) {
  10247b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10247e:	81 3c 85 90 a4 12 00 	cmpl   $0x0,0x12a490(,%eax,4)
  102485:	00 00 00 00 
  102489:	0f 84 8e 00 00 00    	je     10251d <pmm_alloc+0xbd>
			int s;
			for (s = 0; s < 32; s++) {
  10248f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102496:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  10249d:	0f 8d 75 00 00 00    	jge    102518 <pmm_alloc+0xb8>
  1024a3:	b8 01 00 00 00       	mov    $0x1,%eax
				if (allocatable[i] & (1 << s)) {
  1024a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1024ab:	8b 0c 8d 90 a4 12 00 	mov    0x12a490(,%ecx,4),%ecx
  1024b2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1024b5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1024b8:	89 d1                	mov    %edx,%ecx
  1024ba:	d3 e0                	shl    %cl,%eax
  1024bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1024bf:	21 c2                	and    %eax,%edx
  1024c1:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  1024c7:	0f 84 36 00 00 00    	je     102503 <pmm_alloc+0xa3>
  1024cd:	b8 01 00 00 00       	mov    $0x1,%eax
					allocatable[i] &= ~(1 << s);
  1024d2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1024d5:	d3 e0                	shl    %cl,%eax
  1024d7:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  1024dc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1024df:	8b 34 95 90 a4 12 00 	mov    0x12a490(,%edx,4),%esi
  1024e6:	21 c6                	and    %eax,%esi
  1024e8:	89 34 95 90 a4 12 00 	mov    %esi,0x12a490(,%edx,4)
					return (uint8_t*) ((i * 32 + s) * 4096);
  1024ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1024f2:	c1 e0 05             	shl    $0x5,%eax
  1024f5:	03 45 f0             	add    -0x10(%ebp),%eax
  1024f8:	c1 e0 0c             	shl    $0xc,%eax
  1024fb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1024fe:	e9 36 00 00 00       	jmp    102539 <pmm_alloc+0xd9>
				}
			}
  102503:	e9 00 00 00 00       	jmp    102508 <pmm_alloc+0xa8>
void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
		if (allocatable[i]) {
			int s;
			for (s = 0; s < 32; s++) {
  102508:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10250b:	05 01 00 00 00       	add    $0x1,%eax
  102510:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102513:	e9 7e ff ff ff       	jmp    102496 <pmm_alloc+0x36>
				if (allocatable[i] & (1 << s)) {
					allocatable[i] &= ~(1 << s);
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
  102518:	e9 00 00 00 00       	jmp    10251d <pmm_alloc+0xbd>
	}
  10251d:	e9 00 00 00 00       	jmp    102522 <pmm_alloc+0xc2>
uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102522:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102525:	05 01 00 00 00       	add    $0x1,%eax
  10252a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10252d:	e9 3c ff ff ff       	jmp    10246e <pmm_alloc+0xe>
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
	}
	return NULL ;
  102532:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  102539:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10253c:	83 c4 10             	add    $0x10,%esp
  10253f:	5e                   	pop    %esi
  102540:	5d                   	pop    %ebp
  102541:	c3                   	ret    
  102542:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102549:	1f 84 00 00 00 00 00 

00102550 <pmm_print_stats>:

void pmm_print_stats() {
  102550:	55                   	push   %ebp
  102551:	89 e5                	mov    %esp,%ebp
  102553:	56                   	push   %esi
  102554:	83 ec 34             	sub    $0x34,%esp
  102557:	b8 00 00 10 00       	mov    $0x100000,%eax
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
  10255c:	c7 04 24 00 00 10 00 	movl   $0x100000,(%esp)
  102563:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102566:	e8 65 00 00 00       	call   1025d0 <pmm_get_free_space>
  10256b:	b9 00 04 00 00       	mov    $0x400,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102570:	8b 15 20 a4 10 00    	mov    0x10a420,%edx
  102576:	c1 ea 14             	shr    $0x14,%edx
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
  102579:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
  102580:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102583:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  102586:	89 55 ec             	mov    %edx,-0x14(%ebp)
  102589:	e8 42 00 00 00       	call   1025d0 <pmm_get_free_space>
  10258e:	8d 0d 8e 83 10 00    	lea    0x10838e,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102594:	8b 15 20 a4 10 00    	mov    0x10a420,%edx
  10259a:	c1 ea 0a             	shr    $0xa,%edx
  10259d:	89 0c 24             	mov    %ecx,(%esp)
  1025a0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1025a3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1025a7:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1025aa:	89 74 24 08          	mov    %esi,0x8(%esp)
  1025ae:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1025b2:	89 54 24 10          	mov    %edx,0x10(%esp)
  1025b6:	e8 95 df ff ff       	call   100550 <kprintf>
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
}
  1025bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1025be:	83 c4 34             	add    $0x34,%esp
  1025c1:	5e                   	pop    %esi
  1025c2:	5d                   	pop    %ebp
  1025c3:	c3                   	ret    
  1025c4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1025cb:	00 00 00 00 00 

001025d0 <pmm_get_free_space>:

uint32_t pmm_get_free_space(uint32_t div) {
  1025d0:	55                   	push   %ebp
  1025d1:	89 e5                	mov    %esp,%ebp
  1025d3:	83 ec 14             	sub    $0x14,%esp
  1025d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1025d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t free = 0;
  1025dc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  1025e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1025ea:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  1025f1:	0f 83 73 00 00 00    	jae    10266a <pmm_get_free_space+0x9a>
		for (uint32_t s = 0; s < 32; s++) {
  1025f7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1025fe:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  102605:	0f 83 4a 00 00 00    	jae    102655 <pmm_get_free_space+0x85>
  10260b:	b8 01 00 00 00       	mov    $0x1,%eax
			if (allocatable[i] & (1 << s))
  102610:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102613:	8b 0c 8d 90 a4 12 00 	mov    0x12a490(,%ecx,4),%ecx
  10261a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10261d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102620:	89 d1                	mov    %edx,%ecx
  102622:	d3 e0                	shl    %cl,%eax
  102624:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102627:	21 c2                	and    %eax,%edx
  102629:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  10262f:	0f 84 0b 00 00 00    	je     102640 <pmm_get_free_space+0x70>
				free += 0x1000;
  102635:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102638:	05 00 10 00 00       	add    $0x1000,%eax
  10263d:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  102640:	e9 00 00 00 00       	jmp    102645 <pmm_get_free_space+0x75>

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
		for (uint32_t s = 0; s < 32; s++) {
  102645:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102648:	05 01 00 00 00       	add    $0x1,%eax
  10264d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102650:	e9 a9 ff ff ff       	jmp    1025fe <pmm_get_free_space+0x2e>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}
  102655:	e9 00 00 00 00       	jmp    10265a <pmm_get_free_space+0x8a>
}

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  10265a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10265d:	05 01 00 00 00       	add    $0x1,%eax
  102662:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102665:	e9 80 ff ff ff       	jmp    1025ea <pmm_get_free_space+0x1a>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}

	return free / div;
  10266a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10266d:	31 d2                	xor    %edx,%edx
  10266f:	f7 75 fc             	divl   -0x4(%ebp)
  102672:	83 c4 14             	add    $0x14,%esp
  102675:	5d                   	pop    %ebp
  102676:	c3                   	ret    
  102677:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10267e:	00 00 

00102680 <pmm_free>:
}

void pmm_free(void* addr) {
  102680:	55                   	push   %ebp
  102681:	89 e5                	mov    %esp,%ebp
  102683:	56                   	push   %esi
  102684:	83 ec 14             	sub    $0x14,%esp
  102687:	8b 45 08             	mov    0x8(%ebp),%eax
  10268a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10268f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  102692:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102695:	c1 e8 0c             	shr    $0xc,%eax
  102698:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  10269b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10269e:	25 1f 00 00 00       	and    $0x1f,%eax
  1026a3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  1026a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026a9:	c1 e8 05             	shr    $0x5,%eax
  1026ac:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] |= (1 << s);
  1026af:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1026b2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1026b5:	89 c1                	mov    %eax,%ecx
  1026b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1026ba:	d3 e0                	shl    %cl,%eax
  1026bc:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1026bf:	8b 34 95 90 a4 12 00 	mov    0x12a490(,%edx,4),%esi
  1026c6:	09 c6                	or     %eax,%esi
  1026c8:	89 34 95 90 a4 12 00 	mov    %esi,0x12a490(,%edx,4)
}
  1026cf:	83 c4 14             	add    $0x14,%esp
  1026d2:	5e                   	pop    %esi
  1026d3:	5d                   	pop    %ebp
  1026d4:	c3                   	ret    
  1026d5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1026dc:	00 00 00 00 

001026e0 <pmm_mark_used>:

void pmm_mark_used(void* addr) {
  1026e0:	55                   	push   %ebp
  1026e1:	89 e5                	mov    %esp,%ebp
  1026e3:	56                   	push   %esi
  1026e4:	83 ec 14             	sub    $0x14,%esp
  1026e7:	8b 45 08             	mov    0x8(%ebp),%eax
  1026ea:	b9 01 00 00 00       	mov    $0x1,%ecx
  1026ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  1026f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1026f5:	c1 e8 0c             	shr    $0xc,%eax
  1026f8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  1026fb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026fe:	25 1f 00 00 00       	and    $0x1f,%eax
  102703:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  102706:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102709:	c1 e8 05             	shr    $0x5,%eax
  10270c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] &= ~(1 << s);
  10270f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102712:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102715:	89 c1                	mov    %eax,%ecx
  102717:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10271a:	d3 e0                	shl    %cl,%eax
  10271c:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  102721:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102724:	8b 34 95 90 a4 12 00 	mov    0x12a490(,%edx,4),%esi
  10272b:	21 c6                	and    %eax,%esi
  10272d:	89 34 95 90 a4 12 00 	mov    %esi,0x12a490(,%edx,4)
}
  102734:	83 c4 14             	add    $0x14,%esp
  102737:	5e                   	pop    %esi
  102738:	5d                   	pop    %ebp
  102739:	c3                   	ret    
  10273a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00102740 <pmm_init>:

void pmm_init(struct multiboot_info* mb_info) {
  102740:	55                   	push   %ebp
  102741:	89 e5                	mov    %esp,%ebp
  102743:	53                   	push   %ebx
  102744:	57                   	push   %edi
  102745:	56                   	push   %esi
  102746:	83 ec 5c             	sub    $0x5c,%esp
  102749:	8b 45 08             	mov    0x8(%ebp),%eax
  10274c:	8d 0d cb 83 10 00    	lea    0x1083cb,%ecx
  102752:	8d 15 90 a4 12 00    	lea    0x12a490,%edx
  102758:	89 d6                	mov    %edx,%esi
  10275a:	81 c6 00 00 02 00    	add    $0x20000,%esi
  102760:	89 d7                	mov    %edx,%edi
  102762:	bb 00 00 00 00       	mov    $0x0,%ebx
  102767:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10276a:	b8 00 00 02 00       	mov    $0x20000,%eax
  10276f:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102772:	8b 45 d0             	mov    -0x30(%ebp),%eax
  102775:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct multiboot_mmap* mmap = mb_info->mi_mmap_addr;
  102778:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10277b:	8b 40 30             	mov    0x30(%eax),%eax
  10277e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct multiboot_mmap* mmap_end = (void*) ((uintptr_t) mb_info->mi_mmap_addr
  102781:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102784:	8b 40 30             	mov    0x30(%eax),%eax
  102787:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10278a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10278d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  102790:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102793:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  102796:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  102799:	03 41 2c             	add    0x2c(%ecx),%eax
  10279c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			+ mb_info->mi_mmap_length);

	memset(allocatable, 0, sizeof(allocatable));
  10279f:	89 3c 24             	mov    %edi,(%esp)
  1027a2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1027a9:	00 
  1027aa:	c7 44 24 08 00 00 02 	movl   $0x20000,0x8(%esp)
  1027b1:	00 
  1027b2:	89 5d bc             	mov    %ebx,-0x44(%ebp)
  1027b5:	89 55 b8             	mov    %edx,-0x48(%ebp)
  1027b8:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  1027bb:	e8 90 1e 00 00       	call   104650 <memset>

	kprintf("Mem-Bitmap: %x to %x\n", allocatable, &(allocatable[BITMAP_SIZE]));
  1027c0:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1027c3:	89 04 24             	mov    %eax,(%esp)
  1027c6:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  1027c9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1027cd:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  1027d0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1027d4:	e8 77 dd ff ff       	call   100550 <kprintf>
  1027d9:	89 45 b0             	mov    %eax,-0x50(%ebp)

	while (mmap < mmap_end) {
  1027dc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027df:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  1027e2:	0f 83 77 00 00 00    	jae    10285f <pmm_init+0x11f>
		if (mmap->mm_type == 1) {
  1027e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027eb:	81 78 14 01 00 00 00 	cmpl   $0x1,0x14(%eax)
  1027f2:	0f 85 57 00 00 00    	jne    10284f <pmm_init+0x10f>
			uintptr_t addr = mmap->mm_base_addr;
  1027f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1027fb:	8b 40 04             	mov    0x4(%eax),%eax
  1027fe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uintptr_t end_addr = addr + mmap->mm_length;
  102801:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102804:	8b 49 0c             	mov    0xc(%ecx),%ecx
  102807:	01 c8                	add    %ecx,%eax
  102809:	89 45 e0             	mov    %eax,-0x20(%ebp)

			while (addr < end_addr) {
  10280c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10280f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  102812:	0f 83 32 00 00 00    	jae    10284a <pmm_init+0x10a>
				pmm_free((void*) addr);
  102818:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10281b:	89 04 24             	mov    %eax,(%esp)
  10281e:	e8 5d fe ff ff       	call   102680 <pmm_free>
				if (addr > upper_limit)
  102823:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102826:	3b 05 20 a4 10 00    	cmp    0x10a420,%eax
  10282c:	0f 86 08 00 00 00    	jbe    10283a <pmm_init+0xfa>
					upper_limit = addr;
  102832:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102835:	a3 20 a4 10 00       	mov    %eax,0x10a420
				addr += 0x1000;
  10283a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10283d:	05 00 10 00 00       	add    $0x1000,%eax
  102842:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			}
  102845:	e9 c2 ff ff ff       	jmp    10280c <pmm_init+0xcc>
		}
  10284a:	e9 00 00 00 00       	jmp    10284f <pmm_init+0x10f>
		mmap++;
  10284f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102852:	05 18 00 00 00       	add    $0x18,%eax
  102857:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}
  10285a:	e9 7d ff ff ff       	jmp    1027dc <pmm_init+0x9c>
  10285f:	8d 05 00 00 10 00    	lea    0x100000,%eax

	extern const void kernel_start;
	extern const void kernel_end;

	uintptr_t addr = (uintptr_t) &kernel_start;
  102865:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102868:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
	while (addr < (uintptr_t) &kernel_end) {
  10286e:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  102871:	0f 83 1b 00 00 00    	jae    102892 <pmm_init+0x152>
		pmm_mark_used((void*) addr);
  102877:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10287a:	89 04 24             	mov    %eax,(%esp)
  10287d:	e8 5e fe ff ff       	call   1026e0 <pmm_mark_used>
		addr += 0x1000;
  102882:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102885:	05 00 10 00 00       	add    $0x1000,%eax
  10288a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
  10288d:	e9 d6 ff ff ff       	jmp    102868 <pmm_init+0x128>

	struct multiboot_module* modules = mb_info->mi_mods_addr;
  102892:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102895:	8b 40 18             	mov    0x18(%eax),%eax
  102898:	89 45 d8             	mov    %eax,-0x28(%ebp)

	pmm_mark_used(mb_info);
  10289b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10289e:	89 04 24             	mov    %eax,(%esp)
  1028a1:	e8 3a fe ff ff       	call   1026e0 <pmm_mark_used>
	pmm_mark_used(modules);
  1028a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1028a9:	89 04 24             	mov    %eax,(%esp)
  1028ac:	e8 2f fe ff ff       	call   1026e0 <pmm_mark_used>

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  1028b1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  1028b8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1028bb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1028be:	3b 41 14             	cmp    0x14(%ecx),%eax
  1028c1:	0f 83 59 00 00 00    	jae    102920 <pmm_init+0x1e0>
		addr = (uintptr_t) modules[i].start;
  1028c7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1028ca:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1028cd:	c1 e0 04             	shl    $0x4,%eax
  1028d0:	01 c1                	add    %eax,%ecx
  1028d2:	8b 01                	mov    (%ecx),%eax
  1028d4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while (addr < (uintptr_t) modules[i].end) {
  1028d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1028da:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  1028dd:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1028e0:	c1 e1 04             	shl    $0x4,%ecx
  1028e3:	01 ca                	add    %ecx,%edx
  1028e5:	8b 4a 04             	mov    0x4(%edx),%ecx
  1028e8:	39 c8                	cmp    %ecx,%eax
  1028ea:	0f 83 1b 00 00 00    	jae    10290b <pmm_init+0x1cb>
			pmm_mark_used((void*) addr);
  1028f0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1028f3:	89 04 24             	mov    %eax,(%esp)
  1028f6:	e8 e5 fd ff ff       	call   1026e0 <pmm_mark_used>
			addr += 0x1000;
  1028fb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1028fe:	05 00 10 00 00       	add    $0x1000,%eax
  102903:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
  102906:	e9 cc ff ff ff       	jmp    1028d7 <pmm_init+0x197>
	}
  10290b:	e9 00 00 00 00       	jmp    102910 <pmm_init+0x1d0>

	pmm_mark_used(mb_info);
	pmm_mark_used(modules);

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  102910:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102913:	05 01 00 00 00       	add    $0x1,%eax
  102918:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10291b:	e9 98 ff ff ff       	jmp    1028b8 <pmm_init+0x178>
		while (addr < (uintptr_t) modules[i].end) {
			pmm_mark_used((void*) addr);
			addr += 0x1000;
		}
	}
}
  102920:	83 c4 5c             	add    $0x5c,%esp
  102923:	5e                   	pop    %esi
  102924:	5f                   	pop    %edi
  102925:	5b                   	pop    %ebx
  102926:	5d                   	pop    %ebp
  102927:	c3                   	ret    
  102928:	66 90                	xchg   %ax,%ax
  10292a:	66 90                	xchg   %ax,%ax
  10292c:	66 90                	xchg   %ax,%ax
  10292e:	66 90                	xchg   %ax,%ax

00102930 <ramfs_block_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  102930:	55                   	push   %ebp
  102931:	89 e5                	mov    %esp,%ebp
  102933:	83 ec 18             	sub    $0x18,%esp
  102936:	8d 05 90 a4 14 00    	lea    0x14a490,%eax
  10293c:	b9 00 00 00 00       	mov    $0x0,%ecx
  102941:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102946:	89 04 24             	mov    %eax,(%esp)
  102949:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102950:	00 
  102951:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102958:	00 
  102959:	89 55 fc             	mov    %edx,-0x4(%ebp)
  10295c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10295f:	e8 ec 1c 00 00       	call   104650 <memset>
}
  102964:	83 c4 18             	add    $0x18,%esp
  102967:	5d                   	pop    %ebp
  102968:	c3                   	ret    
  102969:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102970 <ramfs_block_read>:
    }

    return 0;
}

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  102970:	55                   	push   %ebp
  102971:	89 e5                	mov    %esp,%ebp
  102973:	83 ec 28             	sub    $0x28,%esp
  102976:	8b 45 10             	mov    0x10(%ebp),%eax
  102979:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10297c:	8b 55 08             	mov    0x8(%ebp),%edx
  10297f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102982:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102985:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102988:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10298b:	8b 40 04             	mov    0x4(%eax),%eax
  10298e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102991:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102994:	8b 00                	mov    (%eax),%eax
  102996:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  10299d:	00 00 00 00 
  1029a1:	0f 84 70 00 00 00    	je     102a17 <ramfs_block_read+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't read that much biatch
  1029a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1029aa:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1029ad:	8b 09                	mov    (%ecx),%ecx
  1029af:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  1029b6:	8b 49 04             	mov    0x4(%ecx),%ecx
  1029b9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1029bc:	2b 4a 08             	sub    0x8(%edx),%ecx
  1029bf:	39 c8                	cmp    %ecx,%eax
  1029c1:	0f 86 0c 00 00 00    	jbe    1029d3 <ramfs_block_read+0x63>
  1029c7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  1029ce:	e9 4b 00 00 00       	jmp    102a1e <ramfs_block_read+0xae>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  1029d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029d6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1029d9:	8b 09                	mov    (%ecx),%ecx
  1029db:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  1029e2:	8b 09                	mov    (%ecx),%ecx
  1029e4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1029e7:	03 4a 08             	add    0x8(%edx),%ecx
  1029ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1029ed:	89 04 24             	mov    %eax,(%esp)
  1029f0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1029f4:	89 54 24 08          	mov    %edx,0x8(%esp)
  1029f8:	e8 b3 1c 00 00       	call   1046b0 <memcpy>
        handle->position += length;
  1029fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102a00:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102a03:	8b 51 08             	mov    0x8(%ecx),%edx
  102a06:	01 c2                	add    %eax,%edx
  102a08:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102a0b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102a12:	e9 07 00 00 00       	jmp    102a1e <ramfs_block_read+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102a17:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102a1e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102a21:	83 c4 28             	add    $0x28,%esp
  102a24:	5d                   	pop    %ebp
  102a25:	c3                   	ret    
  102a26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  102a2d:	00 00 00 

00102a30 <ramfs_block_write>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  102a30:	55                   	push   %ebp
  102a31:	89 e5                	mov    %esp,%ebp
  102a33:	83 ec 28             	sub    $0x28,%esp
  102a36:	8b 45 10             	mov    0x10(%ebp),%eax
  102a39:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102a3c:	8b 55 08             	mov    0x8(%ebp),%edx
  102a3f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102a42:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102a45:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102a48:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102a4b:	8b 40 04             	mov    0x4(%eax),%eax
  102a4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102a51:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a54:	8b 00                	mov    (%eax),%eax
  102a56:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102a5d:	00 00 00 00 
  102a61:	0f 84 70 00 00 00    	je     102ad7 <ramfs_block_write+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't write  that much biatch TODO realloc so file may grow
  102a67:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102a6a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102a6d:	8b 09                	mov    (%ecx),%ecx
  102a6f:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102a76:	8b 49 04             	mov    0x4(%ecx),%ecx
  102a79:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102a7c:	2b 4a 08             	sub    0x8(%edx),%ecx
  102a7f:	39 c8                	cmp    %ecx,%eax
  102a81:	0f 86 0c 00 00 00    	jbe    102a93 <ramfs_block_write+0x63>
  102a87:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102a8e:	e9 4b 00 00 00       	jmp    102ade <ramfs_block_write+0xae>

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  102a93:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a96:	8b 00                	mov    (%eax),%eax
  102a98:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102a9f:	8b 00                	mov    (%eax),%eax
  102aa1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102aa4:	03 41 08             	add    0x8(%ecx),%eax
  102aa7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102aaa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102aad:	89 04 24             	mov    %eax,(%esp)
  102ab0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102ab4:	89 54 24 08          	mov    %edx,0x8(%esp)
  102ab8:	e8 f3 1b 00 00       	call   1046b0 <memcpy>
        handle->position += length;
  102abd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102ac0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102ac3:	8b 51 08             	mov    0x8(%ecx),%edx
  102ac6:	01 c2                	add    %eax,%edx
  102ac8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102acb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102ad2:	e9 07 00 00 00       	jmp    102ade <ramfs_block_write+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  102ad7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102ade:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102ae1:	83 c4 28             	add    $0x28,%esp
  102ae4:	5d                   	pop    %ebp
  102ae5:	c3                   	ret    
  102ae6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  102aed:	00 00 00 

00102af0 <ramfs_block_open>:

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  102af0:	55                   	push   %ebp
  102af1:	89 e5                	mov    %esp,%ebp
  102af3:	83 ec 18             	sub    $0x18,%esp
  102af6:	8b 45 0c             	mov    0xc(%ebp),%eax
  102af9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102afc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102aff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  102b02:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102b05:	8b 00                	mov    (%eax),%eax
  102b07:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102b0e:	00 00 00 00 
  102b12:	0f 84 9d 00 00 00    	je     102bb5 <ramfs_block_open+0xc5>
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  102b18:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b1b:	25 01 00 00 00       	and    $0x1,%eax
  102b20:	3d 00 00 00 00       	cmp    $0x0,%eax
  102b25:	0f 84 18 00 00 00    	je     102b43 <ramfs_block_open+0x53>
  102b2b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102b2e:	8b 00                	mov    (%eax),%eax
  102b30:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102b37:	8b 48 08             	mov    0x8(%eax),%ecx
  102b3a:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102b40:	89 48 08             	mov    %ecx,0x8(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  102b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b46:	25 02 00 00 00       	and    $0x2,%eax
  102b4b:	3d 00 00 00 00       	cmp    $0x0,%eax
  102b50:	0f 84 18 00 00 00    	je     102b6e <ramfs_block_open+0x7e>
  102b56:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102b59:	8b 00                	mov    (%eax),%eax
  102b5b:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102b62:	8b 48 0c             	mov    0xc(%eax),%ecx
  102b65:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102b6b:	89 48 0c             	mov    %ecx,0xc(%eax)
  102b6e:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  102b73:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  102b7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102b7d:	e8 5e 14 00 00       	call   103fe0 <malloc>
  102b82:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  102b85:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b88:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102b8b:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  102b8e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102b91:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  102b98:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102b9b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  102ba1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102ba4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102ba7:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  102baa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102bad:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102bb0:	e9 08 00 00 00       	jmp    102bbd <ramfs_block_open+0xcd>
  102bb5:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return (void*)1;
  102bba:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  102bbd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102bc0:	83 c4 18             	add    $0x18,%esp
  102bc3:	5d                   	pop    %ebp
  102bc4:	c3                   	ret    
  102bc5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  102bcc:	00 00 00 00 

00102bd0 <ramfs_block_close>:

uint32_t ramfs_block_close(struct res_handle* handle) {
  102bd0:	55                   	push   %ebp
  102bd1:	89 e5                	mov    %esp,%ebp
  102bd3:	83 ec 18             	sub    $0x18,%esp
  102bd6:	8b 45 08             	mov    0x8(%ebp),%eax
  102bd9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102bdc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102bdf:	8b 40 04             	mov    0x4(%eax),%eax
  102be2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  102be5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102be8:	8b 00                	mov    (%eax),%eax
  102bea:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102bf1:	00 00 00 00 
  102bf5:	0f 84 61 00 00 00    	je     102c5c <ramfs_block_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  102bfb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102bfe:	8b 40 0c             	mov    0xc(%eax),%eax
  102c01:	25 01 00 00 00       	and    $0x1,%eax
  102c06:	3d 00 00 00 00       	cmp    $0x0,%eax
  102c0b:	0f 84 18 00 00 00    	je     102c29 <ramfs_block_close+0x59>
  102c11:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c14:	8b 00                	mov    (%eax),%eax
  102c16:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102c1d:	8b 48 08             	mov    0x8(%eax),%ecx
  102c20:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102c26:	89 48 08             	mov    %ecx,0x8(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  102c29:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102c2c:	8b 40 0c             	mov    0xc(%eax),%eax
  102c2f:	25 02 00 00 00       	and    $0x2,%eax
  102c34:	3d 00 00 00 00       	cmp    $0x0,%eax
  102c39:	0f 84 18 00 00 00    	je     102c57 <ramfs_block_close+0x87>
  102c3f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c42:	8b 00                	mov    (%eax),%eax
  102c44:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102c4b:	8b 48 0c             	mov    0xc(%eax),%ecx
  102c4e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102c54:	89 48 0c             	mov    %ecx,0xc(%eax)
    }
  102c57:	e9 00 00 00 00       	jmp    102c5c <ramfs_block_close+0x8c>

    free(handle);
  102c5c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102c5f:	89 04 24             	mov    %eax,(%esp)
  102c62:	e8 49 17 00 00       	call   1043b0 <free>
  102c67:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  102c6c:	83 c4 18             	add    $0x18,%esp
  102c6f:	5d                   	pop    %ebp
  102c70:	c3                   	ret    
  102c71:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102c78:	0f 1f 84 00 00 00 00 
  102c7f:	00 

00102c80 <ramfs_block_available>:

struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
}

uint32_t ramfs_block_available(struct res_handle* handle) {
  102c80:	55                   	push   %ebp
  102c81:	89 e5                	mov    %esp,%ebp
  102c83:	83 ec 0c             	sub    $0xc,%esp
  102c86:	8b 45 08             	mov    0x8(%ebp),%eax
  102c89:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102c8c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c8f:	8b 40 04             	mov    0x4(%eax),%eax
  102c92:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  102c95:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c98:	8b 00                	mov    (%eax),%eax
  102c9a:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102ca1:	00 00 00 00 
  102ca5:	0f 84 1d 00 00 00    	je     102cc8 <ramfs_block_available+0x48>
        return buffer[kf->id]->size - handle->position;
  102cab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cae:	8b 00                	mov    (%eax),%eax
  102cb0:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102cb7:	8b 40 04             	mov    0x4(%eax),%eax
  102cba:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102cbd:	2b 41 08             	sub    0x8(%ecx),%eax
  102cc0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102cc3:	e9 07 00 00 00       	jmp    102ccf <ramfs_block_available+0x4f>
    }

    return 0;
  102cc8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  102ccf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102cd2:	83 c4 0c             	add    $0xc,%esp
  102cd5:	5d                   	pop    %ebp
  102cd6:	c3                   	ret    
  102cd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  102cde:	00 00 

00102ce0 <ramfs_block_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  102ce0:	55                   	push   %ebp
  102ce1:	89 e5                	mov    %esp,%ebp
  102ce3:	83 ec 28             	sub    $0x28,%esp
  102ce6:	8b 45 08             	mov    0x8(%ebp),%eax
  102ce9:	b9 08 00 00 00       	mov    $0x8,%ecx
  102cee:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  102cf1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  102cf8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102cfb:	e8 e0 12 00 00       	call   103fe0 <malloc>
  102d00:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  102d03:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102d0a:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  102d11:	0f 8d a7 00 00 00    	jge    102dbe <ramfs_block_create+0xde>
        if(buffer[i] == 0) {
  102d17:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d1a:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102d21:	00 00 00 00 
  102d25:	0f 85 7e 00 00 00    	jne    102da9 <ramfs_block_create+0xc9>
  102d2b:	b8 10 00 00 00       	mov    $0x10,%eax
            buffer[i] = malloc(sizeof(struct block_buffer));
  102d30:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  102d37:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102d3a:	e8 a1 12 00 00       	call   103fe0 <malloc>
  102d3f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d42:	89 04 8d 90 a4 14 00 	mov    %eax,0x14a490(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  102d49:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d4c:	8b 00                	mov    (%eax),%eax
  102d4e:	89 04 24             	mov    %eax,(%esp)
  102d51:	e8 8a 12 00 00       	call   103fe0 <malloc>
  102d56:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d59:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102d60:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  102d62:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d65:	8b 00                	mov    (%eax),%eax
  102d67:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d6a:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102d71:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->writers = 0;
  102d74:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d77:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102d7e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            buffer[i]->readers = 0;
  102d85:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d88:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102d8f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

            kfret->id = i;
  102d96:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d99:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102d9c:	89 01                	mov    %eax,(%ecx)

            return kfret;
  102d9e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102da1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102da4:	e9 1c 00 00 00       	jmp    102dc5 <ramfs_block_create+0xe5>
        }
    }
  102da9:	e9 00 00 00 00       	jmp    102dae <ramfs_block_create+0xce>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  102dae:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102db1:	05 01 00 00 00       	add    $0x1,%eax
  102db6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102db9:	e9 4c ff ff ff       	jmp    102d0a <ramfs_block_create+0x2a>

            return kfret;
        }
    }

    return 0;
  102dbe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  102dc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102dc8:	83 c4 28             	add    $0x28,%esp
  102dcb:	5d                   	pop    %ebp
  102dcc:	c3                   	ret    
  102dcd:	0f 1f 00             	nopl   (%eax)

00102dd0 <ramfs_block_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  102dd0:	55                   	push   %ebp
  102dd1:	89 e5                	mov    %esp,%ebp
  102dd3:	8d 05 88 71 10 00    	lea    0x107188,%eax
    return &block_driver;
  102dd9:	5d                   	pop    %ebp
  102dda:	c3                   	ret    
  102ddb:	66 90                	xchg   %ax,%ax
  102ddd:	66 90                	xchg   %ax,%ax
  102ddf:	90                   	nop

00102de0 <ramfs_fifo_init>:
#include "ramfs/fifo.h"

struct fifo_buffer* buffer[65536];

void ramfs_fifo_init() {
  102de0:	55                   	push   %ebp
  102de1:	89 e5                	mov    %esp,%ebp
  102de3:	83 ec 18             	sub    $0x18,%esp
  102de6:	8d 05 90 a4 14 00    	lea    0x14a490,%eax
  102dec:	b9 00 00 00 00       	mov    $0x0,%ecx
  102df1:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102df6:	89 04 24             	mov    %eax,(%esp)
  102df9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102e00:	00 
  102e01:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102e08:	00 
  102e09:	89 55 fc             	mov    %edx,-0x4(%ebp)
  102e0c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102e0f:	e8 3c 18 00 00       	call   104650 <memset>
}
  102e14:	83 c4 18             	add    $0x18,%esp
  102e17:	5d                   	pop    %ebp
  102e18:	c3                   	ret    
  102e19:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102e20 <ramfs_fifo_read>:
    }

    return 0;
}

uint32_t ramfs_fifo_read(struct res_handle* handle, void* dest, uint32_t length) {
  102e20:	55                   	push   %ebp
  102e21:	89 e5                	mov    %esp,%ebp
  102e23:	83 ec 28             	sub    $0x28,%esp
  102e26:	8b 45 10             	mov    0x10(%ebp),%eax
  102e29:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102e2c:	8b 55 08             	mov    0x8(%ebp),%edx
  102e2f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102e32:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102e35:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102e38:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102e3b:	8b 40 04             	mov    0x4(%eax),%eax
  102e3e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102e41:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102e44:	8b 00                	mov    (%eax),%eax
  102e46:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102e4d:	00 00 00 00 
  102e51:	0f 84 d0 00 00 00    	je     102f27 <ramfs_fifo_read+0x107>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't read cause buffer too small
  102e57:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102e5a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102e5d:	8b 09                	mov    (%ecx),%ecx
  102e5f:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102e66:	3b 41 04             	cmp    0x4(%ecx),%eax
  102e69:	0f 86 0c 00 00 00    	jbe    102e7b <ramfs_fifo_read+0x5b>
  102e6f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102e76:	e9 b3 00 00 00       	jmp    102f2e <ramfs_fifo_read+0x10e>
        if(length > buffer[kf->id]->pos)  return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has writers
  102e7b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102e7e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102e81:	8b 09                	mov    (%ecx),%ecx
  102e83:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102e8a:	3b 41 08             	cmp    0x8(%ecx),%eax
  102e8d:	0f 86 0c 00 00 00    	jbe    102e9f <ramfs_fifo_read+0x7f>
  102e93:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  102e9a:	e9 8f 00 00 00       	jmp    102f2e <ramfs_fifo_read+0x10e>

        memcpy(dest, buffer[kf->id]->buffer, length);
  102e9f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ea2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102ea5:	8b 09                	mov    (%ecx),%ecx
  102ea7:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102eae:	8b 09                	mov    (%ecx),%ecx
  102eb0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102eb3:	89 04 24             	mov    %eax,(%esp)
  102eb6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102eba:	89 54 24 08          	mov    %edx,0x8(%esp)
  102ebe:	e8 ed 17 00 00       	call   1046b0 <memcpy>
        memcpy(buffer[kf->id]->buffer, buffer[kf->id]->buffer + length, buffer[kf->id]->pos - length);
  102ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102ec6:	8b 00                	mov    (%eax),%eax
  102ec8:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102ecf:	8b 00                	mov    (%eax),%eax
  102ed1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102ed4:	8b 09                	mov    (%ecx),%ecx
  102ed6:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102edd:	8b 09                	mov    (%ecx),%ecx
  102edf:	03 4d f0             	add    -0x10(%ebp),%ecx
  102ee2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102ee5:	8b 12                	mov    (%edx),%edx
  102ee7:	8b 14 95 90 a4 14 00 	mov    0x14a490(,%edx,4),%edx
  102eee:	8b 52 08             	mov    0x8(%edx),%edx
  102ef1:	2b 55 f0             	sub    -0x10(%ebp),%edx
  102ef4:	89 04 24             	mov    %eax,(%esp)
  102ef7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102efb:	89 54 24 08          	mov    %edx,0x8(%esp)
  102eff:	e8 ac 17 00 00       	call   1046b0 <memcpy>
        buffer[kf->id]->pos -= length;
  102f04:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f07:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102f0a:	8b 09                	mov    (%ecx),%ecx
  102f0c:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102f13:	8b 51 08             	mov    0x8(%ecx),%edx
  102f16:	29 c2                	sub    %eax,%edx
  102f18:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102f1b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102f22:	e9 07 00 00 00       	jmp    102f2e <ramfs_fifo_read+0x10e>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102f27:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102f2e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102f31:	83 c4 28             	add    $0x28,%esp
  102f34:	5d                   	pop    %ebp
  102f35:	c3                   	ret    
  102f36:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  102f3d:	00 00 00 

00102f40 <ramfs_fifo_write>:

uint32_t ramfs_fifo_write(struct res_handle* handle, void* src, uint32_t length) {
  102f40:	55                   	push   %ebp
  102f41:	89 e5                	mov    %esp,%ebp
  102f43:	83 ec 28             	sub    $0x28,%esp
  102f46:	8b 45 10             	mov    0x10(%ebp),%eax
  102f49:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102f4c:	8b 55 08             	mov    0x8(%ebp),%edx
  102f4f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102f52:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102f55:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102f58:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f5b:	8b 40 04             	mov    0x4(%eax),%eax
  102f5e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102f61:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102f64:	8b 00                	mov    (%eax),%eax
  102f66:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  102f6d:	00 00 00 00 
  102f71:	0f 84 af 00 00 00    	je     103026 <ramfs_fifo_write+0xe6>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't write cause buffer too small
  102f77:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f7a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102f7d:	8b 09                	mov    (%ecx),%ecx
  102f7f:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102f86:	3b 41 04             	cmp    0x4(%ecx),%eax
  102f89:	0f 86 0c 00 00 00    	jbe    102f9b <ramfs_fifo_write+0x5b>
  102f8f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102f96:	e9 92 00 00 00       	jmp    10302d <ramfs_fifo_write+0xed>
        if(length > (buffer[kf->id]->size - buffer[kf->id]->pos)) return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has readers
  102f9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f9e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102fa1:	8b 09                	mov    (%ecx),%ecx
  102fa3:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102faa:	8b 49 04             	mov    0x4(%ecx),%ecx
  102fad:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102fb0:	8b 12                	mov    (%edx),%edx
  102fb2:	8b 14 95 90 a4 14 00 	mov    0x14a490(,%edx,4),%edx
  102fb9:	2b 4a 08             	sub    0x8(%edx),%ecx
  102fbc:	39 c8                	cmp    %ecx,%eax
  102fbe:	0f 86 0c 00 00 00    	jbe    102fd0 <ramfs_fifo_write+0x90>
  102fc4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  102fcb:	e9 5d 00 00 00       	jmp    10302d <ramfs_fifo_write+0xed>

        memcpy(buffer[kf->id]->buffer + buffer[kf->id]->pos, src, length);
  102fd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102fd3:	8b 00                	mov    (%eax),%eax
  102fd5:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  102fdc:	8b 00                	mov    (%eax),%eax
  102fde:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102fe1:	8b 09                	mov    (%ecx),%ecx
  102fe3:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  102fea:	03 41 08             	add    0x8(%ecx),%eax
  102fed:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102ff0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102ff3:	89 04 24             	mov    %eax,(%esp)
  102ff6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102ffa:	89 54 24 08          	mov    %edx,0x8(%esp)
  102ffe:	e8 ad 16 00 00       	call   1046b0 <memcpy>
        buffer[kf->id]->pos += length;
  103003:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103006:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103009:	8b 09                	mov    (%ecx),%ecx
  10300b:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  103012:	8b 51 08             	mov    0x8(%ecx),%edx
  103015:	01 c2                	add    %eax,%edx
  103017:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  10301a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103021:	e9 07 00 00 00       	jmp    10302d <ramfs_fifo_write+0xed>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103026:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  10302d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103030:	83 c4 28             	add    $0x28,%esp
  103033:	5d                   	pop    %ebp
  103034:	c3                   	ret    
  103035:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10303c:	00 00 00 00 

00103040 <ramfs_fifo_open>:

struct res_handle* ramfs_fifo_open(struct res_kfile* kf, uint32_t filemode) {
  103040:	55                   	push   %ebp
  103041:	89 e5                	mov    %esp,%ebp
  103043:	83 ec 18             	sub    $0x18,%esp
  103046:	8b 45 0c             	mov    0xc(%ebp),%eax
  103049:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10304c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10304f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  103052:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103055:	8b 00                	mov    (%eax),%eax
  103057:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  10305e:	00 00 00 00 
  103062:	0f 84 f4 00 00 00    	je     10315c <ramfs_fifo_open+0x11c>
        if(filemode & FM_EXEC) return 0;
  103068:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10306b:	25 04 00 00 00       	and    $0x4,%eax
  103070:	3d 00 00 00 00       	cmp    $0x0,%eax
  103075:	0f 84 0c 00 00 00    	je     103087 <ramfs_fifo_open+0x47>
  10307b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103082:	e9 dc 00 00 00       	jmp    103163 <ramfs_fifo_open+0x123>
        if((filemode & FM_READ) && buffer[kf->id]->readers > 0) return 0;
  103087:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10308a:	25 01 00 00 00       	and    $0x1,%eax
  10308f:	3d 00 00 00 00       	cmp    $0x0,%eax
  103094:	0f 84 25 00 00 00    	je     1030bf <ramfs_fifo_open+0x7f>
  10309a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10309d:	8b 00                	mov    (%eax),%eax
  10309f:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  1030a6:	81 78 0c 00 00 00 00 	cmpl   $0x0,0xc(%eax)
  1030ad:	0f 86 0c 00 00 00    	jbe    1030bf <ramfs_fifo_open+0x7f>
  1030b3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1030ba:	e9 a4 00 00 00       	jmp    103163 <ramfs_fifo_open+0x123>

        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  1030bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1030c2:	25 01 00 00 00       	and    $0x1,%eax
  1030c7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1030cc:	0f 84 18 00 00 00    	je     1030ea <ramfs_fifo_open+0xaa>
  1030d2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030d5:	8b 00                	mov    (%eax),%eax
  1030d7:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  1030de:	8b 48 0c             	mov    0xc(%eax),%ecx
  1030e1:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1030e7:	89 48 0c             	mov    %ecx,0xc(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  1030ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1030ed:	25 02 00 00 00       	and    $0x2,%eax
  1030f2:	3d 00 00 00 00       	cmp    $0x0,%eax
  1030f7:	0f 84 18 00 00 00    	je     103115 <ramfs_fifo_open+0xd5>
  1030fd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103100:	8b 00                	mov    (%eax),%eax
  103102:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  103109:	8b 48 10             	mov    0x10(%eax),%ecx
  10310c:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103112:	89 48 10             	mov    %ecx,0x10(%eax)
  103115:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  10311a:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  103121:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103124:	e8 b7 0e 00 00       	call   103fe0 <malloc>
  103129:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  10312c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10312f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103132:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  103135:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103138:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  10313f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103142:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  103148:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10314b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10314e:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  103151:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103154:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103157:	e9 07 00 00 00       	jmp    103163 <ramfs_fifo_open+0x123>
    }

    return 0;
  10315c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103163:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103166:	83 c4 18             	add    $0x18,%esp
  103169:	5d                   	pop    %ebp
  10316a:	c3                   	ret    
  10316b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103170 <ramfs_fifo_close>:

uint32_t ramfs_fifo_close(struct res_handle* handle) {
  103170:	55                   	push   %ebp
  103171:	89 e5                	mov    %esp,%ebp
  103173:	83 ec 18             	sub    $0x18,%esp
  103176:	8b 45 08             	mov    0x8(%ebp),%eax
  103179:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10317c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10317f:	8b 40 04             	mov    0x4(%eax),%eax
  103182:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  103185:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103188:	8b 00                	mov    (%eax),%eax
  10318a:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  103191:	00 00 00 00 
  103195:	0f 84 61 00 00 00    	je     1031fc <ramfs_fifo_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  10319b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10319e:	8b 40 0c             	mov    0xc(%eax),%eax
  1031a1:	25 01 00 00 00       	and    $0x1,%eax
  1031a6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1031ab:	0f 84 18 00 00 00    	je     1031c9 <ramfs_fifo_close+0x59>
  1031b1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1031b4:	8b 00                	mov    (%eax),%eax
  1031b6:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  1031bd:	8b 48 0c             	mov    0xc(%eax),%ecx
  1031c0:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1031c6:	89 48 0c             	mov    %ecx,0xc(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  1031c9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031cc:	8b 40 0c             	mov    0xc(%eax),%eax
  1031cf:	25 02 00 00 00       	and    $0x2,%eax
  1031d4:	3d 00 00 00 00       	cmp    $0x0,%eax
  1031d9:	0f 84 18 00 00 00    	je     1031f7 <ramfs_fifo_close+0x87>
  1031df:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1031e2:	8b 00                	mov    (%eax),%eax
  1031e4:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  1031eb:	8b 48 10             	mov    0x10(%eax),%ecx
  1031ee:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1031f4:	89 48 10             	mov    %ecx,0x10(%eax)
    }
  1031f7:	e9 00 00 00 00       	jmp    1031fc <ramfs_fifo_close+0x8c>

    free(handle);
  1031fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031ff:	89 04 24             	mov    %eax,(%esp)
  103202:	e8 a9 11 00 00       	call   1043b0 <free>
  103207:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  10320c:	83 c4 18             	add    $0x18,%esp
  10320f:	5d                   	pop    %ebp
  103210:	c3                   	ret    
  103211:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103218:	0f 1f 84 00 00 00 00 
  10321f:	00 

00103220 <ramfs_fifo_available>:

struct kfs_driver* ramfs_fifo_driver_struct() {
    return &fifo_driver;
}

uint32_t ramfs_fifo_available(struct res_handle* handle) {
  103220:	55                   	push   %ebp
  103221:	89 e5                	mov    %esp,%ebp
  103223:	83 ec 0c             	sub    $0xc,%esp
  103226:	8b 45 08             	mov    0x8(%ebp),%eax
  103229:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10322c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10322f:	8b 40 04             	mov    0x4(%eax),%eax
  103232:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  103235:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103238:	8b 00                	mov    (%eax),%eax
  10323a:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  103241:	00 00 00 00 
  103245:	0f 84 17 00 00 00    	je     103262 <ramfs_fifo_available+0x42>
        return buffer[kf->id]->pos;
  10324b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10324e:	8b 00                	mov    (%eax),%eax
  103250:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  103257:	8b 40 08             	mov    0x8(%eax),%eax
  10325a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10325d:	e9 07 00 00 00       	jmp    103269 <ramfs_fifo_available+0x49>
    }

    return 0;
  103262:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103269:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10326c:	83 c4 0c             	add    $0xc,%esp
  10326f:	5d                   	pop    %ebp
  103270:	c3                   	ret    
  103271:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103278:	0f 1f 84 00 00 00 00 
  10327f:	00 

00103280 <ramfs_fifo_create>:

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
  103280:	55                   	push   %ebp
  103281:	89 e5                	mov    %esp,%ebp
  103283:	83 ec 28             	sub    $0x28,%esp
  103286:	8b 45 08             	mov    0x8(%ebp),%eax
  103289:	b9 08 00 00 00       	mov    $0x8,%ecx
  10328e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  103291:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103298:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10329b:	e8 40 0d 00 00       	call   103fe0 <malloc>
  1032a0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  1032a3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1032aa:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  1032b1:	0f 8d b8 00 00 00    	jge    10336f <ramfs_fifo_create+0xef>
        if(buffer[i] == 0) {
  1032b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032ba:	81 3c 85 90 a4 14 00 	cmpl   $0x0,0x14a490(,%eax,4)
  1032c1:	00 00 00 00 
  1032c5:	0f 85 8f 00 00 00    	jne    10335a <ramfs_fifo_create+0xda>
  1032cb:	b8 14 00 00 00       	mov    $0x14,%eax
            buffer[i] = malloc(sizeof(struct fifo_buffer));
  1032d0:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  1032d7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1032da:	e8 01 0d 00 00       	call   103fe0 <malloc>
  1032df:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1032e2:	89 04 8d 90 a4 14 00 	mov    %eax,0x14a490(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  1032e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1032ec:	8b 00                	mov    (%eax),%eax
  1032ee:	89 04 24             	mov    %eax,(%esp)
  1032f1:	e8 ea 0c 00 00       	call   103fe0 <malloc>
  1032f6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1032f9:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  103300:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  103302:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103305:	8b 00                	mov    (%eax),%eax
  103307:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10330a:	8b 0c 8d 90 a4 14 00 	mov    0x14a490(,%ecx,4),%ecx
  103311:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->pos = 0;
  103314:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103317:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  10331e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            buffer[i]->writers = 0;
  103325:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103328:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  10332f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
            buffer[i]->readers = 0;
  103336:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103339:	8b 04 85 90 a4 14 00 	mov    0x14a490(,%eax,4),%eax
  103340:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

            kfret->id = i;
  103347:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10334a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10334d:	89 01                	mov    %eax,(%ecx)

            return kfret;
  10334f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103352:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103355:	e9 1c 00 00 00       	jmp    103376 <ramfs_fifo_create+0xf6>
        }
    }
  10335a:	e9 00 00 00 00       	jmp    10335f <ramfs_fifo_create+0xdf>
}

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  10335f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103362:	05 01 00 00 00       	add    $0x1,%eax
  103367:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10336a:	e9 3b ff ff ff       	jmp    1032aa <ramfs_fifo_create+0x2a>

            return kfret;
        }
    }

    return 0;
  10336f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103376:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103379:	83 c4 28             	add    $0x28,%esp
  10337c:	5d                   	pop    %ebp
  10337d:	c3                   	ret    
  10337e:	66 90                	xchg   %ax,%ax

00103380 <ramfs_fifo_driver_struct>:
    .close     = ramfs_fifo_close,
    .available = ramfs_fifo_available,
    .drvname   = "FIFO"
};

struct kfs_driver* ramfs_fifo_driver_struct() {
  103380:	55                   	push   %ebp
  103381:	89 e5                	mov    %esp,%ebp
  103383:	8d 05 a4 71 10 00    	lea    0x1071a4,%eax
    return &fifo_driver;
  103389:	5d                   	pop    %ebp
  10338a:	c3                   	ret    
  10338b:	90                   	nop
  10338c:	66 90                	xchg   %ax,%ax
  10338e:	66 90                	xchg   %ax,%ax

00103390 <tar_load_ramfs>:

    return size;

}

void tar_load_ramfs(void* tarball) {
  103390:	55                   	push   %ebp
  103391:	89 e5                	mov    %esp,%ebp
  103393:	56                   	push   %esi
  103394:	83 ec 64             	sub    $0x64,%esp
  103397:	8b 45 08             	mov    0x8(%ebp),%eax
  10339a:	8d 0d ee 83 10 00    	lea    0x1083ee,%ecx
  1033a0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* address = tarball;
  1033a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1033a6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);
  1033a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1033ac:	89 0c 24             	mov    %ecx,(%esp)
  1033af:	89 44 24 04          	mov    %eax,0x4(%esp)
  1033b3:	e8 98 d1 ff ff       	call   100550 <kprintf>

    for (i = 0; ; i++)
  1033b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1033bf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    {

        struct tar_header *header = (struct tar_header*)address;
  1033c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1033c5:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (header->name[0] == '\0')
  1033c8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033cb:	0f be 00             	movsbl (%eax),%eax
  1033ce:	3d 00 00 00 00       	cmp    $0x0,%eax
  1033d3:	0f 85 05 00 00 00    	jne    1033de <tar_load_ramfs+0x4e>
            break;
  1033d9:	e9 67 01 00 00       	jmp    103545 <tar_load_ramfs+0x1b5>

        uint32_t size = tar_parse_number(header->size);
  1033de:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1033e1:	05 7c 00 00 00       	add    $0x7c,%eax
  1033e6:	89 04 24             	mov    %eax,(%esp)
  1033e9:	e8 72 01 00 00       	call   103560 <tar_parse_number>
  1033ee:	89 45 e8             	mov    %eax,-0x18(%ebp)
        address += 512;
  1033f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1033f4:	05 00 02 00 00       	add    $0x200,%eax
  1033f9:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(size != 0) {
  1033fc:	81 7d e8 00 00 00 00 	cmpl   $0x0,-0x18(%ebp)
  103403:	0f 84 cb 00 00 00    	je     1034d4 <tar_load_ramfs+0x144>
  103409:	8d 05 1a 84 10 00    	lea    0x10841a,%eax
            kprintf("[initrfs] Extracting %s (%d bytes)\n", header->name, size);
  10340f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103412:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103415:	89 04 24             	mov    %eax,(%esp)
  103418:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10341c:	89 54 24 08          	mov    %edx,0x8(%esp)
  103420:	e8 2b d1 ff ff       	call   100550 <kprintf>
  103425:	8d 4d e8             	lea    -0x18(%ebp),%ecx

            vfs_create_kfile(header->name, ramfs_block_driver_struct(), &size);
  103428:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10342b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10342e:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  103431:	89 55 d0             	mov    %edx,-0x30(%ebp)
  103434:	e8 97 f9 ff ff       	call   102dd0 <ramfs_block_driver_struct>
  103439:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  10343c:	89 0c 24             	mov    %ecx,(%esp)
  10343f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103443:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  103446:	89 44 24 08          	mov    %eax,0x8(%esp)
  10344a:	e8 21 19 00 00       	call   104d70 <vfs_create_kfile>
  10344f:	b9 02 00 00 00       	mov    $0x2,%ecx
            struct res_handle* h = vfs_open(header->name, FM_WRITE);
  103454:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103457:	89 14 24             	mov    %edx,(%esp)
  10345a:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  103461:	00 
  103462:	89 45 cc             	mov    %eax,-0x34(%ebp)
  103465:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  103468:	e8 73 1a 00 00       	call   104ee0 <vfs_open>
  10346d:	b9 01 00 00 00       	mov    $0x1,%ecx
  103472:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            uint32_t err = vfs_write(h, address, size, 1);
  103475:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103478:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10347b:	8b 75 e8             	mov    -0x18(%ebp),%esi
  10347e:	89 04 24             	mov    %eax,(%esp)
  103481:	89 54 24 04          	mov    %edx,0x4(%esp)
  103485:	89 74 24 08          	mov    %esi,0x8(%esp)
  103489:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  103490:	00 
  103491:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  103494:	e8 f7 1b 00 00       	call   105090 <vfs_write>
  103499:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(err) {
  10349c:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1034a3:	0f 84 18 00 00 00    	je     1034c1 <tar_load_ramfs+0x131>
  1034a9:	8d 05 3e 84 10 00    	lea    0x10843e,%eax
                kprintf("[initrfs] VFS ERROR: %d\n", err);
  1034af:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1034b2:	89 04 24             	mov    %eax,(%esp)
  1034b5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1034b9:	e8 92 d0 ff ff       	call   100550 <kprintf>
  1034be:	89 45 c0             	mov    %eax,-0x40(%ebp)
            }

            vfs_close(h);
  1034c1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1034c4:	89 04 24             	mov    %eax,(%esp)
  1034c7:	e8 94 1a 00 00       	call   104f60 <vfs_close>
        }
  1034cc:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1034cf:	e9 2d 00 00 00       	jmp    103501 <tar_load_ramfs+0x171>
  1034d4:	8d 05 57 84 10 00    	lea    0x108457,%eax
        else
        {
            kprintf("[initrfs] Creating dir %s (%d bytes)\n", header->name, size);
  1034da:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1034dd:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1034e0:	89 04 24             	mov    %eax,(%esp)
  1034e3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1034e7:	89 54 24 08          	mov    %edx,0x8(%esp)
  1034eb:	e8 60 d0 ff ff       	call   100550 <kprintf>
            vfs_create_dir(header->name);
  1034f0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1034f3:	89 0c 24             	mov    %ecx,(%esp)
  1034f6:	89 45 b8             	mov    %eax,-0x48(%ebp)
  1034f9:	e8 e2 16 00 00       	call   104be0 <vfs_create_dir>
  1034fe:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        }

        address += (size / 512) * 512;
  103501:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103504:	c1 e8 09             	shr    $0x9,%eax
  103507:	c1 e0 09             	shl    $0x9,%eax
  10350a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10350d:	01 c1                	add    %eax,%ecx
  10350f:	89 4d f4             	mov    %ecx,-0xc(%ebp)

        if (size % 512)
  103512:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103515:	25 ff 01 00 00       	and    $0x1ff,%eax
  10351a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10351f:	0f 84 0b 00 00 00    	je     103530 <tar_load_ramfs+0x1a0>
            address += 512;
  103525:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103528:	05 00 02 00 00       	add    $0x200,%eax
  10352d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    }
  103530:	e9 00 00 00 00       	jmp    103535 <tar_load_ramfs+0x1a5>

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);

    for (i = 0; ; i++)
  103535:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103538:	05 01 00 00 00       	add    $0x1,%eax
  10353d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103540:	e9 7d fe ff ff       	jmp    1033c2 <tar_load_ramfs+0x32>
  103545:	8d 05 7d 84 10 00    	lea    0x10847d,%eax
        if (size % 512)
            address += 512;

    }

    kprintf("[initrfs] Finished unpacking tarball\n");
  10354b:	89 04 24             	mov    %eax,(%esp)
  10354e:	e8 fd cf ff ff       	call   100550 <kprintf>
}
  103553:	89 45 b0             	mov    %eax,-0x50(%ebp)
  103556:	83 c4 64             	add    $0x64,%esp
  103559:	5e                   	pop    %esi
  10355a:	5d                   	pop    %ebp
  10355b:	c3                   	ret    
  10355c:	0f 1f 40 00          	nopl   0x0(%eax)

00103560 <tar_parse_number>:
#include "ramfs/tar.h"
#include "ramfs/block.h"
#include "vfs.h"

static uint32_t tar_parse_number(const char *in)
{
  103560:	55                   	push   %ebp
  103561:	89 e5                	mov    %esp,%ebp
  103563:	83 ec 10             	sub    $0x10,%esp
  103566:	8b 45 08             	mov    0x8(%ebp),%eax
  103569:	89 45 fc             	mov    %eax,-0x4(%ebp)

    unsigned int size = 0;
  10356c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    unsigned int j;
    unsigned int count = 1;
  103573:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

    for (j = 11; j > 0; j--, count *= 8)
  10357a:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
  103581:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103588:	0f 86 39 00 00 00    	jbe    1035c7 <tar_parse_number+0x67>
        size += ((in[j - 1] - '0') * count);
  10358e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103591:	2d 01 00 00 00       	sub    $0x1,%eax
  103596:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103599:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  10359d:	2d 30 00 00 00       	sub    $0x30,%eax
  1035a2:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  1035a6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1035a9:	01 c1                	add    %eax,%ecx
  1035ab:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    unsigned int size = 0;
    unsigned int j;
    unsigned int count = 1;

    for (j = 11; j > 0; j--, count *= 8)
  1035ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1035b1:	05 ff ff ff ff       	add    $0xffffffff,%eax
  1035b6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1035b9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1035bc:	c1 e0 03             	shl    $0x3,%eax
  1035bf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1035c2:	e9 ba ff ff ff       	jmp    103581 <tar_parse_number+0x21>
        size += ((in[j - 1] - '0') * count);

    return size;
  1035c7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1035ca:	83 c4 10             	add    $0x10,%esp
  1035cd:	5d                   	pop    %ebp
  1035ce:	c3                   	ret    
  1035cf:	90                   	nop

001035d0 <ramfs_vga_read>:

struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
}

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  1035d0:	55                   	push   %ebp
  1035d1:	89 e5                	mov    %esp,%ebp
  1035d3:	56                   	push   %esi
  1035d4:	83 ec 0c             	sub    $0xc,%esp
  1035d7:	8b 45 10             	mov    0x10(%ebp),%eax
  1035da:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1035dd:	8b 55 08             	mov    0x8(%ebp),%edx
  1035e0:	be 03 00 00 00       	mov    $0x3,%esi
  1035e5:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1035e8:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1035eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  1035ee:	89 f0                	mov    %esi,%eax
  1035f0:	83 c4 0c             	add    $0xc,%esp
  1035f3:	5e                   	pop    %esi
  1035f4:	5d                   	pop    %ebp
  1035f5:	c3                   	ret    
  1035f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1035fd:	00 00 00 

00103600 <ramfs_vga_write>:
}

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  103600:	55                   	push   %ebp
  103601:	89 e5                	mov    %esp,%ebp
  103603:	83 ec 1c             	sub    $0x1c,%esp
  103606:	8b 45 10             	mov    0x10(%ebp),%eax
  103609:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10360c:	8b 55 08             	mov    0x8(%ebp),%edx
  10360f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103612:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103615:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  103618:	81 7d f0 06 00 00 00 	cmpl   $0x6,-0x10(%ebp)
  10361f:	0f 84 0c 00 00 00    	je     103631 <ramfs_vga_write+0x31>
  103625:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  10362c:	e9 1f 01 00 00       	jmp    103750 <ramfs_vga_write+0x150>

    struct vga_command* vgac = src;
  103631:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103634:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(vgac->command == CMD_SET) {
  103637:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10363a:	0f b7 00             	movzwl (%eax),%eax
  10363d:	3d 00 00 00 00       	cmp    $0x0,%eax
  103642:	0f 85 2f 00 00 00    	jne    103677 <ramfs_vga_write+0x77>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  103648:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10364b:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  10364f:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  103654:	0f 8d 18 00 00 00    	jge    103672 <ramfs_vga_write+0x72>
  10365a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10365d:	66 8b 48 04          	mov    0x4(%eax),%cx
  103661:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103664:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  103668:	8b 15 c0 71 10 00    	mov    0x1071c0,%edx
  10366e:	66 89 0c 42          	mov    %cx,(%edx,%eax,2)
    }
  103672:	e9 00 00 00 00       	jmp    103677 <ramfs_vga_write+0x77>

    if(vgac->command == CMD_CLEAR) {
  103677:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10367a:	0f b7 00             	movzwl (%eax),%eax
  10367d:	3d 01 00 00 00       	cmp    $0x1,%eax
  103682:	0f 85 38 00 00 00    	jne    1036c0 <ramfs_vga_write+0xc0>
        for(int i = 0; i < (80 * 25); i++) {
  103688:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10368f:	81 7d e8 d0 07 00 00 	cmpl   $0x7d0,-0x18(%ebp)
  103696:	0f 8d 1f 00 00 00    	jge    1036bb <ramfs_vga_write+0xbb>
            vga_buffer[i] = 0;
  10369c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10369f:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  1036a5:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
    if(vgac->command == CMD_SET) {
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
  1036ab:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1036ae:	05 01 00 00 00       	add    $0x1,%eax
  1036b3:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1036b6:	e9 d4 ff ff ff       	jmp    10368f <ramfs_vga_write+0x8f>
            vga_buffer[i] = 0;
        }
    }
  1036bb:	e9 00 00 00 00       	jmp    1036c0 <ramfs_vga_write+0xc0>

    if(vgac->command == CMD_SCROLL) {
  1036c0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1036c3:	0f b7 00             	movzwl (%eax),%eax
  1036c6:	3d 02 00 00 00       	cmp    $0x2,%eax
  1036cb:	0f 85 78 00 00 00    	jne    103749 <ramfs_vga_write+0x149>
        int i;
        for (i = 0; i < 24 * 80; i++) {
  1036d1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1036d8:	81 7d e4 80 07 00 00 	cmpl   $0x780,-0x1c(%ebp)
  1036df:	0f 8d 2e 00 00 00    	jge    103713 <ramfs_vga_write+0x113>
            vga_buffer[i] = vga_buffer[i + 80];
  1036e5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1036e8:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  1036ee:	66 8b 94 41 a0 00 00 	mov    0xa0(%ecx,%eax,2),%dx
  1036f5:	00 
  1036f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1036f9:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  1036ff:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  103703:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103706:	05 01 00 00 00       	add    $0x1,%eax
  10370b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10370e:	e9 c5 ff ff ff       	jmp    1036d8 <ramfs_vga_write+0xd8>
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  103713:	e9 00 00 00 00       	jmp    103718 <ramfs_vga_write+0x118>
  103718:	81 7d e4 d0 07 00 00 	cmpl   $0x7d0,-0x1c(%ebp)
  10371f:	0f 8d 1f 00 00 00    	jge    103744 <ramfs_vga_write+0x144>
            vga_buffer[i] = 0;
  103725:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103728:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  10372e:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  103734:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103737:	05 01 00 00 00       	add    $0x1,%eax
  10373c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10373f:	e9 d4 ff ff ff       	jmp    103718 <ramfs_vga_write+0x118>
            vga_buffer[i] = 0;
        }
    }
  103744:	e9 00 00 00 00       	jmp    103749 <ramfs_vga_write+0x149>

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103749:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103750:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103753:	83 c4 1c             	add    $0x1c,%esp
  103756:	5d                   	pop    %ebp
  103757:	c3                   	ret    
  103758:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10375f:	00 

00103760 <ramfs_vga_open>:

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
  103760:	55                   	push   %ebp
  103761:	89 e5                	mov    %esp,%ebp
  103763:	83 ec 18             	sub    $0x18,%esp
  103766:	8b 45 0c             	mov    0xc(%ebp),%eax
  103769:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10376c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10376f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filemode & FM_EXEC) return 0;
  103772:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103775:	25 04 00 00 00       	and    $0x4,%eax
  10377a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10377f:	0f 84 0c 00 00 00    	je     103791 <ramfs_vga_open+0x31>
  103785:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10378c:	e9 b2 00 00 00       	jmp    103843 <ramfs_vga_open+0xe3>
    if(filemode & FM_READ) return 0;
  103791:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103794:	25 01 00 00 00       	and    $0x1,%eax
  103799:	3d 00 00 00 00       	cmp    $0x0,%eax
  10379e:	0f 84 0c 00 00 00    	je     1037b0 <ramfs_vga_open+0x50>
  1037a4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1037ab:	e9 93 00 00 00       	jmp    103843 <ramfs_vga_open+0xe3>

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  1037b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037b3:	25 02 00 00 00       	and    $0x2,%eax
  1037b8:	3d 00 00 00 00       	cmp    $0x0,%eax
  1037bd:	0f 84 1c 00 00 00    	je     1037df <ramfs_vga_open+0x7f>
  1037c3:	81 3d 24 a4 10 00 00 	cmpl   $0x0,0x10a424
  1037ca:	00 00 00 
  1037cd:	0f 84 0c 00 00 00    	je     1037df <ramfs_vga_open+0x7f>
  1037d3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1037da:	e9 64 00 00 00       	jmp    103843 <ramfs_vga_open+0xe3>
    if((filemode & FM_WRITE)) vga_writers++;
  1037df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037e2:	25 02 00 00 00       	and    $0x2,%eax
  1037e7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1037ec:	0f 84 0f 00 00 00    	je     103801 <ramfs_vga_open+0xa1>
  1037f2:	a1 24 a4 10 00       	mov    0x10a424,%eax
  1037f7:	05 01 00 00 00       	add    $0x1,%eax
  1037fc:	a3 24 a4 10 00       	mov    %eax,0x10a424
  103801:	b8 10 00 00 00       	mov    $0x10,%eax

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103806:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10380d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103810:	e8 cb 07 00 00       	call   103fe0 <malloc>
  103815:	89 45 f0             	mov    %eax,-0x10(%ebp)

    rethandle->filemode = filemode;
  103818:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10381b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10381e:	89 41 0c             	mov    %eax,0xc(%ecx)
    rethandle->position = 0;
  103821:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103824:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    rethandle->res_type = RES_KERNDRV;
  10382b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10382e:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    rethandle->res_ptr  = kf;
  103834:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103837:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10383a:	89 41 04             	mov    %eax,0x4(%ecx)

    return rethandle;
  10383d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103840:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  103843:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103846:	83 c4 18             	add    $0x18,%esp
  103849:	5d                   	pop    %ebp
  10384a:	c3                   	ret    
  10384b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103850 <ramfs_vga_close>:

uint32_t ramfs_vga_close(struct res_handle* handle) {
  103850:	55                   	push   %ebp
  103851:	89 e5                	mov    %esp,%ebp
  103853:	83 ec 08             	sub    $0x8,%esp
  103856:	8b 45 08             	mov    0x8(%ebp),%eax
  103859:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(handle->filemode & FM_WRITE) vga_writers--;
  10385c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10385f:	8b 40 0c             	mov    0xc(%eax),%eax
  103862:	25 02 00 00 00       	and    $0x2,%eax
  103867:	3d 00 00 00 00       	cmp    $0x0,%eax
  10386c:	0f 84 0f 00 00 00    	je     103881 <ramfs_vga_close+0x31>
  103872:	a1 24 a4 10 00       	mov    0x10a424,%eax
  103877:	05 ff ff ff ff       	add    $0xffffffff,%eax
  10387c:	a3 24 a4 10 00       	mov    %eax,0x10a424

    free(handle);
  103881:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103884:	89 04 24             	mov    %eax,(%esp)
  103887:	e8 24 0b 00 00       	call   1043b0 <free>
  10388c:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  103891:	83 c4 08             	add    $0x8,%esp
  103894:	5d                   	pop    %ebp
  103895:	c3                   	ret    
  103896:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10389d:	00 00 00 

001038a0 <ramfs_vga_available>:

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

uint32_t ramfs_vga_available(struct res_handle* handle) {
  1038a0:	55                   	push   %ebp
  1038a1:	89 e5                	mov    %esp,%ebp
  1038a3:	50                   	push   %eax
  1038a4:	8b 45 08             	mov    0x8(%ebp),%eax
  1038a7:	b9 06 00 00 00       	mov    $0x6,%ecx
  1038ac:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return sizeof(struct vga_command);
  1038af:	89 c8                	mov    %ecx,%eax
  1038b1:	83 c4 04             	add    $0x4,%esp
  1038b4:	5d                   	pop    %ebp
  1038b5:	c3                   	ret    
  1038b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1038bd:	00 00 00 

001038c0 <ramfs_vga_create>:
}

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  1038c0:	55                   	push   %ebp
  1038c1:	89 e5                	mov    %esp,%ebp
  1038c3:	83 ec 18             	sub    $0x18,%esp
  1038c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1038c9:	b9 08 00 00 00       	mov    $0x8,%ecx
  1038ce:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return malloc(sizeof(struct res_kfile));
  1038d1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1038d8:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1038db:	e8 00 07 00 00       	call   103fe0 <malloc>
  1038e0:	83 c4 18             	add    $0x18,%esp
  1038e3:	5d                   	pop    %ebp
  1038e4:	c3                   	ret    
  1038e5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1038ec:	00 00 00 00 

001038f0 <ramfs_vga_driver_struct>:
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
  1038f0:	55                   	push   %ebp
  1038f1:	89 e5                	mov    %esp,%ebp
  1038f3:	8d 05 c4 71 10 00    	lea    0x1071c4,%eax
    return &vga_driver;
  1038f9:	5d                   	pop    %ebp
  1038fa:	c3                   	ret    
  1038fb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103900 <ramfs_vga_writers>:
}

uint32_t ramfs_vga_writers() {
  103900:	55                   	push   %ebp
  103901:	89 e5                	mov    %esp,%ebp
    return vga_writers;
  103903:	a1 24 a4 10 00       	mov    0x10a424,%eax
  103908:	5d                   	pop    %ebp
  103909:	c3                   	ret    
  10390a:	66 90                	xchg   %ax,%ax
  10390c:	66 90                	xchg   %ax,%ax
  10390e:	66 90                	xchg   %ax,%ax

00103910 <enableScheduling>:
struct task* first_task = 0;
struct task* current_task = 0;

int nextPID = 1;

void enableScheduling(void) {
  103910:	55                   	push   %ebp
  103911:	89 e5                	mov    %esp,%ebp
    schedulingEnabled = 1;
  103913:	c7 05 28 a4 10 00 01 	movl   $0x1,0x10a428
  10391a:	00 00 00 
}
  10391d:	5d                   	pop    %ebp
  10391e:	c3                   	ret    
  10391f:	90                   	nop

00103920 <isSchedulingEnabled>:

uint32_t isSchedulingEnabled(void) {
  103920:	55                   	push   %ebp
  103921:	89 e5                	mov    %esp,%ebp
    return schedulingEnabled;
  103923:	a1 28 a4 10 00       	mov    0x10a428,%eax
  103928:	5d                   	pop    %ebp
  103929:	c3                   	ret    
  10392a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103930 <get_current_task>:
}

struct task* get_current_task(void) {
  103930:	55                   	push   %ebp
  103931:	89 e5                	mov    %esp,%ebp
    return current_task;
  103933:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103938:	5d                   	pop    %ebp
  103939:	c3                   	ret    
  10393a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103940 <register_handle>:
}

uint32_t register_handle(struct res_handle* h) {
  103940:	55                   	push   %ebp
  103941:	89 e5                	mov    %esp,%ebp
  103943:	83 ec 18             	sub    $0x18,%esp
  103946:	8b 45 08             	mov    0x8(%ebp),%eax
  103949:	b9 08 00 00 00       	mov    $0x8,%ecx
  10394e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct hl_node* old = current_task->handle_list;
  103951:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103956:	8b 40 28             	mov    0x28(%eax),%eax
  103959:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task->handle_list = malloc(sizeof(struct hl_node));
  10395c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103963:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103966:	e8 75 06 00 00       	call   103fe0 <malloc>
  10396b:	b9 00 00 00 00       	mov    $0x0,%ecx
  103970:	8b 15 30 a4 10 00    	mov    0x10a430,%edx
  103976:	89 42 28             	mov    %eax,0x28(%edx)
    current_task->handle_list->next = old;
  103979:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10397c:	8b 15 30 a4 10 00    	mov    0x10a430,%edx
  103982:	8b 52 28             	mov    0x28(%edx),%edx
  103985:	89 42 04             	mov    %eax,0x4(%edx)
    current_task->handle_list->handle = h;
  103988:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10398b:	8b 15 30 a4 10 00    	mov    0x10a430,%edx
  103991:	8b 52 28             	mov    0x28(%edx),%edx
  103994:	89 02                	mov    %eax,(%edx)

    return 0;
  103996:	89 c8                	mov    %ecx,%eax
  103998:	83 c4 18             	add    $0x18,%esp
  10399b:	5d                   	pop    %ebp
  10399c:	c3                   	ret    
  10399d:	0f 1f 00             	nopl   (%eax)

001039a0 <unregister_handle>:
}

uint32_t unregister_handle(struct res_handle* h) {
  1039a0:	55                   	push   %ebp
  1039a1:	89 e5                	mov    %esp,%ebp
  1039a3:	83 ec 18             	sub    $0x18,%esp
  1039a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1039a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct hl_node* cur = current_task->handle_list;
  1039ac:	a1 30 a4 10 00       	mov    0x10a430,%eax
  1039b1:	8b 40 28             	mov    0x28(%eax),%eax
  1039b4:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(h == 0) return 2;
  1039b7:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1039be:	0f 85 0c 00 00 00    	jne    1039d0 <unregister_handle+0x30>
  1039c4:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
  1039cb:	e9 b4 00 00 00       	jmp    103a84 <unregister_handle+0xe4>
    if(cur == 0) return 1;
  1039d0:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1039d7:	0f 85 0c 00 00 00    	jne    1039e9 <unregister_handle+0x49>
  1039dd:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1039e4:	e9 9b 00 00 00       	jmp    103a84 <unregister_handle+0xe4>

    if(cur->handle == h) {
  1039e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1039ec:	8b 00                	mov    (%eax),%eax
  1039ee:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1039f1:	0f 85 26 00 00 00    	jne    103a1d <unregister_handle+0x7d>
        current_task->handle_list = cur->next;
  1039f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1039fa:	8b 40 04             	mov    0x4(%eax),%eax
  1039fd:	8b 0d 30 a4 10 00    	mov    0x10a430,%ecx
  103a03:	89 41 28             	mov    %eax,0x28(%ecx)
        free(cur);
  103a06:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a09:	89 04 24             	mov    %eax,(%esp)
  103a0c:	e8 9f 09 00 00       	call   1043b0 <free>

        return 0;
  103a11:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103a18:	e9 67 00 00 00       	jmp    103a84 <unregister_handle+0xe4>
    }

    while(cur != 0) {
  103a1d:	e9 00 00 00 00       	jmp    103a22 <unregister_handle+0x82>
  103a22:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103a29:	0f 84 4e 00 00 00    	je     103a7d <unregister_handle+0xdd>
        if(cur->next->handle == h) {
  103a2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a32:	8b 40 04             	mov    0x4(%eax),%eax
  103a35:	8b 00                	mov    (%eax),%eax
  103a37:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103a3a:	0f 85 2f 00 00 00    	jne    103a6f <unregister_handle+0xcf>
            void* next = cur->next;
  103a40:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a43:	8b 40 04             	mov    0x4(%eax),%eax
  103a46:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cur->next =  cur->next->next;
  103a49:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a4c:	8b 40 04             	mov    0x4(%eax),%eax
  103a4f:	8b 40 04             	mov    0x4(%eax),%eax
  103a52:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103a55:	89 41 04             	mov    %eax,0x4(%ecx)

            free(next);
  103a58:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a5b:	89 04 24             	mov    %eax,(%esp)
  103a5e:	e8 4d 09 00 00       	call   1043b0 <free>

            return 0;
  103a63:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103a6a:	e9 15 00 00 00       	jmp    103a84 <unregister_handle+0xe4>
        }

        cur = cur->next;
  103a6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103a72:	8b 40 04             	mov    0x4(%eax),%eax
  103a75:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  103a78:	e9 a5 ff ff ff       	jmp    103a22 <unregister_handle+0x82>

    return 3;
  103a7d:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  103a84:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a87:	83 c4 18             	add    $0x18,%esp
  103a8a:	5d                   	pop    %ebp
  103a8b:	c3                   	ret    
  103a8c:	0f 1f 40 00          	nopl   0x0(%eax)

00103a90 <schedule_exception>:

struct cpu_state* schedule_exception(struct cpu_state* cpu) {
  103a90:	55                   	push   %ebp
  103a91:	89 e5                	mov    %esp,%ebp
  103a93:	56                   	push   %esi
  103a94:	83 ec 34             	sub    $0x34,%esp
  103a97:	8b 45 08             	mov    0x8(%ebp),%eax
  103a9a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (current_task == first_task && current_task->next == 0) {
  103a9d:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103aa2:	3b 05 2c a4 10 00    	cmp    0x10a42c,%eax
  103aa8:	0f 85 71 00 00 00    	jne    103b1f <schedule_exception+0x8f>
  103aae:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103ab3:	81 78 08 00 00 00 00 	cmpl   $0x0,0x8(%eax)
  103aba:	0f 85 5f 00 00 00    	jne    103b1f <schedule_exception+0x8f>
  103ac0:	b8 04 00 00 00       	mov    $0x4,%eax
        //Only one process is running, which just crashed. Stop system.
        setclr(0x04);
  103ac5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  103acc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103acf:	e8 5c ca ff ff       	call   100530 <setclr>
  103ad4:	8d 05 af 84 10 00    	lea    0x1084af,%eax
        kprintf("\n Terminated task (PID=%d) due to exception %x:%x \n",
  103ada:	8b 0d 30 a4 10 00    	mov    0x10a430,%ecx
  103ae0:	8b 09                	mov    (%ecx),%ecx
  103ae2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103ae5:	8b 52 1c             	mov    0x1c(%edx),%edx
  103ae8:	8b 75 f4             	mov    -0xc(%ebp),%esi
  103aeb:	8b 76 20             	mov    0x20(%esi),%esi
  103aee:	89 04 24             	mov    %eax,(%esp)
  103af1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103af5:	89 54 24 08          	mov    %edx,0x8(%esp)
  103af9:	89 74 24 0c          	mov    %esi,0xc(%esp)
  103afd:	e8 4e ca ff ff       	call   100550 <kprintf>
  103b02:	8d 0d e3 84 10 00    	lea    0x1084e3,%ecx
                current_task->PID, cpu->intr, cpu->error);
        show_cod(cpu, "Last task crashed. Terminating kernel...");
  103b08:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103b0b:	89 14 24             	mov    %edx,(%esp)
  103b0e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103b12:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103b15:	e8 56 c8 ff ff       	call   100370 <show_cod>
    } else {
  103b1a:	e9 88 00 00 00       	jmp    103ba7 <schedule_exception+0x117>
  103b1f:	b8 04 00 00 00       	mov    $0x4,%eax
        //Potential security leaks available in following code.
        setclr(0x04);
  103b24:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  103b2b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103b2e:	e8 fd c9 ff ff       	call   100530 <setclr>
  103b33:	8d 05 af 84 10 00    	lea    0x1084af,%eax
        kprintf("\n Terminated task (PID=%d) due to exception %x:%x \n",
  103b39:	8b 0d 30 a4 10 00    	mov    0x10a430,%ecx
  103b3f:	8b 09                	mov    (%ecx),%ecx
  103b41:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103b44:	8b 52 1c             	mov    0x1c(%edx),%edx
  103b47:	8b 75 f4             	mov    -0xc(%ebp),%esi
  103b4a:	8b 76 20             	mov    0x20(%esi),%esi
  103b4d:	89 04 24             	mov    %eax,(%esp)
  103b50:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103b54:	89 54 24 08          	mov    %edx,0x8(%esp)
  103b58:	89 74 24 0c          	mov    %esi,0xc(%esp)
  103b5c:	e8 ef c9 ff ff       	call   100550 <kprintf>
  103b61:	8d 0d e5 82 10 00    	lea    0x1082e5,%ecx
                current_task->PID, cpu->intr, cpu->error);
        kprintf("\n");
  103b67:	89 0c 24             	mov    %ecx,(%esp)
  103b6a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  103b6d:	e8 de c9 ff ff       	call   100550 <kprintf>
        show_dump(cpu);
  103b72:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103b75:	89 0c 24             	mov    %ecx,(%esp)
  103b78:	89 45 e0             	mov    %eax,-0x20(%ebp)
  103b7b:	e8 60 c8 ff ff       	call   1003e0 <show_dump>
  103b80:	b8 07 00 00 00       	mov    $0x7,%eax
        setclr(0x07);
  103b85:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  103b8c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  103b8f:	e8 9c c9 ff ff       	call   100530 <setclr>

        return terminate_current(cpu);
  103b94:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b97:	89 04 24             	mov    %eax,(%esp)
  103b9a:	e8 21 00 00 00       	call   103bc0 <terminate_current>
  103b9f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  103ba2:	e9 06 00 00 00       	jmp    103bad <schedule_exception+0x11d>
    }
    return cpu;
  103ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103baa:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  103bad:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103bb0:	83 c4 34             	add    $0x34,%esp
  103bb3:	5e                   	pop    %esi
  103bb4:	5d                   	pop    %ebp
  103bb5:	c3                   	ret    
  103bb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  103bbd:	00 00 00 

00103bc0 <terminate_current>:

struct cpu_state* terminate_current(struct cpu_state* cpu) {
  103bc0:	55                   	push   %ebp
  103bc1:	89 e5                	mov    %esp,%ebp
  103bc3:	83 ec 18             	sub    $0x18,%esp
  103bc6:	8b 45 08             	mov    0x8(%ebp),%eax
  103bc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct task* next = current_task->next;
  103bcc:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103bd1:	8b 40 08             	mov    0x8(%eax),%eax
  103bd4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* prev = current_task->prev;
  103bd7:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103bdc:	8b 40 0c             	mov    0xc(%eax),%eax
  103bdf:	89 45 f4             	mov    %eax,-0xc(%ebp)

    //TODO: free resources here

    if (current_task == first_task) {
  103be2:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103be7:	3b 05 2c a4 10 00    	cmp    0x10a42c,%eax
  103bed:	0f 85 0d 00 00 00    	jne    103c00 <terminate_current+0x40>
        first_task = current_task->next;
  103bf3:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103bf8:	8b 40 08             	mov    0x8(%eax),%eax
  103bfb:	a3 2c a4 10 00       	mov    %eax,0x10a42c
    }

    if (next != 0) {
  103c00:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103c07:	0f 84 09 00 00 00    	je     103c16 <terminate_current+0x56>
        next->prev = prev;
  103c0d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c10:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103c13:	89 41 0c             	mov    %eax,0xc(%ecx)
    }

    if (prev != 0) {
  103c16:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103c1d:	0f 84 09 00 00 00    	je     103c2c <terminate_current+0x6c>
        prev->next = next;
  103c23:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103c26:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103c29:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    //TODO: handle if all tasks are closed

    if (next == 0)
  103c2c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103c33:	0f 85 08 00 00 00    	jne    103c41 <terminate_current+0x81>
        next = first_task;
  103c39:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103c3e:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task = next;
  103c41:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103c44:	a3 30 a4 10 00       	mov    %eax,0x10a430

    if(current_task == 0) {
  103c49:	81 3d 30 a4 10 00 00 	cmpl   $0x0,0x10a430
  103c50:	00 00 00 
  103c53:	0f 85 15 00 00 00    	jne    103c6e <terminate_current+0xae>
  103c59:	8d 05 0c 85 10 00    	lea    0x10850c,%eax
        show_cod(cpu, "Last task terminated.");
  103c5f:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103c62:	89 0c 24             	mov    %ecx,(%esp)
  103c65:	89 44 24 04          	mov    %eax,0x4(%esp)
  103c69:	e8 02 c7 ff ff       	call   100370 <show_cod>
    }

    vmm_activate_pagedir(current_task->phys_pdir);
  103c6e:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103c73:	8b 40 14             	mov    0x14(%eax),%eax
  103c76:	89 04 24             	mov    %eax,(%esp)
  103c79:	e8 02 27 00 00       	call   106380 <vmm_activate_pagedir>
    return current_task->cpuState;
  103c7e:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103c83:	8b 40 04             	mov    0x4(%eax),%eax
  103c86:	83 c4 18             	add    $0x18,%esp
  103c89:	5d                   	pop    %ebp
  103c8a:	c3                   	ret    
  103c8b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103c90 <fork_task_state>:
}

void fork_task_state(struct task* new_task) {
  103c90:	55                   	push   %ebp
  103c91:	89 e5                	mov    %esp,%ebp
  103c93:	83 ec 18             	sub    $0x18,%esp
  103c96:	8b 45 08             	mov    0x8(%ebp),%eax
  103c99:	b9 38 00 00 00       	mov    $0x38,%ecx
  103c9e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    new_task->user_stack_bottom = current_task->user_stack_bottom;
  103ca1:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103ca6:	8b 40 10             	mov    0x10(%eax),%eax
  103ca9:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103cac:	89 42 10             	mov    %eax,0x10(%edx)

    new_task->stdout = current_task->stdout;
  103caf:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103cb4:	8b 40 1c             	mov    0x1c(%eax),%eax
  103cb7:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103cba:	89 42 1c             	mov    %eax,0x1c(%edx)
    new_task->stdin  = current_task->stdin;
  103cbd:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103cc2:	8b 40 24             	mov    0x24(%eax),%eax
  103cc5:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103cc8:	89 42 24             	mov    %eax,0x24(%edx)
    new_task->stderr = current_task->stderr;
  103ccb:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103cd0:	8b 40 20             	mov    0x20(%eax),%eax
  103cd3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103cd6:	89 42 20             	mov    %eax,0x20(%edx)

    memcpy(new_task->cpuState, current_task->cpuState, sizeof(struct cpu_state));
  103cd9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103cdc:	8b 40 04             	mov    0x4(%eax),%eax
  103cdf:	8b 15 30 a4 10 00    	mov    0x10a430,%edx
  103ce5:	8b 52 04             	mov    0x4(%edx),%edx
  103ce8:	89 04 24             	mov    %eax,(%esp)
  103ceb:	89 54 24 04          	mov    %edx,0x4(%esp)
  103cef:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  103cf6:	00 
  103cf7:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103cfa:	e8 b1 09 00 00       	call   1046b0 <memcpy>

    new_task->cpuState->eax = 0;
  103cff:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103d02:	8b 40 04             	mov    0x4(%eax),%eax
  103d05:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  103d0b:	83 c4 18             	add    $0x18,%esp
  103d0e:	5d                   	pop    %ebp
  103d0f:	c3                   	ret    

00103d10 <init_task>:

struct task* init_task(uint32_t task_pagedir, void* entry) {
  103d10:	55                   	push   %ebp
  103d11:	89 e5                	mov    %esp,%ebp
  103d13:	83 ec 68             	sub    $0x68,%esp
  103d16:	8b 45 0c             	mov    0xc(%ebp),%eax
  103d19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103d1c:	ba 2c 00 00 00       	mov    $0x2c,%edx
  103d21:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  103d24:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* ntask = malloc(sizeof(struct task));
  103d27:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  103d2e:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  103d31:	e8 aa 02 00 00       	call   103fe0 <malloc>
  103d36:	b9 38 00 00 00       	mov    $0x38,%ecx
  103d3b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ntask->cpuState = malloc(sizeof(struct cpu_state));
  103d3e:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  103d45:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  103d48:	e8 93 02 00 00       	call   103fe0 <malloc>
  103d4d:	b9 00 e0 ff ff       	mov    $0xffffe000,%ecx
  103d52:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103d55:	89 42 04             	mov    %eax,0x4(%edx)

    ntask->phys_pdir = task_pagedir;
  103d58:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103d5b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103d5e:	89 42 14             	mov    %eax,0x14(%edx)
    ntask->user_stack_bottom = (void*) 0xFFFFE000;
  103d61:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d64:	89 48 10             	mov    %ecx,0x10(%eax)
    ntask->PID = nextPID++;
  103d67:	a1 e0 71 10 00       	mov    0x1071e0,%eax
  103d6c:	89 c1                	mov    %eax,%ecx
  103d6e:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103d74:	89 0d e0 71 10 00    	mov    %ecx,0x1071e0
  103d7a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103d7d:	89 01                	mov    %eax,(%ecx)

    ntask->stdin  = 0;
  103d7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d82:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
    ntask->stdout = 0;
  103d89:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d8c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    ntask->stderr = 0;
  103d93:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d96:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

    ntask->next = (void*) 0;
  103d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103da0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    ntask->prev = (void*) 0;
  103da7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103daa:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

    if (first_task == 0) {
  103db1:	81 3d 2c a4 10 00 00 	cmpl   $0x0,0x10a42c
  103db8:	00 00 00 
  103dbb:	0f 85 0d 00 00 00    	jne    103dce <init_task+0xbe>
        first_task = ntask;
  103dc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103dc4:	a3 2c a4 10 00       	mov    %eax,0x10a42c
    } else {
  103dc9:	e9 1f 00 00 00       	jmp    103ded <init_task+0xdd>
        ntask->next = first_task;
  103dce:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103dd3:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103dd6:	89 41 08             	mov    %eax,0x8(%ecx)
        first_task->prev = ntask;
  103dd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ddc:	8b 0d 2c a4 10 00    	mov    0x10a42c,%ecx
  103de2:	89 41 0c             	mov    %eax,0xc(%ecx)
        first_task = ntask;
  103de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103de8:	a3 2c a4 10 00       	mov    %eax,0x10a42c
    }

    uint32_t rest_pdir = vmm_get_current_pagedir();
  103ded:	e8 4e 1a 00 00       	call   105840 <vmm_get_current_pagedir>
  103df2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    vmm_activate_pagedir(task_pagedir);
  103df5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103df8:	89 04 24             	mov    %eax,(%esp)
  103dfb:	e8 80 25 00 00       	call   106380 <vmm_activate_pagedir>

    if (entry != 0) { //entry == 0 means that this will be forked
  103e00:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103e07:	0f 84 21 00 00 00    	je     103e2e <init_task+0x11e>
  103e0d:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_alloc_addr(ntask->user_stack_bottom, 0);
  103e12:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103e15:	8b 49 10             	mov    0x10(%ecx),%ecx
  103e18:	89 0c 24             	mov    %ecx,(%esp)
  103e1b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103e22:	00 
  103e23:	89 45 ac             	mov    %eax,-0x54(%ebp)
  103e26:	e8 55 24 00 00       	call   106280 <vmm_alloc_addr>
  103e2b:	89 45 a8             	mov    %eax,-0x58(%ebp)
  103e2e:	b8 38 00 00 00       	mov    $0x38,%eax
  103e33:	8d 4d b8             	lea    -0x48(%ebp),%ecx
    }

    struct cpu_state nstate = { .eax = 0, .ebx = 0, .ecx = 0, .edx = 0,
  103e36:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  103e3d:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  103e44:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  103e4b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  103e52:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  103e59:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  103e60:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  103e67:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  103e6e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  103e75:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103e78:	89 55 dc             	mov    %edx,-0x24(%ebp)
  103e7b:	c7 45 e0 1b 00 00 00 	movl   $0x1b,-0x20(%ebp)
  103e82:	c7 45 e4 00 02 00 00 	movl   $0x200,-0x1c(%ebp)
  103e89:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103e8c:	8b 52 10             	mov    0x10(%edx),%edx
  103e8f:	81 c2 00 10 00 00    	add    $0x1000,%edx
  103e95:	89 55 e8             	mov    %edx,-0x18(%ebp)
  103e98:	c7 45 ec 23 00 00 00 	movl   $0x23,-0x14(%ebp)
            /* Ring-3-Segmentregister */
            .cs = 0x18 | 0x03, .ss = 0x20 | 0x03,

            .eflags = 0x200, };

    memcpy(ntask->cpuState, &nstate, sizeof(struct cpu_state));
  103e9f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103ea2:	8b 52 04             	mov    0x4(%edx),%edx
  103ea5:	89 14 24             	mov    %edx,(%esp)
  103ea8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103eac:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  103eb3:	00 
  103eb4:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  103eb7:	e8 f4 07 00 00       	call   1046b0 <memcpy>

    vmm_activate_pagedir(rest_pdir);
  103ebc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103ebf:	89 04 24             	mov    %eax,(%esp)
  103ec2:	e8 b9 24 00 00       	call   106380 <vmm_activate_pagedir>

    return ntask;
  103ec7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103eca:	83 c4 68             	add    $0x68,%esp
  103ecd:	5d                   	pop    %ebp
  103ece:	c3                   	ret    
  103ecf:	90                   	nop

00103ed0 <save_cpu_state>:
}

void save_cpu_state(struct cpu_state* cpu) {
  103ed0:	55                   	push   %ebp
  103ed1:	89 e5                	mov    %esp,%ebp
  103ed3:	83 ec 18             	sub    $0x18,%esp
  103ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  103ed9:	b9 38 00 00 00       	mov    $0x38,%ecx
  103ede:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memcpy(current_task->cpuState, cpu, sizeof(struct cpu_state));
  103ee1:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103ee6:	8b 40 04             	mov    0x4(%eax),%eax
  103ee9:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103eec:	89 04 24             	mov    %eax,(%esp)
  103eef:	89 54 24 04          	mov    %edx,0x4(%esp)
  103ef3:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  103efa:	00 
  103efb:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103efe:	e8 ad 07 00 00       	call   1046b0 <memcpy>
}
  103f03:	83 c4 18             	add    $0x18,%esp
  103f06:	5d                   	pop    %ebp
  103f07:	c3                   	ret    
  103f08:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  103f0f:	00 

00103f10 <schedule>:

struct cpu_state* schedule(struct cpu_state* cpu) {
  103f10:	55                   	push   %ebp
  103f11:	89 e5                	mov    %esp,%ebp
  103f13:	83 ec 18             	sub    $0x18,%esp
  103f16:	8b 45 08             	mov    0x8(%ebp),%eax
  103f19:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (first_task != 0 && schedulingEnabled) {
  103f1c:	81 3d 2c a4 10 00 00 	cmpl   $0x0,0x10a42c
  103f23:	00 00 00 
  103f26:	0f 84 9d 00 00 00    	je     103fc9 <schedule+0xb9>
  103f2c:	81 3d 28 a4 10 00 00 	cmpl   $0x0,0x10a428
  103f33:	00 00 00 
  103f36:	0f 84 8d 00 00 00    	je     103fc9 <schedule+0xb9>
        if (current_task == 0) {
  103f3c:	81 3d 30 a4 10 00 00 	cmpl   $0x0,0x10a430
  103f43:	00 00 00 
  103f46:	0f 85 2a 00 00 00    	jne    103f76 <schedule+0x66>
            current_task = first_task;
  103f4c:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103f51:	a3 30 a4 10 00       	mov    %eax,0x10a430
            vmm_activate_pagedir(current_task->phys_pdir);
  103f56:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103f5b:	8b 40 14             	mov    0x14(%eax),%eax
  103f5e:	89 04 24             	mov    %eax,(%esp)
  103f61:	e8 1a 24 00 00       	call   106380 <vmm_activate_pagedir>
            return current_task->cpuState;
  103f66:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103f6b:	8b 40 04             	mov    0x4(%eax),%eax
  103f6e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103f71:	e9 59 00 00 00       	jmp    103fcf <schedule+0xbf>
        }

        struct task* next = current_task->next;
  103f76:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103f7b:	8b 40 08             	mov    0x8(%eax),%eax
  103f7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (next == 0)
  103f81:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103f88:	0f 85 08 00 00 00    	jne    103f96 <schedule+0x86>
            next = first_task;
  103f8e:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103f93:	89 45 f4             	mov    %eax,-0xc(%ebp)

        save_cpu_state(cpu);
  103f96:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103f99:	89 04 24             	mov    %eax,(%esp)
  103f9c:	e8 2f ff ff ff       	call   103ed0 <save_cpu_state>

        current_task = next;
  103fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103fa4:	a3 30 a4 10 00       	mov    %eax,0x10a430
        vmm_activate_pagedir(current_task->phys_pdir);
  103fa9:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103fae:	8b 40 14             	mov    0x14(%eax),%eax
  103fb1:	89 04 24             	mov    %eax,(%esp)
  103fb4:	e8 c7 23 00 00       	call   106380 <vmm_activate_pagedir>
        return current_task->cpuState;
  103fb9:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103fbe:	8b 40 04             	mov    0x4(%eax),%eax
  103fc1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103fc4:	e9 06 00 00 00       	jmp    103fcf <schedule+0xbf>
    }
    return cpu;
  103fc9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103fcc:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  103fcf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103fd2:	83 c4 18             	add    $0x18,%esp
  103fd5:	5d                   	pop    %ebp
  103fd6:	c3                   	ret    
  103fd7:	66 90                	xchg   %ax,%ax
  103fd9:	66 90                	xchg   %ax,%ax
  103fdb:	66 90                	xchg   %ax,%ax
  103fdd:	66 90                	xchg   %ax,%ax
  103fdf:	90                   	nop

00103fe0 <malloc>:
    }

    append_to_list(&first_free, tf);
}

void* malloc(size_t size) {
  103fe0:	55                   	push   %ebp
  103fe1:	89 e5                	mov    %esp,%ebp
  103fe3:	83 ec 38             	sub    $0x38,%esp
  103fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  103fe9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(size == 0) return 0;
  103fec:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103ff3:	0f 85 0c 00 00 00    	jne    104005 <malloc+0x25>
  103ff9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104000:	e9 95 01 00 00       	jmp    10419a <malloc+0x1ba>

    struct memory_node* last = 0;
  104005:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
  10400c:	a1 3c a4 10 00       	mov    0x10a43c,%eax
  104011:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  104014:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10401b:	0f 84 27 00 00 00    	je     104048 <malloc+0x68>
        if (cur->size >= size) {
  104021:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104024:	8b 00                	mov    (%eax),%eax
  104026:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  104029:	0f 82 05 00 00 00    	jb     104034 <malloc+0x54>
            break;
  10402f:	e9 14 00 00 00       	jmp    104048 <malloc+0x68>
        }
        last = cur;
  104034:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104037:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  10403a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10403d:	8b 40 08             	mov    0x8(%eax),%eax
  104040:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  104043:	e9 cc ff ff ff       	jmp    104014 <malloc+0x34>

    if (cur == 0) {
  104048:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10404f:	0f 85 bc 00 00 00    	jne    104111 <malloc+0x131>
        uint32_t pgs = size / PAGESIZE;
  104055:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104058:	c1 e8 0c             	shr    $0xc,%eax
  10405b:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
  10405e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104061:	25 ff 0f 00 00       	and    $0xfff,%eax
  104066:	3d 00 00 00 00       	cmp    $0x0,%eax
  10406b:	0f 84 0b 00 00 00    	je     10407c <malloc+0x9c>
            pgs++;
  104071:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104074:	05 01 00 00 00       	add    $0x1,%eax
  104079:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
  10407c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10407f:	89 04 24             	mov    %eax,(%esp)
  104082:	e8 a9 21 00 00       	call   106230 <vmm_alloc_cont>
  104087:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
  10408a:	e8 81 04 00 00       	call   104510 <pop_unused_node>
  10408f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
  104092:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104095:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104098:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
  10409b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10409e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1040a1:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
  1040a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040a6:	c1 e0 0c             	shl    $0xc,%eax
  1040a9:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1040ac:	0f 86 3c 00 00 00    	jbe    1040ee <malloc+0x10e>
            struct memory_node* free = pop_unused_node();
  1040b2:	e8 59 04 00 00       	call   104510 <pop_unused_node>
  1040b7:	8d 0d 3c a4 10 00    	lea    0x10a43c,%ecx
  1040bd:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
  1040c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1040c3:	8b 40 04             	mov    0x4(%eax),%eax
  1040c6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  1040c9:	03 02                	add    (%edx),%eax
  1040cb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1040ce:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
  1040d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040d4:	c1 e0 0c             	shl    $0xc,%eax
  1040d7:	2b 45 f8             	sub    -0x8(%ebp),%eax
  1040da:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1040dd:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  1040df:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1040e2:	89 0c 24             	mov    %ecx,(%esp)
  1040e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1040e9:	e8 c2 00 00 00       	call   1041b0 <append_to_list>
  1040ee:	8d 05 38 a4 10 00    	lea    0x10a438,%eax
        }

        append_to_list(&first_used, fill);
  1040f4:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1040f7:	89 04 24             	mov    %eax,(%esp)
  1040fa:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1040fe:	e8 ad 00 00 00       	call   1041b0 <append_to_list>

        return (void*) fill->address;
  104103:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104106:	8b 40 04             	mov    0x4(%eax),%eax
  104109:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10410c:	e9 89 00 00 00       	jmp    10419a <malloc+0x1ba>
  104111:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax
    } else {
        uint32_t freesize = cur->size - size;
  104117:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10411a:	8b 09                	mov    (%ecx),%ecx
  10411c:	2b 4d f8             	sub    -0x8(%ebp),%ecx
  10411f:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
  104122:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104125:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104128:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
  10412a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10412d:	89 04 24             	mov    %eax,(%esp)
  104130:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104134:	e8 a7 00 00 00       	call   1041e0 <remove_from_list>
  104139:	8d 05 38 a4 10 00    	lea    0x10a438,%eax
        append_to_list(&first_used, cur);
  10413f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104142:	89 04 24             	mov    %eax,(%esp)
  104145:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104149:	e8 62 00 00 00       	call   1041b0 <append_to_list>

        if (freesize > 0) {
  10414e:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  104155:	0f 86 36 00 00 00    	jbe    104191 <malloc+0x1b1>
            struct memory_node* free = pop_unused_node();
  10415b:	e8 b0 03 00 00       	call   104510 <pop_unused_node>
  104160:	8d 0d 3c a4 10 00    	lea    0x10a43c,%ecx
  104166:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
  104169:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10416c:	8b 40 04             	mov    0x4(%eax),%eax
  10416f:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104172:	03 02                	add    (%edx),%eax
  104174:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104177:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
  10417a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10417d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104180:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  104182:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104185:	89 0c 24             	mov    %ecx,(%esp)
  104188:	89 44 24 04          	mov    %eax,0x4(%esp)
  10418c:	e8 1f 00 00 00       	call   1041b0 <append_to_list>
        }

        return (void*) cur->address;
  104191:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104194:	8b 40 04             	mov    0x4(%eax),%eax
  104197:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  10419a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10419d:	83 c4 38             	add    $0x38,%esp
  1041a0:	5d                   	pop    %ebp
  1041a1:	c3                   	ret    
  1041a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1041a9:	1f 84 00 00 00 00 00 

001041b0 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
  1041b0:	55                   	push   %ebp
  1041b1:	89 e5                	mov    %esp,%ebp
  1041b3:	83 ec 08             	sub    $0x8,%esp
  1041b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1041b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1041bc:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1041bf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
  1041c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1041c5:	8b 00                	mov    (%eax),%eax
  1041c7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1041ca:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
  1041cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041d0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1041d3:	89 01                	mov    %eax,(%ecx)
}
  1041d5:	83 c4 08             	add    $0x8,%esp
  1041d8:	5d                   	pop    %ebp
  1041d9:	c3                   	ret    
  1041da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001041e0 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
  1041e0:	55                   	push   %ebp
  1041e1:	89 e5                	mov    %esp,%ebp
  1041e3:	83 ec 10             	sub    $0x10,%esp
  1041e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1041e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1041ec:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1041ef:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
  1041f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
  1041f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1041fc:	8b 00                	mov    (%eax),%eax
  1041fe:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  104201:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104208:	0f 84 4e 00 00 00    	je     10425c <remove_from_list+0x7c>
        if (cur == element) {
  10420e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104211:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  104214:	0f 85 2e 00 00 00    	jne    104248 <remove_from_list+0x68>
            if (last == 0) {
  10421a:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104221:	0f 85 10 00 00 00    	jne    104237 <remove_from_list+0x57>
                *root = cur->next;
  104227:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10422a:	8b 40 08             	mov    0x8(%eax),%eax
  10422d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104230:	89 01                	mov    %eax,(%ecx)
                return;
  104232:	e9 25 00 00 00       	jmp    10425c <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
  104237:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10423a:	8b 40 08             	mov    0x8(%eax),%eax
  10423d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104240:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
  104243:	e9 14 00 00 00       	jmp    10425c <remove_from_list+0x7c>
            }
        }
        last = cur;
  104248:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10424b:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  10424e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104251:	8b 40 08             	mov    0x8(%eax),%eax
  104254:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  104257:	e9 a5 ff ff ff       	jmp    104201 <remove_from_list+0x21>
}
  10425c:	83 c4 10             	add    $0x10,%esp
  10425f:	5d                   	pop    %ebp
  104260:	c3                   	ret    
  104261:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104268:	0f 1f 84 00 00 00 00 
  10426f:	00 

00104270 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
  104270:	55                   	push   %ebp
  104271:	89 e5                	mov    %esp,%ebp
  104273:	83 ec 28             	sub    $0x28,%esp
  104276:	8b 45 0c             	mov    0xc(%ebp),%eax
  104279:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10427c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10427f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
  104282:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104285:	0f af 45 f8          	imul   -0x8(%ebp),%eax
  104289:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
  10428c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10428f:	89 04 24             	mov    %eax,(%esp)
  104292:	e8 49 fd ff ff       	call   103fe0 <malloc>
  104297:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
  10429a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1042a1:	0f 84 22 00 00 00    	je     1042c9 <calloc+0x59>
  1042a7:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
  1042ac:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1042af:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1042b2:	89 0c 24             	mov    %ecx,(%esp)
  1042b5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1042bc:	00 
  1042bd:	89 54 24 08          	mov    %edx,0x8(%esp)
  1042c1:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1042c4:	e8 87 03 00 00       	call   104650 <memset>
    }

    return p;
  1042c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1042cc:	83 c4 28             	add    $0x28,%esp
  1042cf:	5d                   	pop    %ebp
  1042d0:	c3                   	ret    
  1042d1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1042d8:	0f 1f 84 00 00 00 00 
  1042df:	00 

001042e0 <realloc>:
}

void* realloc(void* ptr, size_t size) {
  1042e0:	55                   	push   %ebp
  1042e1:	89 e5                	mov    %esp,%ebp
  1042e3:	83 ec 28             	sub    $0x28,%esp
  1042e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1042e9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1042ec:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1042ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
  1042f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
  1042f9:	a1 38 a4 10 00       	mov    0x10a438,%eax
  1042fe:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
  104301:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104308:	0f 84 8e 00 00 00    	je     10439c <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
  10430e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104311:	8b 40 04             	mov    0x4(%eax),%eax
  104314:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104317:	39 c8                	cmp    %ecx,%eax
  104319:	0f 85 69 00 00 00    	jne    104388 <realloc+0xa8>
            if (size == 0) {
  10431f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104326:	0f 85 17 00 00 00    	jne    104343 <realloc+0x63>
                free(ptr);
  10432c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10432f:	89 04 24             	mov    %eax,(%esp)
  104332:	e8 79 00 00 00       	call   1043b0 <free>
                return 0;
  104337:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10433e:	e9 60 00 00 00       	jmp    1043a3 <realloc+0xc3>
            } else {
                void* new = malloc(size);
  104343:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104346:	89 04 24             	mov    %eax,(%esp)
  104349:	e8 92 fc ff ff       	call   103fe0 <malloc>
  10434e:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
  104351:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104354:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104357:	8b 49 04             	mov    0x4(%ecx),%ecx
  10435a:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10435d:	8b 12                	mov    (%edx),%edx
  10435f:	89 04 24             	mov    %eax,(%esp)
  104362:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104366:	89 54 24 08          	mov    %edx,0x8(%esp)
  10436a:	e8 41 03 00 00       	call   1046b0 <memcpy>
                free((void*) cur->address);
  10436f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104372:	8b 40 04             	mov    0x4(%eax),%eax
  104375:	89 04 24             	mov    %eax,(%esp)
  104378:	e8 33 00 00 00       	call   1043b0 <free>

                return new;
  10437d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104380:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104383:	e9 1b 00 00 00       	jmp    1043a3 <realloc+0xc3>
            }
        }
        last = cur;
  104388:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10438b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
  10438e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104391:	8b 40 08             	mov    0x8(%eax),%eax
  104394:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
  104397:	e9 65 ff ff ff       	jmp    104301 <realloc+0x21>
    return 0;
  10439c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1043a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1043a6:	83 c4 28             	add    $0x28,%esp
  1043a9:	5d                   	pop    %ebp
  1043aa:	c3                   	ret    
  1043ab:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001043b0 <free>:

void free(void* ptr) {
  1043b0:	55                   	push   %ebp
  1043b1:	89 e5                	mov    %esp,%ebp
  1043b3:	83 ec 18             	sub    $0x18,%esp
  1043b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1043b9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
  1043bc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
  1043c3:	a1 38 a4 10 00       	mov    0x10a438,%eax
  1043c8:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
  1043cb:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1043d2:	0f 84 35 00 00 00    	je     10440d <free+0x5d>
        if (cur->address == (uint32_t) ptr) {
  1043d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1043db:	8b 40 04             	mov    0x4(%eax),%eax
  1043de:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1043e1:	39 c8                	cmp    %ecx,%eax
  1043e3:	0f 85 10 00 00 00    	jne    1043f9 <free+0x49>
            merge_into_frees(cur);
  1043e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1043ec:	89 04 24             	mov    %eax,(%esp)
  1043ef:	e8 2c 00 00 00       	call   104420 <merge_into_frees>
            break;
  1043f4:	e9 14 00 00 00       	jmp    10440d <free+0x5d>
        }
        last = cur;
  1043f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1043fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
  1043ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104402:	8b 40 08             	mov    0x8(%eax),%eax
  104405:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  104408:	e9 be ff ff ff       	jmp    1043cb <free+0x1b>
}
  10440d:	83 c4 18             	add    $0x18,%esp
  104410:	5d                   	pop    %ebp
  104411:	c3                   	ret    
  104412:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104419:	1f 84 00 00 00 00 00 

00104420 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
  104420:	55                   	push   %ebp
  104421:	89 e5                	mov    %esp,%ebp
  104423:	56                   	push   %esi
  104424:	83 ec 14             	sub    $0x14,%esp
  104427:	8b 45 08             	mov    0x8(%ebp),%eax
  10442a:	8d 0d 38 a4 10 00    	lea    0x10a438,%ecx
  104430:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
  104433:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104436:	89 0c 24             	mov    %ecx,(%esp)
  104439:	89 44 24 04          	mov    %eax,0x4(%esp)
  10443d:	e8 9e fd ff ff       	call   1041e0 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
  104442:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
  104449:	a1 3c a4 10 00       	mov    0x10a43c,%eax
  10444e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  104451:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104458:	0f 84 92 00 00 00    	je     1044f0 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
  10445e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104461:	8b 40 04             	mov    0x4(%eax),%eax
  104464:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104467:	03 01                	add    (%ecx),%eax
  104469:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10446c:	3b 41 04             	cmp    0x4(%ecx),%eax
  10446f:	0f 85 26 00 00 00    	jne    10449b <merge_into_frees+0x7b>
  104475:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax
            tf->address = cur->address;
  10447b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10447e:	8b 49 04             	mov    0x4(%ecx),%ecx
  104481:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104484:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
  104487:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10448a:	89 04 24             	mov    %eax,(%esp)
  10448d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104491:	e8 4a fd ff ff       	call   1041e0 <remove_from_list>
            goto editedList;
  104496:	e9 a7 ff ff ff       	jmp    104442 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
  10449b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10449e:	8b 40 04             	mov    0x4(%eax),%eax
  1044a1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1044a4:	8b 49 04             	mov    0x4(%ecx),%ecx
  1044a7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1044aa:	03 0a                	add    (%edx),%ecx
  1044ac:	39 c8                	cmp    %ecx,%eax
  1044ae:	0f 85 28 00 00 00    	jne    1044dc <merge_into_frees+0xbc>
  1044b4:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax
            tf->size += cur->size;
  1044ba:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1044bd:	8b 09                	mov    (%ecx),%ecx
  1044bf:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1044c2:	8b 32                	mov    (%edx),%esi
  1044c4:	01 ce                	add    %ecx,%esi
  1044c6:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
  1044c8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1044cb:	89 04 24             	mov    %eax,(%esp)
  1044ce:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1044d2:	e8 09 fd ff ff       	call   1041e0 <remove_from_list>
            goto editedList;
  1044d7:	e9 66 ff ff ff       	jmp    104442 <merge_into_frees+0x22>
        }

        last = cur;
  1044dc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1044df:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  1044e2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1044e5:	8b 40 08             	mov    0x8(%eax),%eax
  1044e8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  1044eb:	e9 61 ff ff ff       	jmp    104451 <merge_into_frees+0x31>
  1044f0:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax

    append_to_list(&first_free, tf);
  1044f6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1044f9:	89 04 24             	mov    %eax,(%esp)
  1044fc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104500:	e8 ab fc ff ff       	call   1041b0 <append_to_list>
}
  104505:	83 c4 14             	add    $0x14,%esp
  104508:	5e                   	pop    %esi
  104509:	5d                   	pop    %ebp
  10450a:	c3                   	ret    
  10450b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104510 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
  104510:	55                   	push   %ebp
  104511:	89 e5                	mov    %esp,%ebp
  104513:	83 ec 08             	sub    $0x8,%esp
  104516:	8d 05 34 a4 10 00    	lea    0x10a434,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
  10451c:	89 04 24             	mov    %eax,(%esp)
  10451f:	e8 3c 00 00 00       	call   104560 <pop_from_list>
  104524:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
  104527:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
  10452e:	0f 85 1b 00 00 00    	jne    10454f <pop_unused_node+0x3f>
        allocate_unused_nodes();
  104534:	e8 77 00 00 00       	call   1045b0 <allocate_unused_nodes>
  104539:	8d 05 34 a4 10 00    	lea    0x10a434,%eax
        ret = pop_from_list(&first_unused);
  10453f:	89 04 24             	mov    %eax,(%esp)
  104542:	e8 19 00 00 00       	call   104560 <pop_from_list>
  104547:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  10454a:	e9 d8 ff ff ff       	jmp    104527 <pop_unused_node+0x17>

    return ret;
  10454f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104552:	83 c4 08             	add    $0x8,%esp
  104555:	5d                   	pop    %ebp
  104556:	c3                   	ret    
  104557:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10455e:	00 00 

00104560 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
  104560:	55                   	push   %ebp
  104561:	89 e5                	mov    %esp,%ebp
  104563:	83 ec 18             	sub    $0x18,%esp
  104566:	8b 45 08             	mov    0x8(%ebp),%eax
  104569:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
  10456c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10456f:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
  104575:	0f 85 0c 00 00 00    	jne    104587 <pop_from_list+0x27>
        return 0;
  10457b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104582:	e9 20 00 00 00       	jmp    1045a7 <pop_from_list+0x47>
    struct memory_node* pop = *root;
  104587:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10458a:	8b 00                	mov    (%eax),%eax
  10458c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
  10458f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104592:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104595:	89 04 24             	mov    %eax,(%esp)
  104598:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10459c:	e8 3f fc ff ff       	call   1041e0 <remove_from_list>
    return pop;
  1045a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1045a4:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1045a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1045aa:	83 c4 18             	add    $0x18,%esp
  1045ad:	5d                   	pop    %ebp
  1045ae:	c3                   	ret    
  1045af:	90                   	nop

001045b0 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
  1045b0:	55                   	push   %ebp
  1045b1:	89 e5                	mov    %esp,%ebp
  1045b3:	83 ec 28             	sub    $0x28,%esp
  1045b6:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
  1045bb:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1045c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1045c5:	e8 66 1c 00 00       	call   106230 <vmm_alloc_cont>
  1045ca:	b9 00 00 00 00       	mov    $0x0,%ecx
  1045cf:	ba 00 10 00 00       	mov    $0x1000,%edx
  1045d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
  1045d7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1045da:	89 04 24             	mov    %eax,(%esp)
  1045dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1045e4:	00 
  1045e5:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  1045ec:	00 
  1045ed:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1045f0:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1045f3:	e8 58 00 00 00       	call   104650 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  1045f8:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1045ff:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
  104606:	0f 83 30 00 00 00    	jae    10463c <allocate_unused_nodes+0x8c>
  10460c:	8d 05 34 a4 10 00    	lea    0x10a434,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
  104612:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104615:	8b 55 fc             	mov    -0x4(%ebp),%edx
  104618:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
  10461e:	01 ca                	add    %ecx,%edx
  104620:	89 04 24             	mov    %eax,(%esp)
  104623:	89 54 24 04          	mov    %edx,0x4(%esp)
  104627:	e8 84 fb ff ff       	call   1041b0 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  10462c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10462f:	05 01 00 00 00       	add    $0x1,%eax
  104634:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104637:	e9 c3 ff ff ff       	jmp    1045ff <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
  10463c:	83 c4 28             	add    $0x28,%esp
  10463f:	5d                   	pop    %ebp
  104640:	c3                   	ret    
  104641:	66 90                	xchg   %ax,%ax
  104643:	66 90                	xchg   %ax,%ax
  104645:	66 90                	xchg   %ax,%ax
  104647:	66 90                	xchg   %ax,%ax
  104649:	66 90                	xchg   %ax,%ax
  10464b:	66 90                	xchg   %ax,%ax
  10464d:	66 90                	xchg   %ax,%ax
  10464f:	90                   	nop

00104650 <memset>:
#include "vmm.h"
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
  104650:	55                   	push   %ebp
  104651:	89 e5                	mov    %esp,%ebp
  104653:	83 ec 10             	sub    $0x10,%esp
  104656:	8b 45 10             	mov    0x10(%ebp),%eax
  104659:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10465c:	8b 55 08             	mov    0x8(%ebp),%edx
  10465f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104662:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104665:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* p = buf;
  104668:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10466b:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (n--) {
  10466e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104671:	89 c1                	mov    %eax,%ecx
  104673:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  104679:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10467c:	3d 00 00 00 00       	cmp    $0x0,%eax
  104681:	0f 84 1a 00 00 00    	je     1046a1 <memset+0x51>
        *p++ = c;
  104687:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10468a:	88 c1                	mov    %al,%cl
  10468c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10468f:	89 c2                	mov    %eax,%edx
  104691:	81 c2 01 00 00 00    	add    $0x1,%edx
  104697:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10469a:	88 08                	mov    %cl,(%eax)
    }
  10469c:	e9 cd ff ff ff       	jmp    10466e <memset+0x1e>

    return buf;
  1046a1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046a4:	83 c4 10             	add    $0x10,%esp
  1046a7:	5d                   	pop    %ebp
  1046a8:	c3                   	ret    
  1046a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

001046b0 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
  1046b0:	55                   	push   %ebp
  1046b1:	89 e5                	mov    %esp,%ebp
  1046b3:	83 ec 14             	sub    $0x14,%esp
  1046b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1046b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1046bc:	8b 55 08             	mov    0x8(%ebp),%edx
  1046bf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1046c2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1046c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* d = dest;
  1046c8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const unsigned char* s = src;
  1046ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1046d1:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (n--) {
  1046d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1046d7:	89 c1                	mov    %eax,%ecx
  1046d9:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1046df:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1046e2:	3d 00 00 00 00       	cmp    $0x0,%eax
  1046e7:	0f 84 25 00 00 00    	je     104712 <memcpy+0x62>
        *(d++) = *(s++);
  1046ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1046f0:	89 c1                	mov    %eax,%ecx
  1046f2:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1046f8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1046fb:	8a 10                	mov    (%eax),%dl
  1046fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104700:	89 c1                	mov    %eax,%ecx
  104702:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104708:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10470b:	88 10                	mov    %dl,(%eax)
    }
  10470d:	e9 c2 ff ff ff       	jmp    1046d4 <memcpy+0x24>

    return dest;
  104712:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104715:	83 c4 14             	add    $0x14,%esp
  104718:	5d                   	pop    %ebp
  104719:	c3                   	ret    
  10471a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104720 <memcmp>:
}

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  104720:	55                   	push   %ebp
  104721:	89 e5                	mov    %esp,%ebp
  104723:	83 ec 1c             	sub    $0x1c,%esp
  104726:	8b 45 10             	mov    0x10(%ebp),%eax
  104729:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10472c:	8b 55 08             	mov    0x8(%ebp),%edx
  10472f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  104732:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104735:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
  104738:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10473f:	0f 85 0c 00 00 00    	jne    104751 <memcmp+0x31>
        return -1;
  104745:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  10474c:	e9 a7 00 00 00       	jmp    1047f8 <memcmp+0xd8>
    if (ptr2 == 0)
  104751:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104758:	0f 85 0c 00 00 00    	jne    10476a <memcmp+0x4a>
        return 1;
  10475e:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  104765:	e9 8e 00 00 00       	jmp    1047f8 <memcmp+0xd8>
    if (num == 0)
  10476a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104771:	0f 85 0c 00 00 00    	jne    104783 <memcmp+0x63>
        return 0;
  104777:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10477e:	e9 75 00 00 00       	jmp    1047f8 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
  104783:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104786:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
  104789:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10478c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
  10478f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104796:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104799:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10479c:	0f 83 4f 00 00 00    	jae    1047f1 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
  1047a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1047a5:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1047a8:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  1047ac:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1047af:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1047b2:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  1047b6:	39 c8                	cmp    %ecx,%eax
  1047b8:	0f 84 1e 00 00 00    	je     1047dc <memcmp+0xbc>
            return pa[i] - pb[i];
  1047be:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1047c1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1047c4:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  1047c8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1047cb:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1047ce:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  1047d2:	29 c8                	sub    %ecx,%eax
  1047d4:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1047d7:	e9 1c 00 00 00       	jmp    1047f8 <memcmp+0xd8>
        }
    }
  1047dc:	e9 00 00 00 00       	jmp    1047e1 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
  1047e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1047e4:	05 01 00 00 00       	add    $0x1,%eax
  1047e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1047ec:	e9 a5 ff ff ff       	jmp    104796 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
  1047f1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1047f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1047fb:	83 c4 1c             	add    $0x1c,%esp
  1047fe:	5d                   	pop    %ebp
  1047ff:	c3                   	ret    

00104800 <strcmp>:

int strcmp(const char* str1, const char* str2) {
  104800:	55                   	push   %ebp
  104801:	89 e5                	mov    %esp,%ebp
  104803:	56                   	push   %esi
  104804:	83 ec 24             	sub    $0x24,%esp
  104807:	8b 45 0c             	mov    0xc(%ebp),%eax
  10480a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10480d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104810:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
  104813:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104816:	89 e1                	mov    %esp,%ecx
  104818:	89 01                	mov    %eax,(%ecx)
  10481a:	e8 61 00 00 00       	call   104880 <strlen>
  10481f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
  104822:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104825:	89 e1                	mov    %esp,%ecx
  104827:	89 01                	mov    %eax,(%ecx)
  104829:	e8 52 00 00 00       	call   104880 <strlen>
  10482e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
  104831:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104834:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104837:	0f 8d 0b 00 00 00    	jge    104848 <strcmp+0x48>
  10483d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104840:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104843:	e9 06 00 00 00       	jmp    10484e <strcmp+0x4e>
  104848:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10484b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10484e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104851:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, l1 * sizeof(char));
  104854:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104857:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10485a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10485d:	c1 e2 00             	shl    $0x0,%edx
  104860:	89 e6                	mov    %esp,%esi
  104862:	89 56 08             	mov    %edx,0x8(%esi)
  104865:	89 4e 04             	mov    %ecx,0x4(%esi)
  104868:	89 06                	mov    %eax,(%esi)
  10486a:	e8 b1 fe ff ff       	call   104720 <memcmp>
  10486f:	83 c4 24             	add    $0x24,%esp
  104872:	5e                   	pop    %esi
  104873:	5d                   	pop    %ebp
  104874:	c3                   	ret    
  104875:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10487c:	00 00 00 00 

00104880 <strlen>:
}

unsigned int strlen(const char* str) {
  104880:	55                   	push   %ebp
  104881:	89 e5                	mov    %esp,%ebp
  104883:	83 ec 0c             	sub    $0xc,%esp
  104886:	8b 45 08             	mov    0x8(%ebp),%eax
  104889:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
  10488c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104893:	0f 85 0c 00 00 00    	jne    1048a5 <strlen+0x25>
        return 0;
  104899:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1048a0:	e9 37 00 00 00       	jmp    1048dc <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
  1048a5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1048ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1048af:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1048b2:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  1048b6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1048bb:	0f 84 15 00 00 00    	je     1048d6 <strlen+0x56>
  1048c1:	e9 00 00 00 00       	jmp    1048c6 <strlen+0x46>
  1048c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1048c9:	05 01 00 00 00       	add    $0x1,%eax
  1048ce:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1048d1:	e9 d6 ff ff ff       	jmp    1048ac <strlen+0x2c>
        ;
    return i;
  1048d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1048d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1048dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1048df:	83 c4 0c             	add    $0xc,%esp
  1048e2:	5d                   	pop    %ebp
  1048e3:	c3                   	ret    
  1048e4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1048eb:	00 00 00 00 00 

001048f0 <strcpy>:

char* strcpy(char* dest, const char* src) {
  1048f0:	55                   	push   %ebp
  1048f1:	89 e5                	mov    %esp,%ebp
  1048f3:	56                   	push   %esi
  1048f4:	83 ec 24             	sub    $0x24,%esp
  1048f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1048fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1048fd:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104900:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
  104903:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104906:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104909:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10490c:	89 e6                	mov    %esp,%esi
  10490e:	89 16                	mov    %edx,(%esi)
  104910:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104913:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104916:	e8 65 ff ff ff       	call   104880 <strlen>
  10491b:	c1 e0 00             	shl    $0x0,%eax
  10491e:	05 01 00 00 00       	add    $0x1,%eax
  104923:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104926:	89 0c 24             	mov    %ecx,(%esp)
  104929:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10492c:	89 54 24 04          	mov    %edx,0x4(%esp)
  104930:	89 44 24 08          	mov    %eax,0x8(%esp)
  104934:	e8 77 fd ff ff       	call   1046b0 <memcpy>
    return dest;
  104939:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10493c:	83 c4 24             	add    $0x24,%esp
  10493f:	5e                   	pop    %esi
  104940:	5d                   	pop    %ebp
  104941:	c3                   	ret    
  104942:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104949:	1f 84 00 00 00 00 00 

00104950 <strclone>:
}

char* strclone(char* str) {
  104950:	55                   	push   %ebp
  104951:	89 e5                	mov    %esp,%ebp
  104953:	83 ec 18             	sub    $0x18,%esp
  104956:	8b 45 08             	mov    0x8(%ebp),%eax
  104959:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
  10495c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10495f:	89 e1                	mov    %esp,%ecx
  104961:	89 01                	mov    %eax,(%ecx)
  104963:	e8 18 ff ff ff       	call   104880 <strlen>
  104968:	c1 e0 00             	shl    $0x0,%eax
  10496b:	05 01 00 00 00       	add    $0x1,%eax
  104970:	89 04 24             	mov    %eax,(%esp)
  104973:	e8 68 f6 ff ff       	call   103fe0 <malloc>
  104978:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
  10497b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10497e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104981:	89 e2                	mov    %esp,%edx
  104983:	89 4a 04             	mov    %ecx,0x4(%edx)
  104986:	89 02                	mov    %eax,(%edx)
  104988:	e8 63 ff ff ff       	call   1048f0 <strcpy>

    return ret;
  10498d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104990:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104993:	89 c8                	mov    %ecx,%eax
  104995:	83 c4 18             	add    $0x18,%esp
  104998:	5d                   	pop    %ebp
  104999:	c3                   	ret    
  10499a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001049a0 <strtok>:
}

char* sp = NULL; /* the start position of the string */

char* strtok(char* str, const char* delimiters) {
  1049a0:	55                   	push   %ebp
  1049a1:	89 e5                	mov    %esp,%ebp
  1049a3:	83 ec 18             	sub    $0x18,%esp
  1049a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1049a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1049ac:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1049af:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) {
  1049b2:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1049b9:	0f 84 22 00 00 00    	je     1049e1 <strtok+0x41>
        return strtoknc(strclone(str), delimiters);
  1049bf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1049c2:	89 04 24             	mov    %eax,(%esp)
  1049c5:	e8 86 ff ff ff       	call   104950 <strclone>
  1049ca:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1049cd:	89 04 24             	mov    %eax,(%esp)
  1049d0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1049d4:	e8 37 00 00 00       	call   104a10 <strtoknc>
  1049d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1049dc:	e9 1e 00 00 00       	jmp    1049ff <strtok+0x5f>
  1049e1:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
  1049e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1049e9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1049f0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1049f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1049f7:	e8 14 00 00 00       	call   104a10 <strtoknc>
  1049fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1049ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104a02:	83 c4 18             	add    $0x18,%esp
  104a05:	5d                   	pop    %ebp
  104a06:	c3                   	ret    
  104a07:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  104a0e:	00 00 

00104a10 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
  104a10:	55                   	push   %ebp
  104a11:	89 e5                	mov    %esp,%ebp
  104a13:	83 ec 28             	sub    $0x28,%esp
  104a16:	8b 45 0c             	mov    0xc(%ebp),%eax
  104a19:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104a1c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104a1f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
  104a22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
  104a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a2c:	89 e1                	mov    %esp,%ecx
  104a2e:	89 01                	mov    %eax,(%ecx)
  104a30:	e8 4b fe ff ff       	call   104880 <strlen>
  104a35:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
  104a38:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104a3f:	0f 85 0c 00 00 00    	jne    104a51 <strtoknc+0x41>
        return 0;
  104a45:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104a4c:	e9 80 01 00 00       	jmp    104bd1 <strtoknc+0x1c1>

    /* if the original string has nothing left */
    if (!str && !sp)
  104a51:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104a58:	0f 85 1c 00 00 00    	jne    104a7a <strtoknc+0x6a>
  104a5e:	81 3d 40 a4 10 00 00 	cmpl   $0x0,0x10a440
  104a65:	00 00 00 
  104a68:	0f 85 0c 00 00 00    	jne    104a7a <strtoknc+0x6a>
        return 0;
  104a6e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104a75:	e9 57 01 00 00       	jmp    104bd1 <strtoknc+0x1c1>

    /* initialize the sp during the first call */
    if (str && !sp)
  104a7a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104a81:	0f 84 18 00 00 00    	je     104a9f <strtoknc+0x8f>
  104a87:	81 3d 40 a4 10 00 00 	cmpl   $0x0,0x10a440
  104a8e:	00 00 00 
  104a91:	0f 85 08 00 00 00    	jne    104a9f <strtoknc+0x8f>
        sp = str;
  104a97:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a9a:	a3 40 a4 10 00       	mov    %eax,0x10a440

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
  104a9f:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104aa4:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
  104aa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104aae:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104ab1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104ab4:	0f 8d 3d 00 00 00    	jge    104af7 <strtoknc+0xe7>
            if (*p_start == delimiters[i]) {
  104aba:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104abd:	0f be 00             	movsbl (%eax),%eax
  104ac0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104ac3:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104ac6:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  104aca:	39 c8                	cmp    %ecx,%eax
  104acc:	0f 85 10 00 00 00    	jne    104ae2 <strtoknc+0xd2>
                p_start++;
  104ad2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104ad5:	05 01 00 00 00       	add    $0x1,%eax
  104ada:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
  104add:	e9 15 00 00 00       	jmp    104af7 <strtoknc+0xe7>
            }
        }
  104ae2:	e9 00 00 00 00       	jmp    104ae7 <strtoknc+0xd7>
        sp = str;

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
  104ae7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104aea:	05 01 00 00 00       	add    $0x1,%eax
  104aef:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104af2:	e9 b7 ff ff ff       	jmp    104aae <strtoknc+0x9e>
                p_start++;
                break;
            }
        }

        if (i == len) {
  104af7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104afa:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104afd:	0f 85 0d 00 00 00    	jne    104b10 <strtoknc+0x100>
            sp = p_start;
  104b03:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104b06:	a3 40 a4 10 00       	mov    %eax,0x10a440
            break;
  104b0b:	e9 05 00 00 00       	jmp    104b15 <strtoknc+0x105>
        }
    }
  104b10:	e9 92 ff ff ff       	jmp    104aa7 <strtoknc+0x97>

    /* return NULL if nothing left */
    if (*sp == '\0') {
  104b15:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104b1a:	0f be 00             	movsbl (%eax),%eax
  104b1d:	3d 00 00 00 00       	cmp    $0x0,%eax
  104b22:	0f 85 17 00 00 00    	jne    104b3f <strtoknc+0x12f>
        sp = NULL;
  104b28:	c7 05 40 a4 10 00 00 	movl   $0x0,0x10a440
  104b2f:	00 00 00 
        return sp;
  104b32:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104b37:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104b3a:	e9 92 00 00 00       	jmp    104bd1 <strtoknc+0x1c1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
  104b3f:	e9 00 00 00 00       	jmp    104b44 <strtoknc+0x134>
  104b44:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104b49:	0f be 00             	movsbl (%eax),%eax
  104b4c:	3d 00 00 00 00       	cmp    $0x0,%eax
  104b51:	0f 84 74 00 00 00    	je     104bcb <strtoknc+0x1bb>
        for (i = 0; i < len; i++) {
  104b57:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104b5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104b61:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104b64:	0f 8d 3c 00 00 00    	jge    104ba6 <strtoknc+0x196>
            if (*sp == delimiters[i]) {
  104b6a:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104b6f:	0f be 00             	movsbl (%eax),%eax
  104b72:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104b75:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104b78:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  104b7c:	39 c8                	cmp    %ecx,%eax
  104b7e:	0f 85 0d 00 00 00    	jne    104b91 <strtoknc+0x181>
                *sp = '\0';
  104b84:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104b89:	c6 00 00             	movb   $0x0,(%eax)
                break;
  104b8c:	e9 15 00 00 00       	jmp    104ba6 <strtoknc+0x196>
            }
        }
  104b91:	e9 00 00 00 00       	jmp    104b96 <strtoknc+0x186>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
  104b96:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104b99:	05 01 00 00 00       	add    $0x1,%eax
  104b9e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104ba1:	e9 b8 ff ff ff       	jmp    104b5e <strtoknc+0x14e>
                *sp = '\0';
                break;
            }
        }

        sp++;
  104ba6:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104bab:	05 01 00 00 00       	add    $0x1,%eax
  104bb0:	a3 40 a4 10 00       	mov    %eax,0x10a440
        if (i < len)
  104bb5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104bb8:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104bbb:	0f 8d 05 00 00 00    	jge    104bc6 <strtoknc+0x1b6>
            break;
  104bc1:	e9 05 00 00 00       	jmp    104bcb <strtoknc+0x1bb>
    }
  104bc6:	e9 79 ff ff ff       	jmp    104b44 <strtoknc+0x134>

    return p_start;
  104bcb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104bce:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104bd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104bd4:	83 c4 28             	add    $0x28,%esp
  104bd7:	5d                   	pop    %ebp
  104bd8:	c3                   	ret    
  104bd9:	66 90                	xchg   %ax,%ax
  104bdb:	66 90                	xchg   %ax,%ax
  104bdd:	66 90                	xchg   %ax,%ax
  104bdf:	90                   	nop

00104be0 <vfs_create_dir>:
    }

    return child;
}

uint32_t vfs_create_dir(char* path) {
  104be0:	55                   	push   %ebp
  104be1:	89 e5                	mov    %esp,%ebp
  104be3:	83 ec 08             	sub    $0x8,%esp
  104be6:	8b 45 08             	mov    0x8(%ebp),%eax
  104be9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return vfs_create_path(path);
  104bec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104bef:	89 04 24             	mov    %eax,(%esp)
  104bf2:	e8 09 00 00 00       	call   104c00 <vfs_create_path>
  104bf7:	83 c4 08             	add    $0x8,%esp
  104bfa:	5d                   	pop    %ebp
  104bfb:	c3                   	ret    
  104bfc:	0f 1f 40 00          	nopl   0x0(%eax)

00104c00 <vfs_create_path>:
    }

    return 1;
}

static int vfs_create_path(char* path) {
  104c00:	55                   	push   %ebp
  104c01:	89 e5                	mov    %esp,%ebp
  104c03:	83 ec 38             	sub    $0x38,%esp
  104c06:	8b 45 08             	mov    0x8(%ebp),%eax
  104c09:	8d 0d fb 85 10 00    	lea    0x1085fb,%ecx
  104c0f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  104c12:	a1 44 a4 10 00       	mov    0x10a444,%eax
  104c17:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  104c1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    int created = 0;
  104c21:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    sub = strtok(path, "/");
  104c28:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c2b:	89 04 24             	mov    %eax,(%esp)
  104c2e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104c32:	e8 69 fd ff ff       	call   1049a0 <strtok>
  104c37:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  104c3a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c3d:	0f be 00             	movsbl (%eax),%eax
  104c40:	3d 00 00 00 00       	cmp    $0x0,%eax
  104c45:	0f 85 21 00 00 00    	jne    104c6c <vfs_create_path+0x6c>
  104c4b:	b8 00 00 00 00       	mov    $0x0,%eax
  104c50:	8d 0d fb 85 10 00    	lea    0x1085fb,%ecx
  104c56:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104c5d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104c61:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104c64:	e8 37 fd ff ff       	call   1049a0 <strtok>
  104c69:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  104c6c:	e9 00 00 00 00       	jmp    104c71 <vfs_create_path+0x71>
  104c71:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104c78:	0f 84 e8 00 00 00    	je     104d66 <vfs_create_path+0x166>
    {
        child = vfs_find_node(parent, sub);
  104c7e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c81:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104c84:	89 04 24             	mov    %eax,(%esp)
  104c87:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104c8b:	e8 90 0a 00 00       	call   105720 <vfs_find_node>
  104c90:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(child == 0) {
  104c93:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104c9a:	0f 85 9a 00 00 00    	jne    104d3a <vfs_create_path+0x13a>
  104ca0:	b8 10 01 00 00       	mov    $0x110,%eax
            child = malloc(sizeof(struct res_node));
  104ca5:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  104cac:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104caf:	e8 2c f3 ff ff       	call   103fe0 <malloc>
  104cb4:	89 45 f0             	mov    %eax,-0x10(%ebp)

            strcpy(child->name, sub);
  104cb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104cba:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104cbd:	89 e2                	mov    %esp,%edx
  104cbf:	89 4a 04             	mov    %ecx,0x4(%edx)
  104cc2:	89 02                	mov    %eax,(%edx)
  104cc4:	e8 27 fc ff ff       	call   1048f0 <strcpy>
            child->res_type = RES_SUBDIR;
  104cc9:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104ccc:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  104cd3:	00 00 00 
            child->res_ptr = 0;
  104cd6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104cd9:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  104ce0:	00 00 00 

            created++;
  104ce3:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104ce6:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104cec:	89 4d ec             	mov    %ecx,-0x14(%ebp)

            if(vfs_insert_node(parent, child)) {
  104cef:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104cf2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104cf5:	89 0c 24             	mov    %ecx,(%esp)
  104cf8:	89 54 24 04          	mov    %edx,0x4(%esp)
  104cfc:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104cff:	e8 ac 0a 00 00       	call   1057b0 <vfs_insert_node>
  104d04:	3d 00 00 00 00       	cmp    $0x0,%eax
  104d09:	0f 84 26 00 00 00    	je     104d35 <vfs_create_path+0x135>
  104d0f:	b8 38 00 00 00       	mov    $0x38,%eax
                show_cod(malloc(sizeof(struct cpu_state)), "Tried to insert VFS node in non RES_SUBDIR parent");
  104d14:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  104d1b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  104d1e:	e8 bd f2 ff ff       	call   103fe0 <malloc>
  104d23:	8d 0d fd 85 10 00    	lea    0x1085fd,%ecx
  104d29:	89 04 24             	mov    %eax,(%esp)
  104d2c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104d30:	e8 3b b6 ff ff       	call   100370 <show_cod>
            }
        }
  104d35:	e9 00 00 00 00       	jmp    104d3a <vfs_create_path+0x13a>
  104d3a:	b8 00 00 00 00       	mov    $0x0,%eax
  104d3f:	8d 0d fb 85 10 00    	lea    0x1085fb,%ecx

        parent = child;
  104d45:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104d48:	89 55 f4             	mov    %edx,-0xc(%ebp)

        sub = strtok(0, "/");
  104d4b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104d52:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104d56:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104d59:	e8 42 fc ff ff       	call   1049a0 <strtok>
  104d5e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  104d61:	e9 0b ff ff ff       	jmp    104c71 <vfs_create_path+0x71>

    return created;
  104d66:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104d69:	83 c4 38             	add    $0x38,%esp
  104d6c:	5d                   	pop    %ebp
  104d6d:	c3                   	ret    
  104d6e:	66 90                	xchg   %ax,%ax

00104d70 <vfs_create_kfile>:

uint32_t vfs_create_dir(char* path) {
    return vfs_create_path(path);
}

uint32_t vfs_create_kfile(char* path, struct kfs_driver* driver, uint32_t* params) {
  104d70:	55                   	push   %ebp
  104d71:	89 e5                	mov    %esp,%ebp
  104d73:	83 ec 28             	sub    $0x28,%esp
  104d76:	8b 45 10             	mov    0x10(%ebp),%eax
  104d79:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104d7c:	8b 55 08             	mov    0x8(%ebp),%edx
  104d7f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104d82:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104d85:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* pathc = malloc(strlen(path) + 1);
  104d88:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104d8b:	89 e1                	mov    %esp,%ecx
  104d8d:	89 01                	mov    %eax,(%ecx)
  104d8f:	e8 ec fa ff ff       	call   104880 <strlen>
  104d94:	05 01 00 00 00       	add    $0x1,%eax
  104d99:	89 04 24             	mov    %eax,(%esp)
  104d9c:	e8 3f f2 ff ff       	call   103fe0 <malloc>
  104da1:	89 45 f0             	mov    %eax,-0x10(%ebp)
    strcpy(pathc, path);
  104da4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104da7:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104daa:	89 e2                	mov    %esp,%edx
  104dac:	89 4a 04             	mov    %ecx,0x4(%edx)
  104daf:	89 02                	mov    %eax,(%edx)
  104db1:	e8 3a fb ff ff       	call   1048f0 <strcpy>

    uint32_t ret = vfs_create_path(pathc);
  104db6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104db9:	89 0c 24             	mov    %ecx,(%esp)
  104dbc:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104dbf:	e8 3c fe ff ff       	call   104c00 <vfs_create_path>
  104dc4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    static struct res_node* node;
    node = vfs_get_node(path);
  104dc7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104dca:	89 04 24             	mov    %eax,(%esp)
  104dcd:	e8 4e 00 00 00       	call   104e20 <vfs_get_node>
  104dd2:	a3 50 a4 10 00       	mov    %eax,0x10a450

    node->res_type = RES_KERNDRV;
  104dd7:	a1 50 a4 10 00       	mov    0x10a450,%eax
  104ddc:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  104de3:	00 00 00 
    node->res_ptr = driver->create(params);
  104de6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104de9:	8b 40 14             	mov    0x14(%eax),%eax
  104dec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104def:	89 0c 24             	mov    %ecx,(%esp)
  104df2:	ff d0                	call   *%eax
  104df4:	8b 0d 50 a4 10 00    	mov    0x10a450,%ecx
  104dfa:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)
    ((struct res_kfile*) node->res_ptr)->driver = driver;
  104e00:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104e03:	8b 0d 50 a4 10 00    	mov    0x10a450,%ecx
  104e09:	8b 89 04 01 00 00    	mov    0x104(%ecx),%ecx
  104e0f:	89 41 04             	mov    %eax,0x4(%ecx)

    return ret;
  104e12:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104e15:	83 c4 28             	add    $0x28,%esp
  104e18:	5d                   	pop    %ebp
  104e19:	c3                   	ret    
  104e1a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104e20 <vfs_get_node>:
    }

    return created;
}

static struct res_node* vfs_get_node(char* path) {
  104e20:	55                   	push   %ebp
  104e21:	89 e5                	mov    %esp,%ebp
  104e23:	83 ec 28             	sub    $0x28,%esp
  104e26:	8b 45 08             	mov    0x8(%ebp),%eax
  104e29:	8d 0d fb 85 10 00    	lea    0x1085fb,%ecx
  104e2f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  104e32:	a1 44 a4 10 00       	mov    0x10a444,%eax
  104e37:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  104e3a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    sub = strtok(path, "/");
  104e41:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104e44:	89 04 24             	mov    %eax,(%esp)
  104e47:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104e4b:	e8 50 fb ff ff       	call   1049a0 <strtok>
  104e50:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  104e53:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104e56:	0f be 00             	movsbl (%eax),%eax
  104e59:	3d 00 00 00 00       	cmp    $0x0,%eax
  104e5e:	0f 85 21 00 00 00    	jne    104e85 <vfs_get_node+0x65>
  104e64:	b8 00 00 00 00       	mov    $0x0,%eax
  104e69:	8d 0d fb 85 10 00    	lea    0x1085fb,%ecx
  104e6f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104e76:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104e7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104e7d:	e8 1e fb ff ff       	call   1049a0 <strtok>
  104e82:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  104e85:	e9 00 00 00 00       	jmp    104e8a <vfs_get_node+0x6a>
  104e8a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104e91:	0f 84 41 00 00 00    	je     104ed8 <vfs_get_node+0xb8>
    {
        child = vfs_find_node(parent, sub);
  104e97:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e9a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104e9d:	89 04 24             	mov    %eax,(%esp)
  104ea0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104ea4:	e8 77 08 00 00       	call   105720 <vfs_find_node>
  104ea9:	b9 00 00 00 00       	mov    $0x0,%ecx
  104eae:	8d 15 fb 85 10 00    	lea    0x1085fb,%edx
  104eb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        parent = child;
  104eb7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104eba:	89 45 f4             	mov    %eax,-0xc(%ebp)
        sub = strtok(0, "/");
  104ebd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104ec4:	89 54 24 04          	mov    %edx,0x4(%esp)
  104ec8:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  104ecb:	e8 d0 fa ff ff       	call   1049a0 <strtok>
  104ed0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  104ed3:	e9 b2 ff ff ff       	jmp    104e8a <vfs_get_node+0x6a>

    return child;
  104ed8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104edb:	83 c4 28             	add    $0x28,%esp
  104ede:	5d                   	pop    %ebp
  104edf:	c3                   	ret    

00104ee0 <vfs_open>:
    ((struct res_kfile*) node->res_ptr)->driver = driver;

    return ret;
}

struct res_handle* vfs_open(char* path, uint32_t filemode) {
  104ee0:	55                   	push   %ebp
  104ee1:	89 e5                	mov    %esp,%ebp
  104ee3:	83 ec 28             	sub    $0x28,%esp
  104ee6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104ee9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104eec:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104eef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    static struct res_node* node;

    node = vfs_get_node(path);
  104ef2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104ef5:	89 04 24             	mov    %eax,(%esp)
  104ef8:	e8 23 ff ff ff       	call   104e20 <vfs_get_node>
  104efd:	a3 54 a4 10 00       	mov    %eax,0x10a454

    if(node->res_type == RES_KERNDRV) {
  104f02:	a1 54 a4 10 00       	mov    0x10a454,%eax
  104f07:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  104f0e:	00 00 00 
  104f11:	0f 85 34 00 00 00    	jne    104f4b <vfs_open+0x6b>
        struct res_kfile* kf = (struct res_kfile*)node->res_ptr;
  104f17:	a1 54 a4 10 00       	mov    0x10a454,%eax
  104f1c:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104f22:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct res_handle* handle = kf->driver->open(kf, filemode);
  104f25:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f28:	8b 40 04             	mov    0x4(%eax),%eax
  104f2b:	8b 40 08             	mov    0x8(%eax),%eax
  104f2e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104f31:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104f34:	89 0c 24             	mov    %ecx,(%esp)
  104f37:	89 54 24 04          	mov    %edx,0x4(%esp)
  104f3b:	ff d0                	call   *%eax
  104f3d:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return handle;
  104f40:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104f43:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104f46:	e9 07 00 00 00       	jmp    104f52 <vfs_open+0x72>
    }

    return 0;
  104f4b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104f52:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104f55:	83 c4 28             	add    $0x28,%esp
  104f58:	5d                   	pop    %ebp
  104f59:	c3                   	ret    
  104f5a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104f60 <vfs_close>:

uint32_t vfs_close(struct res_handle* handle) {
  104f60:	55                   	push   %ebp
  104f61:	89 e5                	mov    %esp,%ebp
  104f63:	83 ec 18             	sub    $0x18,%esp
  104f66:	8b 45 08             	mov    0x8(%ebp),%eax
  104f69:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle->res_type == RES_KERNDRV) {
  104f6c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f6f:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  104f75:	0f 85 22 00 00 00    	jne    104f9d <vfs_close+0x3d>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  104f7b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f7e:	8b 40 04             	mov    0x4(%eax),%eax
  104f81:	89 45 f4             	mov    %eax,-0xc(%ebp)

       return kf->driver->close(handle);
  104f84:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104f87:	8b 40 04             	mov    0x4(%eax),%eax
  104f8a:	8b 40 0c             	mov    0xc(%eax),%eax
  104f8d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104f90:	89 0c 24             	mov    %ecx,(%esp)
  104f93:	ff d0                	call   *%eax
  104f95:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104f98:	e9 07 00 00 00       	jmp    104fa4 <vfs_close+0x44>
    }

    return 0;
  104f9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104fa4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104fa7:	83 c4 18             	add    $0x18,%esp
  104faa:	5d                   	pop    %ebp
  104fab:	c3                   	ret    
  104fac:	0f 1f 40 00          	nopl   0x0(%eax)

00104fb0 <vfs_read>:

uint32_t vfs_read(struct res_handle* handle, void* dest, uint32_t size, uint32_t count) {
  104fb0:	55                   	push   %ebp
  104fb1:	89 e5                	mov    %esp,%ebp
  104fb3:	56                   	push   %esi
  104fb4:	83 ec 34             	sub    $0x34,%esp
  104fb7:	8b 45 14             	mov    0x14(%ebp),%eax
  104fba:	8b 4d 10             	mov    0x10(%ebp),%ecx
  104fbd:	8b 55 0c             	mov    0xc(%ebp),%edx
  104fc0:	8b 75 08             	mov    0x8(%ebp),%esi
  104fc3:	89 75 f4             	mov    %esi,-0xc(%ebp)
  104fc6:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104fc9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104fcc:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  104fcf:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104fd6:	0f 85 0c 00 00 00    	jne    104fe8 <vfs_read+0x38>
  104fdc:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  104fe3:	e9 94 00 00 00       	jmp    10507c <vfs_read+0xcc>

    if(handle->res_type == RES_KERNDRV) {
  104fe8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104feb:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  104ff1:	0f 85 7e 00 00 00    	jne    105075 <vfs_read+0xc5>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  104ff7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104ffa:	8b 40 04             	mov    0x4(%eax),%eax
  104ffd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rread(handle, dest, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  105000:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105003:	8b 40 04             	mov    0x4(%eax),%eax
  105006:	8b 00                	mov    (%eax),%eax
  105008:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10500b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10500e:	8b 75 ec             	mov    -0x14(%ebp),%esi
  105011:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  105015:	89 0c 24             	mov    %ecx,(%esp)
  105018:	89 54 24 04          	mov    %edx,0x4(%esp)
  10501c:	89 74 24 08          	mov    %esi,0x8(%esp)
  105020:	ff d0                	call   *%eax
  105022:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  105025:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10502c:	0f 85 1e 00 00 00    	jne    105050 <vfs_read+0xa0>
           handle->position += size * count;
  105032:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105035:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  105039:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10503c:	8b 51 08             	mov    0x8(%ecx),%edx
  10503f:	01 c2                	add    %eax,%edx
  105041:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  105044:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10504b:	e9 2c 00 00 00       	jmp    10507c <vfs_read+0xcc>
       }

       if(res == RW_BLOCK) {
  105050:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  105057:	0f 85 0c 00 00 00    	jne    105069 <vfs_read+0xb9>
           return RW_BLOCK;
  10505d:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  105064:	e9 13 00 00 00       	jmp    10507c <vfs_read+0xcc>
       }

       return RW_ERR_DRIVER;
  105069:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  105070:	e9 07 00 00 00       	jmp    10507c <vfs_read+0xcc>
    }

    return RW_ERR_VFS;
  105075:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  10507c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10507f:	83 c4 34             	add    $0x34,%esp
  105082:	5e                   	pop    %esi
  105083:	5d                   	pop    %ebp
  105084:	c3                   	ret    
  105085:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10508c:	00 00 00 00 

00105090 <vfs_write>:

uint32_t vfs_write(struct res_handle* handle, void* src,  uint32_t size, uint32_t count) {
  105090:	55                   	push   %ebp
  105091:	89 e5                	mov    %esp,%ebp
  105093:	56                   	push   %esi
  105094:	83 ec 34             	sub    $0x34,%esp
  105097:	8b 45 14             	mov    0x14(%ebp),%eax
  10509a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10509d:	8b 55 0c             	mov    0xc(%ebp),%edx
  1050a0:	8b 75 08             	mov    0x8(%ebp),%esi
  1050a3:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1050a6:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1050a9:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1050ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  1050af:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1050b6:	0f 85 0c 00 00 00    	jne    1050c8 <vfs_write+0x38>
  1050bc:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  1050c3:	e9 95 00 00 00       	jmp    10515d <vfs_write+0xcd>

    if(handle->res_type == RES_KERNDRV) {
  1050c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1050cb:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  1050d1:	0f 85 7f 00 00 00    	jne    105156 <vfs_write+0xc6>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  1050d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1050da:	8b 40 04             	mov    0x4(%eax),%eax
  1050dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rwrite(handle, src, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  1050e0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1050e3:	8b 40 04             	mov    0x4(%eax),%eax
  1050e6:	8b 40 04             	mov    0x4(%eax),%eax
  1050e9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1050ec:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1050ef:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1050f2:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  1050f6:	89 0c 24             	mov    %ecx,(%esp)
  1050f9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1050fd:	89 74 24 08          	mov    %esi,0x8(%esp)
  105101:	ff d0                	call   *%eax
  105103:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  105106:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10510d:	0f 85 1e 00 00 00    	jne    105131 <vfs_write+0xa1>
           handle->position += size * count;
  105113:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105116:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  10511a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10511d:	8b 51 08             	mov    0x8(%ecx),%edx
  105120:	01 c2                	add    %eax,%edx
  105122:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  105125:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10512c:	e9 2c 00 00 00       	jmp    10515d <vfs_write+0xcd>
       }

       if(res == RW_BLOCK) {
  105131:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  105138:	0f 85 0c 00 00 00    	jne    10514a <vfs_write+0xba>
           return RW_BLOCK;
  10513e:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  105145:	e9 13 00 00 00       	jmp    10515d <vfs_write+0xcd>
       }

       return RW_ERR_DRIVER;
  10514a:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  105151:	e9 07 00 00 00       	jmp    10515d <vfs_write+0xcd>
    }

    return RW_ERR_VFS;
  105156:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  10515d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105160:	83 c4 34             	add    $0x34,%esp
  105163:	5e                   	pop    %esi
  105164:	5d                   	pop    %ebp
  105165:	c3                   	ret    
  105166:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10516d:	00 00 00 

00105170 <vfs_available>:

uint32_t vfs_available(struct res_handle* handle) {
  105170:	55                   	push   %ebp
  105171:	89 e5                	mov    %esp,%ebp
  105173:	83 ec 18             	sub    $0x18,%esp
  105176:	8b 45 08             	mov    0x8(%ebp),%eax
  105179:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle == 0) return 0;
  10517c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105183:	0f 85 0c 00 00 00    	jne    105195 <vfs_available+0x25>
  105189:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105190:	e9 38 00 00 00       	jmp    1051cd <vfs_available+0x5d>

    if(handle->res_type == RES_KERNDRV) {
  105195:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105198:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  10519e:	0f 85 22 00 00 00    	jne    1051c6 <vfs_available+0x56>
        struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  1051a4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1051a7:	8b 40 04             	mov    0x4(%eax),%eax
  1051aa:	89 45 f4             	mov    %eax,-0xc(%ebp)

        return kf->driver->available(handle);
  1051ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1051b0:	8b 40 04             	mov    0x4(%eax),%eax
  1051b3:	8b 40 10             	mov    0x10(%eax),%eax
  1051b6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1051b9:	89 0c 24             	mov    %ecx,(%esp)
  1051bc:	ff d0                	call   *%eax
  1051be:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1051c1:	e9 07 00 00 00       	jmp    1051cd <vfs_available+0x5d>
    }

    return 0;
  1051c6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1051cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1051d0:	83 c4 18             	add    $0x18,%esp
  1051d3:	5d                   	pop    %ebp
  1051d4:	c3                   	ret    
  1051d5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1051dc:	00 00 00 00 

001051e0 <vfs_exists>:

uint32_t vfs_exists(char* path) {
  1051e0:	55                   	push   %ebp
  1051e1:	89 e5                	mov    %esp,%ebp
  1051e3:	83 ec 18             	sub    $0x18,%esp
  1051e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1051e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(vfs_get_node(path) != 0) return 1;
  1051ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1051ef:	89 04 24             	mov    %eax,(%esp)
  1051f2:	e8 29 fc ff ff       	call   104e20 <vfs_get_node>
  1051f7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1051fc:	0f 84 0c 00 00 00    	je     10520e <vfs_exists+0x2e>
  105202:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  105209:	e9 07 00 00 00       	jmp    105215 <vfs_exists+0x35>
    return 0;
  10520e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105215:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105218:	83 c4 18             	add    $0x18,%esp
  10521b:	5d                   	pop    %ebp
  10521c:	c3                   	ret    
  10521d:	0f 1f 00             	nopl   (%eax)

00105220 <vfs_seek>:

void vfs_seek(struct res_handle* handle, uint32_t offset, uint32_t origin) {
  105220:	55                   	push   %ebp
  105221:	89 e5                	mov    %esp,%ebp
  105223:	83 ec 0c             	sub    $0xc,%esp
  105226:	8b 45 10             	mov    0x10(%ebp),%eax
  105229:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10522c:	8b 55 08             	mov    0x8(%ebp),%edx
  10522f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  105232:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105235:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(origin == SEEK_SET) {
  105238:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  10523f:	0f 85 09 00 00 00    	jne    10524e <vfs_seek+0x2e>
        handle->position = offset;
  105245:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105248:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10524b:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if(origin == SEEK_CUR) {
  10524e:	81 7d f4 01 00 00 00 	cmpl   $0x1,-0xc(%ebp)
  105255:	0f 85 0e 00 00 00    	jne    105269 <vfs_seek+0x49>
        handle->position += offset;
  10525b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10525e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105261:	8b 51 08             	mov    0x8(%ecx),%edx
  105264:	01 c2                	add    %eax,%edx
  105266:	89 51 08             	mov    %edx,0x8(%ecx)
    }
}
  105269:	83 c4 0c             	add    $0xc,%esp
  10526c:	5d                   	pop    %ebp
  10526d:	c3                   	ret    
  10526e:	66 90                	xchg   %ax,%ax

00105270 <vfs_exec>:

void vfs_exec(char* ip, char* args[], struct task* task) {
  105270:	55                   	push   %ebp
  105271:	89 e5                	mov    %esp,%ebp
  105273:	56                   	push   %esi
  105274:	81 ec 94 00 00 00    	sub    $0x94,%esp
  10527a:	8b 45 10             	mov    0x10(%ebp),%eax
  10527d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105280:	8b 55 08             	mov    0x8(%ebp),%edx
  105283:	89 55 f8             	mov    %edx,-0x8(%ebp)
  105286:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  105289:	89 45 f0             	mov    %eax,-0x10(%ebp)
    char* path = strclone(ip);
  10528c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10528f:	89 04 24             	mov    %eax,(%esp)
  105292:	e8 b9 f6 ff ff       	call   104950 <strclone>
  105297:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(vfs_exists(path)) {
  10529a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10529d:	89 04 24             	mov    %eax,(%esp)
  1052a0:	e8 3b ff ff ff       	call   1051e0 <vfs_exists>
  1052a5:	3d 00 00 00 00       	cmp    $0x0,%eax
  1052aa:	0f 84 eb 02 00 00    	je     10559b <vfs_exec+0x32b>
        uint32_t elf_mod_pdir;

        if(task == 0) {
  1052b0:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1052b7:	0f 85 35 00 00 00    	jne    1052f2 <vfs_exec+0x82>
            elf_mod_pdir = vmm_create_pagedir();
  1052bd:	e8 de 0a 00 00       	call   105da0 <vmm_create_pagedir>
  1052c2:	b9 01 00 00 00       	mov    $0x1,%ecx
  1052c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
            task = init_task(elf_mod_pdir, (void*)1);
  1052ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1052cd:	89 04 24             	mov    %eax,(%esp)
  1052d0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1052d4:	e8 37 ea ff ff       	call   103d10 <init_task>
  1052d9:	8d 0d 22 85 10 00    	lea    0x108522,%ecx
  1052df:	89 45 f0             	mov    %eax,-0x10(%ebp)
            kprintf("[exec] Initialized new task...\n");
  1052e2:	89 0c 24             	mov    %ecx,(%esp)
  1052e5:	e8 66 b2 ff ff       	call   100550 <kprintf>
        }
  1052ea:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  1052ed:	e9 1a 00 00 00       	jmp    10530c <vfs_exec+0x9c>
  1052f2:	8d 05 42 85 10 00    	lea    0x108542,%eax
        else
        {
            elf_mod_pdir = task->phys_pdir;
  1052f8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1052fb:	8b 49 14             	mov    0x14(%ecx),%ecx
  1052fe:	89 4d e8             	mov    %ecx,-0x18(%ebp)
            kprintf("[exec] Replacing old task...\n");
  105301:	89 04 24             	mov    %eax,(%esp)
  105304:	e8 47 b2 ff ff       	call   100550 <kprintf>
  105309:	89 45 b0             	mov    %eax,-0x50(%ebp)
  10530c:	b8 05 00 00 00       	mov    $0x5,%eax
        }

        struct res_handle* handle = vfs_open(path, FM_EXEC | FM_READ);
  105311:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105314:	89 0c 24             	mov    %ecx,(%esp)
  105317:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  10531e:	00 
  10531f:	89 45 ac             	mov    %eax,-0x54(%ebp)
  105322:	e8 b9 fb ff ff       	call   104ee0 <vfs_open>
  105327:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(handle) {
  10532a:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  105331:	0f 84 47 02 00 00    	je     10557e <vfs_exec+0x30e>
            uint32_t size = vfs_available(handle);
  105337:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10533a:	89 04 24             	mov    %eax,(%esp)
  10533d:	e8 2e fe ff ff       	call   105170 <vfs_available>
  105342:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(size == 0) {
  105345:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10534c:	0f 85 1d 00 00 00    	jne    10536f <vfs_exec+0xff>
  105352:	8d 05 60 85 10 00    	lea    0x108560,%eax
                kprintf("[exec] %s is empty\n", path);
  105358:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10535b:	89 04 24             	mov    %eax,(%esp)
  10535e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105362:	e8 e9 b1 ff ff       	call   100550 <kprintf>
                return;
  105367:	89 45 a8             	mov    %eax,-0x58(%ebp)
  10536a:	e9 2c 02 00 00       	jmp    10559b <vfs_exec+0x32b>
            }

            void* modsrc = malloc(size);
  10536f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105372:	89 04 24             	mov    %eax,(%esp)
  105375:	e8 66 ec ff ff       	call   103fe0 <malloc>
  10537a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10537f:	89 45 dc             	mov    %eax,-0x24(%ebp)

            uint32_t res = vfs_read(handle, modsrc, size, 1);
  105382:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105385:	8b 55 dc             	mov    -0x24(%ebp),%edx
  105388:	8b 75 e0             	mov    -0x20(%ebp),%esi
  10538b:	89 04 24             	mov    %eax,(%esp)
  10538e:	89 54 24 04          	mov    %edx,0x4(%esp)
  105392:	89 74 24 08          	mov    %esi,0x8(%esp)
  105396:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10539d:	00 
  10539e:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  1053a1:	e8 0a fc ff ff       	call   104fb0 <vfs_read>
  1053a6:	89 45 d8             	mov    %eax,-0x28(%ebp)

            if(res != RW_OK) {
  1053a9:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  1053b0:	0f 84 21 00 00 00    	je     1053d7 <vfs_exec+0x167>
  1053b6:	8d 05 74 85 10 00    	lea    0x108574,%eax
                kprintf("[exec] Error while reading %s\n");
  1053bc:	89 04 24             	mov    %eax,(%esp)
  1053bf:	e8 8c b1 ff ff       	call   100550 <kprintf>
                free(modsrc);
  1053c4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1053c7:	89 0c 24             	mov    %ecx,(%esp)
  1053ca:	89 45 a0             	mov    %eax,-0x60(%ebp)
  1053cd:	e8 de ef ff ff       	call   1043b0 <free>
                return;
  1053d2:	e9 c4 01 00 00       	jmp    10559b <vfs_exec+0x32b>
            }

            uint32_t old_pdir = vmm_get_current_pagedir();
  1053d7:	e8 64 04 00 00       	call   105840 <vmm_get_current_pagedir>
  1053dc:	89 45 d4             	mov    %eax,-0x2c(%ebp)

            //**********************************************************************************************************
            if(task != get_current_task())  vmm_activate_pagedir(elf_mod_pdir);
  1053df:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1053e2:	89 45 9c             	mov    %eax,-0x64(%ebp)
  1053e5:	e8 46 e5 ff ff       	call   103930 <get_current_task>
  1053ea:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
  1053ed:	39 c1                	cmp    %eax,%ecx
  1053ef:	0f 84 0b 00 00 00    	je     105400 <vfs_exec+0x190>
  1053f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1053f8:	89 04 24             	mov    %eax,(%esp)
  1053fb:	e8 80 0f 00 00       	call   106380 <vmm_activate_pagedir>

            struct elf_header* header = modsrc;
  105400:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105403:	89 45 d0             	mov    %eax,-0x30(%ebp)
            struct elf_program_header* ph;

            /* Ist es ueberhaupt eine ELF-Datei? */
            if (header->magic != ELF_MAGIC) {
  105406:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105409:	81 38 7f 45 4c 46    	cmpl   $0x464c457f,(%eax)
  10540f:	0f 84 28 00 00 00    	je     10543d <vfs_exec+0x1cd>
  105415:	8d 05 93 85 10 00    	lea    0x108593,%eax
                kprintf("[exec] Invalid ELF-Magic in %s!\n", path);
  10541b:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10541e:	89 04 24             	mov    %eax,(%esp)
  105421:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105425:	e8 26 b1 ff ff       	call   100550 <kprintf>
                free(modsrc);
  10542a:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  10542d:	89 0c 24             	mov    %ecx,(%esp)
  105430:	89 45 98             	mov    %eax,-0x68(%ebp)
  105433:	e8 78 ef ff ff       	call   1043b0 <free>
                return;
  105438:	e9 5e 01 00 00       	jmp    10559b <vfs_exec+0x32b>
            }

            void* elf_mod_entry = (void*) (header->entry);
  10543d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105440:	8b 40 18             	mov    0x18(%eax),%eax
  105443:	89 45 c8             	mov    %eax,-0x38(%ebp)

            ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);
  105446:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105449:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  10544c:	03 41 1c             	add    0x1c(%ecx),%eax
  10544f:	89 45 cc             	mov    %eax,-0x34(%ebp)

            for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  105452:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  105459:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  10545c:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  10545f:	0f b7 49 2c          	movzwl 0x2c(%ecx),%ecx
  105463:	39 c8                	cmp    %ecx,%eax
  105465:	0f 83 b5 00 00 00    	jae    105520 <vfs_exec+0x2b0>
                void* dest = (void*) ph->virt_addr;
  10546b:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10546e:	8b 40 08             	mov    0x8(%eax),%eax
  105471:	89 45 c0             	mov    %eax,-0x40(%ebp)
                void* src = ((char*) header) + ph->offset;
  105474:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105477:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  10547a:	03 41 04             	add    0x4(%ecx),%eax
  10547d:	89 45 bc             	mov    %eax,-0x44(%ebp)

                /* Nur Program Header vom Typ LOAD laden */
                if (ph->type != 1) {
  105480:	8b 45 cc             	mov    -0x34(%ebp),%eax
  105483:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105489:	0f 84 05 00 00 00    	je     105494 <vfs_exec+0x224>
                    continue;
  10548f:	e9 71 00 00 00       	jmp    105505 <vfs_exec+0x295>
                }

                for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  105494:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  10549b:	8b 45 b8             	mov    -0x48(%ebp),%eax
  10549e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  1054a1:	3b 41 14             	cmp    0x14(%ecx),%eax
  1054a4:	0f 83 3f 00 00 00    	jae    1054e9 <vfs_exec+0x279>
                    vmm_free(dest + offset);
  1054aa:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1054ad:	03 45 b8             	add    -0x48(%ebp),%eax
  1054b0:	89 04 24             	mov    %eax,(%esp)
  1054b3:	e8 58 0a 00 00       	call   105f10 <vmm_free>
  1054b8:	b8 00 00 00 00       	mov    $0x0,%eax
                    vmm_alloc_addr(dest + offset, 0);
  1054bd:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  1054c0:	03 4d b8             	add    -0x48(%ebp),%ecx
  1054c3:	89 0c 24             	mov    %ecx,(%esp)
  1054c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1054cd:	00 
  1054ce:	89 45 94             	mov    %eax,-0x6c(%ebp)
  1054d1:	e8 aa 0d 00 00       	call   106280 <vmm_alloc_addr>
  1054d6:	89 45 90             	mov    %eax,-0x70(%ebp)
                /* Nur Program Header vom Typ LOAD laden */
                if (ph->type != 1) {
                    continue;
                }

                for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  1054d9:	8b 45 b8             	mov    -0x48(%ebp),%eax
  1054dc:	05 00 10 00 00       	add    $0x1000,%eax
  1054e1:	89 45 b8             	mov    %eax,-0x48(%ebp)
  1054e4:	e9 b2 ff ff ff       	jmp    10549b <vfs_exec+0x22b>
                    vmm_free(dest + offset);
                    vmm_alloc_addr(dest + offset, 0);
                }

                memcpy(dest, src, ph->file_size);
  1054e9:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1054ec:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  1054ef:	8b 55 cc             	mov    -0x34(%ebp),%edx
  1054f2:	8b 52 10             	mov    0x10(%edx),%edx
  1054f5:	89 04 24             	mov    %eax,(%esp)
  1054f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1054fc:	89 54 24 08          	mov    %edx,0x8(%esp)
  105500:	e8 ab f1 ff ff       	call   1046b0 <memcpy>

            void* elf_mod_entry = (void*) (header->entry);

            ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);

            for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  105505:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  105508:	05 01 00 00 00       	add    $0x1,%eax
  10550d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  105510:	8b 45 cc             	mov    -0x34(%ebp),%eax
  105513:	05 20 00 00 00       	add    $0x20,%eax
  105518:	89 45 cc             	mov    %eax,-0x34(%ebp)
  10551b:	e9 39 ff ff ff       	jmp    105459 <vfs_exec+0x1e9>
                }

                memcpy(dest, src, ph->file_size);
            }

            task->args = args;
  105520:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105523:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105526:	89 41 18             	mov    %eax,0x18(%ecx)
            task->cpuState->eip = (uint32_t) elf_mod_entry;
  105529:	8b 45 c8             	mov    -0x38(%ebp),%eax
  10552c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10552f:	8b 49 04             	mov    0x4(%ecx),%ecx
  105532:	89 41 24             	mov    %eax,0x24(%ecx)

            if(task != get_current_task()) vmm_activate_pagedir(old_pdir);
  105535:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105538:	89 45 8c             	mov    %eax,-0x74(%ebp)
  10553b:	e8 f0 e3 ff ff       	call   103930 <get_current_task>
  105540:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  105543:	39 c1                	cmp    %eax,%ecx
  105545:	0f 84 0b 00 00 00    	je     105556 <vfs_exec+0x2e6>
  10554b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10554e:	89 04 24             	mov    %eax,(%esp)
  105551:	e8 2a 0e 00 00       	call   106380 <vmm_activate_pagedir>
  105556:	8d 05 b4 85 10 00    	lea    0x1085b4,%eax

            kprintf("[exec] Executed %s\n", path);
  10555c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10555f:	89 04 24             	mov    %eax,(%esp)
  105562:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105566:	e8 e5 af ff ff       	call   100550 <kprintf>
            free(modsrc);
  10556b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  10556e:	89 0c 24             	mov    %ecx,(%esp)
  105571:	89 45 88             	mov    %eax,-0x78(%ebp)
  105574:	e8 37 ee ff ff       	call   1043b0 <free>
        }
  105579:	e9 18 00 00 00       	jmp    105596 <vfs_exec+0x326>
  10557e:	8d 05 c8 85 10 00    	lea    0x1085c8,%eax
        else
        {
            kprintf("[exec] %s doesn't exist\n", path);
  105584:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105587:	89 04 24             	mov    %eax,(%esp)
  10558a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10558e:	e8 bd af ff ff       	call   100550 <kprintf>
  105593:	89 45 84             	mov    %eax,-0x7c(%ebp)
        }
    }
  105596:	e9 00 00 00 00       	jmp    10559b <vfs_exec+0x32b>
}
  10559b:	81 c4 94 00 00 00    	add    $0x94,%esp
  1055a1:	5e                   	pop    %esi
  1055a2:	5d                   	pop    %ebp
  1055a3:	c3                   	ret    
  1055a4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1055ab:	00 00 00 00 00 

001055b0 <vfs_init_root>:

void vfs_init_root() {
  1055b0:	55                   	push   %ebp
  1055b1:	89 e5                	mov    %esp,%ebp
    if(root == 0) {
  1055b3:	83 ec 18             	sub    $0x18,%esp
  1055b6:	81 3d 44 a4 10 00 00 	cmpl   $0x0,0x10a444
  1055bd:	00 00 00 
  1055c0:	0f 85 6f 00 00 00    	jne    105635 <vfs_init_root+0x85>
  1055c6:	b8 10 01 00 00       	mov    $0x110,%eax
        root = malloc(sizeof(struct res_node));
  1055cb:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  1055d2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1055d5:	e8 06 ea ff ff       	call   103fe0 <malloc>
  1055da:	a3 44 a4 10 00       	mov    %eax,0x10a444
        root->next = 0;
  1055df:	a1 44 a4 10 00       	mov    0x10a444,%eax
  1055e4:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  1055eb:	00 00 00 
        root->parent = 0;
  1055ee:	a1 44 a4 10 00       	mov    0x10a444,%eax
  1055f3:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  1055fa:	00 00 00 
        strcpy(root->name, "$");
  1055fd:	a1 44 a4 10 00       	mov    0x10a444,%eax
  105602:	89 e1                	mov    %esp,%ecx
  105604:	89 01                	mov    %eax,(%ecx)
  105606:	c7 41 04 e1 85 10 00 	movl   $0x1085e1,0x4(%ecx)
  10560d:	e8 de f2 ff ff       	call   1048f0 <strcpy>
        root->res_ptr = 0;
  105612:	8b 0d 44 a4 10 00    	mov    0x10a444,%ecx
  105618:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  10561f:	00 00 00 
        root->res_type = RES_SUBDIR;
  105622:	8b 0d 44 a4 10 00    	mov    0x10a444,%ecx
  105628:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  10562f:	00 00 00 
  105632:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  105635:	83 c4 18             	add    $0x18,%esp
  105638:	5d                   	pop    %ebp
  105639:	c3                   	ret    
  10563a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105640 <vfs_debug_ls>:

void vfs_debug_ls(char* path) {
  105640:	55                   	push   %ebp
  105641:	89 e5                	mov    %esp,%ebp
  105643:	56                   	push   %esi
  105644:	83 ec 24             	sub    $0x24,%esp
  105647:	8b 45 08             	mov    0x8(%ebp),%eax
  10564a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    static struct res_node* node;
    node = vfs_get_node(path);
  10564d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105650:	89 04 24             	mov    %eax,(%esp)
  105653:	e8 c8 f7 ff ff       	call   104e20 <vfs_get_node>
  105658:	a3 58 a4 10 00       	mov    %eax,0x10a458
    node = node->res_ptr;
  10565d:	a1 58 a4 10 00       	mov    0x10a458,%eax
  105662:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105668:	a3 58 a4 10 00       	mov    %eax,0x10a458

    while(node != 0) {
  10566d:	81 3d 58 a4 10 00 00 	cmpl   $0x0,0x10a458
  105674:	00 00 00 
  105677:	0f 84 90 00 00 00    	je     10570d <vfs_debug_ls+0xcd>
  10567d:	8d 05 e3 85 10 00    	lea    0x1085e3,%eax
        char* type = "N/A";
  105683:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(node->res_type == RES_SUBDIR) {
  105686:	a1 58 a4 10 00       	mov    0x10a458,%eax
  10568b:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  105692:	00 00 00 
  105695:	0f 85 09 00 00 00    	jne    1056a4 <vfs_debug_ls+0x64>
  10569b:	8d 05 e7 85 10 00    	lea    0x1085e7,%eax
            type = "DIR";
  1056a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        if(node->res_type == RES_KERNDRV) {
  1056a4:	a1 58 a4 10 00       	mov    0x10a458,%eax
  1056a9:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  1056b0:	00 00 00 
  1056b3:	0f 85 14 00 00 00    	jne    1056cd <vfs_debug_ls+0x8d>
            type = ((struct res_kfile*)node->res_ptr)->driver->drvname;
  1056b9:	a1 58 a4 10 00       	mov    0x10a458,%eax
  1056be:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1056c4:	8b 40 04             	mov    0x4(%eax),%eax
  1056c7:	8b 40 18             	mov    0x18(%eax),%eax
  1056ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1056cd:	8d 05 eb 85 10 00    	lea    0x1085eb,%eax
        }

        kprintf("LS %s: %s [%s]\n", path, node->name, type);
  1056d3:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1056d6:	8b 15 58 a4 10 00    	mov    0x10a458,%edx
  1056dc:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1056df:	89 04 24             	mov    %eax,(%esp)
  1056e2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1056e6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1056ea:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1056ee:	e8 5d ae ff ff       	call   100550 <kprintf>

        node = node->next;
  1056f3:	8b 0d 58 a4 10 00    	mov    0x10a458,%ecx
  1056f9:	8b 89 08 01 00 00    	mov    0x108(%ecx),%ecx
  1056ff:	89 0d 58 a4 10 00    	mov    %ecx,0x10a458
    }
  105705:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105708:	e9 60 ff ff ff       	jmp    10566d <vfs_debug_ls+0x2d>
}
  10570d:	83 c4 24             	add    $0x24,%esp
  105710:	5e                   	pop    %esi
  105711:	5d                   	pop    %ebp
  105712:	c3                   	ret    
  105713:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10571a:	84 00 00 00 00 00 

00105720 <vfs_find_node>:

struct res_node* root = 0;
struct res_node* current = 0;
struct res_node* temp = 0;

static struct res_node* vfs_find_node(struct res_node* parent, char* name) {
  105720:	55                   	push   %ebp
  105721:	89 e5                	mov    %esp,%ebp
  105723:	83 ec 18             	sub    $0x18,%esp
  105726:	8b 45 0c             	mov    0xc(%ebp),%eax
  105729:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10572c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10572f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_type == RES_SUBDIR) {
  105732:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105735:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  10573c:	00 00 00 
  10573f:	0f 85 57 00 00 00    	jne    10579c <vfs_find_node+0x7c>
        struct res_node* ptr = parent->res_ptr;
  105745:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105748:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10574e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        while(ptr != 0) {
  105751:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105758:	0f 84 39 00 00 00    	je     105797 <vfs_find_node+0x77>
            if(strcmp(name, ptr->name) == 0) {
  10575e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105761:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105764:	89 e2                	mov    %esp,%edx
  105766:	89 4a 04             	mov    %ecx,0x4(%edx)
  105769:	89 02                	mov    %eax,(%edx)
  10576b:	e8 90 f0 ff ff       	call   104800 <strcmp>
  105770:	3d 00 00 00 00       	cmp    $0x0,%eax
  105775:	0f 85 0b 00 00 00    	jne    105786 <vfs_find_node+0x66>
                return ptr;
  10577b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10577e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105781:	e9 1d 00 00 00       	jmp    1057a3 <vfs_find_node+0x83>
            }

            ptr = ptr->next;
  105786:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105789:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  10578f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
  105792:	e9 ba ff ff ff       	jmp    105751 <vfs_find_node+0x31>
    }
  105797:	e9 00 00 00 00       	jmp    10579c <vfs_find_node+0x7c>

    return 0;
  10579c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1057a3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1057a6:	83 c4 18             	add    $0x18,%esp
  1057a9:	5d                   	pop    %ebp
  1057aa:	c3                   	ret    
  1057ab:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001057b0 <vfs_insert_node>:

static int vfs_insert_node(struct res_node* parent, struct res_node* child) {
  1057b0:	55                   	push   %ebp
  1057b1:	89 e5                	mov    %esp,%ebp
  1057b3:	83 ec 0c             	sub    $0xc,%esp
  1057b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1057b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1057bc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1057bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_ptr == 0) {
  1057c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057c5:	81 b8 04 01 00 00 00 	cmpl   $0x0,0x104(%eax)
  1057cc:	00 00 00 
  1057cf:	0f 85 0d 00 00 00    	jne    1057e2 <vfs_insert_node+0x32>
        parent->res_type = RES_SUBDIR;
  1057d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057d8:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  1057df:	00 00 00 
    }

    if(parent->res_type == RES_SUBDIR) {
  1057e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057e5:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  1057ec:	00 00 00 
  1057ef:	0f 85 36 00 00 00    	jne    10582b <vfs_insert_node+0x7b>
        child->next = parent->res_ptr;
  1057f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057f8:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1057fe:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105801:	89 81 08 01 00 00    	mov    %eax,0x108(%ecx)
        child->parent = parent;
  105807:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10580a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10580d:	89 81 0c 01 00 00    	mov    %eax,0x10c(%ecx)
        parent->res_ptr = child;
  105813:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105816:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105819:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)

        return 0;
  10581f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105826:	e9 07 00 00 00       	jmp    105832 <vfs_insert_node+0x82>
    }

    return 1;
  10582b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
}
  105832:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105835:	83 c4 0c             	add    $0xc,%esp
  105838:	5d                   	pop    %ebp
  105839:	c3                   	ret    
  10583a:	66 90                	xchg   %ax,%ax
  10583c:	66 90                	xchg   %ax,%ax
  10583e:	66 90                	xchg   %ax,%ax

00105840 <vmm_get_current_pagedir>:
	}

	vmm_unmap(pagedir_ptr);
}

uint32_t vmm_get_current_pagedir(void) {
  105840:	55                   	push   %ebp
  105841:	89 e5                	mov    %esp,%ebp
	return active_pagedir;
  105843:	a1 5c a4 10 00       	mov    0x10a45c,%eax
  105848:	5d                   	pop    %ebp
  105849:	c3                   	ret    
  10584a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105850 <vmm_fork_current>:
}

uint32_t vmm_fork_current(void) {
  105850:	55                   	push   %ebp
  105851:	89 e5                	mov    %esp,%ebp
  105853:	56                   	push   %esi
  105854:	83 ec 34             	sub    $0x34,%esp
  105857:	8d 45 f8             	lea    -0x8(%ebp),%eax
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  10585a:	89 04 24             	mov    %eax,(%esp)
  10585d:	e8 ce 00 00 00       	call   105930 <vmm_create_vpdraw>
  105862:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  105865:	c7 45 f0 00 10 40 20 	movl   $0x20401000,-0x10(%ebp)
  10586c:	81 7d f0 00 f0 ff ff 	cmpl   $0xfffff000,-0x10(%ebp)
  105873:	0f 83 98 00 00 00    	jae    105911 <vmm_fork_current+0xc1>
		if (active_pagetables[i >> 12] & PT_PRESENT) {
  105879:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10587c:	c1 e8 0c             	shr    $0xc,%eax
  10587f:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105885:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105888:	25 01 00 00 00       	and    $0x1,%eax
  10588d:	3d 00 00 00 00       	cmp    $0x0,%eax
  105892:	0f 84 64 00 00 00    	je     1058fc <vmm_fork_current+0xac>
  105898:	8d 45 f4             	lea    -0xc(%ebp),%eax
			void* newp = vmm_alloc_user(&paddr);
  10589b:	89 04 24             	mov    %eax,(%esp)
  10589e:	e8 4d 03 00 00       	call   105bf0 <vmm_alloc_user>
  1058a3:	b9 00 00 00 00       	mov    $0x0,%ecx
  1058a8:	ba 00 10 00 00       	mov    $0x1000,%edx
  1058ad:	89 45 e8             	mov    %eax,-0x18(%ebp)

			memcpy(newp, (void*) i, 0x1000);
  1058b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1058b3:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1058b6:	89 04 24             	mov    %eax,(%esp)
  1058b9:	89 74 24 04          	mov    %esi,0x4(%esp)
  1058bd:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  1058c4:	00 
  1058c5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1058c8:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1058cb:	e8 e0 ed ff ff       	call   1046b0 <memcpy>
			map_address_context(pdptr, i, paddr, 0);
  1058d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1058d3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1058d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1058d9:	89 04 24             	mov    %eax,(%esp)
  1058dc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1058e0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1058e4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1058eb:	00 
  1058ec:	e8 4f 03 00 00       	call   105c40 <map_address_context>

			vmm_unmap(newp);
  1058f1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1058f4:	89 04 24             	mov    %eax,(%esp)
  1058f7:	e8 d4 03 00 00       	call   105cd0 <vmm_unmap>
		}

	}
  1058fc:	e9 00 00 00 00       	jmp    105901 <vmm_fork_current+0xb1>

uint32_t vmm_fork_current(void) {
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  105901:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105904:	05 00 10 00 00       	add    $0x1000,%eax
  105909:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10590c:	e9 5b ff ff ff       	jmp    10586c <vmm_fork_current+0x1c>
			vmm_unmap(newp);
		}

	}

	vmm_free_pdptr(pdptr);
  105911:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105914:	89 04 24             	mov    %eax,(%esp)
  105917:	e8 24 04 00 00       	call   105d40 <vmm_free_pdptr>

	return phys_pagedir;
  10591c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10591f:	83 c4 34             	add    $0x34,%esp
  105922:	5e                   	pop    %esi
  105923:	5d                   	pop    %ebp
  105924:	c3                   	ret    
  105925:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10592c:	00 00 00 00 

00105930 <vmm_create_vpdraw>:
uint32_t* active_pagetables = (uint32_t*) (ACTIVE_PAGETBL_VADDR);
struct vmm_context* active_context = (void*) (ACTIVE_CONTEXT_VADDR);

uint32_t active_pagedir = 0;

static uint32_t* vmm_create_vpdraw(uint32_t* pagedir) {
  105930:	55                   	push   %ebp
  105931:	89 e5                	mov    %esp,%ebp
  105933:	53                   	push   %ebx
  105934:	57                   	push   %edi
  105935:	56                   	push   %esi
  105936:	83 ec 4c             	sub    $0x4c,%esp
  105939:	8b 45 08             	mov    0x8(%ebp),%eax
  10593c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  10593f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t phys_context = 0;
  105942:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct vmm_context* context = vmm_alloc(&phys_context);
  105949:	89 0c 24             	mov    %ecx,(%esp)
  10594c:	e8 6f 05 00 00       	call   105ec0 <vmm_alloc>
  105951:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  105954:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32_t phys_pagedir = 0;
  105957:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	context->pagedir = vmm_alloc(&phys_pagedir);
  10595e:	89 0c 24             	mov    %ecx,(%esp)
  105961:	e8 5a 05 00 00       	call   105ec0 <vmm_alloc>
  105966:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  105969:	89 01                	mov    %eax,(%ecx)
	if (pagedir != 0)
  10596b:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105972:	0f 84 08 00 00 00    	je     105980 <vmm_create_vpdraw+0x50>
		*pagedir = phys_pagedir;
  105978:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10597b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10597e:	89 01                	mov    %eax,(%ecx)
  105980:	b8 00 00 00 00       	mov    $0x0,%eax

	uint32_t* pagedir_ptr = vmm_alloc(0);
  105985:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10598c:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10598f:	e8 2c 05 00 00       	call   105ec0 <vmm_alloc>
  105994:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  105997:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  10599e:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  1059a5:	0f 83 25 01 00 00    	jae    105ad0 <vmm_create_vpdraw+0x1a0>
  1059ab:	8d 45 dc             	lea    -0x24(%ebp),%eax
		pagedir_ptr[i] = (uint32_t) vmm_alloc(&paddr);
  1059ae:	89 04 24             	mov    %eax,(%esp)
  1059b1:	e8 0a 05 00 00       	call   105ec0 <vmm_alloc>
  1059b6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1059b9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1059bc:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i < PMEM_TABLES) {
  1059bf:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  1059c6:	0f 83 4d 00 00 00    	jae    105a19 <vmm_create_vpdraw+0xe9>
			vmm_free((void*) (pagedir_ptr[i]));
  1059cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1059cf:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1059d2:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1059d5:	89 04 24             	mov    %eax,(%esp)
  1059d8:	e8 33 05 00 00       	call   105f10 <vmm_free>
  1059dd:	b8 00 00 00 00       	mov    $0x0,%eax
			map_address_active(pagedir_ptr[i], kernel_pagetables[i], 0); //Can reuse pagedir_ptr[i] cause of vmm_free
  1059e2:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1059e5:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1059e8:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  1059eb:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1059ee:	8b 14 95 90 a4 18 00 	mov    0x18a490(,%edx,4),%edx
  1059f5:	89 0c 24             	mov    %ecx,(%esp)
  1059f8:	89 54 24 04          	mov    %edx,0x4(%esp)
  1059fc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105a03:	00 
  105a04:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  105a07:	e8 84 05 00 00       	call   105f90 <map_address_active>
			paddr = kernel_pagetables[i];
  105a0c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105a0f:	8b 04 85 90 a4 18 00 	mov    0x18a490(,%eax,4),%eax
  105a16:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;
  105a19:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105a1c:	0d 01 00 00 00       	or     $0x1,%eax
  105a21:	0d 02 00 00 00       	or     $0x2,%eax
  105a26:	0d 04 00 00 00       	or     $0x4,%eax
  105a2b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105a2e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105a31:	8b 12                	mov    (%edx),%edx
  105a33:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
  105a36:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  105a3d:	0f 82 78 00 00 00    	jb     105abb <vmm_create_vpdraw+0x18b>
			for (i2 = 0; i2 < 1024; i2++) {
  105a43:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  105a4a:	81 7d d4 00 04 00 00 	cmpl   $0x400,-0x2c(%ebp)
  105a51:	0f 83 5f 00 00 00    	jae    105ab6 <vmm_create_vpdraw+0x186>
  105a57:	b8 04 00 00 00       	mov    $0x4,%eax
  105a5c:	b9 00 00 00 00       	mov    $0x0,%ecx
  105a61:	ba 00 02 00 00       	mov    $0x200,%edx
				uint32_t vaddr = (i << 22) + (i2 << 12);
  105a66:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105a69:	c1 e6 16             	shl    $0x16,%esi
  105a6c:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  105a6f:	c1 e7 0c             	shl    $0xc,%edi
  105a72:	01 fe                	add    %edi,%esi
  105a74:	89 75 d0             	mov    %esi,-0x30(%ebp)

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
  105a77:	81 7d d0 00 00 00 01 	cmpl   $0x1000000,-0x30(%ebp)
  105a7e:	0f 97 c3             	seta   %bl
  105a81:	84 db                	test   %bl,%bl
  105a83:	0f 44 d1             	cmove  %ecx,%edx
  105a86:	81 7d d0 00 10 40 20 	cmpl   $0x20401000,-0x30(%ebp)
  105a8d:	0f 97 c3             	seta   %bl
  105a90:	84 db                	test   %bl,%bl
  105a92:	0f 44 c1             	cmove  %ecx,%eax
  105a95:	09 c2                	or     %eax,%edx
  105a97:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  105a9a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105a9d:	8b 75 e0             	mov    -0x20(%ebp),%esi
  105aa0:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  105aa3:	89 14 81             	mov    %edx,(%ecx,%eax,4)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
			for (i2 = 0; i2 < 1024; i2++) {
  105aa6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  105aa9:	05 01 00 00 00       	add    $0x1,%eax
  105aae:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  105ab1:	e9 94 ff ff ff       	jmp    105a4a <vmm_create_vpdraw+0x11a>

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
						(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
  105ab6:	e9 00 00 00 00       	jmp    105abb <vmm_create_vpdraw+0x18b>
	}
  105abb:	e9 00 00 00 00       	jmp    105ac0 <vmm_create_vpdraw+0x190>
		*pagedir = phys_pagedir;

	uint32_t* pagedir_ptr = vmm_alloc(0);
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  105ac0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105ac3:	05 01 00 00 00       	add    $0x1,%eax
  105ac8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105acb:	e9 ce fe ff ff       	jmp    10599e <vmm_create_vpdraw+0x6e>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  105ad0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  105ad7:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  105ade:	0f 83 58 00 00 00    	jae    105b3c <vmm_create_vpdraw+0x20c>
  105ae4:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
  105ae9:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105aec:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105aef:	8b 12                	mov    (%edx),%edx
  105af1:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105af4:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  105afa:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		map_address_context(pagedir_ptr,
  105afd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105b00:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105b06:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105b09:	c1 e6 0c             	shl    $0xc,%esi
  105b0c:	01 f2                	add    %esi,%edx
  105b0e:	8b 75 dc             	mov    -0x24(%ebp),%esi
  105b11:	89 0c 24             	mov    %ecx,(%esp)
  105b14:	89 54 24 04          	mov    %edx,0x4(%esp)
  105b18:	89 74 24 08          	mov    %esi,0x8(%esp)
  105b1c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105b23:	00 
  105b24:	89 45 c0             	mov    %eax,-0x40(%ebp)
  105b27:	e8 14 01 00 00       	call   105c40 <map_address_context>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  105b2c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105b2f:	05 01 00 00 00       	add    $0x1,%eax
  105b34:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105b37:	e9 9b ff ff ff       	jmp    105ad7 <vmm_create_vpdraw+0x1a7>
  105b3c:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(pagedir_ptr,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
  105b41:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105b44:	8b 15 e8 71 10 00    	mov    0x1071e8,%edx
  105b4a:	8b 75 ec             	mov    -0x14(%ebp),%esi
  105b4d:	89 0c 24             	mov    %ecx,(%esp)
  105b50:	89 54 24 04          	mov    %edx,0x4(%esp)
  105b54:	89 74 24 08          	mov    %esi,0x8(%esp)
  105b58:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105b5f:	00 
  105b60:	89 45 bc             	mov    %eax,-0x44(%ebp)
  105b63:	e8 d8 00 00 00       	call   105c40 <map_address_context>
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105b68:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
  105b6f:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
  105b75:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  105b78:	0f 83 39 00 00 00    	jae    105bb7 <vmm_create_vpdraw+0x287>
  105b7e:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(pagedir_ptr, i, i, 0);
  105b83:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105b86:	8b 55 d8             	mov    -0x28(%ebp),%edx
  105b89:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105b8c:	89 0c 24             	mov    %ecx,(%esp)
  105b8f:	89 54 24 04          	mov    %edx,0x4(%esp)
  105b93:	89 74 24 08          	mov    %esi,0x8(%esp)
  105b97:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105b9e:	00 
  105b9f:	89 45 b8             	mov    %eax,-0x48(%ebp)
  105ba2:	e8 99 00 00 00       	call   105c40 <map_address_context>
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105ba7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105baa:	05 00 10 00 00       	add    $0x1000,%eax
  105baf:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105bb2:	e9 b8 ff ff ff       	jmp    105b6f <vmm_create_vpdraw+0x23f>
		map_address_context(pagedir_ptr, i, i, 0);
	}

	uint32_t* pd_ptr = context->pagedir;
  105bb7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105bba:	8b 00                	mov    (%eax),%eax
  105bbc:	89 45 cc             	mov    %eax,-0x34(%ebp)
	context->pagedir = (uint32_t*) phys_pagedir;
  105bbf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105bc2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  105bc5:	89 01                	mov    %eax,(%ecx)

	vmm_unmap(pd_ptr);
  105bc7:	8b 45 cc             	mov    -0x34(%ebp),%eax
  105bca:	89 04 24             	mov    %eax,(%esp)
  105bcd:	e8 fe 00 00 00       	call   105cd0 <vmm_unmap>
	vmm_unmap(context);
  105bd2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105bd5:	89 04 24             	mov    %eax,(%esp)
  105bd8:	e8 f3 00 00 00       	call   105cd0 <vmm_unmap>

	return pagedir_ptr;
  105bdd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105be0:	83 c4 4c             	add    $0x4c,%esp
  105be3:	5e                   	pop    %esi
  105be4:	5f                   	pop    %edi
  105be5:	5b                   	pop    %ebx
  105be6:	5d                   	pop    %ebp
  105be7:	c3                   	ret    
  105be8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  105bef:	00 

00105bf0 <vmm_alloc_user>:

void* vmm_alloc_ucont(uint32_t cont) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
}

void* vmm_alloc_user(uint32_t* retpaddr) {
  105bf0:	55                   	push   %ebp
  105bf1:	89 e5                	mov    %esp,%ebp
  105bf3:	56                   	push   %esi
  105bf4:	83 ec 24             	sub    $0x24,%esp
  105bf7:	8b 45 08             	mov    0x8(%ebp),%eax
  105bfa:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  105bff:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  105c04:	be 01 00 00 00       	mov    $0x1,%esi
  105c09:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
  105c0c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105c0f:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  105c16:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  105c1d:	ff 
  105c1e:	89 44 24 08          	mov    %eax,0x8(%esp)
  105c22:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105c29:	00 
  105c2a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105c2d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105c30:	89 55 ec             	mov    %edx,-0x14(%ebp)
  105c33:	e8 b8 04 00 00       	call   1060f0 <vmm_alloc_in_range>
  105c38:	83 c4 24             	add    $0x24,%esp
  105c3b:	5e                   	pop    %esi
  105c3c:	5d                   	pop    %ebp
  105c3d:	c3                   	ret    
  105c3e:	66 90                	xchg   %ax,%ax

00105c40 <map_address_context>:
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}

void map_address_context(uint32_t* pagedir, uint32_t vaddr, uint32_t paddr,
		uint32_t flags) {
  105c40:	55                   	push   %ebp
  105c41:	89 e5                	mov    %esp,%ebp
  105c43:	56                   	push   %esi
  105c44:	83 ec 18             	sub    $0x18,%esp
  105c47:	8b 45 14             	mov    0x14(%ebp),%eax
  105c4a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105c4d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105c50:	8b 75 08             	mov    0x8(%ebp),%esi
  105c53:	89 75 f8             	mov    %esi,-0x8(%ebp)
  105c56:	89 55 f4             	mov    %edx,-0xc(%ebp)
  105c59:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105c5c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32_t pd_entry = vaddr >> 22;
  105c5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105c62:	c1 e8 16             	shr    $0x16,%eax
  105c65:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pt_entry = (vaddr >> 12) % 1024;
  105c68:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105c6b:	c1 e8 0c             	shr    $0xc,%eax
  105c6e:	25 ff 03 00 00       	and    $0x3ff,%eax
  105c73:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry] = (paddr
  105c76:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105c79:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105c7e:	0d 01 00 00 00       	or     $0x1,%eax
  105c83:	0d 02 00 00 00       	or     $0x2,%eax
  105c88:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105c8b:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  105c91:	09 c8                	or     %ecx,%eax
  105c93:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105c96:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105c99:	8b 75 f8             	mov    -0x8(%ebp),%esi
  105c9c:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105c9f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  105ca5:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105ca8:	81 e1 04 02 00 00    	and    $0x204,%ecx
  105cae:	09 c8                	or     %ecx,%eax
  105cb0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105cb3:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105cb6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  105cb9:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105cbc:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  105cc2:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}
  105cc5:	83 c4 18             	add    $0x18,%esp
  105cc8:	5e                   	pop    %esi
  105cc9:	5d                   	pop    %ebp
  105cca:	c3                   	ret    
  105ccb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105cd0 <vmm_unmap>:
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

void vmm_unmap(void* p_vaddr) { //USE ONLY IF YOU KNOW WHAT YOU DO. POTENTIAL MEMORY LEAK!
  105cd0:	55                   	push   %ebp
  105cd1:	89 e5                	mov    %esp,%ebp
  105cd3:	83 ec 08             	sub    $0x8,%esp
  105cd6:	8b 45 08             	mov    0x8(%ebp),%eax
  105cd9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  105cdc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105cdf:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  105ce2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ce5:	c1 e8 0c             	shr    $0xc,%eax
  105ce8:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105cee:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105cf1:	25 01 02 00 00       	and    $0x201,%eax
  105cf6:	3d 01 02 00 00       	cmp    $0x201,%eax
  105cfb:	0f 85 2e 00 00 00    	jne    105d2f <vmm_unmap+0x5f>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  105d01:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105d04:	c1 e8 0c             	shr    $0xc,%eax
  105d07:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105d0d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105d10:	25 04 00 00 00       	and    $0x4,%eax
  105d15:	0d 00 02 00 00       	or     $0x200,%eax
  105d1a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105d1d:	c1 e9 0c             	shr    $0xc,%ecx
  105d20:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105d26:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  105d29:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105d2c:	0f 01 38             	invlpg (%eax)
	}
}
  105d2f:	83 c4 08             	add    $0x8,%esp
  105d32:	5d                   	pop    %ebp
  105d33:	c3                   	ret    
  105d34:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105d3b:	00 00 00 00 00 

00105d40 <vmm_free_pdptr>:
	vmm_unmap(context);

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
  105d40:	55                   	push   %ebp
  105d41:	89 e5                	mov    %esp,%ebp
  105d43:	83 ec 18             	sub    $0x18,%esp
  105d46:	8b 45 08             	mov    0x8(%ebp),%eax
  105d49:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (uint32_t i = 0; i < 1024; i++) {
  105d4c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  105d53:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
  105d5a:	0f 83 21 00 00 00    	jae    105d81 <vmm_free_pdptr+0x41>
		vmm_unmap((void*) pagedir_ptr[i]);
  105d60:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105d63:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105d66:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105d69:	89 04 24             	mov    %eax,(%esp)
  105d6c:	e8 5f ff ff ff       	call   105cd0 <vmm_unmap>

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
	for (uint32_t i = 0; i < 1024; i++) {
  105d71:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105d74:	05 01 00 00 00       	add    $0x1,%eax
  105d79:	89 45 f8             	mov    %eax,-0x8(%ebp)
  105d7c:	e9 d2 ff ff ff       	jmp    105d53 <vmm_free_pdptr+0x13>
		vmm_unmap((void*) pagedir_ptr[i]);
	}

	vmm_unmap(pagedir_ptr);
  105d81:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105d84:	89 04 24             	mov    %eax,(%esp)
  105d87:	e8 44 ff ff ff       	call   105cd0 <vmm_unmap>
}
  105d8c:	83 c4 18             	add    $0x18,%esp
  105d8f:	5d                   	pop    %ebp
  105d90:	c3                   	ret    
  105d91:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105d98:	0f 1f 84 00 00 00 00 
  105d9f:	00 

00105da0 <vmm_create_pagedir>:
	vmm_free_pdptr(pdptr);

	return phys_pagedir;
}

uint32_t vmm_create_pagedir() {
  105da0:	55                   	push   %ebp
  105da1:	89 e5                	mov    %esp,%ebp
  105da3:	83 ec 18             	sub    $0x18,%esp
  105da6:	8d 45 fc             	lea    -0x4(%ebp),%eax
	uint32_t phys_pagedir;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  105da9:	89 04 24             	mov    %eax,(%esp)
  105dac:	e8 7f fb ff ff       	call   105930 <vmm_create_vpdraw>
  105db1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	vmm_free_pdptr(pdptr);
  105db4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105db7:	89 04 24             	mov    %eax,(%esp)
  105dba:	e8 81 ff ff ff       	call   105d40 <vmm_free_pdptr>

	return phys_pagedir;
  105dbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105dc2:	83 c4 18             	add    $0x18,%esp
  105dc5:	5d                   	pop    %ebp
  105dc6:	c3                   	ret    
  105dc7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  105dce:	00 00 

00105dd0 <vmm_resolve>:
}

uint32_t vmm_resolve(void* vaddr) {
  105dd0:	55                   	push   %ebp
  105dd1:	89 e5                	mov    %esp,%ebp
  105dd3:	50                   	push   %eax
  105dd4:	8b 45 08             	mov    0x8(%ebp),%eax
  105dd7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return active_pagetables[(uint32_t) vaddr >> 12] & 0xFFFFF000;
  105dda:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105ddd:	c1 e8 0c             	shr    $0xc,%eax
  105de0:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105de6:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105de9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105dee:	83 c4 04             	add    $0x4,%esp
  105df1:	5d                   	pop    %ebp
  105df2:	c3                   	ret    
  105df3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105dfa:	84 00 00 00 00 00 

00105e00 <vmm_resolve_ppd>:
}

uint32_t vmm_resolve_ppd(uint32_t pdir, void* vaddr) {
  105e00:	55                   	push   %ebp
  105e01:	89 e5                	mov    %esp,%ebp
  105e03:	83 ec 38             	sub    $0x38,%esp
  105e06:	8b 45 0c             	mov    0xc(%ebp),%eax
  105e09:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105e0c:	ba 00 00 00 00       	mov    $0x0,%edx
  105e11:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  105e14:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32_t pd_entry = (uint32_t) vaddr >> 22;
  105e17:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105e1a:	c1 e8 16             	shr    $0x16,%eax
  105e1d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t pt_entry = ((uint32_t) vaddr >> 12) % 1024;
  105e20:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105e23:	c1 e8 0c             	shr    $0xc,%eax
  105e26:	25 ff 03 00 00       	and    $0x3ff,%eax
  105e2b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	uint32_t* vpd = vmm_alloc(0);
  105e2e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105e35:	89 55 e0             	mov    %edx,-0x20(%ebp)
  105e38:	e8 83 00 00 00       	call   105ec0 <vmm_alloc>
  105e3d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	vmm_free(vpd);
  105e40:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105e43:	89 04 24             	mov    %eax,(%esp)
  105e46:	e8 c5 00 00 00       	call   105f10 <vmm_free>
  105e4b:	b8 00 00 00 00       	mov    $0x0,%eax

	map_address_active((uint32_t) vpd, pdir, 0);
  105e50:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105e53:	8b 55 fc             	mov    -0x4(%ebp),%edx
  105e56:	89 0c 24             	mov    %ecx,(%esp)
  105e59:	89 54 24 04          	mov    %edx,0x4(%esp)
  105e5d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105e64:	00 
  105e65:	89 45 dc             	mov    %eax,-0x24(%ebp)
  105e68:	e8 23 01 00 00       	call   105f90 <map_address_active>
  105e6d:	b8 00 00 00 00       	mov    $0x0,%eax
	uint32_t table = vpd[pd_entry] & 0xFFFFF000;
  105e72:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105e75:	8b 55 ec             	mov    -0x14(%ebp),%edx
  105e78:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105e7b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  105e81:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	map_address_active((uint32_t) vpd, table, 0);
  105e84:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105e87:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105e8a:	89 0c 24             	mov    %ecx,(%esp)
  105e8d:	89 54 24 04          	mov    %edx,0x4(%esp)
  105e91:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105e98:	00 
  105e99:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105e9c:	e8 ef 00 00 00       	call   105f90 <map_address_active>
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;
  105ea1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105ea4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105ea7:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105eaa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105eaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	return addr & 0xFFFFF000;
  105eb2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105eb5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105eba:	83 c4 38             	add    $0x38,%esp
  105ebd:	5d                   	pop    %ebp
  105ebe:	c3                   	ret    
  105ebf:	90                   	nop

00105ec0 <vmm_alloc>:

void* vmm_alloc_cont(uint32_t cont) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
}

void* vmm_alloc(uint32_t* retpaddr) {
  105ec0:	55                   	push   %ebp
  105ec1:	89 e5                	mov    %esp,%ebp
  105ec3:	56                   	push   %esi
  105ec4:	83 ec 24             	sub    $0x24,%esp
  105ec7:	8b 45 08             	mov    0x8(%ebp),%eax
  105eca:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  105ecf:	ba 00 00 00 20       	mov    $0x20000000,%edx
  105ed4:	be 01 00 00 00       	mov    $0x1,%esi
  105ed9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
  105edc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105edf:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
  105ee6:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  105eed:	20 
  105eee:	89 44 24 08          	mov    %eax,0x8(%esp)
  105ef2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105ef9:	00 
  105efa:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105efd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105f00:	89 55 ec             	mov    %edx,-0x14(%ebp)
  105f03:	e8 e8 01 00 00       	call   1060f0 <vmm_alloc_in_range>
  105f08:	83 c4 24             	add    $0x24,%esp
  105f0b:	5e                   	pop    %esi
  105f0c:	5d                   	pop    %ebp
  105f0d:	c3                   	ret    
  105f0e:	66 90                	xchg   %ax,%ax

00105f10 <vmm_free>:
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
}

void vmm_free(void* p_vaddr) {
  105f10:	55                   	push   %ebp
  105f11:	89 e5                	mov    %esp,%ebp
  105f13:	83 ec 18             	sub    $0x18,%esp
  105f16:	8b 45 08             	mov    0x8(%ebp),%eax
  105f19:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  105f1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105f1f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  105f22:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f25:	c1 e8 0c             	shr    $0xc,%eax
  105f28:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105f2e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105f31:	25 01 02 00 00       	and    $0x201,%eax
  105f36:	3d 01 02 00 00       	cmp    $0x201,%eax
  105f3b:	0f 85 4a 00 00 00    	jne    105f8b <vmm_free+0x7b>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		pmm_free((void*) (active_pagetables[vaddr >> 12] & 0xFFFFF000));
  105f41:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f44:	c1 e8 0c             	shr    $0xc,%eax
  105f47:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105f4d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105f50:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105f55:	89 04 24             	mov    %eax,(%esp)
  105f58:	e8 23 c7 ff ff       	call   102680 <pmm_free>

		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  105f5d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f60:	c1 e8 0c             	shr    $0xc,%eax
  105f63:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105f69:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105f6c:	25 04 00 00 00       	and    $0x4,%eax
  105f71:	0d 00 02 00 00       	or     $0x200,%eax
  105f76:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105f79:	c1 e9 0c             	shr    $0xc,%ecx
  105f7c:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105f82:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  105f85:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f88:	0f 01 38             	invlpg (%eax)
	}
}
  105f8b:	83 c4 18             	add    $0x18,%esp
  105f8e:	5d                   	pop    %ebp
  105f8f:	c3                   	ret    

00105f90 <map_address_active>:
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}

void map_address_active(uint32_t vaddr, uint32_t paddr, uint32_t flags) {
  105f90:	55                   	push   %ebp
  105f91:	89 e5                	mov    %esp,%ebp
  105f93:	83 ec 0c             	sub    $0xc,%esp
  105f96:	8b 45 10             	mov    0x10(%ebp),%eax
  105f99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105f9c:	8b 55 08             	mov    0x8(%ebp),%edx
  105f9f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  105fa2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105fa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	active_pagetables[vaddr >> 12] = (paddr & 0xFFFFF000) | PT_PRESENT
  105fa8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105fab:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105fb0:	0d 01 00 00 00       	or     $0x1,%eax
  105fb5:	0d 02 00 00 00       	or     $0x2,%eax
  105fba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105fbd:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  105fc3:	09 c8                	or     %ecx,%eax
  105fc5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105fc8:	c1 e9 0c             	shr    $0xc,%ecx
  105fcb:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105fd1:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105fd4:	81 e1 04 02 00 00    	and    $0x204,%ecx
  105fda:	09 c8                	or     %ecx,%eax
  105fdc:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105fdf:	c1 e9 0c             	shr    $0xc,%ecx
  105fe2:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105fe8:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  105feb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105fee:	0f 01 38             	invlpg (%eax)
}
  105ff1:	83 c4 0c             	add    $0xc,%esp
  105ff4:	5d                   	pop    %ebp
  105ff5:	c3                   	ret    
  105ff6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  105ffd:	00 00 00 

00106000 <vmm_map_range>:
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;

	return addr & 0xFFFFF000;
}

void vmm_map_range(void* vaddr, void* paddr, uint32_t length, uint32_t flags) {
  106000:	55                   	push   %ebp
  106001:	89 e5                	mov    %esp,%ebp
  106003:	56                   	push   %esi
  106004:	83 ec 24             	sub    $0x24,%esp
  106007:	8b 45 14             	mov    0x14(%ebp),%eax
  10600a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10600d:	8b 55 0c             	mov    0xc(%ebp),%edx
  106010:	8b 75 08             	mov    0x8(%ebp),%esi
  106013:	89 75 f8             	mov    %esi,-0x8(%ebp)
  106016:	89 55 f4             	mov    %edx,-0xc(%ebp)
  106019:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10601c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((uint32_t) vaddr & 0xFFF)
  10601f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106022:	25 ff 0f 00 00       	and    $0xfff,%eax
  106027:	3d 00 00 00 00       	cmp    $0x0,%eax
  10602c:	0f 84 05 00 00 00    	je     106037 <vmm_map_range+0x37>
		return;
  106032:	e9 5a 00 00 00       	jmp    106091 <vmm_map_range+0x91>
	if ((uint32_t) paddr & 0xFFF)
  106037:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10603a:	25 ff 0f 00 00       	and    $0xfff,%eax
  10603f:	3d 00 00 00 00       	cmp    $0x0,%eax
  106044:	0f 84 05 00 00 00    	je     10604f <vmm_map_range+0x4f>
		return;
  10604a:	e9 42 00 00 00       	jmp    106091 <vmm_map_range+0x91>

	for (uint32_t i = 0; i < length; i += 0x1000) {
  10604f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  106056:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106059:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10605c:	0f 83 2f 00 00 00    	jae    106091 <vmm_map_range+0x91>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
  106062:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106065:	03 45 e8             	add    -0x18(%ebp),%eax
  106068:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10606b:	03 4d e8             	add    -0x18(%ebp),%ecx
  10606e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106071:	89 04 24             	mov    %eax,(%esp)
  106074:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106078:	89 54 24 08          	mov    %edx,0x8(%esp)
  10607c:	e8 0f ff ff ff       	call   105f90 <map_address_active>
	if ((uint32_t) vaddr & 0xFFF)
		return;
	if ((uint32_t) paddr & 0xFFF)
		return;

	for (uint32_t i = 0; i < length; i += 0x1000) {
  106081:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106084:	05 00 10 00 00       	add    $0x1000,%eax
  106089:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10608c:	e9 c5 ff ff ff       	jmp    106056 <vmm_map_range+0x56>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}
  106091:	83 c4 24             	add    $0x24,%esp
  106094:	5e                   	pop    %esi
  106095:	5d                   	pop    %ebp
  106096:	c3                   	ret    
  106097:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10609e:	00 00 

001060a0 <vmm_alloc_ucont>:
	}

	return vaddr;
}

void* vmm_alloc_ucont(uint32_t cont) {
  1060a0:	55                   	push   %ebp
  1060a1:	89 e5                	mov    %esp,%ebp
  1060a3:	56                   	push   %esi
  1060a4:	83 ec 24             	sub    $0x24,%esp
  1060a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1060aa:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  1060af:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  1060b4:	be 00 00 00 00       	mov    $0x0,%esi
  1060b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
  1060bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1060bf:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  1060c6:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  1060cd:	ff 
  1060ce:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1060d5:	00 
  1060d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1060da:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1060dd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1060e0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1060e3:	e8 08 00 00 00       	call   1060f0 <vmm_alloc_in_range>
  1060e8:	83 c4 24             	add    $0x24,%esp
  1060eb:	5e                   	pop    %esi
  1060ec:	5d                   	pop    %ebp
  1060ed:	c3                   	ret    
  1060ee:	66 90                	xchg   %ax,%ax

001060f0 <vmm_alloc_in_range>:
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

static void* vmm_alloc_in_range(uint32_t low, uint32_t high, uint32_t* retpaddr,
		uint32_t cont) {
  1060f0:	55                   	push   %ebp
  1060f1:	89 e5                	mov    %esp,%ebp
  1060f3:	56                   	push   %esi
  1060f4:	83 ec 34             	sub    $0x34,%esp
  1060f7:	8b 45 14             	mov    0x14(%ebp),%eax
  1060fa:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1060fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  106100:	8b 75 08             	mov    0x8(%ebp),%esi
  106103:	89 75 f8             	mov    %esi,-0x8(%ebp)
  106106:	89 55 f4             	mov    %edx,-0xc(%ebp)
  106109:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10610c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	void* vaddr = 0;
  10610f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32_t i = 0;
  106116:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32_t c = 0;
  10611d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  106124:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106127:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10612c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10612f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106132:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  106135:	0f 83 6f 00 00 00    	jae    1061aa <vmm_alloc_in_range+0xba>
		if ((active_pagetables[i >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  10613b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10613e:	c1 e8 0c             	shr    $0xc,%eax
  106141:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  106147:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10614a:	25 01 02 00 00       	and    $0x201,%eax
  10614f:	3d 00 02 00 00       	cmp    $0x200,%eax
  106154:	0f 85 34 00 00 00    	jne    10618e <vmm_alloc_in_range+0x9e>
				== PT_ALLOCATABLE) {
			if (c == 0)
  10615a:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  106161:	0f 85 06 00 00 00    	jne    10616d <vmm_alloc_in_range+0x7d>
				vaddr = (void*) i;
  106167:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10616a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			c++;
  10616d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  106170:	05 01 00 00 00       	add    $0x1,%eax
  106175:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (c >= cont)
  106178:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10617b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10617e:	0f 82 05 00 00 00    	jb     106189 <vmm_alloc_in_range+0x99>
				break;
  106184:	e9 21 00 00 00       	jmp    1061aa <vmm_alloc_in_range+0xba>
		} else {
  106189:	e9 07 00 00 00       	jmp    106195 <vmm_alloc_in_range+0xa5>
			c = 0;
  10618e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
	}
  106195:	e9 00 00 00 00       	jmp    10619a <vmm_alloc_in_range+0xaa>
		uint32_t cont) {
	void* vaddr = 0;
	uint32_t i = 0;
	uint32_t c = 0;

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  10619a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10619d:	05 00 10 00 00       	add    $0x1000,%eax
  1061a2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1061a5:	e9 85 ff ff ff       	jmp    10612f <vmm_alloc_in_range+0x3f>
		} else {
			c = 0;
		}
	}

	uint32_t off = 0;
  1061aa:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	while (c--) {
  1061b1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1061b4:	89 c1                	mov    %eax,%ecx
  1061b6:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1061bc:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1061bf:	3d 00 00 00 00       	cmp    $0x0,%eax
  1061c4:	0f 84 59 00 00 00    	je     106223 <vmm_alloc_in_range+0x133>
		vmm_alloc_addr(vaddr + off * 0x1000, off == 0 ? retpaddr : 0);
  1061ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1061cd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1061d0:	c1 e1 0c             	shl    $0xc,%ecx
  1061d3:	01 c8                	add    %ecx,%eax
  1061d5:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  1061dc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1061df:	0f 85 0b 00 00 00    	jne    1061f0 <vmm_alloc_in_range+0x100>
  1061e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1061e8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1061eb:	e9 0d 00 00 00       	jmp    1061fd <vmm_alloc_in_range+0x10d>
  1061f0:	b8 00 00 00 00       	mov    $0x0,%eax
  1061f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1061f8:	e9 00 00 00 00       	jmp    1061fd <vmm_alloc_in_range+0x10d>
  1061fd:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  106200:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  106203:	89 0c 24             	mov    %ecx,(%esp)
  106206:	89 44 24 04          	mov    %eax,0x4(%esp)
  10620a:	e8 71 00 00 00       	call   106280 <vmm_alloc_addr>
		off++;
  10620f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  106212:	81 c1 01 00 00 00    	add    $0x1,%ecx
  106218:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	}
  10621b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10621e:	e9 8e ff ff ff       	jmp    1061b1 <vmm_alloc_in_range+0xc1>

	return vaddr;
  106223:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106226:	83 c4 34             	add    $0x34,%esp
  106229:	5e                   	pop    %esi
  10622a:	5d                   	pop    %ebp
  10622b:	c3                   	ret    
  10622c:	0f 1f 40 00          	nopl   0x0(%eax)

00106230 <vmm_alloc_cont>:

void* vmm_alloc_user(uint32_t* retpaddr) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
}

void* vmm_alloc_cont(uint32_t cont) {
  106230:	55                   	push   %ebp
  106231:	89 e5                	mov    %esp,%ebp
  106233:	56                   	push   %esi
  106234:	83 ec 24             	sub    $0x24,%esp
  106237:	8b 45 08             	mov    0x8(%ebp),%eax
  10623a:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  10623f:	ba 00 00 00 20       	mov    $0x20000000,%edx
  106244:	be 00 00 00 00       	mov    $0x0,%esi
  106249:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
  10624c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10624f:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
  106256:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  10625d:	20 
  10625e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106265:	00 
  106266:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10626a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10626d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106270:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106273:	e8 78 fe ff ff       	call   1060f0 <vmm_alloc_in_range>
  106278:	83 c4 24             	add    $0x24,%esp
  10627b:	5e                   	pop    %esi
  10627c:	5d                   	pop    %ebp
  10627d:	c3                   	ret    
  10627e:	66 90                	xchg   %ax,%ax

00106280 <vmm_alloc_addr>:

void* vmm_alloc(uint32_t* retpaddr) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
}

void* vmm_alloc_addr(void* reqvaddr, uint32_t* retpaddr) {
  106280:	55                   	push   %ebp
  106281:	89 e5                	mov    %esp,%ebp
  106283:	56                   	push   %esi
  106284:	83 ec 34             	sub    $0x34,%esp
  106287:	8b 45 0c             	mov    0xc(%ebp),%eax
  10628a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10628d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  106290:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (reqvaddr == 0) {
  106293:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  10629a:	0f 85 34 00 00 00    	jne    1062d4 <vmm_alloc_addr+0x54>
  1062a0:	8d 05 2f 86 10 00    	lea    0x10862f,%eax
  1062a6:	b9 00 00 00 00       	mov    $0x0,%ecx
		kprintf(
  1062ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1062ae:	89 04 24             	mov    %eax,(%esp)
  1062b1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1062b5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1062bc:	00 
  1062bd:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1062c0:	e8 8b a2 ff ff       	call   100550 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, 0);
		return 0;
  1062c5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1062cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1062cf:	e9 9b 00 00 00       	jmp    10636f <vmm_alloc_addr+0xef>
	}

	if ((active_pagetables[(uint32_t) reqvaddr >> 12]
  1062d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1062d7:	c1 e8 0c             	shr    $0xc,%eax
  1062da:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  1062e0:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1062e3:	25 01 02 00 00       	and    $0x201,%eax
  1062e8:	3d 00 02 00 00       	cmp    $0x200,%eax
  1062ed:	0f 84 37 00 00 00    	je     10632a <vmm_alloc_addr+0xaa>
  1062f3:	8d 05 2f 86 10 00    	lea    0x10862f,%eax
			& (PT_ALLOCATABLE | PT_PRESENT)) != PT_ALLOCATABLE) {
		kprintf(
  1062f9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1062fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1062ff:	c1 ea 0c             	shr    $0xc,%edx
  106302:	8b 35 e4 71 10 00    	mov    0x1071e4,%esi
  106308:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10630b:	89 04 24             	mov    %eax,(%esp)
  10630e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106312:	89 54 24 08          	mov    %edx,0x8(%esp)
  106316:	e8 35 a2 ff ff       	call   100550 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, active_pagetables[(uint32_t) reqvaddr >> 12]);
		return 0;
  10631b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  106322:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106325:	e9 45 00 00 00       	jmp    10636f <vmm_alloc_addr+0xef>
  10632a:	b8 04 02 00 00       	mov    $0x204,%eax
	}

	uint32_t paddr = (uint32_t) pmm_alloc();
  10632f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  106332:	e8 29 c1 ff ff       	call   102460 <pmm_alloc>
  106337:	89 45 ec             	mov    %eax,-0x14(%ebp)
	map_address_active((uint32_t) reqvaddr, paddr, PT_PUBLIC | PT_ALLOCATABLE);
  10633a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10633d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106340:	89 04 24             	mov    %eax,(%esp)
  106343:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106347:	c7 44 24 08 04 02 00 	movl   $0x204,0x8(%esp)
  10634e:	00 
  10634f:	e8 3c fc ff ff       	call   105f90 <map_address_active>

	if (retpaddr != 0)
  106354:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10635b:	0f 84 08 00 00 00    	je     106369 <vmm_alloc_addr+0xe9>
		*retpaddr = paddr;
  106361:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106364:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106367:	89 01                	mov    %eax,(%ecx)

	return reqvaddr;
  106369:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10636c:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  10636f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106372:	83 c4 34             	add    $0x34,%esp
  106375:	5e                   	pop    %esi
  106376:	5d                   	pop    %ebp
  106377:	c3                   	ret    
  106378:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10637f:	00 

00106380 <vmm_activate_pagedir>:

void vmm_activate_pagedir(uint32_t pdpaddr) {
  106380:	55                   	push   %ebp
  106381:	89 e5                	mov    %esp,%ebp
  106383:	50                   	push   %eax
  106384:	8b 45 08             	mov    0x8(%ebp),%eax
  106387:	89 45 fc             	mov    %eax,-0x4(%ebp)
	active_pagedir = pdpaddr;
  10638a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10638d:	a3 5c a4 10 00       	mov    %eax,0x10a45c
	asm volatile("mov %0, %%cr3" : : "r" (pdpaddr));
  106392:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106395:	0f 22 d8             	mov    %eax,%cr3
}
  106398:	83 c4 04             	add    $0x4,%esp
  10639b:	5d                   	pop    %ebp
  10639c:	c3                   	ret    
  10639d:	0f 1f 00             	nopl   (%eax)

001063a0 <vmm_init>:

uint32_t vmm_init(void) {
  1063a0:	55                   	push   %ebp
  1063a1:	89 e5                	mov    %esp,%ebp
	//CREATE CONTEXT ************************************************************

	struct vmm_context* context = pmm_alloc();
  1063a3:	53                   	push   %ebx
  1063a4:	57                   	push   %edi
  1063a5:	56                   	push   %esi
  1063a6:	83 ec 3c             	sub    $0x3c,%esp
  1063a9:	e8 b2 c0 ff ff       	call   102460 <pmm_alloc>
  1063ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t i, i2;

	context->pagedir = pmm_alloc();
  1063b1:	e8 aa c0 ff ff       	call   102460 <pmm_alloc>
  1063b6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1063b9:	89 01                	mov    %eax,(%ecx)

	for (i = 0; i < 1024; i++) {
  1063bb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1063c2:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  1063c9:	0f 83 d6 00 00 00    	jae    1064a5 <vmm_init+0x105>
		context->pagedir[i] = ((uint32_t) pmm_alloc());
  1063cf:	e8 8c c0 ff ff       	call   102460 <pmm_alloc>
  1063d4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1063d7:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1063da:	8b 12                	mov    (%edx),%edx
  1063dc:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		if (i < PMEM_TABLES) {
  1063df:	81 7d ec 80 00 00 00 	cmpl   $0x80,-0x14(%ebp)
  1063e6:	0f 83 15 00 00 00    	jae    106401 <vmm_init+0x61>
			kernel_pagetables[i] = context->pagedir[i];
  1063ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1063ef:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1063f2:	8b 09                	mov    (%ecx),%ecx
  1063f4:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1063f7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1063fa:	89 04 8d 90 a4 18 00 	mov    %eax,0x18a490(,%ecx,4)
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;
  106401:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106404:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106407:	8b 09                	mov    (%ecx),%ecx
  106409:	8b 14 81             	mov    (%ecx,%eax,4),%edx
  10640c:	81 ca 07 00 00 00    	or     $0x7,%edx
  106412:	89 14 81             	mov    %edx,(%ecx,%eax,4)

		for (i2 = 0; i2 < 1024; i2++) {
  106415:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10641c:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
  106423:	0f 83 67 00 00 00    	jae    106490 <vmm_init+0xf0>
  106429:	b8 04 00 00 00       	mov    $0x4,%eax
  10642e:	b9 00 00 00 00       	mov    $0x0,%ecx
  106433:	ba 00 02 00 00       	mov    $0x200,%edx
			uint32_t vaddr = (i << 22) + (i2 << 12);
  106438:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10643b:	c1 e6 16             	shl    $0x16,%esi
  10643e:	8b 7d e8             	mov    -0x18(%ebp),%edi
  106441:	c1 e7 0c             	shl    $0xc,%edi
  106444:	01 fe                	add    %edi,%esi
  106446:	89 75 e4             	mov    %esi,-0x1c(%ebp)

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
  106449:	81 7d e4 00 00 00 01 	cmpl   $0x1000000,-0x1c(%ebp)
  106450:	0f 97 c3             	seta   %bl
  106453:	84 db                	test   %bl,%bl
  106455:	0f 44 d1             	cmove  %ecx,%edx
  106458:	81 7d e4 00 10 40 20 	cmpl   $0x20401000,-0x1c(%ebp)
  10645f:	0f 97 c3             	seta   %bl
  106462:	84 db                	test   %bl,%bl
  106464:	0f 44 c1             	cmove  %ecx,%eax
  106467:	09 c2                	or     %eax,%edx
  106469:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10646c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10646f:	8b 75 f0             	mov    -0x10(%ebp),%esi
  106472:	8b 36                	mov    (%esi),%esi
  106474:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  106477:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  10647d:	89 14 81             	mov    %edx,(%ecx,%eax,4)
			kernel_pagetables[i] = context->pagedir[i];
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;

		for (i2 = 0; i2 < 1024; i2++) {
  106480:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106483:	05 01 00 00 00       	add    $0x1,%eax
  106488:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10648b:	e9 8c ff ff ff       	jmp    10641c <vmm_init+0x7c>

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}
  106490:	e9 00 00 00 00       	jmp    106495 <vmm_init+0xf5>
	struct vmm_context* context = pmm_alloc();
	uint32_t i, i2;

	context->pagedir = pmm_alloc();

	for (i = 0; i < 1024; i++) {
  106495:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106498:	05 01 00 00 00       	add    $0x1,%eax
  10649d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1064a0:	e9 1d ff ff ff       	jmp    1063c2 <vmm_init+0x22>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  1064a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1064ac:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  1064b3:	0f 83 5a 00 00 00    	jae    106513 <vmm_init+0x173>
  1064b9:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
  1064be:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1064c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1064c4:	8b 12                	mov    (%edx),%edx
  1064c6:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  1064c9:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  1064cf:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		map_address_context(context->pagedir,
  1064d2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1064d5:	8b 09                	mov    (%ecx),%ecx
  1064d7:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  1064dd:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1064e0:	c1 e6 0c             	shl    $0xc,%esi
  1064e3:	01 f2                	add    %esi,%edx
  1064e5:	8b 75 e0             	mov    -0x20(%ebp),%esi
  1064e8:	89 0c 24             	mov    %ecx,(%esp)
  1064eb:	89 54 24 04          	mov    %edx,0x4(%esp)
  1064ef:	89 74 24 08          	mov    %esi,0x8(%esp)
  1064f3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1064fa:	00 
  1064fb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1064fe:	e8 3d f7 ff ff       	call   105c40 <map_address_context>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  106503:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106506:	05 01 00 00 00       	add    $0x1,%eax
  10650b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10650e:	e9 99 ff ff ff       	jmp    1064ac <vmm_init+0x10c>
  106513:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(context->pagedir,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
  106518:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10651b:	8b 09                	mov    (%ecx),%ecx
  10651d:	8b 15 e8 71 10 00    	mov    0x1071e8,%edx
  106523:	8b 75 f0             	mov    -0x10(%ebp),%esi
  106526:	89 0c 24             	mov    %ecx,(%esp)
  106529:	89 54 24 04          	mov    %edx,0x4(%esp)
  10652d:	89 74 24 08          	mov    %esi,0x8(%esp)
  106531:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106538:	00 
  106539:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10653c:	e8 ff f6 ff ff       	call   105c40 <map_address_context>
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  106541:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
  106548:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
  10654e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  106551:	0f 83 3b 00 00 00    	jae    106592 <vmm_init+0x1f2>
  106557:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(context->pagedir, i, i, 0);
  10655c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10655f:	8b 09                	mov    (%ecx),%ecx
  106561:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106564:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106567:	89 0c 24             	mov    %ecx,(%esp)
  10656a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10656e:	89 74 24 08          	mov    %esi,0x8(%esp)
  106572:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106579:	00 
  10657a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10657d:	e8 be f6 ff ff       	call   105c40 <map_address_context>
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  106582:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106585:	05 00 10 00 00       	add    $0x1000,%eax
  10658a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10658d:	e9 b6 ff ff ff       	jmp    106548 <vmm_init+0x1a8>
		map_address_context(context->pagedir, i, i, 0);
	}

	//END CREATE CONTEXT ********************************************************

	vmm_activate_pagedir((uint32_t) context->pagedir);
  106592:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106595:	8b 00                	mov    (%eax),%eax
  106597:	89 04 24             	mov    %eax,(%esp)
  10659a:	e8 e1 fd ff ff       	call   106380 <vmm_activate_pagedir>

	uint32_t cr0;

	asm volatile("mov %%cr0, %0" : "=r" (cr0));
  10659f:	0f 20 c0             	mov    %cr0,%eax
  1065a2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= (1 << 31);
  1065a5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1065a8:	0d 00 00 00 80       	or     $0x80000000,%eax
  1065ad:	89 45 dc             	mov    %eax,-0x24(%ebp)
	asm volatile("mov %0, %%cr0" : : "r" (cr0));
  1065b0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1065b3:	0f 22 c0             	mov    %eax,%cr0

	return (uint32_t) active_context->pagedir;
  1065b6:	a1 e8 71 10 00       	mov    0x1071e8,%eax
  1065bb:	8b 00                	mov    (%eax),%eax
  1065bd:	83 c4 3c             	add    $0x3c,%esp
  1065c0:	5e                   	pop    %esi
  1065c1:	5f                   	pop    %edi
  1065c2:	5b                   	pop    %ebx
  1065c3:	5d                   	pop    %ebp
  1065c4:	c3                   	ret    
  1065c5:	66 90                	xchg   %ax,%ax
  1065c7:	90                   	nop

001065c8 <_start>:
  1065c8:	bc 60 a4 11 00       	mov    $0x11a460,%esp
  1065cd:	53                   	push   %ebx
  1065ce:	e8 3d 9a ff ff       	call   100010 <init>

001065d3 <_stop>:
  1065d3:	fa                   	cli    
  1065d4:	f4                   	hlt    
  1065d5:	eb fc                	jmp    1065d3 <_stop>

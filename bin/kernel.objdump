
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <kernel_start>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 66                	in     $0x66,%al
  10000d:	90                   	nop
  10000e:	66 90                	xchg   %ax,%ax

00100010 <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
  100010:	55                   	push   %ebp
  100011:	89 e5                	mov    %esp,%ebp
  100013:	83 ec 28             	sub    $0x28,%esp
  100016:	8b 45 08             	mov    0x8(%ebp),%eax
  100019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	clrscr();
  10001c:	e8 cf 04 00 00       	call   1004f0 <clrscr>
	pmm_init(mb_info);
  100021:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100024:	89 04 24             	mov    %eax,(%esp)
  100027:	e8 d4 28 00 00       	call   102900 <pmm_init>
  10002c:	8d 05 98 80 10 00    	lea    0x108098,%eax
  100032:	8d 0d bb 80 10 00    	lea    0x1080bb,%ecx

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100038:	89 04 24             	mov    %eax,(%esp)
  10003b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10003f:	e8 2c 05 00 00       	call   100570 <kprintf>
  100044:	8d 0d cf 80 10 00    	lea    0x1080cf,%ecx
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10004a:	89 0c 24             	mov    %ecx,(%esp)
  10004d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100050:	e8 1b 05 00 00       	call   100570 <kprintf>
  100055:	8d 0d 0e 81 10 00    	lea    0x10810e,%ecx

	kprintf("Initializing GDT...\n");
  10005b:	89 0c 24             	mov    %ecx,(%esp)
  10005e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100061:	e8 0a 05 00 00       	call   100570 <kprintf>

	init_gdt();
  100066:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100069:	e8 b2 0b 00 00       	call   100c20 <init_gdt>
  10006e:	8d 05 23 81 10 00    	lea    0x108123,%eax

	kprintf("Initializing IDT...\n");
  100074:	89 04 24             	mov    %eax,(%esp)
  100077:	e8 f4 04 00 00       	call   100570 <kprintf>
  10007c:	8d 0d 38 81 10 00    	lea    0x108138,%ecx

	init_idt();
  100082:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100085:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100088:	e8 b3 0d 00 00       	call   100e40 <init_idt>

	kprintf("Initializing in-kernel-Drivers...\n");
  10008d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100090:	89 04 24             	mov    %eax,(%esp)
  100093:	e8 d8 04 00 00       	call   100570 <kprintf>

	init_drivers();
  100098:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10009b:	e8 30 00 00 00       	call   1000d0 <init_drivers>
  1000a0:	8d 05 5b 81 10 00    	lea    0x10815b,%eax

	kprintf("Initializing Kernel...\n");
  1000a6:	89 04 24             	mov    %eax,(%esp)
  1000a9:	e8 c2 04 00 00       	call   100570 <kprintf>

	pmm_print_stats();
  1000ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1000b1:	e8 5a 26 00 00       	call   102710 <pmm_print_stats>

	kernel_main(mb_info);
  1000b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000b9:	89 04 24             	mov    %eax,(%esp)
  1000bc:	e8 af 22 00 00       	call   102370 <kernel_main>

	return;
  1000c1:	83 c4 28             	add    $0x28,%esp
  1000c4:	5d                   	pop    %ebp
  1000c5:	c3                   	ret    
  1000c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1000cd:	00 00 00 

001000d0 <init_drivers>:
#ifndef DRVINIT_H
#define DRVINIT_H

#include "keyboard.h"

static inline void init_drivers() {
  1000d0:	55                   	push   %ebp
  1000d1:	89 e5                	mov    %esp,%ebp
    init_keyboard_drv();
  1000d3:	83 ec 08             	sub    $0x8,%esp
  1000d6:	e8 05 02 00 00       	call   1002e0 <init_keyboard_drv>
}
  1000db:	83 c4 08             	add    $0x8,%esp
  1000de:	5d                   	pop    %ebp
  1000df:	c3                   	ret    

001000e0 <translate_scancode>:

static uint8_t buffer[4096];
static int bfindex = 0;

uint8_t translate_scancode(int set, uint16_t scancode)
{
  1000e0:	55                   	push   %ebp
  1000e1:	89 e5                	mov    %esp,%ebp
  1000e3:	83 ec 28             	sub    $0x28,%esp
  1000e6:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  1000ea:	66 89 c1             	mov    %ax,%cx
  1000ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1000f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1000f3:	66 89 4d fa          	mov    %cx,-0x6(%ebp)
  uint8_t keycode = 0;
  1000f7:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)

  switch (set) {
  1000fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000fe:	89 c2                	mov    %eax,%edx
  100100:	83 ea 02             	sub    $0x2,%edx
  100103:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100106:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100109:	0f 84 4f 00 00 00    	je     10015e <translate_scancode+0x7e>
  10010f:	e9 00 00 00 00       	jmp    100114 <translate_scancode+0x34>
  100114:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100117:	83 e8 01             	sub    $0x1,%eax
  10011a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10011d:	0f 84 28 00 00 00    	je     10014b <translate_scancode+0x6b>
  100123:	e9 00 00 00 00       	jmp    100128 <translate_scancode+0x48>
  100128:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10012b:	85 c0                	test   %eax,%eax
  10012d:	0f 85 54 00 00 00    	jne    100187 <translate_scancode+0xa7>
  100133:	e9 00 00 00 00       	jmp    100138 <translate_scancode+0x58>
    case 0:
      keycode = sc_to_kc[0][scancode];
  100138:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10013c:	8a 0c 05 00 70 10 00 	mov    0x107000(,%eax,1),%cl
  100143:	88 4d f9             	mov    %cl,-0x7(%ebp)
      break;
  100146:	e9 3c 00 00 00       	jmp    100187 <translate_scancode+0xa7>
    case 1:
      keycode = sc_to_kc[1][scancode];
  10014b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10014f:	8a 0c 05 80 70 10 00 	mov    0x107080(,%eax,1),%cl
  100156:	88 4d f9             	mov    %cl,-0x7(%ebp)
      break;
  100159:	e9 29 00 00 00       	jmp    100187 <translate_scancode+0xa7>
    case 2:
      switch (scancode) {
  10015e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100162:	2d 1d 45 00 00       	sub    $0x451d,%eax
  100167:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10016a:	0f 85 0e 00 00 00    	jne    10017e <translate_scancode+0x9e>
  100170:	e9 00 00 00 00       	jmp    100175 <translate_scancode+0x95>
        case 0x451D:
          keycode = 119;
  100175:	c6 45 f9 77          	movb   $0x77,-0x7(%ebp)
          break;
  100179:	e9 04 00 00 00       	jmp    100182 <translate_scancode+0xa2>

        default:
          keycode = 0x0;	
  10017e:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)
      };
      break;
  100182:	e9 00 00 00 00       	jmp    100187 <translate_scancode+0xa7>
  }

  if (keycode == 0) {
  100187:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  10018b:	3d 00 00 00 00       	cmp    $0x0,%eax
  100190:	0f 85 20 00 00 00    	jne    1001b6 <translate_scancode+0xd6>
  100196:	8d 05 73 81 10 00    	lea    0x108173,%eax
      kprintf("kbc: Unbekannter Scancode: 0x%x (%d)\n", scancode, set);
  10019c:	0f b7 4d fa          	movzwl -0x6(%ebp),%ecx
  1001a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1001a3:	89 04 24             	mov    %eax,(%esp)
  1001a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1001aa:	89 54 24 08          	mov    %edx,0x8(%esp)
  1001ae:	e8 bd 03 00 00       	call   100570 <kprintf>
  1001b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }

  return keycode;
  1001b6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  1001ba:	83 c4 28             	add    $0x28,%esp
  1001bd:	5d                   	pop    %ebp
  1001be:	c3                   	ret    
  1001bf:	90                   	nop

001001c0 <keyboard_handler>:
}

void keyboard_handler() {    
  1001c0:	55                   	push   %ebp
  1001c1:	89 e5                	mov    %esp,%ebp
  return;
  1001c3:	5d                   	pop    %ebp
  1001c4:	c3                   	ret    
  1001c5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1001cc:	00 00 00 00 

001001d0 <getc>:
		//buffer[bfindex] = keycode;
		//bfindex++;	
	}
}

char getc() {
  1001d0:	55                   	push   %ebp
  1001d1:	89 e5                	mov    %esp,%ebp
	char ret = buffer[0];
  1001d3:	83 ec 08             	sub    $0x8,%esp
  1001d6:	a0 0a 90 10 00       	mov    0x10900a,%al
  1001db:	88 45 ff             	mov    %al,-0x1(%ebp)
	
	int i;
	for(i = 0; i < bfindex; i++) {
  1001de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001e8:	3b 05 0c a0 10 00    	cmp    0x10a00c,%eax
  1001ee:	0f 8d 24 00 00 00    	jge    100218 <getc+0x48>
		buffer[i] = buffer[i+1];	
  1001f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001f7:	8a 0c 05 0b 90 10 00 	mov    0x10900b(,%eax,1),%cl
  1001fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100201:	88 0c 05 0a 90 10 00 	mov    %cl,0x10900a(,%eax,1)

char getc() {
	char ret = buffer[0];
	
	int i;
	for(i = 0; i < bfindex; i++) {
  100208:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10020b:	05 01 00 00 00       	add    $0x1,%eax
  100210:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100213:	e9 cd ff ff ff       	jmp    1001e5 <getc+0x15>
		buffer[i] = buffer[i+1];	
	}
	bfindex--;
  100218:	a1 0c a0 10 00       	mov    0x10a00c,%eax
  10021d:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100222:	a3 0c a0 10 00       	mov    %eax,0x10a00c

	return ret;
  100227:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  10022b:	83 c4 08             	add    $0x8,%esp
  10022e:	5d                   	pop    %ebp
  10022f:	c3                   	ret    

00100230 <send_command>:
}

void send_command(uint8_t command) {
  100230:	55                   	push   %ebp
  100231:	89 e5                	mov    %esp,%ebp
  100233:	83 ec 18             	sub    $0x18,%esp
  100236:	8a 45 08             	mov    0x8(%ebp),%al
  100239:	88 45 ff             	mov    %al,-0x1(%ebp)
  10023c:	b8 64 00 00 00       	mov    $0x64,%eax
	while((inb(0x64) & 0x2)) { }
  100241:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100248:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10024b:	e8 40 00 00 00       	call   100290 <inb>
  100250:	0f b6 c8             	movzbl %al,%ecx
  100253:	81 e1 02 00 00 00    	and    $0x2,%ecx
  100259:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  10025f:	0f 84 05 00 00 00    	je     10026a <send_command+0x3a>
  100265:	e9 d2 ff ff ff       	jmp    10023c <send_command+0xc>
  10026a:	b8 60 00 00 00       	mov    $0x60,%eax
	outb(0x60, command);
  10026f:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100276:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  10027a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10027e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100281:	e8 2a 00 00 00       	call   1002b0 <outb>
}
  100286:	83 c4 18             	add    $0x18,%esp
  100289:	5d                   	pop    %ebp
  10028a:	c3                   	ret    
  10028b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00100290 <inb>:
    uint16_t result;
    asm volatile ("inw %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline uint8_t inb(uint16_t _port) {
  100290:	55                   	push   %ebp
  100291:	89 e5                	mov    %esp,%ebp
  100293:	50                   	push   %eax
  100294:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100298:	66 89 c1             	mov    %ax,%cx
  10029b:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
    uint8_t result;
    asm volatile ("inb %1, %0" : "=a" (result) : "Nd" (_port));
  10029f:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1002a3:	ec                   	in     (%dx),%al
  1002a4:	88 45 fd             	mov    %al,-0x3(%ebp)
    return result;
  1002a7:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  1002ab:	83 c4 04             	add    $0x4,%esp
  1002ae:	5d                   	pop    %ebp
  1002af:	c3                   	ret    

001002b0 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  1002b0:	55                   	push   %ebp
  1002b1:	89 e5                	mov    %esp,%ebp
  1002b3:	50                   	push   %eax
  1002b4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1002b8:	66 89 c1             	mov    %ax,%cx
  1002bb:	8a 55 0c             	mov    0xc(%ebp),%dl
  1002be:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  1002c2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  1002c5:	8a 45 fd             	mov    -0x3(%ebp),%al
  1002c8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1002cc:	ee                   	out    %al,(%dx)
}
  1002cd:	83 c4 04             	add    $0x4,%esp
  1002d0:	5d                   	pop    %ebp
  1002d1:	c3                   	ret    
  1002d2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1002d9:	1f 84 00 00 00 00 00 

001002e0 <init_keyboard_drv>:

void init_keyboard_drv() {
  1002e0:	55                   	push   %ebp
  1002e1:	89 e5                	mov    %esp,%ebp
  1002e3:	83 ec 28             	sub    $0x28,%esp
  1002e6:	b8 21 00 00 00       	mov    $0x21,%eax
  1002eb:	8d 0d c0 01 10 00    	lea    0x1001c0,%ecx
	register_intr_handler(0x21, &keyboard_handler);
  1002f1:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1002f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1002fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1002ff:	e8 6c 17 00 00       	call   101a70 <register_intr_handler>
  100304:	b8 64 00 00 00       	mov    $0x64,%eax

	while(inb(0x64) & 0x1) {
  100309:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100310:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100313:	e8 78 ff ff ff       	call   100290 <inb>
  100318:	0f b6 c8             	movzbl %al,%ecx
  10031b:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100321:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100327:	0f 84 1c 00 00 00    	je     100349 <init_keyboard_drv+0x69>
  10032d:	b8 60 00 00 00       	mov    $0x60,%eax
		inb(0x60);
  100332:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100339:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10033c:	e8 4f ff ff ff       	call   100290 <inb>
	}
  100341:	88 45 f3             	mov    %al,-0xd(%ebp)
  100344:	e9 bb ff ff ff       	jmp    100304 <init_keyboard_drv+0x24>
  100349:	b8 f4 00 00 00       	mov    $0xf4,%eax

	send_command(0xF4);
  10034e:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp)
  100355:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100358:	e8 d3 fe ff ff       	call   100230 <send_command>

	init_done = 1;
  10035d:	c7 05 10 a0 10 00 01 	movl   $0x1,0x10a010
  100364:	00 00 00 
}
  100367:	83 c4 28             	add    $0x28,%esp
  10036a:	5d                   	pop    %ebp
  10036b:	c3                   	ret    
  10036c:	66 90                	xchg   %ax,%ax
  10036e:	66 90                	xchg   %ax,%ax

00100370 <in_cod>:
#include "catofdeath.h"

static uint32_t icod = 0;

uint32_t in_cod() {
  100370:	55                   	push   %ebp
  100371:	89 e5                	mov    %esp,%ebp
    return icod;
  100373:	a1 14 a0 10 00       	mov    0x10a014,%eax
  100378:	5d                   	pop    %ebp
  100379:	c3                   	ret    
  10037a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00100380 <show_cod>:
}

void show_cod(struct cpu_state* cpu, char* fstr) {
  100380:	55                   	push   %ebp
  100381:	89 e5                	mov    %esp,%ebp
  100383:	56                   	push   %esi
  100384:	83 ec 24             	sub    $0x24,%esp
  100387:	8b 45 0c             	mov    0xc(%ebp),%eax
  10038a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10038d:	ba 04 00 00 00       	mov    $0x4,%edx
  100392:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100395:	89 45 f4             	mov    %eax,-0xc(%ebp)
    icod = 1;
  100398:	c7 05 14 a0 10 00 01 	movl   $0x1,0x10a014
  10039f:	00 00 00 
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
  1003a2:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1003a9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1003ac:	e8 9f 01 00 00       	call   100550 <setclr>
    kprintf(fstr);
  1003b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003b4:	89 04 24             	mov    %eax,(%esp)
  1003b7:	e8 b4 01 00 00       	call   100570 <kprintf>
  1003bc:	8d 0d 99 81 10 00    	lea    0x108199,%ecx
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  1003c2:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1003c5:	8b 52 1c             	mov    0x1c(%edx),%edx
  1003c8:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1003cb:	8b 76 20             	mov    0x20(%esi),%esi
  1003ce:	89 0c 24             	mov    %ecx,(%esp)
  1003d1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1003d5:	89 74 24 08          	mov    %esi,0x8(%esp)
  1003d9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1003dc:	e8 8f 01 00 00       	call   100570 <kprintf>
    show_dump(cpu);
  1003e1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1003e4:	89 0c 24             	mov    %ecx,(%esp)
  1003e7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1003ea:	e8 11 00 00 00       	call   100400 <show_dump>

    while (1) {
        asm volatile("cli; hlt");
  1003ef:	fa                   	cli    
  1003f0:	f4                   	hlt    
    }
  1003f1:	e9 f9 ff ff ff       	jmp    1003ef <show_cod+0x6f>
  1003f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1003fd:	00 00 00 

00100400 <show_dump>:
}

void show_dump(struct cpu_state* cpu) {
  100400:	55                   	push   %ebp
  100401:	89 e5                	mov    %esp,%ebp
  100403:	53                   	push   %ebx
  100404:	57                   	push   %edi
  100405:	56                   	push   %esi
  100406:	83 ec 2c             	sub    $0x2c,%esp
  100409:	8b 45 08             	mov    0x8(%ebp),%eax
  10040c:	8d 0d be 81 10 00    	lea    0x1081be,%ecx
  100412:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  100415:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100418:	8b 00                	mov    (%eax),%eax
  10041a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10041d:	8b 52 04             	mov    0x4(%edx),%edx
  100420:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100423:	8b 76 08             	mov    0x8(%esi),%esi
  100426:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100429:	8b 7f 0c             	mov    0xc(%edi),%edi
  10042c:	89 0c 24             	mov    %ecx,(%esp)
  10042f:	89 44 24 04          	mov    %eax,0x4(%esp)
  100433:	89 54 24 08          	mov    %edx,0x8(%esp)
  100437:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10043b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10043f:	e8 2c 01 00 00       	call   100570 <kprintf>
  100444:	8d 0d df 81 10 00    	lea    0x1081df,%ecx
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  10044a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10044d:	8b 52 10             	mov    0x10(%edx),%edx
  100450:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100453:	8b 76 14             	mov    0x14(%esi),%esi
  100456:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100459:	8b 7f 18             	mov    0x18(%edi),%edi
  10045c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10045f:	8b 5b 24             	mov    0x24(%ebx),%ebx
  100462:	89 0c 24             	mov    %ecx,(%esp)
  100465:	89 54 24 04          	mov    %edx,0x4(%esp)
  100469:	89 74 24 08          	mov    %esi,0x8(%esp)
  10046d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  100471:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  100475:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100478:	e8 f3 00 00 00       	call   100570 <kprintf>
  10047d:	8d 0d 00 82 10 00    	lea    0x108200,%ecx
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
  100483:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100486:	8b 52 28             	mov    0x28(%edx),%edx
  100489:	8b 75 f0             	mov    -0x10(%ebp),%esi
  10048c:	8b 76 2c             	mov    0x2c(%esi),%esi
  10048f:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100492:	8b 7f 30             	mov    0x30(%edi),%edi
  100495:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  100498:	8b 5b 34             	mov    0x34(%ebx),%ebx
  10049b:	89 0c 24             	mov    %ecx,(%esp)
  10049e:	89 54 24 04          	mov    %edx,0x4(%esp)
  1004a2:	89 74 24 08          	mov    %esi,0x8(%esp)
  1004a6:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1004aa:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1004ae:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1004b1:	e8 ba 00 00 00       	call   100570 <kprintf>
  1004b6:	8d 0d 22 82 10 00    	lea    0x108222,%ecx
            cpu->esp, cpu->ss);

    uint32_t cr2 = 0;
  1004bc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  1004c3:	0f 20 d2             	mov    %cr2,%edx
  1004c6:	89 55 ec             	mov    %edx,-0x14(%ebp)

    kprintf("CR2: %x \n", cr2);
  1004c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1004cc:	89 0c 24             	mov    %ecx,(%esp)
  1004cf:	89 54 24 04          	mov    %edx,0x4(%esp)
  1004d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1004d6:	e8 95 00 00 00       	call   100570 <kprintf>
}
  1004db:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1004de:	83 c4 2c             	add    $0x2c,%esp
  1004e1:	5e                   	pop    %esi
  1004e2:	5f                   	pop    %edi
  1004e3:	5b                   	pop    %ebx
  1004e4:	5d                   	pop    %ebp
  1004e5:	c3                   	ret    
  1004e6:	66 90                	xchg   %ax,%ax
  1004e8:	66 90                	xchg   %ax,%ax
  1004ea:	66 90                	xchg   %ax,%ax
  1004ec:	66 90                	xchg   %ax,%ax
  1004ee:	66 90                	xchg   %ax,%ax

001004f0 <clrscr>:
        x /= base;
    } while (x);
    kputs(p);
}

void clrscr(void) {
  1004f0:	55                   	push   %ebp
  1004f1:	89 e5                	mov    %esp,%ebp
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  1004f3:	50                   	push   %eax
  1004f4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1004fb:	81 7d fc a0 0f 00 00 	cmpl   $0xfa0,-0x4(%ebp)
  100502:	0f 8d 1d 00 00 00    	jge    100525 <clrscr+0x35>
        video[i] = 0;
  100508:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10050b:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  100511:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    kputs(p);
}

void clrscr(void) {
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  100515:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100518:	05 01 00 00 00       	add    $0x1,%eax
  10051d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100520:	e9 d6 ff ff ff       	jmp    1004fb <clrscr+0xb>
        video[i] = 0;
    }

    color = 0x07;
  100525:	c6 05 04 71 10 00 07 	movb   $0x7,0x107104

    x = y = 0;
  10052c:	c7 05 18 a0 10 00 00 	movl   $0x0,0x10a018
  100533:	00 00 00 
  100536:	c7 05 1c a0 10 00 00 	movl   $0x0,0x10a01c
  10053d:	00 00 00 
}
  100540:	83 c4 04             	add    $0x4,%esp
  100543:	5d                   	pop    %ebp
  100544:	c3                   	ret    
  100545:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10054c:	00 00 00 00 

00100550 <setclr>:

void setclr(char clr) {
  100550:	55                   	push   %ebp
  100551:	89 e5                	mov    %esp,%ebp
  100553:	50                   	push   %eax
  100554:	8a 45 08             	mov    0x8(%ebp),%al
  100557:	88 45 ff             	mov    %al,-0x1(%ebp)
    color = clr;
  10055a:	8a 45 ff             	mov    -0x1(%ebp),%al
  10055d:	a2 04 71 10 00       	mov    %al,0x107104
}
  100562:	83 c4 04             	add    $0x4,%esp
  100565:	5d                   	pop    %ebp
  100566:	c3                   	ret    
  100567:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10056e:	00 00 

00100570 <kprintf>:

int kprintf(const char* fmt, ...) {
  100570:	55                   	push   %ebp
  100571:	89 e5                	mov    %esp,%ebp
  100573:	83 ec 58             	sub    $0x58,%esp
  100576:	8b 45 08             	mov    0x8(%ebp),%eax
  100579:	8d 4d f8             	lea    -0x8(%ebp),%ecx
  10057c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10057f:	8d 45 0c             	lea    0xc(%ebp),%eax
    va_list ap;
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
  100582:	89 01                	mov    %eax,(%ecx)
    kprintf_res = 0;
  100584:	c7 05 20 a0 10 00 00 	movl   $0x0,0x10a020
  10058b:	00 00 00 
    while (*fmt) {
  10058e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100591:	80 38 00             	cmpb   $0x0,(%eax)
  100594:	0f 84 dd 01 00 00    	je     100777 <kprintf+0x207>
        if (*fmt == '%') {
  10059a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10059d:	0f be 00             	movsbl (%eax),%eax
  1005a0:	3d 25 00 00 00       	cmp    $0x25,%eax
  1005a5:	0f 85 ae 01 00 00    	jne    100759 <kprintf+0x1e9>
            fmt++;
  1005ab:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1005ae:	89 c1                	mov    %eax,%ecx
  1005b0:	41                   	inc    %ecx
  1005b1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
            switch (*fmt) {
  1005b4:	0f be 40 01          	movsbl 0x1(%eax),%eax
  1005b8:	89 c1                	mov    %eax,%ecx
  1005ba:	83 e9 24             	sub    $0x24,%ecx
  1005bd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1005c0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1005c3:	0f 8f 15 00 00 00    	jg     1005de <kprintf+0x6e>
  1005c9:	e9 00 00 00 00       	jmp    1005ce <kprintf+0x5e>
  1005ce:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005d1:	85 c0                	test   %eax,%eax
  1005d3:	0f 84 54 01 00 00    	je     10072d <kprintf+0x1bd>
  1005d9:	e9 54 01 00 00       	jmp    100732 <kprintf+0x1c2>
  1005de:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005e1:	83 e8 62             	sub    $0x62,%eax
  1005e4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1005e7:	0f 8f 19 00 00 00    	jg     100606 <kprintf+0x96>
  1005ed:	e9 00 00 00 00       	jmp    1005f2 <kprintf+0x82>
  1005f2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005f5:	83 e8 25             	sub    $0x25,%eax
  1005f8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1005fb:	0f 84 13 01 00 00    	je     100714 <kprintf+0x1a4>
  100601:	e9 2c 01 00 00       	jmp    100732 <kprintf+0x1c2>
  100606:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100609:	83 e8 6f             	sub    $0x6f,%eax
  10060c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10060f:	0f 8f 2d 00 00 00    	jg     100642 <kprintf+0xd2>
  100615:	e9 00 00 00 00       	jmp    10061a <kprintf+0xaa>
  10061a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10061d:	83 e8 63             	sub    $0x63,%eax
  100620:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100623:	0f 84 c5 00 00 00    	je     1006ee <kprintf+0x17e>
  100629:	e9 00 00 00 00       	jmp    10062e <kprintf+0xbe>
  10062e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100631:	83 e8 64             	sub    $0x64,%eax
  100634:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100637:	0f 84 4b 00 00 00    	je     100688 <kprintf+0x118>
  10063d:	e9 f0 00 00 00       	jmp    100732 <kprintf+0x1c2>
  100642:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100645:	83 c0 90             	add    $0xffffff90,%eax
  100648:	89 c1                	mov    %eax,%ecx
  10064a:	83 e9 08             	sub    $0x8,%ecx
  10064d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100650:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  100653:	0f 87 d9 00 00 00    	ja     100732 <kprintf+0x1c2>
  100659:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10065c:	8b 0c 85 00 80 10 00 	mov    0x108000(,%eax,4),%ecx
  100663:	ff e1                	jmp    *%ecx
            case 's':
                s = va_arg(ap, char*);
  100665:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100668:	89 c1                	mov    %eax,%ecx
  10066a:	81 c1 04 00 00 00    	add    $0x4,%ecx
  100670:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100673:	8b 00                	mov    (%eax),%eax
  100675:	89 45 f4             	mov    %eax,-0xc(%ebp)
                kputs(s);
  100678:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10067b:	89 04 24             	mov    %eax,(%esp)
  10067e:	e8 0d 01 00 00       	call   100790 <kputs>
                break;
  100683:	e9 cc 00 00 00       	jmp    100754 <kprintf+0x1e4>
  100688:	b8 0a 00 00 00       	mov    $0xa,%eax
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
  10068d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100690:	89 ca                	mov    %ecx,%edx
  100692:	81 c2 04 00 00 00    	add    $0x4,%edx
  100698:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10069b:	8b 09                	mov    (%ecx),%ecx
  10069d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 10);
  1006a0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1006a3:	89 0c 24             	mov    %ecx,(%esp)
  1006a6:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1006ad:	00 
  1006ae:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1006b1:	e8 1a 01 00 00       	call   1007d0 <kputn>
                break;
  1006b6:	e9 99 00 00 00       	jmp    100754 <kprintf+0x1e4>
  1006bb:	b8 10 00 00 00       	mov    $0x10,%eax
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
  1006c0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1006c3:	89 ca                	mov    %ecx,%edx
  1006c5:	81 c2 04 00 00 00    	add    $0x4,%edx
  1006cb:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1006ce:	8b 09                	mov    (%ecx),%ecx
  1006d0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 16);
  1006d3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1006d6:	89 0c 24             	mov    %ecx,(%esp)
  1006d9:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  1006e0:	00 
  1006e1:	89 45 c0             	mov    %eax,-0x40(%ebp)
  1006e4:	e8 e7 00 00 00       	call   1007d0 <kputn>
                break;
  1006e9:	e9 66 00 00 00       	jmp    100754 <kprintf+0x1e4>
            case 'c':
                c = va_arg(ap, int);
  1006ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1006f1:	89 c1                	mov    %eax,%ecx
  1006f3:	81 c1 04 00 00 00    	add    $0x4,%ecx
  1006f9:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1006fc:	8b 00                	mov    (%eax),%eax
  1006fe:	88 c2                	mov    %al,%dl
  100700:	88 55 ef             	mov    %dl,-0x11(%ebp)
                kputc(c);
  100703:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  100707:	89 04 24             	mov    %eax,(%esp)
  10070a:	e8 61 01 00 00       	call   100870 <kputc>
                break;
  10070f:	e9 40 00 00 00       	jmp    100754 <kprintf+0x1e4>
  100714:	b8 25 00 00 00       	mov    $0x25,%eax
            case '%':
                kputc('%');
  100719:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100720:	89 45 bc             	mov    %eax,-0x44(%ebp)
  100723:	e8 48 01 00 00       	call   100870 <kputc>
                break;
  100728:	e9 27 00 00 00       	jmp    100754 <kprintf+0x1e4>
            case '\0':
                goto out;
  10072d:	e9 4a 00 00 00       	jmp    10077c <kprintf+0x20c>
  100732:	b8 25 00 00 00       	mov    $0x25,%eax
            default:
                kputc('%');
  100737:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10073e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100741:	e8 2a 01 00 00       	call   100870 <kputc>
                kputc(*fmt);
  100746:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100749:	0f be 00             	movsbl (%eax),%eax
  10074c:	89 04 24             	mov    %eax,(%esp)
  10074f:	e8 1c 01 00 00       	call   100870 <kputc>
                break;
            }
        } else {
  100754:	e9 0e 00 00 00       	jmp    100767 <kprintf+0x1f7>
            kputc(*fmt);
  100759:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10075c:	0f be 00             	movsbl (%eax),%eax
  10075f:	89 04 24             	mov    %eax,(%esp)
  100762:	e8 09 01 00 00       	call   100870 <kputc>
        }

        fmt++;
  100767:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10076a:	05 01 00 00 00       	add    $0x1,%eax
  10076f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  100772:	e9 17 fe ff ff       	jmp    10058e <kprintf+0x1e>
  100777:	e9 00 00 00 00       	jmp    10077c <kprintf+0x20c>

    out:
    va_end(ap);

    return kprintf_res;
  10077c:	a1 20 a0 10 00       	mov    0x10a020,%eax
  100781:	83 c4 58             	add    $0x58,%esp
  100784:	5d                   	pop    %ebp
  100785:	c3                   	ret    
  100786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10078d:	00 00 00 

00100790 <kputs>:

    x++;
    kprintf_res++;
}

static void kputs(const char* s) {
  100790:	55                   	push   %ebp
  100791:	89 e5                	mov    %esp,%ebp
  100793:	83 ec 08             	sub    $0x8,%esp
  100796:	8b 45 08             	mov    0x8(%ebp),%eax
  100799:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*s) {
  10079c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10079f:	80 38 00             	cmpb   $0x0,(%eax)
  1007a2:	0f 84 1e 00 00 00    	je     1007c6 <kputs+0x36>
        kputc(*s++);
  1007a8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1007ab:	89 c1                	mov    %eax,%ecx
  1007ad:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1007b3:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1007b6:	0f be 00             	movsbl (%eax),%eax
  1007b9:	89 04 24             	mov    %eax,(%esp)
  1007bc:	e8 af 00 00 00       	call   100870 <kputc>
    }
  1007c1:	e9 d6 ff ff ff       	jmp    10079c <kputs+0xc>
}
  1007c6:	83 c4 08             	add    $0x8,%esp
  1007c9:	5d                   	pop    %ebp
  1007ca:	c3                   	ret    
  1007cb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001007d0 <kputn>:

static void kputn(unsigned long x, int base) {
  1007d0:	55                   	push   %ebp
  1007d1:	89 e5                	mov    %esp,%ebp
  1007d3:	56                   	push   %esi
  1007d4:	83 ec 64             	sub    $0x64,%esp
  1007d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1007da:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1007dd:	8d 15 2c 82 10 00    	lea    0x10822c,%edx
  1007e3:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1007e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  1007e9:	89 55 ac             	mov    %edx,-0x54(%ebp)
    char* p;

    if (base > 36) {
  1007ec:	81 7d f4 24 00 00 00 	cmpl   $0x24,-0xc(%ebp)
  1007f3:	0f 8e 05 00 00 00    	jle    1007fe <kputn+0x2e>
        return;
  1007f9:	e9 5d 00 00 00       	jmp    10085b <kputn+0x8b>
  1007fe:	8d 45 b3             	lea    -0x4d(%ebp),%eax
    }

    p = buf + 64;
  100801:	05 40 00 00 00       	add    $0x40,%eax
  100806:	89 45 a8             	mov    %eax,-0x58(%ebp)
    *p = '\0';
  100809:	8b 45 a8             	mov    -0x58(%ebp),%eax
  10080c:	c6 00 00             	movb   $0x0,(%eax)
    do {
        *--p = digits[x % base];
  10080f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100812:	31 d2                	xor    %edx,%edx
  100814:	f7 75 f4             	divl   -0xc(%ebp)
  100817:	8b 45 ac             	mov    -0x54(%ebp),%eax
  10081a:	8a 0c 10             	mov    (%eax,%edx,1),%cl
  10081d:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100820:	89 c2                	mov    %eax,%edx
  100822:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
  100828:	89 55 a8             	mov    %edx,-0x58(%ebp)
  10082b:	88 48 ff             	mov    %cl,-0x1(%eax)
        x /= base;
  10082e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100831:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100834:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  100837:	89 d0                	mov    %edx,%eax
  100839:	31 d2                	xor    %edx,%edx
  10083b:	8b 75 a4             	mov    -0x5c(%ebp),%esi
  10083e:	f7 f6                	div    %esi
  100840:	89 45 f8             	mov    %eax,-0x8(%ebp)
    } while (x);
  100843:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10084a:	0f 85 bf ff ff ff    	jne    10080f <kputn+0x3f>
    kputs(p);
  100850:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100853:	89 04 24             	mov    %eax,(%esp)
  100856:	e8 35 ff ff ff       	call   100790 <kputs>
}
  10085b:	83 c4 64             	add    $0x64,%esp
  10085e:	5e                   	pop    %esi
  10085f:	5d                   	pop    %ebp
  100860:	c3                   	ret    
  100861:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  100868:	0f 1f 84 00 00 00 00 
  10086f:	00 

00100870 <kputc>:
static int kprintf_res = 0;
static char color = 0x07;

static char* video = (char*) 0xb8000;

static void kputc(char c) {
  100870:	55                   	push   %ebp
  100871:	89 e5                	mov    %esp,%ebp
  100873:	83 ec 38             	sub    $0x38,%esp
  100876:	8a 45 08             	mov    0x8(%ebp),%al
  100879:	88 45 ff             	mov    %al,-0x1(%ebp)
    if(in_cod()) {
  10087c:	e8 ef fa ff ff       	call   100370 <in_cod>
  100881:	3d 00 00 00 00       	cmp    $0x0,%eax
  100886:	0f 84 05 00 00 00    	je     100891 <kputc+0x21>
        goto doKPutc;
  10088c:	e9 e3 00 00 00       	jmp    100974 <kputc+0x104>
    }

    if(get_current_task() != 0) {
  100891:	e8 2a 32 00 00       	call   103ac0 <get_current_task>
  100896:	3d 00 00 00 00       	cmp    $0x0,%eax
  10089b:	0f 84 b9 00 00 00    	je     10095a <kputc+0xea>
        if(get_current_task()->stdout != 0) {
  1008a1:	e8 1a 32 00 00       	call   103ac0 <get_current_task>
  1008a6:	81 78 1c 00 00 00 00 	cmpl   $0x0,0x1c(%eax)
  1008ad:	0f 84 a2 00 00 00    	je     100955 <kputc+0xe5>
            vfs_write(get_current_task()->stdout, &(char){0x11}, sizeof(char), 1);
  1008b3:	e8 08 32 00 00       	call   103ac0 <get_current_task>
  1008b8:	8d 4d fe             	lea    -0x2(%ebp),%ecx
  1008bb:	ba 01 00 00 00       	mov    $0x1,%edx
  1008c0:	8b 40 1c             	mov    0x1c(%eax),%eax
  1008c3:	c6 45 fe 11          	movb   $0x11,-0x2(%ebp)
  1008c7:	89 04 24             	mov    %eax,(%esp)
  1008ca:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1008ce:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  1008d5:	00 
  1008d6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1008dd:	00 
  1008de:	89 55 f4             	mov    %edx,-0xc(%ebp)
  1008e1:	e8 3a 49 00 00       	call   105220 <vfs_write>
            vfs_write(get_current_task()->stdout, &color, sizeof(char), 1);
  1008e6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1008e9:	e8 d2 31 00 00       	call   103ac0 <get_current_task>
  1008ee:	8d 0d 04 71 10 00    	lea    0x107104,%ecx
  1008f4:	ba 01 00 00 00       	mov    $0x1,%edx
  1008f9:	8b 40 1c             	mov    0x1c(%eax),%eax
  1008fc:	89 04 24             	mov    %eax,(%esp)
  1008ff:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100903:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10090a:	00 
  10090b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100912:	00 
  100913:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100916:	e8 05 49 00 00       	call   105220 <vfs_write>
            vfs_write(get_current_task()->stdout, &c, sizeof(char), 1);
  10091b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10091e:	e8 9d 31 00 00       	call   103ac0 <get_current_task>
  100923:	8d 4d ff             	lea    -0x1(%ebp),%ecx
  100926:	ba 01 00 00 00       	mov    $0x1,%edx
  10092b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10092e:	89 04 24             	mov    %eax,(%esp)
  100931:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100935:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10093c:	00 
  10093d:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100944:	00 
  100945:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  100948:	e8 d3 48 00 00       	call   105220 <vfs_write>

            return;
  10094d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100950:	e9 5e 01 00 00       	jmp    100ab3 <kputc+0x243>
        }
    }
  100955:	e9 00 00 00 00       	jmp    10095a <kputc+0xea>

    if(ramfs_vga_writers()) {
  10095a:	e8 31 31 00 00       	call   103a90 <ramfs_vga_writers>
  10095f:	3d 00 00 00 00       	cmp    $0x0,%eax
  100964:	0f 84 05 00 00 00    	je     10096f <kputc+0xff>
        return;
  10096a:	e9 44 01 00 00       	jmp    100ab3 <kputc+0x243>
    }
  10096f:	e9 00 00 00 00       	jmp    100974 <kputc+0x104>

    doKPutc:

    if ((c == '\n') || (x > 79)) {
  100974:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  100978:	3d 0a 00 00 00       	cmp    $0xa,%eax
  10097d:	0f 84 10 00 00 00    	je     100993 <kputc+0x123>
  100983:	81 3d 1c a0 10 00 4f 	cmpl   $0x4f,0x10a01c
  10098a:	00 00 00 
  10098d:	0f 8e 19 00 00 00    	jle    1009ac <kputc+0x13c>
        x = 0;
  100993:	c7 05 1c a0 10 00 00 	movl   $0x0,0x10a01c
  10099a:	00 00 00 
        y++;
  10099d:	a1 18 a0 10 00       	mov    0x10a018,%eax
  1009a2:	05 01 00 00 00       	add    $0x1,%eax
  1009a7:	a3 18 a0 10 00       	mov    %eax,0x10a018
    }

    if (c == '\n') {
  1009ac:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  1009b0:	3d 0a 00 00 00       	cmp    $0xa,%eax
  1009b5:	0f 85 05 00 00 00    	jne    1009c0 <kputc+0x150>
        return;
  1009bb:	e9 f3 00 00 00       	jmp    100ab3 <kputc+0x243>
    }

    if (y > 24) {
  1009c0:	81 3d 18 a0 10 00 18 	cmpl   $0x18,0x10a018
  1009c7:	00 00 00 
  1009ca:	0f 8e 7e 00 00 00    	jle    100a4e <kputc+0x1de>
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  1009d0:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1009d7:	81 7d f8 00 0f 00 00 	cmpl   $0xf00,-0x8(%ebp)
  1009de:	0f 8d 2c 00 00 00    	jge    100a10 <kputc+0x1a0>
            video[i] = video[i + 160];
  1009e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1009e7:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  1009ed:	8a 94 01 a0 00 00 00 	mov    0xa0(%ecx,%eax,1),%dl
  1009f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1009f7:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  1009fd:	88 14 01             	mov    %dl,(%ecx,%eax,1)
        return;
    }

    if (y > 24) {
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  100a00:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100a03:	05 01 00 00 00       	add    $0x1,%eax
  100a08:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100a0b:	e9 c7 ff ff ff       	jmp    1009d7 <kputc+0x167>
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  100a10:	e9 00 00 00 00       	jmp    100a15 <kputc+0x1a5>
  100a15:	81 7d f8 a0 0f 00 00 	cmpl   $0xfa0,-0x8(%ebp)
  100a1c:	0f 8d 1d 00 00 00    	jge    100a3f <kputc+0x1cf>
            video[i] = 0;
  100a22:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100a25:	8b 0d 00 71 10 00    	mov    0x107100,%ecx
  100a2b:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  100a2f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100a32:	05 01 00 00 00       	add    $0x1,%eax
  100a37:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100a3a:	e9 d6 ff ff ff       	jmp    100a15 <kputc+0x1a5>
            video[i] = 0;
        }
        y--;
  100a3f:	a1 18 a0 10 00       	mov    0x10a018,%eax
  100a44:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100a49:	a3 18 a0 10 00       	mov    %eax,0x10a018
    }

    video[2 * (y * 80 + x)] = c;
  100a4e:	8a 45 ff             	mov    -0x1(%ebp),%al
  100a51:	69 0d 18 a0 10 00 50 	imul   $0x50,0x10a018,%ecx
  100a58:	00 00 00 
  100a5b:	03 0d 1c a0 10 00    	add    0x10a01c,%ecx
  100a61:	c1 e1 01             	shl    $0x1,%ecx
  100a64:	8b 15 00 71 10 00    	mov    0x107100,%edx
  100a6a:	88 04 0a             	mov    %al,(%edx,%ecx,1)
    video[2 * (y * 80 + x) + 1] = color;
  100a6d:	a0 04 71 10 00       	mov    0x107104,%al
  100a72:	69 0d 18 a0 10 00 50 	imul   $0x50,0x10a018,%ecx
  100a79:	00 00 00 
  100a7c:	03 0d 1c a0 10 00    	add    0x10a01c,%ecx
  100a82:	c1 e1 01             	shl    $0x1,%ecx
  100a85:	8b 15 00 71 10 00    	mov    0x107100,%edx
  100a8b:	88 44 0a 01          	mov    %al,0x1(%edx,%ecx,1)

    x++;
  100a8f:	8b 0d 1c a0 10 00    	mov    0x10a01c,%ecx
  100a95:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100a9b:	89 0d 1c a0 10 00    	mov    %ecx,0x10a01c
    kprintf_res++;
  100aa1:	8b 0d 20 a0 10 00    	mov    0x10a020,%ecx
  100aa7:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100aad:	89 0d 20 a0 10 00    	mov    %ecx,0x10a020
}
  100ab3:	83 c4 38             	add    $0x38,%esp
  100ab6:	5d                   	pop    %ebp
  100ab7:	c3                   	ret    
  100ab8:	66 90                	xchg   %ax,%ax
  100aba:	66 90                	xchg   %ax,%ax
  100abc:	66 90                	xchg   %ax,%ax
  100abe:	66 90                	xchg   %ax,%ax

00100ac0 <load_gdt>:

#define GDT_ENTRIES 6

uint64_t gdt[GDT_ENTRIES];

void load_gdt() {
  100ac0:	55                   	push   %ebp
  100ac1:	89 e5                	mov    %esp,%ebp
	struct {
  100ac3:	83 ec 08             	sub    $0x8,%esp
  100ac6:	a1 24 80 10 00       	mov    0x108024,%eax
  100acb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100ace:	66 8b 0d 28 80 10 00 	mov    0x108028,%cx
  100ad5:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
		uint16_t limit;
		void* pointer;
	}__attribute__((packed)) gdtp = { .limit = GDT_ENTRIES * 8 - 1, .pointer =
			gdt, };

	asm volatile("lgdt %0" : : "m" (gdtp));
  100ad9:	0f 01 55 f8          	lgdtl  -0x8(%ebp)

	asm ("mov $0x10, %ax");
  100add:	66 b8 10 00          	mov    $0x10,%ax
	asm ("mov %ax, %ds");
  100ae1:	66 8e d8             	mov    %ax,%ds
	asm ("mov %ax, %es");
  100ae4:	66 8e c0             	mov    %ax,%es
	asm ("mov %ax, %fs");
  100ae7:	66 8e e0             	mov    %ax,%fs
	asm ("mov %ax, %gs");
  100aea:	66 8e e8             	mov    %ax,%gs
	asm ("mov %ax, %ss");
  100aed:	66 8e d0             	mov    %ax,%ss
	//asm ("ljmp $0x8, $.1");
	//asm (".1:");
}
  100af0:	83 c4 08             	add    $0x8,%esp
  100af3:	5d                   	pop    %ebp
  100af4:	c3                   	ret    
  100af5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  100afc:	00 00 00 00 

00100b00 <set_gdt_entry>:

void set_gdt_entry(int i, unsigned int base, unsigned int limit, int flags) {
  100b00:	55                   	push   %ebp
  100b01:	89 e5                	mov    %esp,%ebp
  100b03:	56                   	push   %esi
  100b04:	83 ec 10             	sub    $0x10,%esp
  100b07:	8b 45 14             	mov    0x14(%ebp),%eax
  100b0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100b0d:	8b 55 0c             	mov    0xc(%ebp),%edx
  100b10:	8b 75 08             	mov    0x8(%ebp),%esi
  100b13:	89 75 f8             	mov    %esi,-0x8(%ebp)
  100b16:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100b19:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100b1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gdt[i] = limit & 0xffffLL;
  100b1f:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  100b23:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100b26:	89 04 cd 68 a4 12 00 	mov    %eax,0x12a468(,%ecx,8)
  100b2d:	c7 04 cd 6c a4 12 00 	movl   $0x0,0x12a46c(,%ecx,8)
  100b34:	00 00 00 00 
	gdt[i] |= (base & 0xffffffLL) << 16;
  100b38:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b3b:	25 ff ff ff 00       	and    $0xffffff,%eax
  100b40:	89 c1                	mov    %eax,%ecx
  100b42:	c1 e1 10             	shl    $0x10,%ecx
  100b45:	c1 e8 10             	shr    $0x10,%eax
  100b48:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100b4b:	8b 34 d5 6c a4 12 00 	mov    0x12a46c(,%edx,8),%esi
  100b52:	09 f0                	or     %esi,%eax
  100b54:	8b 34 d5 68 a4 12 00 	mov    0x12a468(,%edx,8),%esi
  100b5b:	09 ce                	or     %ecx,%esi
  100b5d:	89 04 d5 6c a4 12 00 	mov    %eax,0x12a46c(,%edx,8)
  100b64:	89 34 d5 68 a4 12 00 	mov    %esi,0x12a468(,%edx,8)
	gdt[i] |= (flags & 0xffLL) << 40;
  100b6b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100b6f:	c1 e0 08             	shl    $0x8,%eax
  100b72:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100b75:	8b 14 cd 68 a4 12 00 	mov    0x12a468(,%ecx,8),%edx
  100b7c:	8b 34 cd 6c a4 12 00 	mov    0x12a46c(,%ecx,8),%esi
  100b83:	09 c6                	or     %eax,%esi
  100b85:	89 14 cd 68 a4 12 00 	mov    %edx,0x12a468(,%ecx,8)
  100b8c:	89 34 cd 6c a4 12 00 	mov    %esi,0x12a46c(,%ecx,8)
	gdt[i] |= ((limit >> 16) & 0xfLL) << 48;
  100b93:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  100b97:	83 e0 0f             	and    $0xf,%eax
  100b9a:	c1 e0 10             	shl    $0x10,%eax
  100b9d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100ba0:	8b 14 cd 68 a4 12 00 	mov    0x12a468(,%ecx,8),%edx
  100ba7:	8b 34 cd 6c a4 12 00 	mov    0x12a46c(,%ecx,8),%esi
  100bae:	09 c6                	or     %eax,%esi
  100bb0:	89 14 cd 68 a4 12 00 	mov    %edx,0x12a468(,%ecx,8)
  100bb7:	89 34 cd 6c a4 12 00 	mov    %esi,0x12a46c(,%ecx,8)
	gdt[i] |= ((flags >> 8) & 0xffLL) << 52;
  100bbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100bc1:	c1 e0 0c             	shl    $0xc,%eax
  100bc4:	25 00 00 f0 0f       	and    $0xff00000,%eax
  100bc9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100bcc:	8b 14 cd 68 a4 12 00 	mov    0x12a468(,%ecx,8),%edx
  100bd3:	8b 34 cd 6c a4 12 00 	mov    0x12a46c(,%ecx,8),%esi
  100bda:	09 c6                	or     %eax,%esi
  100bdc:	89 14 cd 68 a4 12 00 	mov    %edx,0x12a468(,%ecx,8)
  100be3:	89 34 cd 6c a4 12 00 	mov    %esi,0x12a46c(,%ecx,8)
	gdt[i] |= ((base >> 24) & 0xffLL) << 56;
  100bea:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100bee:	c1 e0 18             	shl    $0x18,%eax
  100bf1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100bf4:	8b 14 cd 68 a4 12 00 	mov    0x12a468(,%ecx,8),%edx
  100bfb:	8b 34 cd 6c a4 12 00 	mov    0x12a46c(,%ecx,8),%esi
  100c02:	09 c6                	or     %eax,%esi
  100c04:	89 14 cd 68 a4 12 00 	mov    %edx,0x12a468(,%ecx,8)
  100c0b:	89 34 cd 6c a4 12 00 	mov    %esi,0x12a46c(,%ecx,8)
}
  100c12:	83 c4 10             	add    $0x10,%esp
  100c15:	5e                   	pop    %esi
  100c16:	5d                   	pop    %ebp
  100c17:	c3                   	ret    
  100c18:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  100c1f:	00 

00100c20 <init_gdt>:

void init_gdt(void) {
  100c20:	55                   	push   %ebp
  100c21:	89 e5                	mov    %esp,%ebp
  100c23:	56                   	push   %esi
  100c24:	83 ec 54             	sub    $0x54,%esp
  100c27:	b8 00 00 00 00       	mov    $0x0,%eax
	set_gdt_entry(0, 0, 0, 0);
  100c2c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100c33:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100c3a:	00 
  100c3b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100c42:	00 
  100c43:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100c4a:	00 
  100c4b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100c4e:	e8 ad fe ff ff       	call   100b00 <set_gdt_entry>
  100c53:	b8 01 00 00 00       	mov    $0x1,%eax
  100c58:	b9 00 00 00 00       	mov    $0x0,%ecx
  100c5d:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100c62:	be 9a 0c 00 00       	mov    $0xc9a,%esi
	set_gdt_entry(1, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100c67:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100c6e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100c75:	00 
  100c76:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100c7d:	00 
  100c7e:	c7 44 24 0c 9a 0c 00 	movl   $0xc9a,0xc(%esp)
  100c85:	00 
  100c86:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100c89:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100c8c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100c8f:	89 75 e8             	mov    %esi,-0x18(%ebp)
  100c92:	e8 69 fe ff ff       	call   100b00 <set_gdt_entry>
  100c97:	b8 02 00 00 00       	mov    $0x2,%eax
  100c9c:	b9 00 00 00 00       	mov    $0x0,%ecx
  100ca1:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100ca6:	be 92 0c 00 00       	mov    $0xc92,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(2, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100cab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100cb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100cb9:	00 
  100cba:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100cc1:	00 
  100cc2:	c7 44 24 0c 92 0c 00 	movl   $0xc92,0xc(%esp)
  100cc9:	00 
  100cca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100ccd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  100cd0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  100cd3:	89 75 d8             	mov    %esi,-0x28(%ebp)
  100cd6:	e8 25 fe ff ff       	call   100b00 <set_gdt_entry>
  100cdb:	b8 03 00 00 00       	mov    $0x3,%eax
  100ce0:	b9 00 00 00 00       	mov    $0x0,%ecx
  100ce5:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100cea:	be fa 0c 00 00       	mov    $0xcfa,%esi
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(3, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100cef:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  100cf6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100cfd:	00 
  100cfe:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100d05:	00 
  100d06:	c7 44 24 0c fa 0c 00 	movl   $0xcfa,0xc(%esp)
  100d0d:	00 
  100d0e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100d11:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  100d14:	89 55 cc             	mov    %edx,-0x34(%ebp)
  100d17:	89 75 c8             	mov    %esi,-0x38(%ebp)
  100d1a:	e8 e1 fd ff ff       	call   100b00 <set_gdt_entry>
  100d1f:	b8 04 00 00 00       	mov    $0x4,%eax
  100d24:	b9 00 00 00 00       	mov    $0x0,%ecx
  100d29:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100d2e:	be f2 0c 00 00       	mov    $0xcf2,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);
	set_gdt_entry(4, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100d33:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  100d3a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100d41:	00 
  100d42:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100d49:	00 
  100d4a:	c7 44 24 0c f2 0c 00 	movl   $0xcf2,0xc(%esp)
  100d51:	00 
  100d52:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  100d55:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  100d58:	89 55 bc             	mov    %edx,-0x44(%ebp)
  100d5b:	89 75 b8             	mov    %esi,-0x48(%ebp)
  100d5e:	e8 9d fd ff ff       	call   100b00 <set_gdt_entry>
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	load_gdt();
  100d63:	e8 58 fd ff ff       	call   100ac0 <load_gdt>
}
  100d68:	83 c4 54             	add    $0x54,%esp
  100d6b:	5e                   	pop    %esi
  100d6c:	5d                   	pop    %ebp
  100d6d:	c3                   	ret    
  100d6e:	66 90                	xchg   %ax,%ax

00100d70 <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  100d70:	55                   	push   %ebp
  100d71:	89 e5                	mov    %esp,%ebp
  100d73:	53                   	push   %ebx
  100d74:	57                   	push   %edi
  100d75:	56                   	push   %esi
  100d76:	83 ec 10             	sub    $0x10,%esp
  100d79:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  100d7d:	66 89 c1             	mov    %ax,%cx
  100d80:	8a 55 14             	mov    0x14(%ebp),%dl
  100d83:	8b 45 0c             	mov    0xc(%ebp),%eax
  100d86:	8b 75 08             	mov    0x8(%ebp),%esi
  100d89:	89 75 f0             	mov    %esi,-0x10(%ebp)
  100d8c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100d8f:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  100d93:	88 55 e9             	mov    %dl,-0x17(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  100d96:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100d99:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	idt[i] = handler & 0xffffLL;
  100d9c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  100da0:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100da3:	89 04 f5 28 a0 10 00 	mov    %eax,0x10a028(,%esi,8)
  100daa:	c7 04 f5 2c a0 10 00 	movl   $0x0,0x10a02c(,%esi,8)
  100db1:	00 00 00 00 
	idt[i] |= (selector & 0xffffLL) << 16;
  100db5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
  100db9:	c1 e0 10             	shl    $0x10,%eax
  100dbc:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100dbf:	8b 3c f5 2c a0 10 00 	mov    0x10a02c(,%esi,8),%edi
  100dc6:	8b 1c f5 28 a0 10 00 	mov    0x10a028(,%esi,8),%ebx
  100dcd:	09 c3                	or     %eax,%ebx
  100dcf:	89 3c f5 2c a0 10 00 	mov    %edi,0x10a02c(,%esi,8)
  100dd6:	89 1c f5 28 a0 10 00 	mov    %ebx,0x10a028(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  100ddd:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  100de1:	c1 e0 08             	shl    $0x8,%eax
  100de4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100de7:	8b 3c f5 28 a0 10 00 	mov    0x10a028(,%esi,8),%edi
  100dee:	8b 1c f5 2c a0 10 00 	mov    0x10a02c(,%esi,8),%ebx
  100df5:	09 c3                	or     %eax,%ebx
  100df7:	89 3c f5 28 a0 10 00 	mov    %edi,0x10a028(,%esi,8)
  100dfe:	89 1c f5 2c a0 10 00 	mov    %ebx,0x10a02c(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  100e05:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  100e09:	c1 e0 10             	shl    $0x10,%eax
  100e0c:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100e0f:	8b 3c f5 28 a0 10 00 	mov    0x10a028(,%esi,8),%edi
  100e16:	8b 1c f5 2c a0 10 00 	mov    0x10a02c(,%esi,8),%ebx
  100e1d:	09 c3                	or     %eax,%ebx
  100e1f:	89 3c f5 28 a0 10 00 	mov    %edi,0x10a028(,%esi,8)
  100e26:	89 1c f5 2c a0 10 00 	mov    %ebx,0x10a02c(,%esi,8)
}
  100e2d:	83 c4 10             	add    $0x10,%esp
  100e30:	5e                   	pop    %esi
  100e31:	5f                   	pop    %edi
  100e32:	5b                   	pop    %ebx
  100e33:	5d                   	pop    %ebp
  100e34:	c3                   	ret    
  100e35:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  100e3c:	00 00 00 00 

00100e40 <init_idt>:

void init_idt() {
  100e40:	55                   	push   %ebp
  100e41:	89 e5                	mov    %esp,%ebp
	struct {
  100e43:	56                   	push   %esi
  100e44:	81 ec 34 02 00 00    	sub    $0x234,%esp
  100e4a:	a1 2a 80 10 00       	mov    0x10802a,%eax
  100e4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100e52:	66 8b 0d 2e 80 10 00 	mov    0x10802e,%cx
  100e59:	66 89 4d f4          	mov    %cx,-0xc(%ebp)
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;
  100e5d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  100e64:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100e6b:	81 7d ec 40 00 00 00 	cmpl   $0x40,-0x14(%ebp)
  100e72:	0f 8d 1e 00 00 00    	jge    100e96 <init_idt+0x56>
		handler_set[i] = 0;
  100e78:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100e7b:	c7 04 85 28 a2 10 00 	movl   $0x0,0x10a228(,%eax,4)
  100e82:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  100e86:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100e89:	05 01 00 00 00       	add    $0x1,%eax
  100e8e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100e91:	e9 d5 ff ff ff       	jmp    100e6b <init_idt+0x2b>
  100e96:	b8 20 00 00 00       	mov    $0x20,%eax
  100e9b:	b9 11 00 00 00       	mov    $0x11,%ecx
		handler_set[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  100ea0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  100ea7:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  100eae:	00 
  100eaf:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100eb2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100eb5:	e8 86 0b 00 00       	call   101a40 <outb>
  100eba:	b8 21 00 00 00       	mov    $0x21,%eax
  100ebf:	b9 20 00 00 00       	mov    $0x20,%ecx
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  100ec4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100ecb:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  100ed2:	00 
  100ed3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100ed6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  100ed9:	e8 62 0b 00 00       	call   101a40 <outb>
  100ede:	b8 21 00 00 00       	mov    $0x21,%eax
  100ee3:	b9 04 00 00 00       	mov    $0x4,%ecx
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  100ee8:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100eef:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  100ef6:	00 
  100ef7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100efa:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  100efd:	e8 3e 0b 00 00       	call   101a40 <outb>
  100f02:	b8 21 00 00 00       	mov    $0x21,%eax
  100f07:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0x21, 0x01); // ICW 4
  100f0c:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100f13:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100f1a:	00 
  100f1b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100f1e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  100f21:	e8 1a 0b 00 00       	call   101a40 <outb>
  100f26:	b8 a0 00 00 00       	mov    $0xa0,%eax
  100f2b:	b9 11 00 00 00       	mov    $0x11,%ecx

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  100f30:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  100f37:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  100f3e:	00 
  100f3f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  100f42:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  100f45:	e8 f6 0a 00 00       	call   101a40 <outb>
  100f4a:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100f4f:	b9 28 00 00 00       	mov    $0x28,%ecx
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  100f54:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100f5b:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  100f62:	00 
  100f63:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100f66:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  100f69:	e8 d2 0a 00 00       	call   101a40 <outb>
  100f6e:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100f73:	b9 02 00 00 00       	mov    $0x2,%ecx
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  100f78:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100f7f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  100f86:	00 
  100f87:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100f8a:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  100f8d:	e8 ae 0a 00 00       	call   101a40 <outb>
  100f92:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100f97:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0xa1, 0x01); // ICW 4
  100f9c:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100fa3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100faa:	00 
  100fab:	89 45 b0             	mov    %eax,-0x50(%ebp)
  100fae:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  100fb1:	e8 8a 0a 00 00       	call   101a40 <outb>
  100fb6:	b8 20 00 00 00       	mov    $0x20,%eax
  100fbb:	b9 00 00 00 00       	mov    $0x0,%ecx

	outb(0x20, 0x0);
  100fc0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  100fc7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100fce:	00 
  100fcf:	89 45 a8             	mov    %eax,-0x58(%ebp)
  100fd2:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  100fd5:	e8 66 0a 00 00       	call   101a40 <outb>
  100fda:	b8 a0 00 00 00       	mov    $0xa0,%eax
  100fdf:	b9 00 00 00 00       	mov    $0x0,%ecx
	outb(0xa0, 0x0);
  100fe4:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  100feb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ff2:	00 
  100ff3:	89 45 a0             	mov    %eax,-0x60(%ebp)
  100ff6:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  100ff9:	e8 42 0a 00 00       	call   101a40 <outb>
  100ffe:	b8 00 00 00 00       	mov    $0x0,%eax
  101003:	8d 0d 14 1c 10 00    	lea    0x101c14,%ecx
  101009:	ba 08 00 00 00       	mov    $0x8,%edx
  10100e:	be 8e 00 00 00       	mov    $0x8e,%esi

	idt_set_entry(0, intr_stub_0, 0x8,
  101013:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10101a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10101e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101025:	00 
  101026:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10102d:	00 
  10102e:	89 45 98             	mov    %eax,-0x68(%ebp)
  101031:	89 75 94             	mov    %esi,-0x6c(%ebp)
  101034:	89 55 90             	mov    %edx,-0x70(%ebp)
  101037:	e8 34 fd ff ff       	call   100d70 <idt_set_entry>
  10103c:	b8 01 00 00 00       	mov    $0x1,%eax
  101041:	8d 0d 1d 1c 10 00    	lea    0x101c1d,%ecx
  101047:	ba 08 00 00 00       	mov    $0x8,%edx
  10104c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  101051:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  101058:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10105c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101063:	00 
  101064:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10106b:	00 
  10106c:	89 45 8c             	mov    %eax,-0x74(%ebp)
  10106f:	89 75 88             	mov    %esi,-0x78(%ebp)
  101072:	89 55 84             	mov    %edx,-0x7c(%ebp)
  101075:	e8 f6 fc ff ff       	call   100d70 <idt_set_entry>
  10107a:	b8 02 00 00 00       	mov    $0x2,%eax
  10107f:	8d 0d 26 1c 10 00    	lea    0x101c26,%ecx
  101085:	ba 08 00 00 00       	mov    $0x8,%edx
  10108a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  10108f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  101096:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10109a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1010a1:	00 
  1010a2:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1010a9:	00 
  1010aa:	89 45 80             	mov    %eax,-0x80(%ebp)
  1010ad:	89 b5 7c ff ff ff    	mov    %esi,-0x84(%ebp)
  1010b3:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
  1010b9:	e8 b2 fc ff ff       	call   100d70 <idt_set_entry>
  1010be:	b8 03 00 00 00       	mov    $0x3,%eax
  1010c3:	8d 0d 2f 1c 10 00    	lea    0x101c2f,%ecx
  1010c9:	ba 08 00 00 00       	mov    $0x8,%edx
  1010ce:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  1010d3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1010da:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1010de:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1010e5:	00 
  1010e6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1010ed:	00 
  1010ee:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  1010f4:	89 b5 70 ff ff ff    	mov    %esi,-0x90(%ebp)
  1010fa:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  101100:	e8 6b fc ff ff       	call   100d70 <idt_set_entry>
  101105:	b8 04 00 00 00       	mov    $0x4,%eax
  10110a:	8d 0d 38 1c 10 00    	lea    0x101c38,%ecx
  101110:	ba 08 00 00 00       	mov    $0x8,%edx
  101115:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  10111a:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  101121:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101125:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10112c:	00 
  10112d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101134:	00 
  101135:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  10113b:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
  101141:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
  101147:	e8 24 fc ff ff       	call   100d70 <idt_set_entry>
  10114c:	b8 05 00 00 00       	mov    $0x5,%eax
  101151:	8d 0d 41 1c 10 00    	lea    0x101c41,%ecx
  101157:	ba 08 00 00 00       	mov    $0x8,%edx
  10115c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  101161:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101168:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10116c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101173:	00 
  101174:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10117b:	00 
  10117c:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  101182:	89 b5 58 ff ff ff    	mov    %esi,-0xa8(%ebp)
  101188:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
  10118e:	e8 dd fb ff ff       	call   100d70 <idt_set_entry>
  101193:	b8 06 00 00 00       	mov    $0x6,%eax
  101198:	8d 0d 4a 1c 10 00    	lea    0x101c4a,%ecx
  10119e:	ba 08 00 00 00       	mov    $0x8,%edx
  1011a3:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  1011a8:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1011af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1011b3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1011ba:	00 
  1011bb:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1011c2:	00 
  1011c3:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  1011c9:	89 b5 4c ff ff ff    	mov    %esi,-0xb4(%ebp)
  1011cf:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
  1011d5:	e8 96 fb ff ff       	call   100d70 <idt_set_entry>
  1011da:	b8 07 00 00 00       	mov    $0x7,%eax
  1011df:	8d 0d 53 1c 10 00    	lea    0x101c53,%ecx
  1011e5:	ba 08 00 00 00       	mov    $0x8,%edx
  1011ea:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  1011ef:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  1011f6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1011fa:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101201:	00 
  101202:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101209:	00 
  10120a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  101210:	89 b5 40 ff ff ff    	mov    %esi,-0xc0(%ebp)
  101216:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
  10121c:	e8 4f fb ff ff       	call   100d70 <idt_set_entry>
  101221:	b8 08 00 00 00       	mov    $0x8,%eax
  101226:	8d 0d 5c 1c 10 00    	lea    0x101c5c,%ecx
  10122c:	ba 8e 00 00 00       	mov    $0x8e,%edx
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  101231:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  101238:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10123c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101243:	00 
  101244:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10124b:	00 
  10124c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
  101252:	89 95 34 ff ff ff    	mov    %edx,-0xcc(%ebp)
  101258:	e8 13 fb ff ff       	call   100d70 <idt_set_entry>
  10125d:	b8 09 00 00 00       	mov    $0x9,%eax
  101262:	8d 0d 63 1c 10 00    	lea    0x101c63,%ecx
  101268:	ba 08 00 00 00       	mov    $0x8,%edx
  10126d:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  101272:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  101279:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10127d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101284:	00 
  101285:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10128c:	00 
  10128d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
  101293:	89 b5 2c ff ff ff    	mov    %esi,-0xd4(%ebp)
  101299:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%ebp)
  10129f:	e8 cc fa ff ff       	call   100d70 <idt_set_entry>
  1012a4:	b8 0a 00 00 00       	mov    $0xa,%eax
  1012a9:	8d 0d 6c 1c 10 00    	lea    0x101c6c,%ecx
  1012af:	ba 08 00 00 00       	mov    $0x8,%edx
  1012b4:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  1012b9:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1012c0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1012c4:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1012cb:	00 
  1012cc:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1012d3:	00 
  1012d4:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  1012da:	89 b5 20 ff ff ff    	mov    %esi,-0xe0(%ebp)
  1012e0:	89 95 1c ff ff ff    	mov    %edx,-0xe4(%ebp)
  1012e6:	e8 85 fa ff ff       	call   100d70 <idt_set_entry>
  1012eb:	b8 0b 00 00 00       	mov    $0xb,%eax
  1012f0:	8d 0d 73 1c 10 00    	lea    0x101c73,%ecx
  1012f6:	ba 08 00 00 00       	mov    $0x8,%edx
  1012fb:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  101300:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  101307:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10130b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101312:	00 
  101313:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10131a:	00 
  10131b:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  101321:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%ebp)
  101327:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
  10132d:	e8 3e fa ff ff       	call   100d70 <idt_set_entry>
  101332:	b8 0c 00 00 00       	mov    $0xc,%eax
  101337:	8d 0d 7a 1c 10 00    	lea    0x101c7a,%ecx
  10133d:	ba 08 00 00 00       	mov    $0x8,%edx
  101342:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  101347:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10134e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101352:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101359:	00 
  10135a:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101361:	00 
  101362:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  101368:	89 b5 08 ff ff ff    	mov    %esi,-0xf8(%ebp)
  10136e:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
  101374:	e8 f7 f9 ff ff       	call   100d70 <idt_set_entry>
  101379:	b8 0d 00 00 00       	mov    $0xd,%eax
  10137e:	8d 0d 81 1c 10 00    	lea    0x101c81,%ecx
  101384:	ba 08 00 00 00       	mov    $0x8,%edx
  101389:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  10138e:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  101395:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101399:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1013a0:	00 
  1013a1:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1013a8:	00 
  1013a9:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
  1013af:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
  1013b5:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
  1013bb:	e8 b0 f9 ff ff       	call   100d70 <idt_set_entry>
  1013c0:	b8 0e 00 00 00       	mov    $0xe,%eax
  1013c5:	8d 0d 88 1c 10 00    	lea    0x101c88,%ecx
  1013cb:	ba 08 00 00 00       	mov    $0x8,%edx
  1013d0:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  1013d5:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  1013dc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1013e0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1013e7:	00 
  1013e8:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1013ef:	00 
  1013f0:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
  1013f6:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
  1013fc:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
  101402:	e8 69 f9 ff ff       	call   100d70 <idt_set_entry>
  101407:	b8 0f 00 00 00       	mov    $0xf,%eax
  10140c:	8d 0d 8c 1c 10 00    	lea    0x101c8c,%ecx
  101412:	ba 08 00 00 00       	mov    $0x8,%edx
  101417:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  10141c:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  101423:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101427:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10142e:	00 
  10142f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101436:	00 
  101437:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
  10143d:	89 b5 e4 fe ff ff    	mov    %esi,-0x11c(%ebp)
  101443:	89 95 e0 fe ff ff    	mov    %edx,-0x120(%ebp)
  101449:	e8 22 f9 ff ff       	call   100d70 <idt_set_entry>
  10144e:	b8 10 00 00 00       	mov    $0x10,%eax
  101453:	8d 0d 92 1c 10 00    	lea    0x101c92,%ecx
  101459:	ba 08 00 00 00       	mov    $0x8,%edx
  10145e:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  101463:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10146a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10146e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101475:	00 
  101476:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10147d:	00 
  10147e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
  101484:	89 b5 d8 fe ff ff    	mov    %esi,-0x128(%ebp)
  10148a:	89 95 d4 fe ff ff    	mov    %edx,-0x12c(%ebp)
  101490:	e8 db f8 ff ff       	call   100d70 <idt_set_entry>
  101495:	b8 11 00 00 00       	mov    $0x11,%eax
  10149a:	8d 0d 98 1c 10 00    	lea    0x101c98,%ecx
  1014a0:	ba 08 00 00 00       	mov    $0x8,%edx
  1014a5:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  1014aa:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  1014b1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014b5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014bc:	00 
  1014bd:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014c4:	00 
  1014c5:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
  1014cb:	89 b5 cc fe ff ff    	mov    %esi,-0x134(%ebp)
  1014d1:	89 95 c8 fe ff ff    	mov    %edx,-0x138(%ebp)
  1014d7:	e8 94 f8 ff ff       	call   100d70 <idt_set_entry>
  1014dc:	b8 12 00 00 00       	mov    $0x12,%eax
  1014e1:	8d 0d 9c 1c 10 00    	lea    0x101c9c,%ecx
  1014e7:	ba 08 00 00 00       	mov    $0x8,%edx
  1014ec:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  1014f1:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  1014f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014fc:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101503:	00 
  101504:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10150b:	00 
  10150c:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  101512:	89 b5 c0 fe ff ff    	mov    %esi,-0x140(%ebp)
  101518:	89 95 bc fe ff ff    	mov    %edx,-0x144(%ebp)
  10151e:	e8 4d f8 ff ff       	call   100d70 <idt_set_entry>
  101523:	b8 20 00 00 00       	mov    $0x20,%eax
  101528:	8d 0d a2 1c 10 00    	lea    0x101ca2,%ecx
  10152e:	ba 08 00 00 00       	mov    $0x8,%edx
  101533:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  101538:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10153f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101543:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10154a:	00 
  10154b:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101552:	00 
  101553:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
  101559:	89 b5 b4 fe ff ff    	mov    %esi,-0x14c(%ebp)
  10155f:	89 95 b0 fe ff ff    	mov    %edx,-0x150(%ebp)
  101565:	e8 06 f8 ff ff       	call   100d70 <idt_set_entry>
  10156a:	b8 21 00 00 00       	mov    $0x21,%eax
  10156f:	8d 0d a8 1c 10 00    	lea    0x101ca8,%ecx
  101575:	ba 08 00 00 00       	mov    $0x8,%edx
  10157a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  10157f:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101586:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10158a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101591:	00 
  101592:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101599:	00 
  10159a:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
  1015a0:	89 b5 a8 fe ff ff    	mov    %esi,-0x158(%ebp)
  1015a6:	89 95 a4 fe ff ff    	mov    %edx,-0x15c(%ebp)
  1015ac:	e8 bf f7 ff ff       	call   100d70 <idt_set_entry>
  1015b1:	b8 22 00 00 00       	mov    $0x22,%eax
  1015b6:	8d 0d ae 1c 10 00    	lea    0x101cae,%ecx
  1015bc:	ba 08 00 00 00       	mov    $0x8,%edx
  1015c1:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  1015c6:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1015cd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015d1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1015d8:	00 
  1015d9:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015e0:	00 
  1015e1:	89 85 a0 fe ff ff    	mov    %eax,-0x160(%ebp)
  1015e7:	89 b5 9c fe ff ff    	mov    %esi,-0x164(%ebp)
  1015ed:	89 95 98 fe ff ff    	mov    %edx,-0x168(%ebp)
  1015f3:	e8 78 f7 ff ff       	call   100d70 <idt_set_entry>
  1015f8:	b8 23 00 00 00       	mov    $0x23,%eax
  1015fd:	8d 0d b4 1c 10 00    	lea    0x101cb4,%ecx
  101603:	ba 08 00 00 00       	mov    $0x8,%edx
  101608:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  10160d:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  101614:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101618:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10161f:	00 
  101620:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101627:	00 
  101628:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
  10162e:	89 b5 90 fe ff ff    	mov    %esi,-0x170(%ebp)
  101634:	89 95 8c fe ff ff    	mov    %edx,-0x174(%ebp)
  10163a:	e8 31 f7 ff ff       	call   100d70 <idt_set_entry>
  10163f:	b8 24 00 00 00       	mov    $0x24,%eax
  101644:	8d 0d ba 1c 10 00    	lea    0x101cba,%ecx
  10164a:	ba 08 00 00 00       	mov    $0x8,%edx
  10164f:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  101654:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  10165b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10165f:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101666:	00 
  101667:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10166e:	00 
  10166f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
  101675:	89 b5 84 fe ff ff    	mov    %esi,-0x17c(%ebp)
  10167b:	89 95 80 fe ff ff    	mov    %edx,-0x180(%ebp)
  101681:	e8 ea f6 ff ff       	call   100d70 <idt_set_entry>
  101686:	b8 25 00 00 00       	mov    $0x25,%eax
  10168b:	8d 0d c0 1c 10 00    	lea    0x101cc0,%ecx
  101691:	ba 08 00 00 00       	mov    $0x8,%edx
  101696:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  10169b:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  1016a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016a6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1016ad:	00 
  1016ae:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1016b5:	00 
  1016b6:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
  1016bc:	89 b5 78 fe ff ff    	mov    %esi,-0x188(%ebp)
  1016c2:	89 95 74 fe ff ff    	mov    %edx,-0x18c(%ebp)
  1016c8:	e8 a3 f6 ff ff       	call   100d70 <idt_set_entry>
  1016cd:	b8 26 00 00 00       	mov    $0x26,%eax
  1016d2:	8d 0d c6 1c 10 00    	lea    0x101cc6,%ecx
  1016d8:	ba 08 00 00 00       	mov    $0x8,%edx
  1016dd:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  1016e2:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  1016e9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016ed:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1016f4:	00 
  1016f5:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1016fc:	00 
  1016fd:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
  101703:	89 b5 6c fe ff ff    	mov    %esi,-0x194(%ebp)
  101709:	89 95 68 fe ff ff    	mov    %edx,-0x198(%ebp)
  10170f:	e8 5c f6 ff ff       	call   100d70 <idt_set_entry>
  101714:	b8 27 00 00 00       	mov    $0x27,%eax
  101719:	8d 0d cc 1c 10 00    	lea    0x101ccc,%ecx
  10171f:	ba 08 00 00 00       	mov    $0x8,%edx
  101724:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  101729:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
  101730:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101734:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10173b:	00 
  10173c:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101743:	00 
  101744:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%ebp)
  10174a:	89 b5 60 fe ff ff    	mov    %esi,-0x1a0(%ebp)
  101750:	89 95 5c fe ff ff    	mov    %edx,-0x1a4(%ebp)
  101756:	e8 15 f6 ff ff       	call   100d70 <idt_set_entry>
  10175b:	b8 28 00 00 00       	mov    $0x28,%eax
  101760:	8d 0d d2 1c 10 00    	lea    0x101cd2,%ecx
  101766:	ba 08 00 00 00       	mov    $0x8,%edx
  10176b:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  101770:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  101777:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10177b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101782:	00 
  101783:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10178a:	00 
  10178b:	89 85 58 fe ff ff    	mov    %eax,-0x1a8(%ebp)
  101791:	89 b5 54 fe ff ff    	mov    %esi,-0x1ac(%ebp)
  101797:	89 95 50 fe ff ff    	mov    %edx,-0x1b0(%ebp)
  10179d:	e8 ce f5 ff ff       	call   100d70 <idt_set_entry>
  1017a2:	b8 29 00 00 00       	mov    $0x29,%eax
  1017a7:	8d 0d d8 1c 10 00    	lea    0x101cd8,%ecx
  1017ad:	ba 08 00 00 00       	mov    $0x8,%edx
  1017b2:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  1017b7:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
  1017be:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1017c2:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017c9:	00 
  1017ca:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017d1:	00 
  1017d2:	89 85 4c fe ff ff    	mov    %eax,-0x1b4(%ebp)
  1017d8:	89 b5 48 fe ff ff    	mov    %esi,-0x1b8(%ebp)
  1017de:	89 95 44 fe ff ff    	mov    %edx,-0x1bc(%ebp)
  1017e4:	e8 87 f5 ff ff       	call   100d70 <idt_set_entry>
  1017e9:	b8 2a 00 00 00       	mov    $0x2a,%eax
  1017ee:	8d 0d de 1c 10 00    	lea    0x101cde,%ecx
  1017f4:	ba 08 00 00 00       	mov    $0x8,%edx
  1017f9:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  1017fe:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
  101805:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101809:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101810:	00 
  101811:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101818:	00 
  101819:	89 85 40 fe ff ff    	mov    %eax,-0x1c0(%ebp)
  10181f:	89 b5 3c fe ff ff    	mov    %esi,-0x1c4(%ebp)
  101825:	89 95 38 fe ff ff    	mov    %edx,-0x1c8(%ebp)
  10182b:	e8 40 f5 ff ff       	call   100d70 <idt_set_entry>
  101830:	b8 2b 00 00 00       	mov    $0x2b,%eax
  101835:	8d 0d e4 1c 10 00    	lea    0x101ce4,%ecx
  10183b:	ba 08 00 00 00       	mov    $0x8,%edx
  101840:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  101845:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  10184c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101850:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101857:	00 
  101858:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10185f:	00 
  101860:	89 85 34 fe ff ff    	mov    %eax,-0x1cc(%ebp)
  101866:	89 b5 30 fe ff ff    	mov    %esi,-0x1d0(%ebp)
  10186c:	89 95 2c fe ff ff    	mov    %edx,-0x1d4(%ebp)
  101872:	e8 f9 f4 ff ff       	call   100d70 <idt_set_entry>
  101877:	b8 2c 00 00 00       	mov    $0x2c,%eax
  10187c:	8d 0d ea 1c 10 00    	lea    0x101cea,%ecx
  101882:	ba 08 00 00 00       	mov    $0x8,%edx
  101887:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  10188c:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  101893:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101897:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10189e:	00 
  10189f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1018a6:	00 
  1018a7:	89 85 28 fe ff ff    	mov    %eax,-0x1d8(%ebp)
  1018ad:	89 b5 24 fe ff ff    	mov    %esi,-0x1dc(%ebp)
  1018b3:	89 95 20 fe ff ff    	mov    %edx,-0x1e0(%ebp)
  1018b9:	e8 b2 f4 ff ff       	call   100d70 <idt_set_entry>
  1018be:	b8 2d 00 00 00       	mov    $0x2d,%eax
  1018c3:	8d 0d f0 1c 10 00    	lea    0x101cf0,%ecx
  1018c9:	ba 08 00 00 00       	mov    $0x8,%edx
  1018ce:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  1018d3:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  1018da:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018de:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1018e5:	00 
  1018e6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1018ed:	00 
  1018ee:	89 85 1c fe ff ff    	mov    %eax,-0x1e4(%ebp)
  1018f4:	89 b5 18 fe ff ff    	mov    %esi,-0x1e8(%ebp)
  1018fa:	89 95 14 fe ff ff    	mov    %edx,-0x1ec(%ebp)
  101900:	e8 6b f4 ff ff       	call   100d70 <idt_set_entry>
  101905:	b8 2e 00 00 00       	mov    $0x2e,%eax
  10190a:	8d 0d f6 1c 10 00    	lea    0x101cf6,%ecx
  101910:	ba 08 00 00 00       	mov    $0x8,%edx
  101915:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  10191a:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
  101921:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101925:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10192c:	00 
  10192d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101934:	00 
  101935:	89 85 10 fe ff ff    	mov    %eax,-0x1f0(%ebp)
  10193b:	89 b5 0c fe ff ff    	mov    %esi,-0x1f4(%ebp)
  101941:	89 95 08 fe ff ff    	mov    %edx,-0x1f8(%ebp)
  101947:	e8 24 f4 ff ff       	call   100d70 <idt_set_entry>
  10194c:	b8 2f 00 00 00       	mov    $0x2f,%eax
  101951:	8d 0d fc 1c 10 00    	lea    0x101cfc,%ecx
  101957:	ba 08 00 00 00       	mov    $0x8,%edx
  10195c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  101961:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
  101968:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10196c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101973:	00 
  101974:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10197b:	00 
  10197c:	89 85 04 fe ff ff    	mov    %eax,-0x1fc(%ebp)
  101982:	89 b5 00 fe ff ff    	mov    %esi,-0x200(%ebp)
  101988:	89 95 fc fd ff ff    	mov    %edx,-0x204(%ebp)
  10198e:	e8 dd f3 ff ff       	call   100d70 <idt_set_entry>
  101993:	b8 30 00 00 00       	mov    $0x30,%eax
  101998:	8d 0d 02 1d 10 00    	lea    0x101d02,%ecx
  10199e:	ba 08 00 00 00       	mov    $0x8,%edx
  1019a3:	be ee 00 00 00       	mov    $0xee,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  1019a8:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  1019af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1019b3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1019ba:	00 
  1019bb:	c7 44 24 0c ee 00 00 	movl   $0xee,0xc(%esp)
  1019c2:	00 
  1019c3:	89 85 f8 fd ff ff    	mov    %eax,-0x208(%ebp)
  1019c9:	89 b5 f4 fd ff ff    	mov    %esi,-0x20c(%ebp)
  1019cf:	89 95 f0 fd ff ff    	mov    %edx,-0x210(%ebp)
  1019d5:	e8 96 f3 ff ff       	call   100d70 <idt_set_entry>
  1019da:	b8 05 00 00 00       	mov    $0x5,%eax
  1019df:	8d 0d 08 71 10 00    	lea    0x107108,%ecx
  1019e5:	ba 80 00 00 00       	mov    $0x80,%edx
  1019ea:	be e9 00 00 00       	mov    $0xe9,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  1019ef:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  1019f6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1019fa:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  101a01:	00 
  101a02:	c7 44 24 0c e9 00 00 	movl   $0xe9,0xc(%esp)
  101a09:	00 
  101a0a:	89 85 ec fd ff ff    	mov    %eax,-0x214(%ebp)
  101a10:	89 b5 e8 fd ff ff    	mov    %esi,-0x218(%ebp)
  101a16:	89 95 e4 fd ff ff    	mov    %edx,-0x21c(%ebp)
  101a1c:	e8 df f0 ff ff       	call   100b00 <set_gdt_entry>
  101a21:	b8 28 00 00 00       	mov    $0x28,%eax
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101a26:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  101a29:	0f 01 5d f0          	lidtl  -0x10(%ebp)
	asm volatile("sti");
  101a2d:	fb                   	sti    
}
  101a2e:	81 c4 34 02 00 00    	add    $0x234,%esp
  101a34:	5e                   	pop    %esi
  101a35:	5d                   	pop    %ebp
  101a36:	c3                   	ret    
  101a37:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  101a3e:	00 00 

00101a40 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  101a40:	55                   	push   %ebp
  101a41:	89 e5                	mov    %esp,%ebp
  101a43:	50                   	push   %eax
  101a44:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  101a48:	66 89 c1             	mov    %ax,%cx
  101a4b:	8a 55 0c             	mov    0xc(%ebp),%dl
  101a4e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  101a52:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  101a55:	8a 45 fd             	mov    -0x3(%ebp),%al
  101a58:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  101a5c:	ee                   	out    %al,(%dx)
}
  101a5d:	83 c4 04             	add    $0x4,%esp
  101a60:	5d                   	pop    %ebp
  101a61:	c3                   	ret    
  101a62:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101a69:	1f 84 00 00 00 00 00 

00101a70 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  101a70:	55                   	push   %ebp
  101a71:	89 e5                	mov    %esp,%ebp
  101a73:	83 ec 08             	sub    $0x8,%esp
  101a76:	8b 45 0c             	mov    0xc(%ebp),%eax
  101a79:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101a7c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  101a7f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	handlers[i] = fn;
  101a82:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101a85:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101a88:	89 04 8d 28 a3 10 00 	mov    %eax,0x10a328(,%ecx,4)
	handler_set[i] = 1;
  101a8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a92:	c7 04 85 28 a2 10 00 	movl   $0x1,0x10a228(,%eax,4)
  101a99:	01 00 00 00 
}
  101a9d:	83 c4 08             	add    $0x8,%esp
  101aa0:	5d                   	pop    %ebp
  101aa1:	c3                   	ret    
  101aa2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101aa9:	1f 84 00 00 00 00 00 

00101ab0 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  101ab0:	55                   	push   %ebp
  101ab1:	89 e5                	mov    %esp,%ebp
  101ab3:	83 ec 28             	sub    $0x28,%esp
  101ab6:	8b 45 08             	mov    0x8(%ebp),%eax
  101ab9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	struct cpu_state* new_cpu = cpu;
  101abc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101abf:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (cpu->intr <= 0x1f) {
  101ac2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ac5:	81 78 1c 1f 00 00 00 	cmpl   $0x1f,0x1c(%eax)
  101acc:	0f 87 3d 00 00 00    	ja     101b0f <handle_interrupt+0x5f>
		if (!isSchedulingEnabled()) {
  101ad2:	e8 d9 1f 00 00       	call   103ab0 <isSchedulingEnabled>
  101ad7:	3d 00 00 00 00       	cmp    $0x0,%eax
  101adc:	0f 85 1a 00 00 00    	jne    101afc <handle_interrupt+0x4c>
  101ae2:	8d 05 51 82 10 00    	lea    0x108251,%eax
			show_cod(cpu, "Kernel PANIC!");
  101ae8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101aeb:	89 0c 24             	mov    %ecx,(%esp)
  101aee:	89 44 24 04          	mov    %eax,0x4(%esp)
  101af2:	e8 89 e8 ff ff       	call   100380 <show_cod>
		} else {
  101af7:	e9 0e 00 00 00       	jmp    101b0a <handle_interrupt+0x5a>
			new_cpu = schedule_exception(cpu);
  101afc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101aff:	89 04 24             	mov    %eax,(%esp)
  101b02:	e8 19 21 00 00       	call   103c20 <schedule_exception>
  101b07:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  101b0a:	e9 fc 00 00 00       	jmp    101c0b <handle_interrupt+0x15b>
  101b0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101b12:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101b19:	0f 82 a7 00 00 00    	jb     101bc6 <handle_interrupt+0x116>
  101b1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101b22:	81 78 1c 2f 00 00 00 	cmpl   $0x2f,0x1c(%eax)
  101b29:	0f 87 97 00 00 00    	ja     101bc6 <handle_interrupt+0x116>
		if (cpu->intr >= 0x28) {
  101b2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101b32:	81 78 1c 28 00 00 00 	cmpl   $0x28,0x1c(%eax)
  101b39:	0f 82 24 00 00 00    	jb     101b63 <handle_interrupt+0xb3>
  101b3f:	b8 a0 00 00 00       	mov    $0xa0,%eax
  101b44:	b9 20 00 00 00       	mov    $0x20,%ecx
			outb(0xa0, 0x20);
  101b49:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  101b50:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101b57:	00 
  101b58:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101b5b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  101b5e:	e8 dd fe ff ff       	call   101a40 <outb>
		}

		if (cpu->intr == 0x20) {
  101b63:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101b66:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101b6d:	0f 85 2a 00 00 00    	jne    101b9d <handle_interrupt+0xed>
			new_cpu = schedule(cpu);
  101b73:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101b76:	89 04 24             	mov    %eax,(%esp)
  101b79:	e8 22 25 00 00       	call   1040a0 <schedule>
  101b7e:	b9 20 00 00 00       	mov    $0x20,%ecx
  101b83:	89 45 f8             	mov    %eax,-0x8(%ebp)

	        outb(0x20, 0x20);
  101b86:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  101b8d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101b94:	00 
  101b95:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  101b98:	e8 a3 fe ff ff       	call   101a40 <outb>
		}

		if (handler_set[cpu->intr]) {
  101b9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ba0:	8b 40 1c             	mov    0x1c(%eax),%eax
  101ba3:	81 3c 85 28 a2 10 00 	cmpl   $0x0,0x10a228(,%eax,4)
  101baa:	00 00 00 00 
  101bae:	0f 84 0d 00 00 00    	je     101bc1 <handle_interrupt+0x111>
			handlers[cpu->intr]();
  101bb4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101bb7:	8b 40 1c             	mov    0x1c(%eax),%eax
  101bba:	ff 14 85 28 a3 10 00 	call   *0x10a328(,%eax,4)
		}
	} else if (cpu->intr == 0x30) {
  101bc1:	e9 40 00 00 00       	jmp    101c06 <handle_interrupt+0x156>
  101bc6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101bc9:	81 78 1c 30 00 00 00 	cmpl   $0x30,0x1c(%eax)
  101bd0:	0f 85 13 00 00 00    	jne    101be9 <handle_interrupt+0x139>
		new_cpu = syscall(new_cpu);
  101bd6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101bd9:	89 04 24             	mov    %eax,(%esp)
  101bdc:	e8 5f 01 00 00       	call   101d40 <syscall>
  101be1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	} else {
  101be4:	e9 18 00 00 00       	jmp    101c01 <handle_interrupt+0x151>
  101be9:	8d 05 5f 82 10 00    	lea    0x10825f,%eax
		kprintf("Unbekannter Interrupt\n");
  101bef:	89 04 24             	mov    %eax,(%esp)
  101bf2:	e8 79 e9 ff ff       	call   100570 <kprintf>
  101bf7:	89 45 e8             	mov    %eax,-0x18(%ebp)
		while (1) {
			// Prozessor anhalten
			asm volatile("cli; hlt");
  101bfa:	fa                   	cli    
  101bfb:	f4                   	hlt    
		}
  101bfc:	e9 f9 ff ff ff       	jmp    101bfa <handle_interrupt+0x14a>
  101c01:	e9 00 00 00 00       	jmp    101c06 <handle_interrupt+0x156>
  101c06:	e9 00 00 00 00       	jmp    101c0b <handle_interrupt+0x15b>
	}

	return new_cpu;
  101c0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101c0e:	83 c4 28             	add    $0x28,%esp
  101c11:	5d                   	pop    %ebp
  101c12:	c3                   	ret    
  101c13:	90                   	nop

00101c14 <intr_stub_0>:
  101c14:	6a 00                	push   $0x0
  101c16:	6a 00                	push   $0x0
  101c18:	e9 eb 00 00 00       	jmp    101d08 <intr_common_handler>

00101c1d <intr_stub_1>:
  101c1d:	6a 00                	push   $0x0
  101c1f:	6a 01                	push   $0x1
  101c21:	e9 e2 00 00 00       	jmp    101d08 <intr_common_handler>

00101c26 <intr_stub_2>:
  101c26:	6a 00                	push   $0x0
  101c28:	6a 02                	push   $0x2
  101c2a:	e9 d9 00 00 00       	jmp    101d08 <intr_common_handler>

00101c2f <intr_stub_3>:
  101c2f:	6a 00                	push   $0x0
  101c31:	6a 03                	push   $0x3
  101c33:	e9 d0 00 00 00       	jmp    101d08 <intr_common_handler>

00101c38 <intr_stub_4>:
  101c38:	6a 00                	push   $0x0
  101c3a:	6a 04                	push   $0x4
  101c3c:	e9 c7 00 00 00       	jmp    101d08 <intr_common_handler>

00101c41 <intr_stub_5>:
  101c41:	6a 00                	push   $0x0
  101c43:	6a 05                	push   $0x5
  101c45:	e9 be 00 00 00       	jmp    101d08 <intr_common_handler>

00101c4a <intr_stub_6>:
  101c4a:	6a 00                	push   $0x0
  101c4c:	6a 06                	push   $0x6
  101c4e:	e9 b5 00 00 00       	jmp    101d08 <intr_common_handler>

00101c53 <intr_stub_7>:
  101c53:	6a 00                	push   $0x0
  101c55:	6a 07                	push   $0x7
  101c57:	e9 ac 00 00 00       	jmp    101d08 <intr_common_handler>

00101c5c <intr_stub_8>:
  101c5c:	6a 08                	push   $0x8
  101c5e:	e9 a5 00 00 00       	jmp    101d08 <intr_common_handler>

00101c63 <intr_stub_9>:
  101c63:	6a 00                	push   $0x0
  101c65:	6a 09                	push   $0x9
  101c67:	e9 9c 00 00 00       	jmp    101d08 <intr_common_handler>

00101c6c <intr_stub_10>:
  101c6c:	6a 0a                	push   $0xa
  101c6e:	e9 95 00 00 00       	jmp    101d08 <intr_common_handler>

00101c73 <intr_stub_11>:
  101c73:	6a 0b                	push   $0xb
  101c75:	e9 8e 00 00 00       	jmp    101d08 <intr_common_handler>

00101c7a <intr_stub_12>:
  101c7a:	6a 0c                	push   $0xc
  101c7c:	e9 87 00 00 00       	jmp    101d08 <intr_common_handler>

00101c81 <intr_stub_13>:
  101c81:	6a 0d                	push   $0xd
  101c83:	e9 80 00 00 00       	jmp    101d08 <intr_common_handler>

00101c88 <intr_stub_14>:
  101c88:	6a 0e                	push   $0xe
  101c8a:	eb 7c                	jmp    101d08 <intr_common_handler>

00101c8c <intr_stub_15>:
  101c8c:	6a 00                	push   $0x0
  101c8e:	6a 0f                	push   $0xf
  101c90:	eb 76                	jmp    101d08 <intr_common_handler>

00101c92 <intr_stub_16>:
  101c92:	6a 00                	push   $0x0
  101c94:	6a 10                	push   $0x10
  101c96:	eb 70                	jmp    101d08 <intr_common_handler>

00101c98 <intr_stub_17>:
  101c98:	6a 11                	push   $0x11
  101c9a:	eb 6c                	jmp    101d08 <intr_common_handler>

00101c9c <intr_stub_18>:
  101c9c:	6a 00                	push   $0x0
  101c9e:	6a 12                	push   $0x12
  101ca0:	eb 66                	jmp    101d08 <intr_common_handler>

00101ca2 <intr_stub_32>:
  101ca2:	6a 00                	push   $0x0
  101ca4:	6a 20                	push   $0x20
  101ca6:	eb 60                	jmp    101d08 <intr_common_handler>

00101ca8 <intr_stub_33>:
  101ca8:	6a 00                	push   $0x0
  101caa:	6a 21                	push   $0x21
  101cac:	eb 5a                	jmp    101d08 <intr_common_handler>

00101cae <intr_stub_34>:
  101cae:	6a 00                	push   $0x0
  101cb0:	6a 22                	push   $0x22
  101cb2:	eb 54                	jmp    101d08 <intr_common_handler>

00101cb4 <intr_stub_35>:
  101cb4:	6a 00                	push   $0x0
  101cb6:	6a 23                	push   $0x23
  101cb8:	eb 4e                	jmp    101d08 <intr_common_handler>

00101cba <intr_stub_36>:
  101cba:	6a 00                	push   $0x0
  101cbc:	6a 24                	push   $0x24
  101cbe:	eb 48                	jmp    101d08 <intr_common_handler>

00101cc0 <intr_stub_37>:
  101cc0:	6a 00                	push   $0x0
  101cc2:	6a 25                	push   $0x25
  101cc4:	eb 42                	jmp    101d08 <intr_common_handler>

00101cc6 <intr_stub_38>:
  101cc6:	6a 00                	push   $0x0
  101cc8:	6a 26                	push   $0x26
  101cca:	eb 3c                	jmp    101d08 <intr_common_handler>

00101ccc <intr_stub_39>:
  101ccc:	6a 00                	push   $0x0
  101cce:	6a 27                	push   $0x27
  101cd0:	eb 36                	jmp    101d08 <intr_common_handler>

00101cd2 <intr_stub_40>:
  101cd2:	6a 00                	push   $0x0
  101cd4:	6a 28                	push   $0x28
  101cd6:	eb 30                	jmp    101d08 <intr_common_handler>

00101cd8 <intr_stub_41>:
  101cd8:	6a 00                	push   $0x0
  101cda:	6a 29                	push   $0x29
  101cdc:	eb 2a                	jmp    101d08 <intr_common_handler>

00101cde <intr_stub_42>:
  101cde:	6a 00                	push   $0x0
  101ce0:	6a 2a                	push   $0x2a
  101ce2:	eb 24                	jmp    101d08 <intr_common_handler>

00101ce4 <intr_stub_43>:
  101ce4:	6a 00                	push   $0x0
  101ce6:	6a 2b                	push   $0x2b
  101ce8:	eb 1e                	jmp    101d08 <intr_common_handler>

00101cea <intr_stub_44>:
  101cea:	6a 00                	push   $0x0
  101cec:	6a 2c                	push   $0x2c
  101cee:	eb 18                	jmp    101d08 <intr_common_handler>

00101cf0 <intr_stub_45>:
  101cf0:	6a 00                	push   $0x0
  101cf2:	6a 2d                	push   $0x2d
  101cf4:	eb 12                	jmp    101d08 <intr_common_handler>

00101cf6 <intr_stub_46>:
  101cf6:	6a 00                	push   $0x0
  101cf8:	6a 2e                	push   $0x2e
  101cfa:	eb 0c                	jmp    101d08 <intr_common_handler>

00101cfc <intr_stub_47>:
  101cfc:	6a 00                	push   $0x0
  101cfe:	6a 2f                	push   $0x2f
  101d00:	eb 06                	jmp    101d08 <intr_common_handler>

00101d02 <intr_stub_48>:
  101d02:	6a 00                	push   $0x0
  101d04:	6a 30                	push   $0x30
  101d06:	eb 00                	jmp    101d08 <intr_common_handler>

00101d08 <intr_common_handler>:
  101d08:	55                   	push   %ebp
  101d09:	57                   	push   %edi
  101d0a:	56                   	push   %esi
  101d0b:	52                   	push   %edx
  101d0c:	51                   	push   %ecx
  101d0d:	53                   	push   %ebx
  101d0e:	50                   	push   %eax
  101d0f:	54                   	push   %esp
  101d10:	66 b8 10 00          	mov    $0x10,%ax
  101d14:	66 8e d8             	mov    %ax,%ds
  101d17:	66 8e c0             	mov    %ax,%es
  101d1a:	e8 91 fd ff ff       	call   101ab0 <handle_interrupt>
  101d1f:	89 c4                	mov    %eax,%esp
  101d21:	66 b8 23 00          	mov    $0x23,%ax
  101d25:	66 8e d8             	mov    %ax,%ds
  101d28:	66 8e c0             	mov    %ax,%es
  101d2b:	58                   	pop    %eax
  101d2c:	5b                   	pop    %ebx
  101d2d:	59                   	pop    %ecx
  101d2e:	5a                   	pop    %edx
  101d2f:	5e                   	pop    %esi
  101d30:	5f                   	pop    %edi
  101d31:	5d                   	pop    %ebp
  101d32:	83 c4 08             	add    $0x8,%esp
  101d35:	cf                   	iret   
  101d36:	66 90                	xchg   %ax,%ax
  101d38:	66 90                	xchg   %ax,%ax
  101d3a:	66 90                	xchg   %ax,%ax
  101d3c:	66 90                	xchg   %ax,%ax
  101d3e:	66 90                	xchg   %ax,%ax

00101d40 <syscall>:
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"

struct cpu_state* syscall(struct cpu_state* cpu) {
  101d40:	55                   	push   %ebp
  101d41:	89 e5                	mov    %esp,%ebp
  101d43:	56                   	push   %esi
  101d44:	81 ec d4 00 00 00    	sub    $0xd4,%esp
  101d4a:	8b 45 08             	mov    0x8(%ebp),%eax
  101d4d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    save_cpu_state(cpu);
  101d50:	89 e1                	mov    %esp,%ecx
  101d52:	89 01                	mov    %eax,(%ecx)
  101d54:	e8 07 23 00 00       	call   104060 <save_cpu_state>

    cpu = get_current_task()->cpuState;
  101d59:	e8 62 1d 00 00       	call   103ac0 <get_current_task>
  101d5e:	8b 40 04             	mov    0x4(%eax),%eax
  101d61:	89 45 f8             	mov    %eax,-0x8(%ebp)

	switch (cpu->eax) {
  101d64:	8b 00                	mov    (%eax),%eax
  101d66:	89 c1                	mov    %eax,%ecx
  101d68:	81 e9 c8 00 00 00    	sub    $0xc8,%ecx
  101d6e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  101d71:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  101d74:	0f 8f 26 00 00 00    	jg     101da0 <syscall+0x60>
  101d7a:	e9 00 00 00 00       	jmp    101d7f <syscall+0x3f>
  101d7f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  101d82:	48                   	dec    %eax
  101d83:	89 c1                	mov    %eax,%ecx
  101d85:	83 e9 14             	sub    $0x14,%ecx
  101d88:	89 45 ac             	mov    %eax,-0x54(%ebp)
  101d8b:	89 4d a8             	mov    %ecx,-0x58(%ebp)
  101d8e:	0f 87 b1 05 00 00    	ja     102345 <syscall+0x605>
  101d94:	8b 45 ac             	mov    -0x54(%ebp),%eax
  101d97:	8b 0c 85 44 80 10 00 	mov    0x108044(,%eax,4),%ecx
  101d9e:	ff e1                	jmp    *%ecx
  101da0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  101da3:	05 37 ff ff ff       	add    $0xffffff37,%eax
  101da8:	89 c1                	mov    %eax,%ecx
  101daa:	83 e9 04             	sub    $0x4,%ecx
  101dad:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  101db0:	89 4d a0             	mov    %ecx,-0x60(%ebp)
  101db3:	0f 87 8c 05 00 00    	ja     102345 <syscall+0x605>
  101db9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  101dbc:	8b 0c 85 30 80 10 00 	mov    0x108030(,%eax,4),%ecx
  101dc3:	ff e1                	jmp    *%ecx
	case 1: /* exit */
		cpu = terminate_current(cpu);
  101dc5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101dc8:	89 04 24             	mov    %eax,(%esp)
  101dcb:	e8 80 1f 00 00       	call   103d50 <terminate_current>
  101dd0:	89 45 f8             	mov    %eax,-0x8(%ebp)
		break;
  101dd3:	e9 8a 05 00 00       	jmp    102362 <syscall+0x622>

	case 2: /* fork */
	{

		uint32_t forkpdir = vmm_fork_current();
  101dd8:	e8 03 3c 00 00       	call   1059e0 <vmm_fork_current>
  101ddd:	b9 00 00 00 00       	mov    $0x0,%ecx
  101de2:	89 45 f4             	mov    %eax,-0xc(%ebp)

		struct task* ntask = init_task(forkpdir, 0);
  101de5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101de8:	89 04 24             	mov    %eax,(%esp)
  101deb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101df2:	00 
  101df3:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  101df6:	e8 a5 20 00 00       	call   103ea0 <init_task>
  101dfb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		fork_task_state(ntask);
  101dfe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101e01:	89 04 24             	mov    %eax,(%esp)
  101e04:	e8 17 20 00 00       	call   103e20 <fork_task_state>

		cpu->eax = ntask->PID;
  101e09:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101e0c:	8b 00                	mov    (%eax),%eax
  101e0e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e11:	89 01                	mov    %eax,(%ecx)
	}
        break;
  101e13:	e9 4a 05 00 00       	jmp    102362 <syscall+0x622>

    case 3: /* exec */
    {
        vfs_exec((char*) cpu->ebx, (char**) cpu->ecx, get_current_task());
  101e18:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e1b:	8b 40 04             	mov    0x4(%eax),%eax
  101e1e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e21:	8b 49 08             	mov    0x8(%ecx),%ecx
  101e24:	89 45 98             	mov    %eax,-0x68(%ebp)
  101e27:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
  101e2a:	e8 91 1c 00 00       	call   103ac0 <get_current_task>
  101e2f:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  101e32:	89 0c 24             	mov    %ecx,(%esp)
  101e35:	8b 55 94             	mov    -0x6c(%ebp),%edx
  101e38:	89 54 24 04          	mov    %edx,0x4(%esp)
  101e3c:	89 44 24 08          	mov    %eax,0x8(%esp)
  101e40:	e8 bb 35 00 00       	call   105400 <vfs_exec>
    }
        break;
  101e45:	e9 18 05 00 00       	jmp    102362 <syscall+0x622>

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  101e4a:	e8 71 1c 00 00       	call   103ac0 <get_current_task>
  101e4f:	8b 40 18             	mov    0x18(%eax),%eax
  101e52:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e55:	89 01                	mov    %eax,(%ecx)
    }
        break;
  101e57:	e9 06 05 00 00       	jmp    102362 <syscall+0x622>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
  101e5c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e5f:	89 04 24             	mov    %eax,(%esp)
  101e62:	e8 39 22 00 00       	call   1040a0 <schedule>
  101e67:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
        break;
  101e6a:	e9 f3 04 00 00       	jmp    102362 <syscall+0x622>

	case 10: /* fopen */
	{
	    char* name = strclone((char*) cpu->ebx);
  101e6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e72:	8b 40 04             	mov    0x4(%eax),%eax
  101e75:	89 04 24             	mov    %eax,(%esp)
  101e78:	e8 63 2c 00 00       	call   104ae0 <strclone>
  101e7d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  101e80:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e83:	8b 40 08             	mov    0x8(%eax),%eax
  101e86:	89 45 e8             	mov    %eax,-0x18(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  101e89:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101e8c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  101e8f:	89 04 24             	mov    %eax,(%esp)
  101e92:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101e96:	e8 d5 31 00 00       	call   105070 <vfs_open>
  101e9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    if(handle) {
  101e9e:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  101ea5:	0f 84 1b 00 00 00    	je     101ec6 <syscall+0x186>
	        register_handle(handle);
  101eab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101eae:	89 04 24             	mov    %eax,(%esp)
  101eb1:	e8 1a 1c 00 00       	call   103ad0 <register_handle>
	        cpu->eax = (uint32_t) handle;
  101eb6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101eb9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101ebc:	89 0a                	mov    %ecx,(%edx)
	    }
  101ebe:	89 45 90             	mov    %eax,-0x70(%ebp)
  101ec1:	e9 09 00 00 00       	jmp    101ecf <syscall+0x18f>
	    else
	    {
	        cpu->eax = 0;
  101ec6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ec9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }

	    free(name);
  101ecf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101ed2:	89 04 24             	mov    %eax,(%esp)
  101ed5:	e8 66 26 00 00       	call   104540 <free>
	}
	    break;
  101eda:	e9 83 04 00 00       	jmp    102362 <syscall+0x622>

	case 11: /* fclose */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  101edf:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ee2:	8b 40 04             	mov    0x4(%eax),%eax
  101ee5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    if(!unregister_handle(handle)) {
  101ee8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101eeb:	89 04 24             	mov    %eax,(%esp)
  101eee:	e8 3d 1c 00 00       	call   103b30 <unregister_handle>
  101ef3:	3d 00 00 00 00       	cmp    $0x0,%eax
  101ef8:	0f 85 1c 00 00 00    	jne    101f1a <syscall+0x1da>
	        vfs_close(handle);
  101efe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101f01:	89 04 24             	mov    %eax,(%esp)
  101f04:	e8 e7 31 00 00       	call   1050f0 <vfs_close>

	        cpu->eax = 0;
  101f09:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101f0c:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	    }
  101f12:	89 45 8c             	mov    %eax,-0x74(%ebp)
  101f15:	e9 09 00 00 00       	jmp    101f23 <syscall+0x1e3>
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  101f1a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f1d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  101f23:	e9 3a 04 00 00       	jmp    102362 <syscall+0x622>

	case 12: /* fwrite */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  101f28:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f2b:	8b 40 04             	mov    0x4(%eax),%eax
  101f2e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    if(handle != 0) {
  101f31:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  101f38:	0f 84 39 00 00 00    	je     101f77 <syscall+0x237>
  101f3e:	b8 01 00 00 00       	mov    $0x1,%eax
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  101f43:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  101f46:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101f49:	8b 52 08             	mov    0x8(%edx),%edx
  101f4c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  101f4f:	8b 76 0c             	mov    0xc(%esi),%esi
  101f52:	89 0c 24             	mov    %ecx,(%esp)
  101f55:	89 54 24 04          	mov    %edx,0x4(%esp)
  101f59:	89 74 24 08          	mov    %esi,0x8(%esp)
  101f5d:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  101f64:	00 
  101f65:	89 45 88             	mov    %eax,-0x78(%ebp)
  101f68:	e8 b3 32 00 00       	call   105220 <vfs_write>
  101f6d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101f70:	89 01                	mov    %eax,(%ecx)
	    }
  101f72:	e9 09 00 00 00       	jmp    101f80 <syscall+0x240>
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  101f77:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f7a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  101f80:	e9 dd 03 00 00       	jmp    102362 <syscall+0x622>

	case 13: /* fread */
	{
        struct res_handle* handle = (void*) cpu->ebx;
  101f85:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f88:	8b 40 04             	mov    0x4(%eax),%eax
  101f8b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(handle != 0) {
  101f8e:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  101f95:	0f 84 39 00 00 00    	je     101fd4 <syscall+0x294>
  101f9b:	b8 01 00 00 00       	mov    $0x1,%eax
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  101fa0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101fa3:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101fa6:	8b 52 08             	mov    0x8(%edx),%edx
  101fa9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  101fac:	8b 76 0c             	mov    0xc(%esi),%esi
  101faf:	89 0c 24             	mov    %ecx,(%esp)
  101fb2:	89 54 24 04          	mov    %edx,0x4(%esp)
  101fb6:	89 74 24 08          	mov    %esi,0x8(%esp)
  101fba:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  101fc1:	00 
  101fc2:	89 45 84             	mov    %eax,-0x7c(%ebp)
  101fc5:	e8 76 31 00 00       	call   105140 <vfs_read>
  101fca:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101fcd:	89 01                	mov    %eax,(%ecx)
        }
  101fcf:	e9 09 00 00 00       	jmp    101fdd <syscall+0x29d>
        else
        {
            cpu->eax = RW_ERR_VFS;
  101fd4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101fd7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  101fdd:	e9 80 03 00 00       	jmp    102362 <syscall+0x622>

	case 14: /* fmkfifo */
	{
        char* name = strclone((char*) cpu->ebx);
  101fe2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101fe5:	8b 40 04             	mov    0x4(%eax),%eax
  101fe8:	89 04 24             	mov    %eax,(%esp)
  101feb:	e8 f0 2a 00 00       	call   104ae0 <strclone>
  101ff0:	8d 4d d0             	lea    -0x30(%ebp),%ecx
  101ff3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  101ff6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101ff9:	89 4d 80             	mov    %ecx,-0x80(%ebp)
  101ffc:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  102002:	e8 09 15 00 00       	call   103510 <ramfs_fifo_driver_struct>
  102007:	c7 45 d0 00 10 00 00 	movl   $0x1000,-0x30(%ebp)
  10200e:	8b 8d 7c ff ff ff    	mov    -0x84(%ebp),%ecx
  102014:	89 0c 24             	mov    %ecx,(%esp)
  102017:	89 44 24 04          	mov    %eax,0x4(%esp)
  10201b:	8b 45 80             	mov    -0x80(%ebp),%eax
  10201e:	89 44 24 08          	mov    %eax,0x8(%esp)
  102022:	e8 d9 2e 00 00       	call   104f00 <vfs_create_kfile>
  102027:	b9 03 00 00 00       	mov    $0x3,%ecx

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  10202c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  10202f:	89 14 24             	mov    %edx,(%esp)
  102032:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  102039:	00 
  10203a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  102040:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%ebp)
  102046:	e8 25 30 00 00       	call   105070 <vfs_open>
  10204b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(handle) {
  10204e:	81 7d cc 00 00 00 00 	cmpl   $0x0,-0x34(%ebp)
  102055:	0f 84 1e 00 00 00    	je     102079 <syscall+0x339>
            register_handle(handle);
  10205b:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10205e:	89 04 24             	mov    %eax,(%esp)
  102061:	e8 6a 1a 00 00       	call   103ad0 <register_handle>
            cpu->eax = (uint32_t) handle;
  102066:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  102069:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10206c:	89 0a                	mov    %ecx,(%edx)
        }
  10206e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
  102074:	e9 09 00 00 00       	jmp    102082 <syscall+0x342>
        else
        {
            cpu->eax = 0;
  102079:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10207c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        free(name);
  102082:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102085:	89 04 24             	mov    %eax,(%esp)
  102088:	e8 b3 24 00 00       	call   104540 <free>
	}
	    break;
  10208d:	e9 d0 02 00 00       	jmp    102362 <syscall+0x622>

	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  102092:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	    switch(cpu->ebx) {
  102099:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10209c:	8b 40 04             	mov    0x4(%eax),%eax
  10209f:	89 c1                	mov    %eax,%ecx
  1020a1:	83 e9 02             	sub    $0x2,%ecx
  1020a4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
  1020aa:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
  1020b0:	0f 84 52 00 00 00    	je     102108 <syscall+0x3c8>
  1020b6:	e9 00 00 00 00       	jmp    1020bb <syscall+0x37b>
  1020bb:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  1020c1:	83 e8 01             	sub    $0x1,%eax
  1020c4:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  1020ca:	0f 84 28 00 00 00    	je     1020f8 <syscall+0x3b8>
  1020d0:	e9 00 00 00 00       	jmp    1020d5 <syscall+0x395>
  1020d5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  1020db:	85 c0                	test   %eax,%eax
  1020dd:	0f 85 35 00 00 00    	jne    102118 <syscall+0x3d8>
  1020e3:	e9 00 00 00 00       	jmp    1020e8 <syscall+0x3a8>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
  1020e8:	e8 d3 19 00 00       	call   103ac0 <get_current_task>
  1020ed:	8b 40 1c             	mov    0x1c(%eax),%eax
  1020f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
	        break;
  1020f3:	e9 2b 00 00 00       	jmp    102123 <syscall+0x3e3>
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  1020f8:	e8 c3 19 00 00       	call   103ac0 <get_current_task>
  1020fd:	8b 40 24             	mov    0x24(%eax),%eax
  102100:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
  102103:	e9 1b 00 00 00       	jmp    102123 <syscall+0x3e3>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  102108:	e8 b3 19 00 00       	call   103ac0 <get_current_task>
  10210d:	8b 40 20             	mov    0x20(%eax),%eax
  102110:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
  102113:	e9 0b 00 00 00       	jmp    102123 <syscall+0x3e3>
        default:
            handle = get_current_task()->stdout;
  102118:	e8 a3 19 00 00       	call   103ac0 <get_current_task>
  10211d:	8b 40 1c             	mov    0x1c(%eax),%eax
  102120:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
	    }

	    cpu->eax = (uint32_t) handle;
  102123:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102126:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102129:	89 01                	mov    %eax,(%ecx)
	}
	    break;
  10212b:	e9 32 02 00 00       	jmp    102362 <syscall+0x622>

	case 21: /* fopenpmhandle */
	{
	    char* path = strclone((char*)cpu->ecx);
  102130:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102133:	8b 40 08             	mov    0x8(%eax),%eax
  102136:	89 04 24             	mov    %eax,(%esp)
  102139:	e8 a2 29 00 00       	call   104ae0 <strclone>
  10213e:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  102141:	c7 45 bc 02 00 00 00 	movl   $0x2,-0x44(%ebp)

	    if(cpu->ebx == PMID_STDIN) {
  102148:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10214b:	81 78 04 01 00 00 00 	cmpl   $0x1,0x4(%eax)
  102152:	0f 85 07 00 00 00    	jne    10215f <syscall+0x41f>
	        fm = FM_READ;
  102158:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
	    }

	    open = vfs_open(path, fm);
  10215f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  102162:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  102165:	89 04 24             	mov    %eax,(%esp)
  102168:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10216c:	e8 ff 2e 00 00       	call   105070 <vfs_open>
  102171:	89 45 c0             	mov    %eax,-0x40(%ebp)

	    free(path);
  102174:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  102177:	89 04 24             	mov    %eax,(%esp)
  10217a:	e8 c1 23 00 00       	call   104540 <free>

	    if(!open) {
  10217f:	81 7d c0 00 00 00 00 	cmpl   $0x0,-0x40(%ebp)
  102186:	0f 85 0e 00 00 00    	jne    10219a <syscall+0x45a>
	        cpu->eax = (uint32_t) -1;
  10218c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10218f:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	        break;
  102195:	e9 c8 01 00 00       	jmp    102362 <syscall+0x622>
	    }

	    struct res_handle* oldhandle = 0;
  10219a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

        switch(cpu->ebx) {
  1021a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1021a4:	8b 40 04             	mov    0x4(%eax),%eax
  1021a7:	89 c1                	mov    %eax,%ecx
  1021a9:	83 e9 02             	sub    $0x2,%ecx
  1021ac:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
  1021b2:	89 8d 5c ff ff ff    	mov    %ecx,-0xa4(%ebp)
  1021b8:	0f 84 80 00 00 00    	je     10223e <syscall+0x4fe>
  1021be:	e9 00 00 00 00       	jmp    1021c3 <syscall+0x483>
  1021c3:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1021c9:	83 e8 01             	sub    $0x1,%eax
  1021cc:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
  1021d2:	0f 84 3f 00 00 00    	je     102217 <syscall+0x4d7>
  1021d8:	e9 00 00 00 00       	jmp    1021dd <syscall+0x49d>
  1021dd:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1021e3:	85 c0                	test   %eax,%eax
  1021e5:	0f 85 7a 00 00 00    	jne    102265 <syscall+0x525>
  1021eb:	e9 00 00 00 00       	jmp    1021f0 <syscall+0x4b0>
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  1021f0:	e8 cb 18 00 00       	call   103ac0 <get_current_task>
  1021f5:	8b 40 1c             	mov    0x1c(%eax),%eax
  1021f8:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdout = open;
  1021fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1021fe:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  102204:	e8 b7 18 00 00       	call   103ac0 <get_current_task>
  102209:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
  10220f:	89 48 1c             	mov    %ecx,0x1c(%eax)
            break;
  102212:	e9 70 00 00 00       	jmp    102287 <syscall+0x547>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  102217:	e8 a4 18 00 00       	call   103ac0 <get_current_task>
  10221c:	8b 40 24             	mov    0x24(%eax),%eax
  10221f:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdin = open;
  102222:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102225:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  10222b:	e8 90 18 00 00       	call   103ac0 <get_current_task>
  102230:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
  102236:	89 48 24             	mov    %ecx,0x24(%eax)
            break;
  102239:	e9 49 00 00 00       	jmp    102287 <syscall+0x547>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  10223e:	e8 7d 18 00 00       	call   103ac0 <get_current_task>
  102243:	8b 40 20             	mov    0x20(%eax),%eax
  102246:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stderr = open;
  102249:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10224c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
  102252:	e8 69 18 00 00       	call   103ac0 <get_current_task>
  102257:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
  10225d:	89 48 20             	mov    %ecx,0x20(%eax)
            break;
  102260:	e9 22 00 00 00       	jmp    102287 <syscall+0x547>
        default:
            oldhandle = get_current_task()->stdout;
  102265:	e8 56 18 00 00       	call   103ac0 <get_current_task>
  10226a:	8b 40 1c             	mov    0x1c(%eax),%eax
  10226d:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdout = open;
  102270:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102273:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
  102279:	e8 42 18 00 00       	call   103ac0 <get_current_task>
  10227e:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
  102284:	89 48 1c             	mov    %ecx,0x1c(%eax)
            break;
        }

        if(oldhandle != 0) {
  102287:	81 7d b8 00 00 00 00 	cmpl   $0x0,-0x48(%ebp)
  10228e:	0f 84 11 00 00 00    	je     1022a5 <syscall+0x565>
            vfs_close(oldhandle);
  102294:	8b 45 b8             	mov    -0x48(%ebp),%eax
  102297:	89 04 24             	mov    %eax,(%esp)
  10229a:	e8 51 2e 00 00       	call   1050f0 <vfs_close>
  10229f:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
        }

        cpu->eax = 0;
  1022a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1022a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	    break;
  1022ae:	e9 af 00 00 00       	jmp    102362 <syscall+0x622>
  1022b3:	8d 05 76 82 10 00    	lea    0x108276,%eax

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  1022b9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1022bc:	8b 49 04             	mov    0x4(%ecx),%ecx
  1022bf:	89 04 24             	mov    %eax,(%esp)
  1022c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1022c6:	e8 a5 e2 ff ff       	call   100570 <kprintf>
  1022cb:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1022ce:	89 01                	mov    %eax,(%ecx)
		break;
  1022d0:	e9 8d 00 00 00       	jmp    102362 <syscall+0x622>
  1022d5:	8d 05 79 82 10 00    	lea    0x108279,%eax

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  1022db:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1022de:	8b 49 04             	mov    0x4(%ecx),%ecx
  1022e1:	89 04 24             	mov    %eax,(%esp)
  1022e4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1022e8:	e8 83 e2 ff ff       	call   100570 <kprintf>
  1022ed:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1022f0:	89 01                	mov    %eax,(%ecx)
		break;
  1022f2:	e9 6b 00 00 00       	jmp    102362 <syscall+0x622>

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  1022f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1022fa:	8b 40 04             	mov    0x4(%eax),%eax
  1022fd:	89 04 24             	mov    %eax,(%esp)
  102300:	e8 2b 3f 00 00       	call   106230 <vmm_alloc_ucont>
  102305:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102308:	89 01                	mov    %eax,(%ecx)
		break;
  10230a:	e9 53 00 00 00       	jmp    102362 <syscall+0x622>

	case 204: /* vmm_free */
		cpu->eax = 0;
  10230f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102312:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  102318:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10231b:	81 78 04 00 10 40 20 	cmpl   $0x20401000,0x4(%eax)
  102322:	0f 82 0e 00 00 00    	jb     102336 <syscall+0x5f6>
			vmm_free((void*) cpu->ebx);
  102328:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10232b:	8b 40 04             	mov    0x4(%eax),%eax
  10232e:	89 04 24             	mov    %eax,(%esp)
  102331:	e8 6a 3d 00 00       	call   1060a0 <vmm_free>
		}
		break;
  102336:	e9 27 00 00 00       	jmp    102362 <syscall+0x622>

	case 205: /* pmm_print_stats */
		pmm_print_stats();
  10233b:	e8 d0 03 00 00       	call   102710 <pmm_print_stats>
		break;
  102340:	e9 1d 00 00 00       	jmp    102362 <syscall+0x622>
  102345:	8d 05 7c 82 10 00    	lea    0x10827c,%eax

	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  10234b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10234e:	8b 09                	mov    (%ecx),%ecx
  102350:	89 04 24             	mov    %eax,(%esp)
  102353:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102357:	e8 14 e2 ff ff       	call   100570 <kprintf>
  10235c:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		break;
	}

	return cpu;
  102362:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102365:	81 c4 d4 00 00 00    	add    $0xd4,%esp
  10236b:	5e                   	pop    %esi
  10236c:	5d                   	pop    %ebp
  10236d:	c3                   	ret    
  10236e:	66 90                	xchg   %ax,%ax

00102370 <kernel_main>:
}

void kernel_main(struct multiboot_info* mb_info) {
  102370:	55                   	push   %ebp
  102371:	89 e5                	mov    %esp,%ebp
  102373:	57                   	push   %edi
  102374:	56                   	push   %esi
  102375:	83 ec 60             	sub    $0x60,%esp
  102378:	8b 45 08             	mov    0x8(%ebp),%eax
  10237b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t kernel_init_pdir = vmm_init();
  10237e:	e8 ad 41 00 00       	call   106530 <vmm_init>
  102383:	8d 0d 92 82 10 00    	lea    0x108292,%ecx
  102389:	89 45 f0             	mov    %eax,-0x10(%ebp)

	kprintf("Setting PIT interval...\n");
  10238c:	89 0c 24             	mov    %ecx,(%esp)
  10238f:	e8 dc e1 ff ff       	call   100570 <kprintf>
  102394:	b9 43 00 00 00       	mov    $0x43,%ecx
  102399:	ba 36 00 00 00       	mov    $0x36,%edx

	outb(0x43, 0x36);
  10239e:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
  1023a5:	c7 44 24 04 36 00 00 	movl   $0x36,0x4(%esp)
  1023ac:	00 
  1023ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1023b0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1023b3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1023b6:	e8 05 02 00 00       	call   1025c0 <outb>
  1023bb:	b8 40 00 00 00       	mov    $0x40,%eax
  1023c0:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
	outw(0x40, 1000);
  1023c5:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  1023cc:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  1023d3:	00 
  1023d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1023d7:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1023da:	e8 11 02 00 00       	call   1025f0 <outw>
  1023df:	8d 05 ab 82 10 00    	lea    0x1082ab,%eax

    kprintf("Initializing vfs...\n");
  1023e5:	89 04 24             	mov    %eax,(%esp)
  1023e8:	e8 83 e1 ff ff       	call   100570 <kprintf>

    vfs_init_root();
  1023ed:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1023f0:	e8 4b 33 00 00       	call   105740 <vfs_init_root>
  1023f5:	b8 00 00 00 00       	mov    $0x0,%eax
    ramfs_fifo_init();
  1023fa:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1023fd:	e8 9e 0b 00 00       	call   102fa0 <ramfs_fifo_init>
    ramfs_block_init();
  102402:	e8 e9 06 00 00       	call   102af0 <ramfs_block_init>

    map_address_active((uint32_t) mb_info,
  102407:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10240a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10240d:	89 04 24             	mov    %eax,(%esp)
  102410:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102414:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10241b:	00 
  10241c:	e8 ff 3c 00 00       	call   106120 <map_address_active>
  102421:	b8 00 00 00 00       	mov    $0x0,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  102426:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102429:	8b 49 18             	mov    0x18(%ecx),%ecx
  10242c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10242f:	8b 52 18             	mov    0x18(%edx),%edx
  102432:	89 0c 24             	mov    %ecx,(%esp)
  102435:	89 54 24 04          	mov    %edx,0x4(%esp)
  102439:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102440:	00 
  102441:	89 45 d0             	mov    %eax,-0x30(%ebp)
  102444:	e8 d7 3c 00 00       	call   106120 <map_address_active>
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  102449:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10244c:	8b 00                	mov    (%eax),%eax
  10244e:	25 08 00 00 00       	and    $0x8,%eax
  102453:	3d 00 00 00 00       	cmp    $0x0,%eax
  102458:	0f 84 aa 00 00 00    	je     102508 <kernel_main+0x198>
  10245e:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  102463:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102466:	8b 49 18             	mov    0x18(%ecx),%ecx
  102469:	8b 09                	mov    (%ecx),%ecx
  10246b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10246e:	8b 52 18             	mov    0x18(%edx),%edx
  102471:	8b 12                	mov    (%edx),%edx
  102473:	8b 75 f4             	mov    -0xc(%ebp),%esi
  102476:	8b 76 18             	mov    0x18(%esi),%esi
  102479:	8b 76 04             	mov    0x4(%esi),%esi
  10247c:	8b 7d f4             	mov    -0xc(%ebp),%edi
  10247f:	8b 7f 18             	mov    0x18(%edi),%edi
  102482:	8b 3f                	mov    (%edi),%edi
  102484:	29 fe                	sub    %edi,%esi
  102486:	89 0c 24             	mov    %ecx,(%esp)
  102489:	89 54 24 04          	mov    %edx,0x4(%esp)
  10248d:	89 74 24 08          	mov    %esi,0x8(%esp)
  102491:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  102498:	00 
  102499:	89 45 cc             	mov    %eax,-0x34(%ebp)
  10249c:	e8 ef 3c 00 00       	call   106190 <vmm_map_range>
  1024a1:	8d 05 c0 82 10 00    	lea    0x1082c0,%eax
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  1024a7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1024aa:	8b 49 18             	mov    0x18(%ecx),%ecx
  1024ad:	8b 49 04             	mov    0x4(%ecx),%ecx
  1024b0:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1024b3:	8b 52 18             	mov    0x18(%edx),%edx
  1024b6:	8b 12                	mov    (%edx),%edx
  1024b8:	29 d1                	sub    %edx,%ecx
  1024ba:	89 04 24             	mov    %eax,(%esp)
  1024bd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1024c1:	e8 aa e0 ff ff       	call   100570 <kprintf>
  1024c6:	8d 0d 00 83 10 00    	lea    0x108300,%ecx
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);
  1024cc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1024cf:	8b 52 18             	mov    0x18(%edx),%edx
  1024d2:	8b 12                	mov    (%edx),%edx
  1024d4:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1024d7:	8b 76 18             	mov    0x18(%esi),%esi
  1024da:	8b 76 04             	mov    0x4(%esi),%esi
  1024dd:	89 0c 24             	mov    %ecx,(%esp)
  1024e0:	89 54 24 04          	mov    %edx,0x4(%esp)
  1024e4:	89 74 24 08          	mov    %esi,0x8(%esp)
  1024e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
  1024eb:	e8 80 e0 ff ff       	call   100570 <kprintf>

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  1024f0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1024f3:	8b 49 18             	mov    0x18(%ecx),%ecx
  1024f6:	8b 09                	mov    (%ecx),%ecx
  1024f8:	89 0c 24             	mov    %ecx,(%esp)
  1024fb:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1024fe:	e8 1d 10 00 00       	call   103520 <tar_load_ramfs>
    } else {
  102503:	e9 11 00 00 00       	jmp    102519 <kernel_main+0x1a9>
  102508:	8d 05 1a 83 10 00    	lea    0x10831a,%eax
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  10250e:	89 04 24             	mov    %eax,(%esp)
  102511:	e8 5a e0 ff ff       	call   100570 <kprintf>
  102516:	89 45 c0             	mov    %eax,-0x40(%ebp)
  102519:	8d 05 4c 83 10 00    	lea    0x10834c,%eax
    }

    kprintf("[kernel_res] Creating /dev/vga\n");
  10251f:	89 04 24             	mov    %eax,(%esp)
  102522:	e8 49 e0 ff ff       	call   100570 <kprintf>
  102527:	8d 0d 6c 83 10 00    	lea    0x10836c,%ecx
  10252d:	ba 00 00 00 00       	mov    $0x0,%edx
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  102532:	89 45 bc             	mov    %eax,-0x44(%ebp)
  102535:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  102538:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  10253b:	e8 40 15 00 00       	call   103a80 <ramfs_vga_driver_struct>
  102540:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  102543:	89 0c 24             	mov    %ecx,(%esp)
  102546:	89 44 24 04          	mov    %eax,0x4(%esp)
  10254a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102551:	00 
  102552:	e8 a9 29 00 00       	call   104f00 <vfs_create_kfile>
  102557:	8d 0d 75 83 10 00    	lea    0x108375,%ecx

    if(vfs_exists("/ibin/init")) {
  10255d:	89 0c 24             	mov    %ecx,(%esp)
  102560:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102563:	e8 08 2e 00 00       	call   105370 <vfs_exists>
  102568:	3d 00 00 00 00       	cmp    $0x0,%eax
  10256d:	0f 84 3c 00 00 00    	je     1025af <kernel_main+0x23f>
  102573:	8d 05 80 83 10 00    	lea    0x108380,%eax
        kprintf("[init] /ibin/init found. Executing...\n");
  102579:	89 04 24             	mov    %eax,(%esp)
  10257c:	e8 ef df ff ff       	call   100570 <kprintf>
  102581:	8d 0d 75 83 10 00    	lea    0x108375,%ecx
  102587:	ba 00 00 00 00       	mov    $0x0,%edx

        vfs_exec("/ibin/init", 0, 0);
  10258c:	89 0c 24             	mov    %ecx,(%esp)
  10258f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102596:	00 
  102597:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10259e:	00 
  10259f:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1025a2:	89 55 a8             	mov    %edx,-0x58(%ebp)
  1025a5:	e8 56 2e 00 00       	call   105400 <vfs_exec>
        enableScheduling();
  1025aa:	e8 f1 14 00 00       	call   103aa0 <enableScheduling>
    }

	while(1);
  1025af:	e9 00 00 00 00       	jmp    1025b4 <kernel_main+0x244>
  1025b4:	e9 fb ff ff ff       	jmp    1025b4 <kernel_main+0x244>
  1025b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

001025c0 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  1025c0:	55                   	push   %ebp
  1025c1:	89 e5                	mov    %esp,%ebp
  1025c3:	50                   	push   %eax
  1025c4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1025c8:	66 89 c1             	mov    %ax,%cx
  1025cb:	8a 55 0c             	mov    0xc(%ebp),%dl
  1025ce:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  1025d2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  1025d5:	8a 45 fd             	mov    -0x3(%ebp),%al
  1025d8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1025dc:	ee                   	out    %al,(%dx)
}
  1025dd:	83 c4 04             	add    $0x4,%esp
  1025e0:	5d                   	pop    %ebp
  1025e1:	c3                   	ret    
  1025e2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1025e9:	1f 84 00 00 00 00 00 

001025f0 <outw>:
    uint32_t result;
    asm volatile ("inl %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline void outw(uint16_t _port, uint16_t _data) {
  1025f0:	55                   	push   %ebp
  1025f1:	89 e5                	mov    %esp,%ebp
  1025f3:	50                   	push   %eax
  1025f4:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  1025f8:	66 89 c1             	mov    %ax,%cx
  1025fb:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1025ff:	66 89 c2             	mov    %ax,%dx
  102602:	66 89 55 fe          	mov    %dx,-0x2(%ebp)
  102606:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
  10260a:	66 8b 45 fc          	mov    -0x4(%ebp),%ax
  10260e:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  102612:	66 ef                	out    %ax,(%dx)
}
  102614:	83 c4 04             	add    $0x4,%esp
  102617:	5d                   	pop    %ebp
  102618:	c3                   	ret    
  102619:	66 90                	xchg   %ax,%ax
  10261b:	66 90                	xchg   %ax,%ax
  10261d:	66 90                	xchg   %ax,%ax
  10261f:	90                   	nop

00102620 <pmm_alloc>:
#define BITMAP_SIZE 32768

uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
  102620:	55                   	push   %ebp
  102621:	89 e5                	mov    %esp,%ebp
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102623:	56                   	push   %esi
  102624:	83 ec 10             	sub    $0x10,%esp
  102627:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10262e:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102635:	0f 8d b7 00 00 00    	jge    1026f2 <pmm_alloc+0xd2>
		if (allocatable[i]) {
  10263b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10263e:	81 3c 85 98 a4 12 00 	cmpl   $0x0,0x12a498(,%eax,4)
  102645:	00 00 00 00 
  102649:	0f 84 8e 00 00 00    	je     1026dd <pmm_alloc+0xbd>
			int s;
			for (s = 0; s < 32; s++) {
  10264f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102656:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  10265d:	0f 8d 75 00 00 00    	jge    1026d8 <pmm_alloc+0xb8>
  102663:	b8 01 00 00 00       	mov    $0x1,%eax
				if (allocatable[i] & (1 << s)) {
  102668:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10266b:	8b 0c 8d 98 a4 12 00 	mov    0x12a498(,%ecx,4),%ecx
  102672:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102675:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102678:	89 d1                	mov    %edx,%ecx
  10267a:	d3 e0                	shl    %cl,%eax
  10267c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10267f:	21 c2                	and    %eax,%edx
  102681:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  102687:	0f 84 36 00 00 00    	je     1026c3 <pmm_alloc+0xa3>
  10268d:	b8 01 00 00 00       	mov    $0x1,%eax
					allocatable[i] &= ~(1 << s);
  102692:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102695:	d3 e0                	shl    %cl,%eax
  102697:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  10269c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10269f:	8b 34 95 98 a4 12 00 	mov    0x12a498(,%edx,4),%esi
  1026a6:	21 c6                	and    %eax,%esi
  1026a8:	89 34 95 98 a4 12 00 	mov    %esi,0x12a498(,%edx,4)
					return (uint8_t*) ((i * 32 + s) * 4096);
  1026af:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026b2:	c1 e0 05             	shl    $0x5,%eax
  1026b5:	03 45 f0             	add    -0x10(%ebp),%eax
  1026b8:	c1 e0 0c             	shl    $0xc,%eax
  1026bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1026be:	e9 36 00 00 00       	jmp    1026f9 <pmm_alloc+0xd9>
				}
			}
  1026c3:	e9 00 00 00 00       	jmp    1026c8 <pmm_alloc+0xa8>
void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
		if (allocatable[i]) {
			int s;
			for (s = 0; s < 32; s++) {
  1026c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1026cb:	05 01 00 00 00       	add    $0x1,%eax
  1026d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1026d3:	e9 7e ff ff ff       	jmp    102656 <pmm_alloc+0x36>
				if (allocatable[i] & (1 << s)) {
					allocatable[i] &= ~(1 << s);
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
  1026d8:	e9 00 00 00 00       	jmp    1026dd <pmm_alloc+0xbd>
	}
  1026dd:	e9 00 00 00 00       	jmp    1026e2 <pmm_alloc+0xc2>
uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  1026e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1026e5:	05 01 00 00 00       	add    $0x1,%eax
  1026ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1026ed:	e9 3c ff ff ff       	jmp    10262e <pmm_alloc+0xe>
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
	}
	return NULL ;
  1026f2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  1026f9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1026fc:	83 c4 10             	add    $0x10,%esp
  1026ff:	5e                   	pop    %esi
  102700:	5d                   	pop    %ebp
  102701:	c3                   	ret    
  102702:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102709:	1f 84 00 00 00 00 00 

00102710 <pmm_print_stats>:

void pmm_print_stats() {
  102710:	55                   	push   %ebp
  102711:	89 e5                	mov    %esp,%ebp
  102713:	56                   	push   %esi
  102714:	83 ec 34             	sub    $0x34,%esp
  102717:	b8 00 00 10 00       	mov    $0x100000,%eax
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
  10271c:	c7 04 24 00 00 10 00 	movl   $0x100000,(%esp)
  102723:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102726:	e8 65 00 00 00       	call   102790 <pmm_get_free_space>
  10272b:	b9 00 04 00 00       	mov    $0x400,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102730:	8b 15 28 a4 10 00    	mov    0x10a428,%edx
  102736:	c1 ea 14             	shr    $0x14,%edx
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
  102739:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
  102740:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102743:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  102746:	89 55 ec             	mov    %edx,-0x14(%ebp)
  102749:	e8 42 00 00 00       	call   102790 <pmm_get_free_space>
  10274e:	8d 0d a7 83 10 00    	lea    0x1083a7,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102754:	8b 15 28 a4 10 00    	mov    0x10a428,%edx
  10275a:	c1 ea 0a             	shr    $0xa,%edx
  10275d:	89 0c 24             	mov    %ecx,(%esp)
  102760:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102763:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102767:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10276a:	89 74 24 08          	mov    %esi,0x8(%esp)
  10276e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102772:	89 54 24 10          	mov    %edx,0x10(%esp)
  102776:	e8 f5 dd ff ff       	call   100570 <kprintf>
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
}
  10277b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10277e:	83 c4 34             	add    $0x34,%esp
  102781:	5e                   	pop    %esi
  102782:	5d                   	pop    %ebp
  102783:	c3                   	ret    
  102784:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10278b:	00 00 00 00 00 

00102790 <pmm_get_free_space>:

uint32_t pmm_get_free_space(uint32_t div) {
  102790:	55                   	push   %ebp
  102791:	89 e5                	mov    %esp,%ebp
  102793:	83 ec 14             	sub    $0x14,%esp
  102796:	8b 45 08             	mov    0x8(%ebp),%eax
  102799:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t free = 0;
  10279c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  1027a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  1027aa:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  1027b1:	0f 83 73 00 00 00    	jae    10282a <pmm_get_free_space+0x9a>
		for (uint32_t s = 0; s < 32; s++) {
  1027b7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1027be:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  1027c5:	0f 83 4a 00 00 00    	jae    102815 <pmm_get_free_space+0x85>
  1027cb:	b8 01 00 00 00       	mov    $0x1,%eax
			if (allocatable[i] & (1 << s))
  1027d0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1027d3:	8b 0c 8d 98 a4 12 00 	mov    0x12a498(,%ecx,4),%ecx
  1027da:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1027dd:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1027e0:	89 d1                	mov    %edx,%ecx
  1027e2:	d3 e0                	shl    %cl,%eax
  1027e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1027e7:	21 c2                	and    %eax,%edx
  1027e9:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  1027ef:	0f 84 0b 00 00 00    	je     102800 <pmm_get_free_space+0x70>
				free += 0x1000;
  1027f5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1027f8:	05 00 10 00 00       	add    $0x1000,%eax
  1027fd:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  102800:	e9 00 00 00 00       	jmp    102805 <pmm_get_free_space+0x75>

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
		for (uint32_t s = 0; s < 32; s++) {
  102805:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102808:	05 01 00 00 00       	add    $0x1,%eax
  10280d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102810:	e9 a9 ff ff ff       	jmp    1027be <pmm_get_free_space+0x2e>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}
  102815:	e9 00 00 00 00       	jmp    10281a <pmm_get_free_space+0x8a>
}

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  10281a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10281d:	05 01 00 00 00       	add    $0x1,%eax
  102822:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102825:	e9 80 ff ff ff       	jmp    1027aa <pmm_get_free_space+0x1a>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}

	return free / div;
  10282a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10282d:	31 d2                	xor    %edx,%edx
  10282f:	f7 75 fc             	divl   -0x4(%ebp)
  102832:	83 c4 14             	add    $0x14,%esp
  102835:	5d                   	pop    %ebp
  102836:	c3                   	ret    
  102837:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10283e:	00 00 

00102840 <pmm_free>:
}

void pmm_free(void* addr) {
  102840:	55                   	push   %ebp
  102841:	89 e5                	mov    %esp,%ebp
  102843:	56                   	push   %esi
  102844:	83 ec 14             	sub    $0x14,%esp
  102847:	8b 45 08             	mov    0x8(%ebp),%eax
  10284a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10284f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  102852:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102855:	c1 e8 0c             	shr    $0xc,%eax
  102858:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  10285b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10285e:	25 1f 00 00 00       	and    $0x1f,%eax
  102863:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  102866:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102869:	c1 e8 05             	shr    $0x5,%eax
  10286c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] |= (1 << s);
  10286f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102872:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102875:	89 c1                	mov    %eax,%ecx
  102877:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10287a:	d3 e0                	shl    %cl,%eax
  10287c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10287f:	8b 34 95 98 a4 12 00 	mov    0x12a498(,%edx,4),%esi
  102886:	09 c6                	or     %eax,%esi
  102888:	89 34 95 98 a4 12 00 	mov    %esi,0x12a498(,%edx,4)
}
  10288f:	83 c4 14             	add    $0x14,%esp
  102892:	5e                   	pop    %esi
  102893:	5d                   	pop    %ebp
  102894:	c3                   	ret    
  102895:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10289c:	00 00 00 00 

001028a0 <pmm_mark_used>:

void pmm_mark_used(void* addr) {
  1028a0:	55                   	push   %ebp
  1028a1:	89 e5                	mov    %esp,%ebp
  1028a3:	56                   	push   %esi
  1028a4:	83 ec 14             	sub    $0x14,%esp
  1028a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1028aa:	b9 01 00 00 00       	mov    $0x1,%ecx
  1028af:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  1028b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1028b5:	c1 e8 0c             	shr    $0xc,%eax
  1028b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  1028bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028be:	25 1f 00 00 00       	and    $0x1f,%eax
  1028c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  1028c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028c9:	c1 e8 05             	shr    $0x5,%eax
  1028cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] &= ~(1 << s);
  1028cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1028d2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1028d5:	89 c1                	mov    %eax,%ecx
  1028d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1028da:	d3 e0                	shl    %cl,%eax
  1028dc:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  1028e1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1028e4:	8b 34 95 98 a4 12 00 	mov    0x12a498(,%edx,4),%esi
  1028eb:	21 c6                	and    %eax,%esi
  1028ed:	89 34 95 98 a4 12 00 	mov    %esi,0x12a498(,%edx,4)
}
  1028f4:	83 c4 14             	add    $0x14,%esp
  1028f7:	5e                   	pop    %esi
  1028f8:	5d                   	pop    %ebp
  1028f9:	c3                   	ret    
  1028fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00102900 <pmm_init>:

void pmm_init(struct multiboot_info* mb_info) {
  102900:	55                   	push   %ebp
  102901:	89 e5                	mov    %esp,%ebp
  102903:	53                   	push   %ebx
  102904:	57                   	push   %edi
  102905:	56                   	push   %esi
  102906:	83 ec 5c             	sub    $0x5c,%esp
  102909:	8b 45 08             	mov    0x8(%ebp),%eax
  10290c:	8d 0d e4 83 10 00    	lea    0x1083e4,%ecx
  102912:	8d 15 98 a4 12 00    	lea    0x12a498,%edx
  102918:	89 d6                	mov    %edx,%esi
  10291a:	81 c6 00 00 02 00    	add    $0x20000,%esi
  102920:	89 d7                	mov    %edx,%edi
  102922:	bb 00 00 00 00       	mov    $0x0,%ebx
  102927:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10292a:	b8 00 00 02 00       	mov    $0x20000,%eax
  10292f:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102932:	8b 45 d0             	mov    -0x30(%ebp),%eax
  102935:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct multiboot_mmap* mmap = mb_info->mi_mmap_addr;
  102938:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10293b:	8b 40 30             	mov    0x30(%eax),%eax
  10293e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct multiboot_mmap* mmap_end = (void*) ((uintptr_t) mb_info->mi_mmap_addr
  102941:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102944:	8b 40 30             	mov    0x30(%eax),%eax
  102947:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10294a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10294d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  102950:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102953:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  102956:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  102959:	03 41 2c             	add    0x2c(%ecx),%eax
  10295c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			+ mb_info->mi_mmap_length);

	memset(allocatable, 0, sizeof(allocatable));
  10295f:	89 3c 24             	mov    %edi,(%esp)
  102962:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102969:	00 
  10296a:	c7 44 24 08 00 00 02 	movl   $0x20000,0x8(%esp)
  102971:	00 
  102972:	89 5d bc             	mov    %ebx,-0x44(%ebp)
  102975:	89 55 b8             	mov    %edx,-0x48(%ebp)
  102978:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  10297b:	e8 60 1e 00 00       	call   1047e0 <memset>

	kprintf("Mem-Bitmap: %x to %x\n", allocatable, &(allocatable[BITMAP_SIZE]));
  102980:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102983:	89 04 24             	mov    %eax,(%esp)
  102986:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  102989:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10298d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  102990:	89 54 24 08          	mov    %edx,0x8(%esp)
  102994:	e8 d7 db ff ff       	call   100570 <kprintf>
  102999:	89 45 b0             	mov    %eax,-0x50(%ebp)

	while (mmap < mmap_end) {
  10299c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10299f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  1029a2:	0f 83 77 00 00 00    	jae    102a1f <pmm_init+0x11f>
		if (mmap->mm_type == 1) {
  1029a8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1029ab:	81 78 14 01 00 00 00 	cmpl   $0x1,0x14(%eax)
  1029b2:	0f 85 57 00 00 00    	jne    102a0f <pmm_init+0x10f>
			uintptr_t addr = mmap->mm_base_addr;
  1029b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1029bb:	8b 40 04             	mov    0x4(%eax),%eax
  1029be:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uintptr_t end_addr = addr + mmap->mm_length;
  1029c1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1029c4:	8b 49 0c             	mov    0xc(%ecx),%ecx
  1029c7:	01 c8                	add    %ecx,%eax
  1029c9:	89 45 e0             	mov    %eax,-0x20(%ebp)

			while (addr < end_addr) {
  1029cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1029cf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  1029d2:	0f 83 32 00 00 00    	jae    102a0a <pmm_init+0x10a>
				pmm_free((void*) addr);
  1029d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1029db:	89 04 24             	mov    %eax,(%esp)
  1029de:	e8 5d fe ff ff       	call   102840 <pmm_free>
				if (addr > upper_limit)
  1029e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1029e6:	3b 05 28 a4 10 00    	cmp    0x10a428,%eax
  1029ec:	0f 86 08 00 00 00    	jbe    1029fa <pmm_init+0xfa>
					upper_limit = addr;
  1029f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1029f5:	a3 28 a4 10 00       	mov    %eax,0x10a428
				addr += 0x1000;
  1029fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1029fd:	05 00 10 00 00       	add    $0x1000,%eax
  102a02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			}
  102a05:	e9 c2 ff ff ff       	jmp    1029cc <pmm_init+0xcc>
		}
  102a0a:	e9 00 00 00 00       	jmp    102a0f <pmm_init+0x10f>
		mmap++;
  102a0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a12:	05 18 00 00 00       	add    $0x18,%eax
  102a17:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}
  102a1a:	e9 7d ff ff ff       	jmp    10299c <pmm_init+0x9c>
  102a1f:	8d 05 00 00 10 00    	lea    0x100000,%eax

	extern const void kernel_start;
	extern const void kernel_end;

	uintptr_t addr = (uintptr_t) &kernel_start;
  102a25:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102a28:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
	while (addr < (uintptr_t) &kernel_end) {
  102a2e:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  102a31:	0f 83 1b 00 00 00    	jae    102a52 <pmm_init+0x152>
		pmm_mark_used((void*) addr);
  102a37:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102a3a:	89 04 24             	mov    %eax,(%esp)
  102a3d:	e8 5e fe ff ff       	call   1028a0 <pmm_mark_used>
		addr += 0x1000;
  102a42:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102a45:	05 00 10 00 00       	add    $0x1000,%eax
  102a4a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
  102a4d:	e9 d6 ff ff ff       	jmp    102a28 <pmm_init+0x128>

	struct multiboot_module* modules = mb_info->mi_mods_addr;
  102a52:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102a55:	8b 40 18             	mov    0x18(%eax),%eax
  102a58:	89 45 d8             	mov    %eax,-0x28(%ebp)

	pmm_mark_used(mb_info);
  102a5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102a5e:	89 04 24             	mov    %eax,(%esp)
  102a61:	e8 3a fe ff ff       	call   1028a0 <pmm_mark_used>
	pmm_mark_used(modules);
  102a66:	8b 45 d8             	mov    -0x28(%ebp),%eax
  102a69:	89 04 24             	mov    %eax,(%esp)
  102a6c:	e8 2f fe ff ff       	call   1028a0 <pmm_mark_used>

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  102a71:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  102a78:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102a7b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102a7e:	3b 41 14             	cmp    0x14(%ecx),%eax
  102a81:	0f 83 59 00 00 00    	jae    102ae0 <pmm_init+0x1e0>
		addr = (uintptr_t) modules[i].start;
  102a87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102a8a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  102a8d:	c1 e0 04             	shl    $0x4,%eax
  102a90:	01 c1                	add    %eax,%ecx
  102a92:	8b 01                	mov    (%ecx),%eax
  102a94:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while (addr < (uintptr_t) modules[i].end) {
  102a97:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102a9a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  102a9d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  102aa0:	c1 e1 04             	shl    $0x4,%ecx
  102aa3:	01 ca                	add    %ecx,%edx
  102aa5:	8b 4a 04             	mov    0x4(%edx),%ecx
  102aa8:	39 c8                	cmp    %ecx,%eax
  102aaa:	0f 83 1b 00 00 00    	jae    102acb <pmm_init+0x1cb>
			pmm_mark_used((void*) addr);
  102ab0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ab3:	89 04 24             	mov    %eax,(%esp)
  102ab6:	e8 e5 fd ff ff       	call   1028a0 <pmm_mark_used>
			addr += 0x1000;
  102abb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102abe:	05 00 10 00 00       	add    $0x1000,%eax
  102ac3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
  102ac6:	e9 cc ff ff ff       	jmp    102a97 <pmm_init+0x197>
	}
  102acb:	e9 00 00 00 00       	jmp    102ad0 <pmm_init+0x1d0>

	pmm_mark_used(mb_info);
	pmm_mark_used(modules);

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  102ad0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102ad3:	05 01 00 00 00       	add    $0x1,%eax
  102ad8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102adb:	e9 98 ff ff ff       	jmp    102a78 <pmm_init+0x178>
		while (addr < (uintptr_t) modules[i].end) {
			pmm_mark_used((void*) addr);
			addr += 0x1000;
		}
	}
}
  102ae0:	83 c4 5c             	add    $0x5c,%esp
  102ae3:	5e                   	pop    %esi
  102ae4:	5f                   	pop    %edi
  102ae5:	5b                   	pop    %ebx
  102ae6:	5d                   	pop    %ebp
  102ae7:	c3                   	ret    
  102ae8:	66 90                	xchg   %ax,%ax
  102aea:	66 90                	xchg   %ax,%ax
  102aec:	66 90                	xchg   %ax,%ax
  102aee:	66 90                	xchg   %ax,%ax

00102af0 <ramfs_block_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  102af0:	55                   	push   %ebp
  102af1:	89 e5                	mov    %esp,%ebp
  102af3:	83 ec 18             	sub    $0x18,%esp
  102af6:	8d 05 98 a4 14 00    	lea    0x14a498,%eax
  102afc:	b9 00 00 00 00       	mov    $0x0,%ecx
  102b01:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102b06:	89 04 24             	mov    %eax,(%esp)
  102b09:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102b10:	00 
  102b11:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102b18:	00 
  102b19:	89 55 fc             	mov    %edx,-0x4(%ebp)
  102b1c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102b1f:	e8 bc 1c 00 00       	call   1047e0 <memset>
}
  102b24:	83 c4 18             	add    $0x18,%esp
  102b27:	5d                   	pop    %ebp
  102b28:	c3                   	ret    
  102b29:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102b30 <ramfs_block_read>:
    }

    return 0;
}

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  102b30:	55                   	push   %ebp
  102b31:	89 e5                	mov    %esp,%ebp
  102b33:	83 ec 28             	sub    $0x28,%esp
  102b36:	8b 45 10             	mov    0x10(%ebp),%eax
  102b39:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102b3c:	8b 55 08             	mov    0x8(%ebp),%edx
  102b3f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102b42:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102b45:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102b48:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102b4b:	8b 40 04             	mov    0x4(%eax),%eax
  102b4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102b51:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b54:	8b 00                	mov    (%eax),%eax
  102b56:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  102b5d:	00 00 00 00 
  102b61:	0f 84 70 00 00 00    	je     102bd7 <ramfs_block_read+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't read that much biatch
  102b67:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102b6a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b6d:	8b 09                	mov    (%ecx),%ecx
  102b6f:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  102b76:	8b 49 04             	mov    0x4(%ecx),%ecx
  102b79:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102b7c:	2b 4a 08             	sub    0x8(%edx),%ecx
  102b7f:	39 c8                	cmp    %ecx,%eax
  102b81:	0f 86 0c 00 00 00    	jbe    102b93 <ramfs_block_read+0x63>
  102b87:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102b8e:	e9 4b 00 00 00       	jmp    102bde <ramfs_block_read+0xae>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  102b93:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102b96:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b99:	8b 09                	mov    (%ecx),%ecx
  102b9b:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  102ba2:	8b 09                	mov    (%ecx),%ecx
  102ba4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102ba7:	03 4a 08             	add    0x8(%edx),%ecx
  102baa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102bad:	89 04 24             	mov    %eax,(%esp)
  102bb0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102bb4:	89 54 24 08          	mov    %edx,0x8(%esp)
  102bb8:	e8 83 1c 00 00       	call   104840 <memcpy>
        handle->position += length;
  102bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102bc0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102bc3:	8b 51 08             	mov    0x8(%ecx),%edx
  102bc6:	01 c2                	add    %eax,%edx
  102bc8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102bcb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102bd2:	e9 07 00 00 00       	jmp    102bde <ramfs_block_read+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102bd7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102bde:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102be1:	83 c4 28             	add    $0x28,%esp
  102be4:	5d                   	pop    %ebp
  102be5:	c3                   	ret    
  102be6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  102bed:	00 00 00 

00102bf0 <ramfs_block_write>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  102bf0:	55                   	push   %ebp
  102bf1:	89 e5                	mov    %esp,%ebp
  102bf3:	83 ec 28             	sub    $0x28,%esp
  102bf6:	8b 45 10             	mov    0x10(%ebp),%eax
  102bf9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102bfc:	8b 55 08             	mov    0x8(%ebp),%edx
  102bff:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102c02:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102c05:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102c08:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c0b:	8b 40 04             	mov    0x4(%eax),%eax
  102c0e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102c11:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102c14:	8b 00                	mov    (%eax),%eax
  102c16:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  102c1d:	00 00 00 00 
  102c21:	0f 84 70 00 00 00    	je     102c97 <ramfs_block_write+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't write  that much biatch TODO realloc so file may grow
  102c27:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c2a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102c2d:	8b 09                	mov    (%ecx),%ecx
  102c2f:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  102c36:	8b 49 04             	mov    0x4(%ecx),%ecx
  102c39:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102c3c:	2b 4a 08             	sub    0x8(%edx),%ecx
  102c3f:	39 c8                	cmp    %ecx,%eax
  102c41:	0f 86 0c 00 00 00    	jbe    102c53 <ramfs_block_write+0x63>
  102c47:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102c4e:	e9 4b 00 00 00       	jmp    102c9e <ramfs_block_write+0xae>

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  102c53:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102c56:	8b 00                	mov    (%eax),%eax
  102c58:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102c5f:	8b 00                	mov    (%eax),%eax
  102c61:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102c64:	03 41 08             	add    0x8(%ecx),%eax
  102c67:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102c6a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102c6d:	89 04 24             	mov    %eax,(%esp)
  102c70:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102c74:	89 54 24 08          	mov    %edx,0x8(%esp)
  102c78:	e8 c3 1b 00 00       	call   104840 <memcpy>
        handle->position += length;
  102c7d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c80:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102c83:	8b 51 08             	mov    0x8(%ecx),%edx
  102c86:	01 c2                	add    %eax,%edx
  102c88:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102c8b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102c92:	e9 07 00 00 00       	jmp    102c9e <ramfs_block_write+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  102c97:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102c9e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102ca1:	83 c4 28             	add    $0x28,%esp
  102ca4:	5d                   	pop    %ebp
  102ca5:	c3                   	ret    
  102ca6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  102cad:	00 00 00 

00102cb0 <ramfs_block_open>:

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  102cb0:	55                   	push   %ebp
  102cb1:	89 e5                	mov    %esp,%ebp
  102cb3:	83 ec 18             	sub    $0x18,%esp
  102cb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  102cb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102cbc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102cbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  102cc2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102cc5:	8b 00                	mov    (%eax),%eax
  102cc7:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  102cce:	00 00 00 00 
  102cd2:	0f 84 9d 00 00 00    	je     102d75 <ramfs_block_open+0xc5>
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  102cd8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cdb:	25 01 00 00 00       	and    $0x1,%eax
  102ce0:	3d 00 00 00 00       	cmp    $0x0,%eax
  102ce5:	0f 84 18 00 00 00    	je     102d03 <ramfs_block_open+0x53>
  102ceb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102cee:	8b 00                	mov    (%eax),%eax
  102cf0:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102cf7:	8b 48 08             	mov    0x8(%eax),%ecx
  102cfa:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102d00:	89 48 08             	mov    %ecx,0x8(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  102d03:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d06:	25 02 00 00 00       	and    $0x2,%eax
  102d0b:	3d 00 00 00 00       	cmp    $0x0,%eax
  102d10:	0f 84 18 00 00 00    	je     102d2e <ramfs_block_open+0x7e>
  102d16:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d19:	8b 00                	mov    (%eax),%eax
  102d1b:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102d22:	8b 48 0c             	mov    0xc(%eax),%ecx
  102d25:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102d2b:	89 48 0c             	mov    %ecx,0xc(%eax)
  102d2e:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  102d33:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  102d3a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102d3d:	e8 2e 14 00 00       	call   104170 <malloc>
  102d42:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  102d45:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d48:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d4b:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  102d4e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d51:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  102d58:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d5b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  102d61:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d64:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d67:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  102d6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d6d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102d70:	e9 08 00 00 00       	jmp    102d7d <ramfs_block_open+0xcd>
  102d75:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return (void*)1;
  102d7a:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  102d7d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d80:	83 c4 18             	add    $0x18,%esp
  102d83:	5d                   	pop    %ebp
  102d84:	c3                   	ret    
  102d85:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  102d8c:	00 00 00 00 

00102d90 <ramfs_block_close>:

uint32_t ramfs_block_close(struct res_handle* handle) {
  102d90:	55                   	push   %ebp
  102d91:	89 e5                	mov    %esp,%ebp
  102d93:	83 ec 18             	sub    $0x18,%esp
  102d96:	8b 45 08             	mov    0x8(%ebp),%eax
  102d99:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102d9c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d9f:	8b 40 04             	mov    0x4(%eax),%eax
  102da2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  102da5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102da8:	8b 00                	mov    (%eax),%eax
  102daa:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  102db1:	00 00 00 00 
  102db5:	0f 84 61 00 00 00    	je     102e1c <ramfs_block_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  102dbb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102dbe:	8b 40 0c             	mov    0xc(%eax),%eax
  102dc1:	25 01 00 00 00       	and    $0x1,%eax
  102dc6:	3d 00 00 00 00       	cmp    $0x0,%eax
  102dcb:	0f 84 18 00 00 00    	je     102de9 <ramfs_block_close+0x59>
  102dd1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102dd4:	8b 00                	mov    (%eax),%eax
  102dd6:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102ddd:	8b 48 08             	mov    0x8(%eax),%ecx
  102de0:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102de6:	89 48 08             	mov    %ecx,0x8(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  102de9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102dec:	8b 40 0c             	mov    0xc(%eax),%eax
  102def:	25 02 00 00 00       	and    $0x2,%eax
  102df4:	3d 00 00 00 00       	cmp    $0x0,%eax
  102df9:	0f 84 18 00 00 00    	je     102e17 <ramfs_block_close+0x87>
  102dff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102e02:	8b 00                	mov    (%eax),%eax
  102e04:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102e0b:	8b 48 0c             	mov    0xc(%eax),%ecx
  102e0e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102e14:	89 48 0c             	mov    %ecx,0xc(%eax)
    }
  102e17:	e9 00 00 00 00       	jmp    102e1c <ramfs_block_close+0x8c>

    free(handle);
  102e1c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e1f:	89 04 24             	mov    %eax,(%esp)
  102e22:	e8 19 17 00 00       	call   104540 <free>
  102e27:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  102e2c:	83 c4 18             	add    $0x18,%esp
  102e2f:	5d                   	pop    %ebp
  102e30:	c3                   	ret    
  102e31:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102e38:	0f 1f 84 00 00 00 00 
  102e3f:	00 

00102e40 <ramfs_block_available>:

struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
}

uint32_t ramfs_block_available(struct res_handle* handle) {
  102e40:	55                   	push   %ebp
  102e41:	89 e5                	mov    %esp,%ebp
  102e43:	83 ec 0c             	sub    $0xc,%esp
  102e46:	8b 45 08             	mov    0x8(%ebp),%eax
  102e49:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102e4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102e4f:	8b 40 04             	mov    0x4(%eax),%eax
  102e52:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  102e55:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e58:	8b 00                	mov    (%eax),%eax
  102e5a:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  102e61:	00 00 00 00 
  102e65:	0f 84 1d 00 00 00    	je     102e88 <ramfs_block_available+0x48>
        return buffer[kf->id]->size - handle->position;
  102e6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e6e:	8b 00                	mov    (%eax),%eax
  102e70:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102e77:	8b 40 04             	mov    0x4(%eax),%eax
  102e7a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102e7d:	2b 41 08             	sub    0x8(%ecx),%eax
  102e80:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102e83:	e9 07 00 00 00       	jmp    102e8f <ramfs_block_available+0x4f>
    }

    return 0;
  102e88:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  102e8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e92:	83 c4 0c             	add    $0xc,%esp
  102e95:	5d                   	pop    %ebp
  102e96:	c3                   	ret    
  102e97:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  102e9e:	00 00 

00102ea0 <ramfs_block_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  102ea0:	55                   	push   %ebp
  102ea1:	89 e5                	mov    %esp,%ebp
  102ea3:	83 ec 28             	sub    $0x28,%esp
  102ea6:	8b 45 08             	mov    0x8(%ebp),%eax
  102ea9:	b9 08 00 00 00       	mov    $0x8,%ecx
  102eae:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  102eb1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  102eb8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102ebb:	e8 b0 12 00 00       	call   104170 <malloc>
  102ec0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  102ec3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102eca:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  102ed1:	0f 8d a7 00 00 00    	jge    102f7e <ramfs_block_create+0xde>
        if(buffer[i] == 0) {
  102ed7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102eda:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  102ee1:	00 00 00 00 
  102ee5:	0f 85 7e 00 00 00    	jne    102f69 <ramfs_block_create+0xc9>
  102eeb:	b8 10 00 00 00       	mov    $0x10,%eax
            buffer[i] = malloc(sizeof(struct block_buffer));
  102ef0:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  102ef7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102efa:	e8 71 12 00 00       	call   104170 <malloc>
  102eff:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102f02:	89 04 8d 98 a4 14 00 	mov    %eax,0x14a498(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  102f09:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f0c:	8b 00                	mov    (%eax),%eax
  102f0e:	89 04 24             	mov    %eax,(%esp)
  102f11:	e8 5a 12 00 00       	call   104170 <malloc>
  102f16:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102f19:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  102f20:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  102f22:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f25:	8b 00                	mov    (%eax),%eax
  102f27:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102f2a:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  102f31:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->writers = 0;
  102f34:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f37:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102f3e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            buffer[i]->readers = 0;
  102f45:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f48:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  102f4f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

            kfret->id = i;
  102f56:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f59:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102f5c:	89 01                	mov    %eax,(%ecx)

            return kfret;
  102f5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f61:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102f64:	e9 1c 00 00 00       	jmp    102f85 <ramfs_block_create+0xe5>
        }
    }
  102f69:	e9 00 00 00 00       	jmp    102f6e <ramfs_block_create+0xce>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  102f6e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f71:	05 01 00 00 00       	add    $0x1,%eax
  102f76:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102f79:	e9 4c ff ff ff       	jmp    102eca <ramfs_block_create+0x2a>

            return kfret;
        }
    }

    return 0;
  102f7e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  102f85:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102f88:	83 c4 28             	add    $0x28,%esp
  102f8b:	5d                   	pop    %ebp
  102f8c:	c3                   	ret    
  102f8d:	0f 1f 00             	nopl   (%eax)

00102f90 <ramfs_block_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  102f90:	55                   	push   %ebp
  102f91:	89 e5                	mov    %esp,%ebp
  102f93:	8d 05 88 71 10 00    	lea    0x107188,%eax
    return &block_driver;
  102f99:	5d                   	pop    %ebp
  102f9a:	c3                   	ret    
  102f9b:	66 90                	xchg   %ax,%ax
  102f9d:	66 90                	xchg   %ax,%ax
  102f9f:	90                   	nop

00102fa0 <ramfs_fifo_init>:
#include "ramfs/fifo.h"

struct fifo_buffer* buffer[65536];

void ramfs_fifo_init() {
  102fa0:	55                   	push   %ebp
  102fa1:	89 e5                	mov    %esp,%ebp
  102fa3:	83 ec 18             	sub    $0x18,%esp
  102fa6:	8d 05 98 a4 14 00    	lea    0x14a498,%eax
  102fac:	b9 00 00 00 00       	mov    $0x0,%ecx
  102fb1:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102fb6:	89 04 24             	mov    %eax,(%esp)
  102fb9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102fc0:	00 
  102fc1:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102fc8:	00 
  102fc9:	89 55 fc             	mov    %edx,-0x4(%ebp)
  102fcc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102fcf:	e8 0c 18 00 00       	call   1047e0 <memset>
}
  102fd4:	83 c4 18             	add    $0x18,%esp
  102fd7:	5d                   	pop    %ebp
  102fd8:	c3                   	ret    
  102fd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102fe0 <ramfs_fifo_read>:
    }

    return 0;
}

uint32_t ramfs_fifo_read(struct res_handle* handle, void* dest, uint32_t length) {
  102fe0:	55                   	push   %ebp
  102fe1:	89 e5                	mov    %esp,%ebp
  102fe3:	83 ec 28             	sub    $0x28,%esp
  102fe6:	8b 45 10             	mov    0x10(%ebp),%eax
  102fe9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102fec:	8b 55 08             	mov    0x8(%ebp),%edx
  102fef:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102ff2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102ff8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102ffb:	8b 40 04             	mov    0x4(%eax),%eax
  102ffe:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  103001:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103004:	8b 00                	mov    (%eax),%eax
  103006:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  10300d:	00 00 00 00 
  103011:	0f 84 d0 00 00 00    	je     1030e7 <ramfs_fifo_read+0x107>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't read cause buffer too small
  103017:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10301a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10301d:	8b 09                	mov    (%ecx),%ecx
  10301f:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  103026:	3b 41 04             	cmp    0x4(%ecx),%eax
  103029:	0f 86 0c 00 00 00    	jbe    10303b <ramfs_fifo_read+0x5b>
  10302f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103036:	e9 b3 00 00 00       	jmp    1030ee <ramfs_fifo_read+0x10e>
        if(length > buffer[kf->id]->pos)  return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has writers
  10303b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10303e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103041:	8b 09                	mov    (%ecx),%ecx
  103043:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  10304a:	3b 41 08             	cmp    0x8(%ecx),%eax
  10304d:	0f 86 0c 00 00 00    	jbe    10305f <ramfs_fifo_read+0x7f>
  103053:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10305a:	e9 8f 00 00 00       	jmp    1030ee <ramfs_fifo_read+0x10e>

        memcpy(dest, buffer[kf->id]->buffer, length);
  10305f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103062:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103065:	8b 09                	mov    (%ecx),%ecx
  103067:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  10306e:	8b 09                	mov    (%ecx),%ecx
  103070:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103073:	89 04 24             	mov    %eax,(%esp)
  103076:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10307a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10307e:	e8 bd 17 00 00       	call   104840 <memcpy>
        memcpy(buffer[kf->id]->buffer, buffer[kf->id]->buffer + length, buffer[kf->id]->pos - length);
  103083:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103086:	8b 00                	mov    (%eax),%eax
  103088:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  10308f:	8b 00                	mov    (%eax),%eax
  103091:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103094:	8b 09                	mov    (%ecx),%ecx
  103096:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  10309d:	8b 09                	mov    (%ecx),%ecx
  10309f:	03 4d f0             	add    -0x10(%ebp),%ecx
  1030a2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1030a5:	8b 12                	mov    (%edx),%edx
  1030a7:	8b 14 95 98 a4 14 00 	mov    0x14a498(,%edx,4),%edx
  1030ae:	8b 52 08             	mov    0x8(%edx),%edx
  1030b1:	2b 55 f0             	sub    -0x10(%ebp),%edx
  1030b4:	89 04 24             	mov    %eax,(%esp)
  1030b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1030bb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1030bf:	e8 7c 17 00 00       	call   104840 <memcpy>
        buffer[kf->id]->pos -= length;
  1030c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1030c7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1030ca:	8b 09                	mov    (%ecx),%ecx
  1030cc:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  1030d3:	8b 51 08             	mov    0x8(%ecx),%edx
  1030d6:	29 c2                	sub    %eax,%edx
  1030d8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  1030db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1030e2:	e9 07 00 00 00       	jmp    1030ee <ramfs_fifo_read+0x10e>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  1030e7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1030ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1030f1:	83 c4 28             	add    $0x28,%esp
  1030f4:	5d                   	pop    %ebp
  1030f5:	c3                   	ret    
  1030f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1030fd:	00 00 00 

00103100 <ramfs_fifo_write>:

uint32_t ramfs_fifo_write(struct res_handle* handle, void* src, uint32_t length) {
  103100:	55                   	push   %ebp
  103101:	89 e5                	mov    %esp,%ebp
  103103:	83 ec 28             	sub    $0x28,%esp
  103106:	8b 45 10             	mov    0x10(%ebp),%eax
  103109:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10310c:	8b 55 08             	mov    0x8(%ebp),%edx
  10310f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103112:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103115:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103118:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10311b:	8b 40 04             	mov    0x4(%eax),%eax
  10311e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  103121:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103124:	8b 00                	mov    (%eax),%eax
  103126:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  10312d:	00 00 00 00 
  103131:	0f 84 af 00 00 00    	je     1031e6 <ramfs_fifo_write+0xe6>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't write cause buffer too small
  103137:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10313a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10313d:	8b 09                	mov    (%ecx),%ecx
  10313f:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  103146:	3b 41 04             	cmp    0x4(%ecx),%eax
  103149:	0f 86 0c 00 00 00    	jbe    10315b <ramfs_fifo_write+0x5b>
  10314f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103156:	e9 92 00 00 00       	jmp    1031ed <ramfs_fifo_write+0xed>
        if(length > (buffer[kf->id]->size - buffer[kf->id]->pos)) return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has readers
  10315b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10315e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103161:	8b 09                	mov    (%ecx),%ecx
  103163:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  10316a:	8b 49 04             	mov    0x4(%ecx),%ecx
  10316d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103170:	8b 12                	mov    (%edx),%edx
  103172:	8b 14 95 98 a4 14 00 	mov    0x14a498(,%edx,4),%edx
  103179:	2b 4a 08             	sub    0x8(%edx),%ecx
  10317c:	39 c8                	cmp    %ecx,%eax
  10317e:	0f 86 0c 00 00 00    	jbe    103190 <ramfs_fifo_write+0x90>
  103184:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10318b:	e9 5d 00 00 00       	jmp    1031ed <ramfs_fifo_write+0xed>

        memcpy(buffer[kf->id]->buffer + buffer[kf->id]->pos, src, length);
  103190:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103193:	8b 00                	mov    (%eax),%eax
  103195:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  10319c:	8b 00                	mov    (%eax),%eax
  10319e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1031a1:	8b 09                	mov    (%ecx),%ecx
  1031a3:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  1031aa:	03 41 08             	add    0x8(%ecx),%eax
  1031ad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1031b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1031b3:	89 04 24             	mov    %eax,(%esp)
  1031b6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1031ba:	89 54 24 08          	mov    %edx,0x8(%esp)
  1031be:	e8 7d 16 00 00       	call   104840 <memcpy>
        buffer[kf->id]->pos += length;
  1031c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1031c6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1031c9:	8b 09                	mov    (%ecx),%ecx
  1031cb:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  1031d2:	8b 51 08             	mov    0x8(%ecx),%edx
  1031d5:	01 c2                	add    %eax,%edx
  1031d7:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  1031da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1031e1:	e9 07 00 00 00       	jmp    1031ed <ramfs_fifo_write+0xed>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  1031e6:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1031ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031f0:	83 c4 28             	add    $0x28,%esp
  1031f3:	5d                   	pop    %ebp
  1031f4:	c3                   	ret    
  1031f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1031fc:	00 00 00 00 

00103200 <ramfs_fifo_open>:

struct res_handle* ramfs_fifo_open(struct res_kfile* kf, uint32_t filemode) {
  103200:	55                   	push   %ebp
  103201:	89 e5                	mov    %esp,%ebp
  103203:	83 ec 18             	sub    $0x18,%esp
  103206:	8b 45 0c             	mov    0xc(%ebp),%eax
  103209:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10320c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10320f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  103212:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103215:	8b 00                	mov    (%eax),%eax
  103217:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  10321e:	00 00 00 00 
  103222:	0f 84 bc 00 00 00    	je     1032e4 <ramfs_fifo_open+0xe4>
        if(filemode & FM_EXEC) return 0;
  103228:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10322b:	25 04 00 00 00       	and    $0x4,%eax
  103230:	3d 00 00 00 00       	cmp    $0x0,%eax
  103235:	0f 84 0c 00 00 00    	je     103247 <ramfs_fifo_open+0x47>
  10323b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103242:	e9 a4 00 00 00       	jmp    1032eb <ramfs_fifo_open+0xeb>

        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  103247:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10324a:	25 01 00 00 00       	and    $0x1,%eax
  10324f:	3d 00 00 00 00       	cmp    $0x0,%eax
  103254:	0f 84 18 00 00 00    	je     103272 <ramfs_fifo_open+0x72>
  10325a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10325d:	8b 00                	mov    (%eax),%eax
  10325f:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  103266:	8b 48 0c             	mov    0xc(%eax),%ecx
  103269:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10326f:	89 48 0c             	mov    %ecx,0xc(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  103272:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103275:	25 02 00 00 00       	and    $0x2,%eax
  10327a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10327f:	0f 84 18 00 00 00    	je     10329d <ramfs_fifo_open+0x9d>
  103285:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103288:	8b 00                	mov    (%eax),%eax
  10328a:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  103291:	8b 48 10             	mov    0x10(%eax),%ecx
  103294:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10329a:	89 48 10             	mov    %ecx,0x10(%eax)
  10329d:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  1032a2:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  1032a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1032ac:	e8 bf 0e 00 00       	call   104170 <malloc>
  1032b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  1032b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1032ba:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  1032bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032c0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  1032c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032ca:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  1032d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1032d3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1032d6:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  1032d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1032df:	e9 07 00 00 00       	jmp    1032eb <ramfs_fifo_open+0xeb>
    }

    return 0;
  1032e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1032eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1032ee:	83 c4 18             	add    $0x18,%esp
  1032f1:	5d                   	pop    %ebp
  1032f2:	c3                   	ret    
  1032f3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1032fa:	84 00 00 00 00 00 

00103300 <ramfs_fifo_close>:

uint32_t ramfs_fifo_close(struct res_handle* handle) {
  103300:	55                   	push   %ebp
  103301:	89 e5                	mov    %esp,%ebp
  103303:	83 ec 18             	sub    $0x18,%esp
  103306:	8b 45 08             	mov    0x8(%ebp),%eax
  103309:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10330c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10330f:	8b 40 04             	mov    0x4(%eax),%eax
  103312:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  103315:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103318:	8b 00                	mov    (%eax),%eax
  10331a:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  103321:	00 00 00 00 
  103325:	0f 84 61 00 00 00    	je     10338c <ramfs_fifo_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  10332b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10332e:	8b 40 0c             	mov    0xc(%eax),%eax
  103331:	25 01 00 00 00       	and    $0x1,%eax
  103336:	3d 00 00 00 00       	cmp    $0x0,%eax
  10333b:	0f 84 18 00 00 00    	je     103359 <ramfs_fifo_close+0x59>
  103341:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103344:	8b 00                	mov    (%eax),%eax
  103346:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  10334d:	8b 48 0c             	mov    0xc(%eax),%ecx
  103350:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103356:	89 48 0c             	mov    %ecx,0xc(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  103359:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10335c:	8b 40 0c             	mov    0xc(%eax),%eax
  10335f:	25 02 00 00 00       	and    $0x2,%eax
  103364:	3d 00 00 00 00       	cmp    $0x0,%eax
  103369:	0f 84 18 00 00 00    	je     103387 <ramfs_fifo_close+0x87>
  10336f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103372:	8b 00                	mov    (%eax),%eax
  103374:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  10337b:	8b 48 10             	mov    0x10(%eax),%ecx
  10337e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103384:	89 48 10             	mov    %ecx,0x10(%eax)
    }
  103387:	e9 00 00 00 00       	jmp    10338c <ramfs_fifo_close+0x8c>

    free(handle);
  10338c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10338f:	89 04 24             	mov    %eax,(%esp)
  103392:	e8 a9 11 00 00       	call   104540 <free>
  103397:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  10339c:	83 c4 18             	add    $0x18,%esp
  10339f:	5d                   	pop    %ebp
  1033a0:	c3                   	ret    
  1033a1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1033a8:	0f 1f 84 00 00 00 00 
  1033af:	00 

001033b0 <ramfs_fifo_available>:

struct kfs_driver* ramfs_fifo_driver_struct() {
    return &fifo_driver;
}

uint32_t ramfs_fifo_available(struct res_handle* handle) {
  1033b0:	55                   	push   %ebp
  1033b1:	89 e5                	mov    %esp,%ebp
  1033b3:	83 ec 0c             	sub    $0xc,%esp
  1033b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1033b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1033bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1033bf:	8b 40 04             	mov    0x4(%eax),%eax
  1033c2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  1033c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1033c8:	8b 00                	mov    (%eax),%eax
  1033ca:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  1033d1:	00 00 00 00 
  1033d5:	0f 84 17 00 00 00    	je     1033f2 <ramfs_fifo_available+0x42>
        return buffer[kf->id]->pos;
  1033db:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1033de:	8b 00                	mov    (%eax),%eax
  1033e0:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  1033e7:	8b 40 08             	mov    0x8(%eax),%eax
  1033ea:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1033ed:	e9 07 00 00 00       	jmp    1033f9 <ramfs_fifo_available+0x49>
    }

    return 0;
  1033f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1033f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1033fc:	83 c4 0c             	add    $0xc,%esp
  1033ff:	5d                   	pop    %ebp
  103400:	c3                   	ret    
  103401:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103408:	0f 1f 84 00 00 00 00 
  10340f:	00 

00103410 <ramfs_fifo_create>:

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
  103410:	55                   	push   %ebp
  103411:	89 e5                	mov    %esp,%ebp
  103413:	83 ec 28             	sub    $0x28,%esp
  103416:	8b 45 08             	mov    0x8(%ebp),%eax
  103419:	b9 08 00 00 00       	mov    $0x8,%ecx
  10341e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  103421:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103428:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10342b:	e8 40 0d 00 00       	call   104170 <malloc>
  103430:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  103433:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10343a:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  103441:	0f 8d b8 00 00 00    	jge    1034ff <ramfs_fifo_create+0xef>
        if(buffer[i] == 0) {
  103447:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10344a:	81 3c 85 98 a4 14 00 	cmpl   $0x0,0x14a498(,%eax,4)
  103451:	00 00 00 00 
  103455:	0f 85 8f 00 00 00    	jne    1034ea <ramfs_fifo_create+0xda>
  10345b:	b8 14 00 00 00       	mov    $0x14,%eax
            buffer[i] = malloc(sizeof(struct fifo_buffer));
  103460:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  103467:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10346a:	e8 01 0d 00 00       	call   104170 <malloc>
  10346f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103472:	89 04 8d 98 a4 14 00 	mov    %eax,0x14a498(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  103479:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10347c:	8b 00                	mov    (%eax),%eax
  10347e:	89 04 24             	mov    %eax,(%esp)
  103481:	e8 ea 0c 00 00       	call   104170 <malloc>
  103486:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103489:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  103490:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  103492:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103495:	8b 00                	mov    (%eax),%eax
  103497:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10349a:	8b 0c 8d 98 a4 14 00 	mov    0x14a498(,%ecx,4),%ecx
  1034a1:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->pos = 0;
  1034a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034a7:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  1034ae:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            buffer[i]->writers = 0;
  1034b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034b8:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  1034bf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
            buffer[i]->readers = 0;
  1034c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034c9:	8b 04 85 98 a4 14 00 	mov    0x14a498(,%eax,4),%eax
  1034d0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

            kfret->id = i;
  1034d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034da:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1034dd:	89 01                	mov    %eax,(%ecx)

            return kfret;
  1034df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1034e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1034e5:	e9 1c 00 00 00       	jmp    103506 <ramfs_fifo_create+0xf6>
        }
    }
  1034ea:	e9 00 00 00 00       	jmp    1034ef <ramfs_fifo_create+0xdf>
}

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  1034ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034f2:	05 01 00 00 00       	add    $0x1,%eax
  1034f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1034fa:	e9 3b ff ff ff       	jmp    10343a <ramfs_fifo_create+0x2a>

            return kfret;
        }
    }

    return 0;
  1034ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103506:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103509:	83 c4 28             	add    $0x28,%esp
  10350c:	5d                   	pop    %ebp
  10350d:	c3                   	ret    
  10350e:	66 90                	xchg   %ax,%ax

00103510 <ramfs_fifo_driver_struct>:
    .close     = ramfs_fifo_close,
    .available = ramfs_fifo_available,
    .drvname   = "FIFO"
};

struct kfs_driver* ramfs_fifo_driver_struct() {
  103510:	55                   	push   %ebp
  103511:	89 e5                	mov    %esp,%ebp
  103513:	8d 05 a4 71 10 00    	lea    0x1071a4,%eax
    return &fifo_driver;
  103519:	5d                   	pop    %ebp
  10351a:	c3                   	ret    
  10351b:	90                   	nop
  10351c:	66 90                	xchg   %ax,%ax
  10351e:	66 90                	xchg   %ax,%ax

00103520 <tar_load_ramfs>:

    return size;

}

void tar_load_ramfs(void* tarball) {
  103520:	55                   	push   %ebp
  103521:	89 e5                	mov    %esp,%ebp
  103523:	56                   	push   %esi
  103524:	83 ec 64             	sub    $0x64,%esp
  103527:	8b 45 08             	mov    0x8(%ebp),%eax
  10352a:	8d 0d 07 84 10 00    	lea    0x108407,%ecx
  103530:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* address = tarball;
  103533:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103536:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);
  103539:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10353c:	89 0c 24             	mov    %ecx,(%esp)
  10353f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103543:	e8 28 d0 ff ff       	call   100570 <kprintf>

    for (i = 0; ; i++)
  103548:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10354f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    {

        struct tar_header *header = (struct tar_header*)address;
  103552:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103555:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (header->name[0] == '\0')
  103558:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10355b:	0f be 00             	movsbl (%eax),%eax
  10355e:	3d 00 00 00 00       	cmp    $0x0,%eax
  103563:	0f 85 05 00 00 00    	jne    10356e <tar_load_ramfs+0x4e>
            break;
  103569:	e9 67 01 00 00       	jmp    1036d5 <tar_load_ramfs+0x1b5>

        uint32_t size = tar_parse_number(header->size);
  10356e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103571:	05 7c 00 00 00       	add    $0x7c,%eax
  103576:	89 04 24             	mov    %eax,(%esp)
  103579:	e8 72 01 00 00       	call   1036f0 <tar_parse_number>
  10357e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        address += 512;
  103581:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103584:	05 00 02 00 00       	add    $0x200,%eax
  103589:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(size != 0) {
  10358c:	81 7d e8 00 00 00 00 	cmpl   $0x0,-0x18(%ebp)
  103593:	0f 84 cb 00 00 00    	je     103664 <tar_load_ramfs+0x144>
  103599:	8d 05 33 84 10 00    	lea    0x108433,%eax
            kprintf("[initrfs] Extracting %s (%d bytes)\n", header->name, size);
  10359f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1035a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1035a5:	89 04 24             	mov    %eax,(%esp)
  1035a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1035ac:	89 54 24 08          	mov    %edx,0x8(%esp)
  1035b0:	e8 bb cf ff ff       	call   100570 <kprintf>
  1035b5:	8d 4d e8             	lea    -0x18(%ebp),%ecx

            vfs_create_kfile(header->name, ramfs_block_driver_struct(), &size);
  1035b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1035bb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1035be:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  1035c1:	89 55 d0             	mov    %edx,-0x30(%ebp)
  1035c4:	e8 c7 f9 ff ff       	call   102f90 <ramfs_block_driver_struct>
  1035c9:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  1035cc:	89 0c 24             	mov    %ecx,(%esp)
  1035cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1035d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1035d6:	89 44 24 08          	mov    %eax,0x8(%esp)
  1035da:	e8 21 19 00 00       	call   104f00 <vfs_create_kfile>
  1035df:	b9 02 00 00 00       	mov    $0x2,%ecx
            struct res_handle* h = vfs_open(header->name, FM_WRITE);
  1035e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1035e7:	89 14 24             	mov    %edx,(%esp)
  1035ea:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1035f1:	00 
  1035f2:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1035f5:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  1035f8:	e8 73 1a 00 00       	call   105070 <vfs_open>
  1035fd:	b9 01 00 00 00       	mov    $0x1,%ecx
  103602:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            uint32_t err = vfs_write(h, address, size, 1);
  103605:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103608:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10360b:	8b 75 e8             	mov    -0x18(%ebp),%esi
  10360e:	89 04 24             	mov    %eax,(%esp)
  103611:	89 54 24 04          	mov    %edx,0x4(%esp)
  103615:	89 74 24 08          	mov    %esi,0x8(%esp)
  103619:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  103620:	00 
  103621:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  103624:	e8 f7 1b 00 00       	call   105220 <vfs_write>
  103629:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(err) {
  10362c:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  103633:	0f 84 18 00 00 00    	je     103651 <tar_load_ramfs+0x131>
  103639:	8d 05 57 84 10 00    	lea    0x108457,%eax
                kprintf("[initrfs] VFS ERROR: %d\n", err);
  10363f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  103642:	89 04 24             	mov    %eax,(%esp)
  103645:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103649:	e8 22 cf ff ff       	call   100570 <kprintf>
  10364e:	89 45 c0             	mov    %eax,-0x40(%ebp)
            }

            vfs_close(h);
  103651:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103654:	89 04 24             	mov    %eax,(%esp)
  103657:	e8 94 1a 00 00       	call   1050f0 <vfs_close>
        }
  10365c:	89 45 bc             	mov    %eax,-0x44(%ebp)
  10365f:	e9 2d 00 00 00       	jmp    103691 <tar_load_ramfs+0x171>
  103664:	8d 05 70 84 10 00    	lea    0x108470,%eax
        else
        {
            kprintf("[initrfs] Creating dir %s (%d bytes)\n", header->name, size);
  10366a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10366d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103670:	89 04 24             	mov    %eax,(%esp)
  103673:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103677:	89 54 24 08          	mov    %edx,0x8(%esp)
  10367b:	e8 f0 ce ff ff       	call   100570 <kprintf>
            vfs_create_dir(header->name);
  103680:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103683:	89 0c 24             	mov    %ecx,(%esp)
  103686:	89 45 b8             	mov    %eax,-0x48(%ebp)
  103689:	e8 e2 16 00 00       	call   104d70 <vfs_create_dir>
  10368e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        }

        address += (size / 512) * 512;
  103691:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103694:	c1 e8 09             	shr    $0x9,%eax
  103697:	c1 e0 09             	shl    $0x9,%eax
  10369a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10369d:	01 c1                	add    %eax,%ecx
  10369f:	89 4d f4             	mov    %ecx,-0xc(%ebp)

        if (size % 512)
  1036a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1036a5:	25 ff 01 00 00       	and    $0x1ff,%eax
  1036aa:	3d 00 00 00 00       	cmp    $0x0,%eax
  1036af:	0f 84 0b 00 00 00    	je     1036c0 <tar_load_ramfs+0x1a0>
            address += 512;
  1036b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1036b8:	05 00 02 00 00       	add    $0x200,%eax
  1036bd:	89 45 f4             	mov    %eax,-0xc(%ebp)

    }
  1036c0:	e9 00 00 00 00       	jmp    1036c5 <tar_load_ramfs+0x1a5>

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);

    for (i = 0; ; i++)
  1036c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1036c8:	05 01 00 00 00       	add    $0x1,%eax
  1036cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1036d0:	e9 7d fe ff ff       	jmp    103552 <tar_load_ramfs+0x32>
  1036d5:	8d 05 96 84 10 00    	lea    0x108496,%eax
        if (size % 512)
            address += 512;

    }

    kprintf("[initrfs] Finished unpacking tarball\n");
  1036db:	89 04 24             	mov    %eax,(%esp)
  1036de:	e8 8d ce ff ff       	call   100570 <kprintf>
}
  1036e3:	89 45 b0             	mov    %eax,-0x50(%ebp)
  1036e6:	83 c4 64             	add    $0x64,%esp
  1036e9:	5e                   	pop    %esi
  1036ea:	5d                   	pop    %ebp
  1036eb:	c3                   	ret    
  1036ec:	0f 1f 40 00          	nopl   0x0(%eax)

001036f0 <tar_parse_number>:
#include "ramfs/tar.h"
#include "ramfs/block.h"
#include "vfs.h"

static uint32_t tar_parse_number(const char *in)
{
  1036f0:	55                   	push   %ebp
  1036f1:	89 e5                	mov    %esp,%ebp
  1036f3:	83 ec 10             	sub    $0x10,%esp
  1036f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1036f9:	89 45 fc             	mov    %eax,-0x4(%ebp)

    unsigned int size = 0;
  1036fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    unsigned int j;
    unsigned int count = 1;
  103703:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

    for (j = 11; j > 0; j--, count *= 8)
  10370a:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
  103711:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103718:	0f 86 39 00 00 00    	jbe    103757 <tar_parse_number+0x67>
        size += ((in[j - 1] - '0') * count);
  10371e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103721:	2d 01 00 00 00       	sub    $0x1,%eax
  103726:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103729:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  10372d:	2d 30 00 00 00       	sub    $0x30,%eax
  103732:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  103736:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103739:	01 c1                	add    %eax,%ecx
  10373b:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    unsigned int size = 0;
    unsigned int j;
    unsigned int count = 1;

    for (j = 11; j > 0; j--, count *= 8)
  10373e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103741:	05 ff ff ff ff       	add    $0xffffffff,%eax
  103746:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103749:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10374c:	c1 e0 03             	shl    $0x3,%eax
  10374f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103752:	e9 ba ff ff ff       	jmp    103711 <tar_parse_number+0x21>
        size += ((in[j - 1] - '0') * count);

    return size;
  103757:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10375a:	83 c4 10             	add    $0x10,%esp
  10375d:	5d                   	pop    %ebp
  10375e:	c3                   	ret    
  10375f:	90                   	nop

00103760 <ramfs_vga_read>:

struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
}

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  103760:	55                   	push   %ebp
  103761:	89 e5                	mov    %esp,%ebp
  103763:	56                   	push   %esi
  103764:	83 ec 0c             	sub    $0xc,%esp
  103767:	8b 45 10             	mov    0x10(%ebp),%eax
  10376a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10376d:	8b 55 08             	mov    0x8(%ebp),%edx
  103770:	be 03 00 00 00       	mov    $0x3,%esi
  103775:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103778:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10377b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  10377e:	89 f0                	mov    %esi,%eax
  103780:	83 c4 0c             	add    $0xc,%esp
  103783:	5e                   	pop    %esi
  103784:	5d                   	pop    %ebp
  103785:	c3                   	ret    
  103786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10378d:	00 00 00 

00103790 <ramfs_vga_write>:
}

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  103790:	55                   	push   %ebp
  103791:	89 e5                	mov    %esp,%ebp
  103793:	83 ec 1c             	sub    $0x1c,%esp
  103796:	8b 45 10             	mov    0x10(%ebp),%eax
  103799:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10379c:	8b 55 08             	mov    0x8(%ebp),%edx
  10379f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1037a2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1037a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  1037a8:	81 7d f0 06 00 00 00 	cmpl   $0x6,-0x10(%ebp)
  1037af:	0f 84 0c 00 00 00    	je     1037c1 <ramfs_vga_write+0x31>
  1037b5:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  1037bc:	e9 1f 01 00 00       	jmp    1038e0 <ramfs_vga_write+0x150>

    struct vga_command* vgac = src;
  1037c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037c4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(vgac->command == CMD_SET) {
  1037c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1037ca:	0f b7 00             	movzwl (%eax),%eax
  1037cd:	3d 00 00 00 00       	cmp    $0x0,%eax
  1037d2:	0f 85 2f 00 00 00    	jne    103807 <ramfs_vga_write+0x77>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  1037d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1037db:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1037df:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  1037e4:	0f 8d 18 00 00 00    	jge    103802 <ramfs_vga_write+0x72>
  1037ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1037ed:	66 8b 48 04          	mov    0x4(%eax),%cx
  1037f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1037f4:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  1037f8:	8b 15 c0 71 10 00    	mov    0x1071c0,%edx
  1037fe:	66 89 0c 42          	mov    %cx,(%edx,%eax,2)
    }
  103802:	e9 00 00 00 00       	jmp    103807 <ramfs_vga_write+0x77>

    if(vgac->command == CMD_CLEAR) {
  103807:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10380a:	0f b7 00             	movzwl (%eax),%eax
  10380d:	3d 01 00 00 00       	cmp    $0x1,%eax
  103812:	0f 85 38 00 00 00    	jne    103850 <ramfs_vga_write+0xc0>
        for(int i = 0; i < (80 * 25); i++) {
  103818:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10381f:	81 7d e8 d0 07 00 00 	cmpl   $0x7d0,-0x18(%ebp)
  103826:	0f 8d 1f 00 00 00    	jge    10384b <ramfs_vga_write+0xbb>
            vga_buffer[i] = 0;
  10382c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10382f:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  103835:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
    if(vgac->command == CMD_SET) {
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
  10383b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10383e:	05 01 00 00 00       	add    $0x1,%eax
  103843:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103846:	e9 d4 ff ff ff       	jmp    10381f <ramfs_vga_write+0x8f>
            vga_buffer[i] = 0;
        }
    }
  10384b:	e9 00 00 00 00       	jmp    103850 <ramfs_vga_write+0xc0>

    if(vgac->command == CMD_SCROLL) {
  103850:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103853:	0f b7 00             	movzwl (%eax),%eax
  103856:	3d 02 00 00 00       	cmp    $0x2,%eax
  10385b:	0f 85 78 00 00 00    	jne    1038d9 <ramfs_vga_write+0x149>
        int i;
        for (i = 0; i < 24 * 80; i++) {
  103861:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  103868:	81 7d e4 80 07 00 00 	cmpl   $0x780,-0x1c(%ebp)
  10386f:	0f 8d 2e 00 00 00    	jge    1038a3 <ramfs_vga_write+0x113>
            vga_buffer[i] = vga_buffer[i + 80];
  103875:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103878:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  10387e:	66 8b 94 41 a0 00 00 	mov    0xa0(%ecx,%eax,2),%dx
  103885:	00 
  103886:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103889:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  10388f:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  103893:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103896:	05 01 00 00 00       	add    $0x1,%eax
  10389b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10389e:	e9 c5 ff ff ff       	jmp    103868 <ramfs_vga_write+0xd8>
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  1038a3:	e9 00 00 00 00       	jmp    1038a8 <ramfs_vga_write+0x118>
  1038a8:	81 7d e4 d0 07 00 00 	cmpl   $0x7d0,-0x1c(%ebp)
  1038af:	0f 8d 1f 00 00 00    	jge    1038d4 <ramfs_vga_write+0x144>
            vga_buffer[i] = 0;
  1038b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1038b8:	8b 0d c0 71 10 00    	mov    0x1071c0,%ecx
  1038be:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  1038c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1038c7:	05 01 00 00 00       	add    $0x1,%eax
  1038cc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1038cf:	e9 d4 ff ff ff       	jmp    1038a8 <ramfs_vga_write+0x118>
            vga_buffer[i] = 0;
        }
    }
  1038d4:	e9 00 00 00 00       	jmp    1038d9 <ramfs_vga_write+0x149>

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  1038d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1038e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1038e3:	83 c4 1c             	add    $0x1c,%esp
  1038e6:	5d                   	pop    %ebp
  1038e7:	c3                   	ret    
  1038e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  1038ef:	00 

001038f0 <ramfs_vga_open>:

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
  1038f0:	55                   	push   %ebp
  1038f1:	89 e5                	mov    %esp,%ebp
  1038f3:	83 ec 18             	sub    $0x18,%esp
  1038f6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1038f9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1038fc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1038ff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filemode & FM_EXEC) return 0;
  103902:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103905:	25 04 00 00 00       	and    $0x4,%eax
  10390a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10390f:	0f 84 0c 00 00 00    	je     103921 <ramfs_vga_open+0x31>
  103915:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10391c:	e9 b2 00 00 00       	jmp    1039d3 <ramfs_vga_open+0xe3>
    if(filemode & FM_READ) return 0;
  103921:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103924:	25 01 00 00 00       	and    $0x1,%eax
  103929:	3d 00 00 00 00       	cmp    $0x0,%eax
  10392e:	0f 84 0c 00 00 00    	je     103940 <ramfs_vga_open+0x50>
  103934:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10393b:	e9 93 00 00 00       	jmp    1039d3 <ramfs_vga_open+0xe3>

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  103940:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103943:	25 02 00 00 00       	and    $0x2,%eax
  103948:	3d 00 00 00 00       	cmp    $0x0,%eax
  10394d:	0f 84 1c 00 00 00    	je     10396f <ramfs_vga_open+0x7f>
  103953:	81 3d 2c a4 10 00 00 	cmpl   $0x0,0x10a42c
  10395a:	00 00 00 
  10395d:	0f 84 0c 00 00 00    	je     10396f <ramfs_vga_open+0x7f>
  103963:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10396a:	e9 64 00 00 00       	jmp    1039d3 <ramfs_vga_open+0xe3>
    if((filemode & FM_WRITE)) vga_writers++;
  10396f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103972:	25 02 00 00 00       	and    $0x2,%eax
  103977:	3d 00 00 00 00       	cmp    $0x0,%eax
  10397c:	0f 84 0f 00 00 00    	je     103991 <ramfs_vga_open+0xa1>
  103982:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103987:	05 01 00 00 00       	add    $0x1,%eax
  10398c:	a3 2c a4 10 00       	mov    %eax,0x10a42c
  103991:	b8 10 00 00 00       	mov    $0x10,%eax

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103996:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10399d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1039a0:	e8 cb 07 00 00       	call   104170 <malloc>
  1039a5:	89 45 f0             	mov    %eax,-0x10(%ebp)

    rethandle->filemode = filemode;
  1039a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1039ab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1039ae:	89 41 0c             	mov    %eax,0xc(%ecx)
    rethandle->position = 0;
  1039b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039b4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    rethandle->res_type = RES_KERNDRV;
  1039bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039be:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    rethandle->res_ptr  = kf;
  1039c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1039c7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1039ca:	89 41 04             	mov    %eax,0x4(%ecx)

    return rethandle;
  1039cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039d0:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1039d3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039d6:	83 c4 18             	add    $0x18,%esp
  1039d9:	5d                   	pop    %ebp
  1039da:	c3                   	ret    
  1039db:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001039e0 <ramfs_vga_close>:

uint32_t ramfs_vga_close(struct res_handle* handle) {
  1039e0:	55                   	push   %ebp
  1039e1:	89 e5                	mov    %esp,%ebp
  1039e3:	83 ec 08             	sub    $0x8,%esp
  1039e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1039e9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(handle->filemode & FM_WRITE) vga_writers--;
  1039ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1039ef:	8b 40 0c             	mov    0xc(%eax),%eax
  1039f2:	25 02 00 00 00       	and    $0x2,%eax
  1039f7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1039fc:	0f 84 0f 00 00 00    	je     103a11 <ramfs_vga_close+0x31>
  103a02:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103a07:	05 ff ff ff ff       	add    $0xffffffff,%eax
  103a0c:	a3 2c a4 10 00       	mov    %eax,0x10a42c

    free(handle);
  103a11:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a14:	89 04 24             	mov    %eax,(%esp)
  103a17:	e8 24 0b 00 00       	call   104540 <free>
  103a1c:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  103a21:	83 c4 08             	add    $0x8,%esp
  103a24:	5d                   	pop    %ebp
  103a25:	c3                   	ret    
  103a26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  103a2d:	00 00 00 

00103a30 <ramfs_vga_available>:

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

uint32_t ramfs_vga_available(struct res_handle* handle) {
  103a30:	55                   	push   %ebp
  103a31:	89 e5                	mov    %esp,%ebp
  103a33:	50                   	push   %eax
  103a34:	8b 45 08             	mov    0x8(%ebp),%eax
  103a37:	b9 06 00 00 00       	mov    $0x6,%ecx
  103a3c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return sizeof(struct vga_command);
  103a3f:	89 c8                	mov    %ecx,%eax
  103a41:	83 c4 04             	add    $0x4,%esp
  103a44:	5d                   	pop    %ebp
  103a45:	c3                   	ret    
  103a46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  103a4d:	00 00 00 

00103a50 <ramfs_vga_create>:
}

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  103a50:	55                   	push   %ebp
  103a51:	89 e5                	mov    %esp,%ebp
  103a53:	83 ec 18             	sub    $0x18,%esp
  103a56:	8b 45 08             	mov    0x8(%ebp),%eax
  103a59:	b9 08 00 00 00       	mov    $0x8,%ecx
  103a5e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return malloc(sizeof(struct res_kfile));
  103a61:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103a68:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103a6b:	e8 00 07 00 00       	call   104170 <malloc>
  103a70:	83 c4 18             	add    $0x18,%esp
  103a73:	5d                   	pop    %ebp
  103a74:	c3                   	ret    
  103a75:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  103a7c:	00 00 00 00 

00103a80 <ramfs_vga_driver_struct>:
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
  103a80:	55                   	push   %ebp
  103a81:	89 e5                	mov    %esp,%ebp
  103a83:	8d 05 c4 71 10 00    	lea    0x1071c4,%eax
    return &vga_driver;
  103a89:	5d                   	pop    %ebp
  103a8a:	c3                   	ret    
  103a8b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103a90 <ramfs_vga_writers>:
}

uint32_t ramfs_vga_writers() {
  103a90:	55                   	push   %ebp
  103a91:	89 e5                	mov    %esp,%ebp
    return vga_writers;
  103a93:	a1 2c a4 10 00       	mov    0x10a42c,%eax
  103a98:	5d                   	pop    %ebp
  103a99:	c3                   	ret    
  103a9a:	66 90                	xchg   %ax,%ax
  103a9c:	66 90                	xchg   %ax,%ax
  103a9e:	66 90                	xchg   %ax,%ax

00103aa0 <enableScheduling>:
struct task* first_task = 0;
struct task* current_task = 0;

int nextPID = 1;

void enableScheduling(void) {
  103aa0:	55                   	push   %ebp
  103aa1:	89 e5                	mov    %esp,%ebp
    schedulingEnabled = 1;
  103aa3:	c7 05 30 a4 10 00 01 	movl   $0x1,0x10a430
  103aaa:	00 00 00 
}
  103aad:	5d                   	pop    %ebp
  103aae:	c3                   	ret    
  103aaf:	90                   	nop

00103ab0 <isSchedulingEnabled>:

uint32_t isSchedulingEnabled(void) {
  103ab0:	55                   	push   %ebp
  103ab1:	89 e5                	mov    %esp,%ebp
    return schedulingEnabled;
  103ab3:	a1 30 a4 10 00       	mov    0x10a430,%eax
  103ab8:	5d                   	pop    %ebp
  103ab9:	c3                   	ret    
  103aba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103ac0 <get_current_task>:
}

struct task* get_current_task(void) {
  103ac0:	55                   	push   %ebp
  103ac1:	89 e5                	mov    %esp,%ebp
    return current_task;
  103ac3:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103ac8:	5d                   	pop    %ebp
  103ac9:	c3                   	ret    
  103aca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103ad0 <register_handle>:
}

uint32_t register_handle(struct res_handle* h) {
  103ad0:	55                   	push   %ebp
  103ad1:	89 e5                	mov    %esp,%ebp
  103ad3:	83 ec 18             	sub    $0x18,%esp
  103ad6:	8b 45 08             	mov    0x8(%ebp),%eax
  103ad9:	b9 08 00 00 00       	mov    $0x8,%ecx
  103ade:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct hl_node* old = current_task->handle_list;
  103ae1:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103ae6:	8b 40 28             	mov    0x28(%eax),%eax
  103ae9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task->handle_list = malloc(sizeof(struct hl_node));
  103aec:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103af3:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103af6:	e8 75 06 00 00       	call   104170 <malloc>
  103afb:	b9 00 00 00 00       	mov    $0x0,%ecx
  103b00:	8b 15 38 a4 10 00    	mov    0x10a438,%edx
  103b06:	89 42 28             	mov    %eax,0x28(%edx)
    current_task->handle_list->next = old;
  103b09:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103b0c:	8b 15 38 a4 10 00    	mov    0x10a438,%edx
  103b12:	8b 52 28             	mov    0x28(%edx),%edx
  103b15:	89 42 04             	mov    %eax,0x4(%edx)
    current_task->handle_list->handle = h;
  103b18:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103b1b:	8b 15 38 a4 10 00    	mov    0x10a438,%edx
  103b21:	8b 52 28             	mov    0x28(%edx),%edx
  103b24:	89 02                	mov    %eax,(%edx)

    return 0;
  103b26:	89 c8                	mov    %ecx,%eax
  103b28:	83 c4 18             	add    $0x18,%esp
  103b2b:	5d                   	pop    %ebp
  103b2c:	c3                   	ret    
  103b2d:	0f 1f 00             	nopl   (%eax)

00103b30 <unregister_handle>:
}

uint32_t unregister_handle(struct res_handle* h) {
  103b30:	55                   	push   %ebp
  103b31:	89 e5                	mov    %esp,%ebp
  103b33:	83 ec 18             	sub    $0x18,%esp
  103b36:	8b 45 08             	mov    0x8(%ebp),%eax
  103b39:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct hl_node* cur = current_task->handle_list;
  103b3c:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103b41:	8b 40 28             	mov    0x28(%eax),%eax
  103b44:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(h == 0) return 2;
  103b47:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103b4e:	0f 85 0c 00 00 00    	jne    103b60 <unregister_handle+0x30>
  103b54:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
  103b5b:	e9 b4 00 00 00       	jmp    103c14 <unregister_handle+0xe4>
    if(cur == 0) return 1;
  103b60:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103b67:	0f 85 0c 00 00 00    	jne    103b79 <unregister_handle+0x49>
  103b6d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  103b74:	e9 9b 00 00 00       	jmp    103c14 <unregister_handle+0xe4>

    if(cur->handle == h) {
  103b79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b7c:	8b 00                	mov    (%eax),%eax
  103b7e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103b81:	0f 85 26 00 00 00    	jne    103bad <unregister_handle+0x7d>
        current_task->handle_list = cur->next;
  103b87:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b8a:	8b 40 04             	mov    0x4(%eax),%eax
  103b8d:	8b 0d 38 a4 10 00    	mov    0x10a438,%ecx
  103b93:	89 41 28             	mov    %eax,0x28(%ecx)
        free(cur);
  103b96:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b99:	89 04 24             	mov    %eax,(%esp)
  103b9c:	e8 9f 09 00 00       	call   104540 <free>

        return 0;
  103ba1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103ba8:	e9 67 00 00 00       	jmp    103c14 <unregister_handle+0xe4>
    }

    while(cur != 0) {
  103bad:	e9 00 00 00 00       	jmp    103bb2 <unregister_handle+0x82>
  103bb2:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103bb9:	0f 84 4e 00 00 00    	je     103c0d <unregister_handle+0xdd>
        if(cur->next->handle == h) {
  103bbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bc2:	8b 40 04             	mov    0x4(%eax),%eax
  103bc5:	8b 00                	mov    (%eax),%eax
  103bc7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103bca:	0f 85 2f 00 00 00    	jne    103bff <unregister_handle+0xcf>
            void* next = cur->next;
  103bd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bd3:	8b 40 04             	mov    0x4(%eax),%eax
  103bd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cur->next =  cur->next->next;
  103bd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bdc:	8b 40 04             	mov    0x4(%eax),%eax
  103bdf:	8b 40 04             	mov    0x4(%eax),%eax
  103be2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103be5:	89 41 04             	mov    %eax,0x4(%ecx)

            free(next);
  103be8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103beb:	89 04 24             	mov    %eax,(%esp)
  103bee:	e8 4d 09 00 00       	call   104540 <free>

            return 0;
  103bf3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103bfa:	e9 15 00 00 00       	jmp    103c14 <unregister_handle+0xe4>
        }

        cur = cur->next;
  103bff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c02:	8b 40 04             	mov    0x4(%eax),%eax
  103c05:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  103c08:	e9 a5 ff ff ff       	jmp    103bb2 <unregister_handle+0x82>

    return 3;
  103c0d:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  103c14:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c17:	83 c4 18             	add    $0x18,%esp
  103c1a:	5d                   	pop    %ebp
  103c1b:	c3                   	ret    
  103c1c:	0f 1f 40 00          	nopl   0x0(%eax)

00103c20 <schedule_exception>:

struct cpu_state* schedule_exception(struct cpu_state* cpu) {
  103c20:	55                   	push   %ebp
  103c21:	89 e5                	mov    %esp,%ebp
  103c23:	56                   	push   %esi
  103c24:	83 ec 34             	sub    $0x34,%esp
  103c27:	8b 45 08             	mov    0x8(%ebp),%eax
  103c2a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (current_task == first_task && current_task->next == 0) {
  103c2d:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103c32:	3b 05 34 a4 10 00    	cmp    0x10a434,%eax
  103c38:	0f 85 78 00 00 00    	jne    103cb6 <schedule_exception+0x96>
  103c3e:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103c43:	81 78 08 00 00 00 00 	cmpl   $0x0,0x8(%eax)
  103c4a:	0f 85 66 00 00 00    	jne    103cb6 <schedule_exception+0x96>
  103c50:	b8 04 00 00 00       	mov    $0x4,%eax
        //Only one process is running, which just crashed. Stop system.
        setclr(0x04);
  103c55:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  103c5c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103c5f:	e8 ec c8 ff ff       	call   100550 <setclr>
  103c64:	8d 05 c8 84 10 00    	lea    0x1084c8,%eax
        kprintf("\n~~~ Terminated task (PID=%d) due to exception %x:%x \n", current_task->PID, cpu->intr, cpu->error);
  103c6a:	8b 0d 38 a4 10 00    	mov    0x10a438,%ecx
  103c70:	8b 09                	mov    (%ecx),%ecx
  103c72:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103c75:	8b 52 1c             	mov    0x1c(%edx),%edx
  103c78:	8b 75 f4             	mov    -0xc(%ebp),%esi
  103c7b:	8b 76 20             	mov    0x20(%esi),%esi
  103c7e:	89 04 24             	mov    %eax,(%esp)
  103c81:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103c85:	89 54 24 08          	mov    %edx,0x8(%esp)
  103c89:	89 74 24 0c          	mov    %esi,0xc(%esp)
  103c8d:	e8 de c8 ff ff       	call   100570 <kprintf>
  103c92:	8d 0d ff 84 10 00    	lea    0x1084ff,%ecx
        show_cod(cpu, "Last task crashed. Terminating kernel...");
  103c98:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103c9b:	89 14 24             	mov    %edx,(%esp)
  103c9e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103ca2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103ca5:	e8 d6 c6 ff ff       	call   100380 <show_cod>

        //will never occur cause COD terminates execution
        return 0;
  103caa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  103cb1:	e9 83 00 00 00       	jmp    103d39 <schedule_exception+0x119>
  103cb6:	b8 04 00 00 00       	mov    $0x4,%eax
    } else {
        //Potential security leaks available in following code.
        setclr(0x04);
  103cbb:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  103cc2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103cc5:	e8 86 c8 ff ff       	call   100550 <setclr>
  103cca:	8d 05 c8 84 10 00    	lea    0x1084c8,%eax
        kprintf("\n~~~ Terminated task (PID=%d) due to exception %x:%x \n", current_task->PID, cpu->intr, cpu->error);
  103cd0:	8b 0d 38 a4 10 00    	mov    0x10a438,%ecx
  103cd6:	8b 09                	mov    (%ecx),%ecx
  103cd8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103cdb:	8b 52 1c             	mov    0x1c(%edx),%edx
  103cde:	8b 75 f4             	mov    -0xc(%ebp),%esi
  103ce1:	8b 76 20             	mov    0x20(%esi),%esi
  103ce4:	89 04 24             	mov    %eax,(%esp)
  103ce7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103ceb:	89 54 24 08          	mov    %edx,0x8(%esp)
  103cef:	89 74 24 0c          	mov    %esi,0xc(%esp)
  103cf3:	e8 78 c8 ff ff       	call   100570 <kprintf>
  103cf8:	8d 0d fe 82 10 00    	lea    0x1082fe,%ecx
        kprintf("\n");
  103cfe:	89 0c 24             	mov    %ecx,(%esp)
  103d01:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  103d04:	e8 67 c8 ff ff       	call   100570 <kprintf>
        show_dump(cpu);
  103d09:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103d0c:	89 0c 24             	mov    %ecx,(%esp)
  103d0f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  103d12:	e8 e9 c6 ff ff       	call   100400 <show_dump>
  103d17:	b8 07 00 00 00       	mov    $0x7,%eax
        setclr(0x07);
  103d1c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  103d23:	89 45 dc             	mov    %eax,-0x24(%ebp)
  103d26:	e8 25 c8 ff ff       	call   100550 <setclr>

        return terminate_current(cpu);
  103d2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d2e:	89 04 24             	mov    %eax,(%esp)
  103d31:	e8 1a 00 00 00       	call   103d50 <terminate_current>
  103d36:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  103d39:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103d3c:	83 c4 34             	add    $0x34,%esp
  103d3f:	5e                   	pop    %esi
  103d40:	5d                   	pop    %ebp
  103d41:	c3                   	ret    
  103d42:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103d49:	1f 84 00 00 00 00 00 

00103d50 <terminate_current>:

struct cpu_state* terminate_current(struct cpu_state* cpu) {
  103d50:	55                   	push   %ebp
  103d51:	89 e5                	mov    %esp,%ebp
  103d53:	83 ec 18             	sub    $0x18,%esp
  103d56:	8b 45 08             	mov    0x8(%ebp),%eax
  103d59:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct task* next = current_task->next;
  103d5c:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103d61:	8b 40 08             	mov    0x8(%eax),%eax
  103d64:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* prev = current_task->prev;
  103d67:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103d6c:	8b 40 0c             	mov    0xc(%eax),%eax
  103d6f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    //TODO: free resources here

    if (current_task == first_task) {
  103d72:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103d77:	3b 05 34 a4 10 00    	cmp    0x10a434,%eax
  103d7d:	0f 85 0d 00 00 00    	jne    103d90 <terminate_current+0x40>
        first_task = current_task->next;
  103d83:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103d88:	8b 40 08             	mov    0x8(%eax),%eax
  103d8b:	a3 34 a4 10 00       	mov    %eax,0x10a434
    }

    if (next != 0) {
  103d90:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103d97:	0f 84 09 00 00 00    	je     103da6 <terminate_current+0x56>
        next->prev = prev;
  103d9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103da0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103da3:	89 41 0c             	mov    %eax,0xc(%ecx)
    }

    if (prev != 0) {
  103da6:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103dad:	0f 84 09 00 00 00    	je     103dbc <terminate_current+0x6c>
        prev->next = next;
  103db3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103db6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103db9:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if (next == 0)
  103dbc:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103dc3:	0f 85 08 00 00 00    	jne    103dd1 <terminate_current+0x81>
        next = first_task;
  103dc9:	a1 34 a4 10 00       	mov    0x10a434,%eax
  103dce:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task = next;
  103dd1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103dd4:	a3 38 a4 10 00       	mov    %eax,0x10a438

    if(current_task == 0) {
  103dd9:	81 3d 38 a4 10 00 00 	cmpl   $0x0,0x10a438
  103de0:	00 00 00 
  103de3:	0f 85 15 00 00 00    	jne    103dfe <terminate_current+0xae>
  103de9:	8d 05 28 85 10 00    	lea    0x108528,%eax
        show_cod(cpu, "Last task terminated.");
  103def:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103df2:	89 0c 24             	mov    %ecx,(%esp)
  103df5:	89 44 24 04          	mov    %eax,0x4(%esp)
  103df9:	e8 82 c5 ff ff       	call   100380 <show_cod>
    }

    vmm_activate_pagedir(current_task->phys_pdir);
  103dfe:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103e03:	8b 40 14             	mov    0x14(%eax),%eax
  103e06:	89 04 24             	mov    %eax,(%esp)
  103e09:	e8 02 27 00 00       	call   106510 <vmm_activate_pagedir>
    return current_task->cpuState;
  103e0e:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103e13:	8b 40 04             	mov    0x4(%eax),%eax
  103e16:	83 c4 18             	add    $0x18,%esp
  103e19:	5d                   	pop    %ebp
  103e1a:	c3                   	ret    
  103e1b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103e20 <fork_task_state>:
}

void fork_task_state(struct task* new_task) {
  103e20:	55                   	push   %ebp
  103e21:	89 e5                	mov    %esp,%ebp
  103e23:	83 ec 18             	sub    $0x18,%esp
  103e26:	8b 45 08             	mov    0x8(%ebp),%eax
  103e29:	b9 38 00 00 00       	mov    $0x38,%ecx
  103e2e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    new_task->user_stack_bottom = current_task->user_stack_bottom;
  103e31:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103e36:	8b 40 10             	mov    0x10(%eax),%eax
  103e39:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103e3c:	89 42 10             	mov    %eax,0x10(%edx)

    new_task->stdout = current_task->stdout;
  103e3f:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103e44:	8b 40 1c             	mov    0x1c(%eax),%eax
  103e47:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103e4a:	89 42 1c             	mov    %eax,0x1c(%edx)
    new_task->stdin  = current_task->stdin;
  103e4d:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103e52:	8b 40 24             	mov    0x24(%eax),%eax
  103e55:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103e58:	89 42 24             	mov    %eax,0x24(%edx)
    new_task->stderr = current_task->stderr;
  103e5b:	a1 38 a4 10 00       	mov    0x10a438,%eax
  103e60:	8b 40 20             	mov    0x20(%eax),%eax
  103e63:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103e66:	89 42 20             	mov    %eax,0x20(%edx)

    memcpy(new_task->cpuState, current_task->cpuState, sizeof(struct cpu_state));
  103e69:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103e6c:	8b 40 04             	mov    0x4(%eax),%eax
  103e6f:	8b 15 38 a4 10 00    	mov    0x10a438,%edx
  103e75:	8b 52 04             	mov    0x4(%edx),%edx
  103e78:	89 04 24             	mov    %eax,(%esp)
  103e7b:	89 54 24 04          	mov    %edx,0x4(%esp)
  103e7f:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  103e86:	00 
  103e87:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103e8a:	e8 b1 09 00 00       	call   104840 <memcpy>

    new_task->cpuState->eax = 0;
  103e8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103e92:	8b 40 04             	mov    0x4(%eax),%eax
  103e95:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  103e9b:	83 c4 18             	add    $0x18,%esp
  103e9e:	5d                   	pop    %ebp
  103e9f:	c3                   	ret    

00103ea0 <init_task>:

struct task* init_task(uint32_t task_pagedir, void* entry) {
  103ea0:	55                   	push   %ebp
  103ea1:	89 e5                	mov    %esp,%ebp
  103ea3:	83 ec 68             	sub    $0x68,%esp
  103ea6:	8b 45 0c             	mov    0xc(%ebp),%eax
  103ea9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103eac:	ba 2c 00 00 00       	mov    $0x2c,%edx
  103eb1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  103eb4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* ntask = malloc(sizeof(struct task));
  103eb7:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  103ebe:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  103ec1:	e8 aa 02 00 00       	call   104170 <malloc>
  103ec6:	b9 38 00 00 00       	mov    $0x38,%ecx
  103ecb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ntask->cpuState = malloc(sizeof(struct cpu_state));
  103ece:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  103ed5:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  103ed8:	e8 93 02 00 00       	call   104170 <malloc>
  103edd:	b9 00 e0 ff ff       	mov    $0xffffe000,%ecx
  103ee2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103ee5:	89 42 04             	mov    %eax,0x4(%edx)

    ntask->phys_pdir = task_pagedir;
  103ee8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103eeb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103eee:	89 42 14             	mov    %eax,0x14(%edx)
    ntask->user_stack_bottom = (void*) 0xFFFFE000;
  103ef1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ef4:	89 48 10             	mov    %ecx,0x10(%eax)
    ntask->PID = nextPID++;
  103ef7:	a1 e0 71 10 00       	mov    0x1071e0,%eax
  103efc:	89 c1                	mov    %eax,%ecx
  103efe:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103f04:	89 0d e0 71 10 00    	mov    %ecx,0x1071e0
  103f0a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103f0d:	89 01                	mov    %eax,(%ecx)

    ntask->stdin  = 0;
  103f0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f12:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
    ntask->stdout = 0;
  103f19:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f1c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    ntask->stderr = 0;
  103f23:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f26:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

    ntask->next = (void*) 0;
  103f2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f30:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    ntask->prev = (void*) 0;
  103f37:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f3a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

    if (first_task == 0) {
  103f41:	81 3d 34 a4 10 00 00 	cmpl   $0x0,0x10a434
  103f48:	00 00 00 
  103f4b:	0f 85 0d 00 00 00    	jne    103f5e <init_task+0xbe>
        first_task = ntask;
  103f51:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f54:	a3 34 a4 10 00       	mov    %eax,0x10a434
    } else {
  103f59:	e9 1f 00 00 00       	jmp    103f7d <init_task+0xdd>
        ntask->next = first_task;
  103f5e:	a1 34 a4 10 00       	mov    0x10a434,%eax
  103f63:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103f66:	89 41 08             	mov    %eax,0x8(%ecx)
        first_task->prev = ntask;
  103f69:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f6c:	8b 0d 34 a4 10 00    	mov    0x10a434,%ecx
  103f72:	89 41 0c             	mov    %eax,0xc(%ecx)
        first_task = ntask;
  103f75:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f78:	a3 34 a4 10 00       	mov    %eax,0x10a434
    }

    uint32_t rest_pdir = vmm_get_current_pagedir();
  103f7d:	e8 4e 1a 00 00       	call   1059d0 <vmm_get_current_pagedir>
  103f82:	89 45 f0             	mov    %eax,-0x10(%ebp)
    vmm_activate_pagedir(task_pagedir);
  103f85:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f88:	89 04 24             	mov    %eax,(%esp)
  103f8b:	e8 80 25 00 00       	call   106510 <vmm_activate_pagedir>

    if (entry != 0) { //entry == 0 means that this will be forked
  103f90:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103f97:	0f 84 21 00 00 00    	je     103fbe <init_task+0x11e>
  103f9d:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_alloc_addr(ntask->user_stack_bottom, 0);
  103fa2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103fa5:	8b 49 10             	mov    0x10(%ecx),%ecx
  103fa8:	89 0c 24             	mov    %ecx,(%esp)
  103fab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103fb2:	00 
  103fb3:	89 45 ac             	mov    %eax,-0x54(%ebp)
  103fb6:	e8 55 24 00 00       	call   106410 <vmm_alloc_addr>
  103fbb:	89 45 a8             	mov    %eax,-0x58(%ebp)
  103fbe:	b8 38 00 00 00       	mov    $0x38,%eax
  103fc3:	8d 4d b8             	lea    -0x48(%ebp),%ecx
    }

    struct cpu_state nstate = { .eax = 0, .ebx = 0, .ecx = 0, .edx = 0,
  103fc6:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  103fcd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  103fd4:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  103fdb:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  103fe2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  103fe9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  103ff0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  103ff7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  103ffe:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104005:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104008:	89 55 dc             	mov    %edx,-0x24(%ebp)
  10400b:	c7 45 e0 1b 00 00 00 	movl   $0x1b,-0x20(%ebp)
  104012:	c7 45 e4 00 02 00 00 	movl   $0x200,-0x1c(%ebp)
  104019:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10401c:	8b 52 10             	mov    0x10(%edx),%edx
  10401f:	81 c2 00 10 00 00    	add    $0x1000,%edx
  104025:	89 55 e8             	mov    %edx,-0x18(%ebp)
  104028:	c7 45 ec 23 00 00 00 	movl   $0x23,-0x14(%ebp)
            /* Ring-3-Segmentregister */
            .cs = 0x18 | 0x03, .ss = 0x20 | 0x03,

            .eflags = 0x200, };

    memcpy(ntask->cpuState, &nstate, sizeof(struct cpu_state));
  10402f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104032:	8b 52 04             	mov    0x4(%edx),%edx
  104035:	89 14 24             	mov    %edx,(%esp)
  104038:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10403c:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  104043:	00 
  104044:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  104047:	e8 f4 07 00 00       	call   104840 <memcpy>

    vmm_activate_pagedir(rest_pdir);
  10404c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10404f:	89 04 24             	mov    %eax,(%esp)
  104052:	e8 b9 24 00 00       	call   106510 <vmm_activate_pagedir>

    return ntask;
  104057:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10405a:	83 c4 68             	add    $0x68,%esp
  10405d:	5d                   	pop    %ebp
  10405e:	c3                   	ret    
  10405f:	90                   	nop

00104060 <save_cpu_state>:
}

void save_cpu_state(struct cpu_state* cpu) {
  104060:	55                   	push   %ebp
  104061:	89 e5                	mov    %esp,%ebp
  104063:	83 ec 18             	sub    $0x18,%esp
  104066:	8b 45 08             	mov    0x8(%ebp),%eax
  104069:	b9 38 00 00 00       	mov    $0x38,%ecx
  10406e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memcpy(current_task->cpuState, cpu, sizeof(struct cpu_state));
  104071:	a1 38 a4 10 00       	mov    0x10a438,%eax
  104076:	8b 40 04             	mov    0x4(%eax),%eax
  104079:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10407c:	89 04 24             	mov    %eax,(%esp)
  10407f:	89 54 24 04          	mov    %edx,0x4(%esp)
  104083:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  10408a:	00 
  10408b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10408e:	e8 ad 07 00 00       	call   104840 <memcpy>
}
  104093:	83 c4 18             	add    $0x18,%esp
  104096:	5d                   	pop    %ebp
  104097:	c3                   	ret    
  104098:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10409f:	00 

001040a0 <schedule>:

struct cpu_state* schedule(struct cpu_state* cpu) {
  1040a0:	55                   	push   %ebp
  1040a1:	89 e5                	mov    %esp,%ebp
  1040a3:	83 ec 18             	sub    $0x18,%esp
  1040a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1040a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (first_task != 0 && schedulingEnabled) {
  1040ac:	81 3d 34 a4 10 00 00 	cmpl   $0x0,0x10a434
  1040b3:	00 00 00 
  1040b6:	0f 84 9d 00 00 00    	je     104159 <schedule+0xb9>
  1040bc:	81 3d 30 a4 10 00 00 	cmpl   $0x0,0x10a430
  1040c3:	00 00 00 
  1040c6:	0f 84 8d 00 00 00    	je     104159 <schedule+0xb9>
        if (current_task == 0) {
  1040cc:	81 3d 38 a4 10 00 00 	cmpl   $0x0,0x10a438
  1040d3:	00 00 00 
  1040d6:	0f 85 2a 00 00 00    	jne    104106 <schedule+0x66>
            current_task = first_task;
  1040dc:	a1 34 a4 10 00       	mov    0x10a434,%eax
  1040e1:	a3 38 a4 10 00       	mov    %eax,0x10a438
            vmm_activate_pagedir(current_task->phys_pdir);
  1040e6:	a1 38 a4 10 00       	mov    0x10a438,%eax
  1040eb:	8b 40 14             	mov    0x14(%eax),%eax
  1040ee:	89 04 24             	mov    %eax,(%esp)
  1040f1:	e8 1a 24 00 00       	call   106510 <vmm_activate_pagedir>
            return current_task->cpuState;
  1040f6:	a1 38 a4 10 00       	mov    0x10a438,%eax
  1040fb:	8b 40 04             	mov    0x4(%eax),%eax
  1040fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104101:	e9 59 00 00 00       	jmp    10415f <schedule+0xbf>
        }

        struct task* next = current_task->next;
  104106:	a1 38 a4 10 00       	mov    0x10a438,%eax
  10410b:	8b 40 08             	mov    0x8(%eax),%eax
  10410e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (next == 0)
  104111:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104118:	0f 85 08 00 00 00    	jne    104126 <schedule+0x86>
            next = first_task;
  10411e:	a1 34 a4 10 00       	mov    0x10a434,%eax
  104123:	89 45 f4             	mov    %eax,-0xc(%ebp)

        save_cpu_state(cpu);
  104126:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104129:	89 04 24             	mov    %eax,(%esp)
  10412c:	e8 2f ff ff ff       	call   104060 <save_cpu_state>

        current_task = next;
  104131:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104134:	a3 38 a4 10 00       	mov    %eax,0x10a438
        vmm_activate_pagedir(current_task->phys_pdir);
  104139:	a1 38 a4 10 00       	mov    0x10a438,%eax
  10413e:	8b 40 14             	mov    0x14(%eax),%eax
  104141:	89 04 24             	mov    %eax,(%esp)
  104144:	e8 c7 23 00 00       	call   106510 <vmm_activate_pagedir>
        return current_task->cpuState;
  104149:	a1 38 a4 10 00       	mov    0x10a438,%eax
  10414e:	8b 40 04             	mov    0x4(%eax),%eax
  104151:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104154:	e9 06 00 00 00       	jmp    10415f <schedule+0xbf>
    }
    return cpu;
  104159:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10415c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10415f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104162:	83 c4 18             	add    $0x18,%esp
  104165:	5d                   	pop    %ebp
  104166:	c3                   	ret    
  104167:	66 90                	xchg   %ax,%ax
  104169:	66 90                	xchg   %ax,%ax
  10416b:	66 90                	xchg   %ax,%ax
  10416d:	66 90                	xchg   %ax,%ax
  10416f:	90                   	nop

00104170 <malloc>:
    }

    append_to_list(&first_free, tf);
}

void* malloc(size_t size) {
  104170:	55                   	push   %ebp
  104171:	89 e5                	mov    %esp,%ebp
  104173:	83 ec 38             	sub    $0x38,%esp
  104176:	8b 45 08             	mov    0x8(%ebp),%eax
  104179:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(size == 0) return 0;
  10417c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104183:	0f 85 0c 00 00 00    	jne    104195 <malloc+0x25>
  104189:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104190:	e9 95 01 00 00       	jmp    10432a <malloc+0x1ba>

    struct memory_node* last = 0;
  104195:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
  10419c:	a1 44 a4 10 00       	mov    0x10a444,%eax
  1041a1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  1041a4:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1041ab:	0f 84 27 00 00 00    	je     1041d8 <malloc+0x68>
        if (cur->size >= size) {
  1041b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041b4:	8b 00                	mov    (%eax),%eax
  1041b6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1041b9:	0f 82 05 00 00 00    	jb     1041c4 <malloc+0x54>
            break;
  1041bf:	e9 14 00 00 00       	jmp    1041d8 <malloc+0x68>
        }
        last = cur;
  1041c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  1041ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1041cd:	8b 40 08             	mov    0x8(%eax),%eax
  1041d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  1041d3:	e9 cc ff ff ff       	jmp    1041a4 <malloc+0x34>

    if (cur == 0) {
  1041d8:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1041df:	0f 85 bc 00 00 00    	jne    1042a1 <malloc+0x131>
        uint32_t pgs = size / PAGESIZE;
  1041e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041e8:	c1 e8 0c             	shr    $0xc,%eax
  1041eb:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
  1041ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041f1:	25 ff 0f 00 00       	and    $0xfff,%eax
  1041f6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1041fb:	0f 84 0b 00 00 00    	je     10420c <malloc+0x9c>
            pgs++;
  104201:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104204:	05 01 00 00 00       	add    $0x1,%eax
  104209:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
  10420c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10420f:	89 04 24             	mov    %eax,(%esp)
  104212:	e8 a9 21 00 00       	call   1063c0 <vmm_alloc_cont>
  104217:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
  10421a:	e8 81 04 00 00       	call   1046a0 <pop_unused_node>
  10421f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
  104222:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104225:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104228:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
  10422b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10422e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104231:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
  104233:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104236:	c1 e0 0c             	shl    $0xc,%eax
  104239:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10423c:	0f 86 3c 00 00 00    	jbe    10427e <malloc+0x10e>
            struct memory_node* free = pop_unused_node();
  104242:	e8 59 04 00 00       	call   1046a0 <pop_unused_node>
  104247:	8d 0d 44 a4 10 00    	lea    0x10a444,%ecx
  10424d:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
  104250:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104253:	8b 40 04             	mov    0x4(%eax),%eax
  104256:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  104259:	03 02                	add    (%edx),%eax
  10425b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10425e:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
  104261:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104264:	c1 e0 0c             	shl    $0xc,%eax
  104267:	2b 45 f8             	sub    -0x8(%ebp),%eax
  10426a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10426d:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  10426f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104272:	89 0c 24             	mov    %ecx,(%esp)
  104275:	89 44 24 04          	mov    %eax,0x4(%esp)
  104279:	e8 c2 00 00 00       	call   104340 <append_to_list>
  10427e:	8d 05 40 a4 10 00    	lea    0x10a440,%eax
        }

        append_to_list(&first_used, fill);
  104284:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104287:	89 04 24             	mov    %eax,(%esp)
  10428a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10428e:	e8 ad 00 00 00       	call   104340 <append_to_list>

        return (void*) fill->address;
  104293:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104296:	8b 40 04             	mov    0x4(%eax),%eax
  104299:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10429c:	e9 89 00 00 00       	jmp    10432a <malloc+0x1ba>
  1042a1:	8d 05 44 a4 10 00    	lea    0x10a444,%eax
    } else {
        uint32_t freesize = cur->size - size;
  1042a7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1042aa:	8b 09                	mov    (%ecx),%ecx
  1042ac:	2b 4d f8             	sub    -0x8(%ebp),%ecx
  1042af:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
  1042b2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1042b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1042b8:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
  1042ba:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1042bd:	89 04 24             	mov    %eax,(%esp)
  1042c0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1042c4:	e8 a7 00 00 00       	call   104370 <remove_from_list>
  1042c9:	8d 05 40 a4 10 00    	lea    0x10a440,%eax
        append_to_list(&first_used, cur);
  1042cf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1042d2:	89 04 24             	mov    %eax,(%esp)
  1042d5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1042d9:	e8 62 00 00 00       	call   104340 <append_to_list>

        if (freesize > 0) {
  1042de:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  1042e5:	0f 86 36 00 00 00    	jbe    104321 <malloc+0x1b1>
            struct memory_node* free = pop_unused_node();
  1042eb:	e8 b0 03 00 00       	call   1046a0 <pop_unused_node>
  1042f0:	8d 0d 44 a4 10 00    	lea    0x10a444,%ecx
  1042f6:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
  1042f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1042fc:	8b 40 04             	mov    0x4(%eax),%eax
  1042ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104302:	03 02                	add    (%edx),%eax
  104304:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104307:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
  10430a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10430d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104310:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  104312:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104315:	89 0c 24             	mov    %ecx,(%esp)
  104318:	89 44 24 04          	mov    %eax,0x4(%esp)
  10431c:	e8 1f 00 00 00       	call   104340 <append_to_list>
        }

        return (void*) cur->address;
  104321:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104324:	8b 40 04             	mov    0x4(%eax),%eax
  104327:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  10432a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10432d:	83 c4 38             	add    $0x38,%esp
  104330:	5d                   	pop    %ebp
  104331:	c3                   	ret    
  104332:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104339:	1f 84 00 00 00 00 00 

00104340 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
  104340:	55                   	push   %ebp
  104341:	89 e5                	mov    %esp,%ebp
  104343:	83 ec 08             	sub    $0x8,%esp
  104346:	8b 45 0c             	mov    0xc(%ebp),%eax
  104349:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10434c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10434f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
  104352:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104355:	8b 00                	mov    (%eax),%eax
  104357:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10435a:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
  10435d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104360:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104363:	89 01                	mov    %eax,(%ecx)
}
  104365:	83 c4 08             	add    $0x8,%esp
  104368:	5d                   	pop    %ebp
  104369:	c3                   	ret    
  10436a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104370 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
  104370:	55                   	push   %ebp
  104371:	89 e5                	mov    %esp,%ebp
  104373:	83 ec 10             	sub    $0x10,%esp
  104376:	8b 45 0c             	mov    0xc(%ebp),%eax
  104379:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10437c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10437f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
  104382:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
  104389:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10438c:	8b 00                	mov    (%eax),%eax
  10438e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  104391:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104398:	0f 84 4e 00 00 00    	je     1043ec <remove_from_list+0x7c>
        if (cur == element) {
  10439e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043a1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1043a4:	0f 85 2e 00 00 00    	jne    1043d8 <remove_from_list+0x68>
            if (last == 0) {
  1043aa:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1043b1:	0f 85 10 00 00 00    	jne    1043c7 <remove_from_list+0x57>
                *root = cur->next;
  1043b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043ba:	8b 40 08             	mov    0x8(%eax),%eax
  1043bd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1043c0:	89 01                	mov    %eax,(%ecx)
                return;
  1043c2:	e9 25 00 00 00       	jmp    1043ec <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
  1043c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043ca:	8b 40 08             	mov    0x8(%eax),%eax
  1043cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1043d0:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
  1043d3:	e9 14 00 00 00       	jmp    1043ec <remove_from_list+0x7c>
            }
        }
        last = cur;
  1043d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043db:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  1043de:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043e1:	8b 40 08             	mov    0x8(%eax),%eax
  1043e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  1043e7:	e9 a5 ff ff ff       	jmp    104391 <remove_from_list+0x21>
}
  1043ec:	83 c4 10             	add    $0x10,%esp
  1043ef:	5d                   	pop    %ebp
  1043f0:	c3                   	ret    
  1043f1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1043f8:	0f 1f 84 00 00 00 00 
  1043ff:	00 

00104400 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
  104400:	55                   	push   %ebp
  104401:	89 e5                	mov    %esp,%ebp
  104403:	83 ec 28             	sub    $0x28,%esp
  104406:	8b 45 0c             	mov    0xc(%ebp),%eax
  104409:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10440c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10440f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
  104412:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104415:	0f af 45 f8          	imul   -0x8(%ebp),%eax
  104419:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
  10441c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10441f:	89 04 24             	mov    %eax,(%esp)
  104422:	e8 49 fd ff ff       	call   104170 <malloc>
  104427:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
  10442a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104431:	0f 84 22 00 00 00    	je     104459 <calloc+0x59>
  104437:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
  10443c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10443f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104442:	89 0c 24             	mov    %ecx,(%esp)
  104445:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10444c:	00 
  10444d:	89 54 24 08          	mov    %edx,0x8(%esp)
  104451:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104454:	e8 87 03 00 00       	call   1047e0 <memset>
    }

    return p;
  104459:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10445c:	83 c4 28             	add    $0x28,%esp
  10445f:	5d                   	pop    %ebp
  104460:	c3                   	ret    
  104461:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104468:	0f 1f 84 00 00 00 00 
  10446f:	00 

00104470 <realloc>:
}

void* realloc(void* ptr, size_t size) {
  104470:	55                   	push   %ebp
  104471:	89 e5                	mov    %esp,%ebp
  104473:	83 ec 28             	sub    $0x28,%esp
  104476:	8b 45 0c             	mov    0xc(%ebp),%eax
  104479:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10447c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10447f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
  104482:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
  104489:	a1 40 a4 10 00       	mov    0x10a440,%eax
  10448e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
  104491:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104498:	0f 84 8e 00 00 00    	je     10452c <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
  10449e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1044a1:	8b 40 04             	mov    0x4(%eax),%eax
  1044a4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1044a7:	39 c8                	cmp    %ecx,%eax
  1044a9:	0f 85 69 00 00 00    	jne    104518 <realloc+0xa8>
            if (size == 0) {
  1044af:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1044b6:	0f 85 17 00 00 00    	jne    1044d3 <realloc+0x63>
                free(ptr);
  1044bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1044bf:	89 04 24             	mov    %eax,(%esp)
  1044c2:	e8 79 00 00 00       	call   104540 <free>
                return 0;
  1044c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1044ce:	e9 60 00 00 00       	jmp    104533 <realloc+0xc3>
            } else {
                void* new = malloc(size);
  1044d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044d6:	89 04 24             	mov    %eax,(%esp)
  1044d9:	e8 92 fc ff ff       	call   104170 <malloc>
  1044de:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
  1044e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1044e4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1044e7:	8b 49 04             	mov    0x4(%ecx),%ecx
  1044ea:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1044ed:	8b 12                	mov    (%edx),%edx
  1044ef:	89 04 24             	mov    %eax,(%esp)
  1044f2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1044f6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1044fa:	e8 41 03 00 00       	call   104840 <memcpy>
                free((void*) cur->address);
  1044ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104502:	8b 40 04             	mov    0x4(%eax),%eax
  104505:	89 04 24             	mov    %eax,(%esp)
  104508:	e8 33 00 00 00       	call   104540 <free>

                return new;
  10450d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104510:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104513:	e9 1b 00 00 00       	jmp    104533 <realloc+0xc3>
            }
        }
        last = cur;
  104518:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10451b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
  10451e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104521:	8b 40 08             	mov    0x8(%eax),%eax
  104524:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
  104527:	e9 65 ff ff ff       	jmp    104491 <realloc+0x21>
    return 0;
  10452c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104533:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104536:	83 c4 28             	add    $0x28,%esp
  104539:	5d                   	pop    %ebp
  10453a:	c3                   	ret    
  10453b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104540 <free>:

void free(void* ptr) {
  104540:	55                   	push   %ebp
  104541:	89 e5                	mov    %esp,%ebp
  104543:	83 ec 18             	sub    $0x18,%esp
  104546:	8b 45 08             	mov    0x8(%ebp),%eax
  104549:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
  10454c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
  104553:	a1 40 a4 10 00       	mov    0x10a440,%eax
  104558:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
  10455b:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104562:	0f 84 35 00 00 00    	je     10459d <free+0x5d>
        if (cur->address == (uint32_t) ptr) {
  104568:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10456b:	8b 40 04             	mov    0x4(%eax),%eax
  10456e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104571:	39 c8                	cmp    %ecx,%eax
  104573:	0f 85 10 00 00 00    	jne    104589 <free+0x49>
            merge_into_frees(cur);
  104579:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10457c:	89 04 24             	mov    %eax,(%esp)
  10457f:	e8 2c 00 00 00       	call   1045b0 <merge_into_frees>
            break;
  104584:	e9 14 00 00 00       	jmp    10459d <free+0x5d>
        }
        last = cur;
  104589:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10458c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
  10458f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104592:	8b 40 08             	mov    0x8(%eax),%eax
  104595:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  104598:	e9 be ff ff ff       	jmp    10455b <free+0x1b>
}
  10459d:	83 c4 18             	add    $0x18,%esp
  1045a0:	5d                   	pop    %ebp
  1045a1:	c3                   	ret    
  1045a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1045a9:	1f 84 00 00 00 00 00 

001045b0 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
  1045b0:	55                   	push   %ebp
  1045b1:	89 e5                	mov    %esp,%ebp
  1045b3:	56                   	push   %esi
  1045b4:	83 ec 14             	sub    $0x14,%esp
  1045b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1045ba:	8d 0d 40 a4 10 00    	lea    0x10a440,%ecx
  1045c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
  1045c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1045c6:	89 0c 24             	mov    %ecx,(%esp)
  1045c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1045cd:	e8 9e fd ff ff       	call   104370 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
  1045d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
  1045d9:	a1 44 a4 10 00       	mov    0x10a444,%eax
  1045de:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  1045e1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1045e8:	0f 84 92 00 00 00    	je     104680 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
  1045ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1045f1:	8b 40 04             	mov    0x4(%eax),%eax
  1045f4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1045f7:	03 01                	add    (%ecx),%eax
  1045f9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1045fc:	3b 41 04             	cmp    0x4(%ecx),%eax
  1045ff:	0f 85 26 00 00 00    	jne    10462b <merge_into_frees+0x7b>
  104605:	8d 05 44 a4 10 00    	lea    0x10a444,%eax
            tf->address = cur->address;
  10460b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10460e:	8b 49 04             	mov    0x4(%ecx),%ecx
  104611:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104614:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
  104617:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10461a:	89 04 24             	mov    %eax,(%esp)
  10461d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104621:	e8 4a fd ff ff       	call   104370 <remove_from_list>
            goto editedList;
  104626:	e9 a7 ff ff ff       	jmp    1045d2 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
  10462b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10462e:	8b 40 04             	mov    0x4(%eax),%eax
  104631:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104634:	8b 49 04             	mov    0x4(%ecx),%ecx
  104637:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10463a:	03 0a                	add    (%edx),%ecx
  10463c:	39 c8                	cmp    %ecx,%eax
  10463e:	0f 85 28 00 00 00    	jne    10466c <merge_into_frees+0xbc>
  104644:	8d 05 44 a4 10 00    	lea    0x10a444,%eax
            tf->size += cur->size;
  10464a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10464d:	8b 09                	mov    (%ecx),%ecx
  10464f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104652:	8b 32                	mov    (%edx),%esi
  104654:	01 ce                	add    %ecx,%esi
  104656:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
  104658:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10465b:	89 04 24             	mov    %eax,(%esp)
  10465e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104662:	e8 09 fd ff ff       	call   104370 <remove_from_list>
            goto editedList;
  104667:	e9 66 ff ff ff       	jmp    1045d2 <merge_into_frees+0x22>
        }

        last = cur;
  10466c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10466f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  104672:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104675:	8b 40 08             	mov    0x8(%eax),%eax
  104678:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  10467b:	e9 61 ff ff ff       	jmp    1045e1 <merge_into_frees+0x31>
  104680:	8d 05 44 a4 10 00    	lea    0x10a444,%eax

    append_to_list(&first_free, tf);
  104686:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104689:	89 04 24             	mov    %eax,(%esp)
  10468c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104690:	e8 ab fc ff ff       	call   104340 <append_to_list>
}
  104695:	83 c4 14             	add    $0x14,%esp
  104698:	5e                   	pop    %esi
  104699:	5d                   	pop    %ebp
  10469a:	c3                   	ret    
  10469b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001046a0 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
  1046a0:	55                   	push   %ebp
  1046a1:	89 e5                	mov    %esp,%ebp
  1046a3:	83 ec 08             	sub    $0x8,%esp
  1046a6:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
  1046ac:	89 04 24             	mov    %eax,(%esp)
  1046af:	e8 3c 00 00 00       	call   1046f0 <pop_from_list>
  1046b4:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
  1046b7:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
  1046be:	0f 85 1b 00 00 00    	jne    1046df <pop_unused_node+0x3f>
        allocate_unused_nodes();
  1046c4:	e8 77 00 00 00       	call   104740 <allocate_unused_nodes>
  1046c9:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax
        ret = pop_from_list(&first_unused);
  1046cf:	89 04 24             	mov    %eax,(%esp)
  1046d2:	e8 19 00 00 00       	call   1046f0 <pop_from_list>
  1046d7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  1046da:	e9 d8 ff ff ff       	jmp    1046b7 <pop_unused_node+0x17>

    return ret;
  1046df:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046e2:	83 c4 08             	add    $0x8,%esp
  1046e5:	5d                   	pop    %ebp
  1046e6:	c3                   	ret    
  1046e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1046ee:	00 00 

001046f0 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
  1046f0:	55                   	push   %ebp
  1046f1:	89 e5                	mov    %esp,%ebp
  1046f3:	83 ec 18             	sub    $0x18,%esp
  1046f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1046f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
  1046fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1046ff:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
  104705:	0f 85 0c 00 00 00    	jne    104717 <pop_from_list+0x27>
        return 0;
  10470b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104712:	e9 20 00 00 00       	jmp    104737 <pop_from_list+0x47>
    struct memory_node* pop = *root;
  104717:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10471a:	8b 00                	mov    (%eax),%eax
  10471c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
  10471f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104722:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104725:	89 04 24             	mov    %eax,(%esp)
  104728:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10472c:	e8 3f fc ff ff       	call   104370 <remove_from_list>
    return pop;
  104731:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104734:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104737:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10473a:	83 c4 18             	add    $0x18,%esp
  10473d:	5d                   	pop    %ebp
  10473e:	c3                   	ret    
  10473f:	90                   	nop

00104740 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
  104740:	55                   	push   %ebp
  104741:	89 e5                	mov    %esp,%ebp
  104743:	83 ec 28             	sub    $0x28,%esp
  104746:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
  10474b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  104752:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104755:	e8 66 1c 00 00       	call   1063c0 <vmm_alloc_cont>
  10475a:	b9 00 00 00 00       	mov    $0x0,%ecx
  10475f:	ba 00 10 00 00       	mov    $0x1000,%edx
  104764:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
  104767:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10476a:	89 04 24             	mov    %eax,(%esp)
  10476d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  104774:	00 
  104775:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  10477c:	00 
  10477d:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104780:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104783:	e8 58 00 00 00       	call   1047e0 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  104788:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  10478f:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
  104796:	0f 83 30 00 00 00    	jae    1047cc <allocate_unused_nodes+0x8c>
  10479c:	8d 05 3c a4 10 00    	lea    0x10a43c,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
  1047a2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1047a5:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1047a8:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
  1047ae:	01 ca                	add    %ecx,%edx
  1047b0:	89 04 24             	mov    %eax,(%esp)
  1047b3:	89 54 24 04          	mov    %edx,0x4(%esp)
  1047b7:	e8 84 fb ff ff       	call   104340 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  1047bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1047bf:	05 01 00 00 00       	add    $0x1,%eax
  1047c4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1047c7:	e9 c3 ff ff ff       	jmp    10478f <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
  1047cc:	83 c4 28             	add    $0x28,%esp
  1047cf:	5d                   	pop    %ebp
  1047d0:	c3                   	ret    
  1047d1:	66 90                	xchg   %ax,%ax
  1047d3:	66 90                	xchg   %ax,%ax
  1047d5:	66 90                	xchg   %ax,%ax
  1047d7:	66 90                	xchg   %ax,%ax
  1047d9:	66 90                	xchg   %ax,%ax
  1047db:	66 90                	xchg   %ax,%ax
  1047dd:	66 90                	xchg   %ax,%ax
  1047df:	90                   	nop

001047e0 <memset>:
#include "vmm.h"
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
  1047e0:	55                   	push   %ebp
  1047e1:	89 e5                	mov    %esp,%ebp
  1047e3:	83 ec 10             	sub    $0x10,%esp
  1047e6:	8b 45 10             	mov    0x10(%ebp),%eax
  1047e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1047ec:	8b 55 08             	mov    0x8(%ebp),%edx
  1047ef:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1047f2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1047f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* p = buf;
  1047f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1047fb:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (n--) {
  1047fe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104801:	89 c1                	mov    %eax,%ecx
  104803:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  104809:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  10480c:	3d 00 00 00 00       	cmp    $0x0,%eax
  104811:	0f 84 1a 00 00 00    	je     104831 <memset+0x51>
        *p++ = c;
  104817:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10481a:	88 c1                	mov    %al,%cl
  10481c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10481f:	89 c2                	mov    %eax,%edx
  104821:	81 c2 01 00 00 00    	add    $0x1,%edx
  104827:	89 55 f0             	mov    %edx,-0x10(%ebp)
  10482a:	88 08                	mov    %cl,(%eax)
    }
  10482c:	e9 cd ff ff ff       	jmp    1047fe <memset+0x1e>

    return buf;
  104831:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104834:	83 c4 10             	add    $0x10,%esp
  104837:	5d                   	pop    %ebp
  104838:	c3                   	ret    
  104839:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00104840 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
  104840:	55                   	push   %ebp
  104841:	89 e5                	mov    %esp,%ebp
  104843:	83 ec 14             	sub    $0x14,%esp
  104846:	8b 45 10             	mov    0x10(%ebp),%eax
  104849:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10484c:	8b 55 08             	mov    0x8(%ebp),%edx
  10484f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104852:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104855:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* d = dest;
  104858:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10485b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const unsigned char* s = src;
  10485e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104861:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (n--) {
  104864:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104867:	89 c1                	mov    %eax,%ecx
  104869:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  10486f:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104872:	3d 00 00 00 00       	cmp    $0x0,%eax
  104877:	0f 84 25 00 00 00    	je     1048a2 <memcpy+0x62>
        *(d++) = *(s++);
  10487d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104880:	89 c1                	mov    %eax,%ecx
  104882:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104888:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10488b:	8a 10                	mov    (%eax),%dl
  10488d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104890:	89 c1                	mov    %eax,%ecx
  104892:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104898:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10489b:	88 10                	mov    %dl,(%eax)
    }
  10489d:	e9 c2 ff ff ff       	jmp    104864 <memcpy+0x24>

    return dest;
  1048a2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1048a5:	83 c4 14             	add    $0x14,%esp
  1048a8:	5d                   	pop    %ebp
  1048a9:	c3                   	ret    
  1048aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001048b0 <memcmp>:
}

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  1048b0:	55                   	push   %ebp
  1048b1:	89 e5                	mov    %esp,%ebp
  1048b3:	83 ec 1c             	sub    $0x1c,%esp
  1048b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1048b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1048bc:	8b 55 08             	mov    0x8(%ebp),%edx
  1048bf:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1048c2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1048c5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
  1048c8:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1048cf:	0f 85 0c 00 00 00    	jne    1048e1 <memcmp+0x31>
        return -1;
  1048d5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  1048dc:	e9 a7 00 00 00       	jmp    104988 <memcmp+0xd8>
    if (ptr2 == 0)
  1048e1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1048e8:	0f 85 0c 00 00 00    	jne    1048fa <memcmp+0x4a>
        return 1;
  1048ee:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1048f5:	e9 8e 00 00 00       	jmp    104988 <memcmp+0xd8>
    if (num == 0)
  1048fa:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104901:	0f 85 0c 00 00 00    	jne    104913 <memcmp+0x63>
        return 0;
  104907:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10490e:	e9 75 00 00 00       	jmp    104988 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
  104913:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104916:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
  104919:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10491c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
  10491f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104926:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104929:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10492c:	0f 83 4f 00 00 00    	jae    104981 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
  104932:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104935:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104938:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  10493c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10493f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104942:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  104946:	39 c8                	cmp    %ecx,%eax
  104948:	0f 84 1e 00 00 00    	je     10496c <memcmp+0xbc>
            return pa[i] - pb[i];
  10494e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104951:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104954:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  104958:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10495b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10495e:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  104962:	29 c8                	sub    %ecx,%eax
  104964:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104967:	e9 1c 00 00 00       	jmp    104988 <memcmp+0xd8>
        }
    }
  10496c:	e9 00 00 00 00       	jmp    104971 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
  104971:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104974:	05 01 00 00 00       	add    $0x1,%eax
  104979:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10497c:	e9 a5 ff ff ff       	jmp    104926 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
  104981:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104988:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10498b:	83 c4 1c             	add    $0x1c,%esp
  10498e:	5d                   	pop    %ebp
  10498f:	c3                   	ret    

00104990 <strcmp>:

int strcmp(const char* str1, const char* str2) {
  104990:	55                   	push   %ebp
  104991:	89 e5                	mov    %esp,%ebp
  104993:	56                   	push   %esi
  104994:	83 ec 24             	sub    $0x24,%esp
  104997:	8b 45 0c             	mov    0xc(%ebp),%eax
  10499a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10499d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1049a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
  1049a3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1049a6:	89 e1                	mov    %esp,%ecx
  1049a8:	89 01                	mov    %eax,(%ecx)
  1049aa:	e8 61 00 00 00       	call   104a10 <strlen>
  1049af:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
  1049b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1049b5:	89 e1                	mov    %esp,%ecx
  1049b7:	89 01                	mov    %eax,(%ecx)
  1049b9:	e8 52 00 00 00       	call   104a10 <strlen>
  1049be:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
  1049c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1049c4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1049c7:	0f 8d 0b 00 00 00    	jge    1049d8 <strcmp+0x48>
  1049cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1049d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1049d3:	e9 06 00 00 00       	jmp    1049de <strcmp+0x4e>
  1049d8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1049db:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1049de:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1049e1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, l1 * sizeof(char));
  1049e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1049e7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1049ea:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1049ed:	c1 e2 00             	shl    $0x0,%edx
  1049f0:	89 e6                	mov    %esp,%esi
  1049f2:	89 56 08             	mov    %edx,0x8(%esi)
  1049f5:	89 4e 04             	mov    %ecx,0x4(%esi)
  1049f8:	89 06                	mov    %eax,(%esi)
  1049fa:	e8 b1 fe ff ff       	call   1048b0 <memcmp>
  1049ff:	83 c4 24             	add    $0x24,%esp
  104a02:	5e                   	pop    %esi
  104a03:	5d                   	pop    %ebp
  104a04:	c3                   	ret    
  104a05:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  104a0c:	00 00 00 00 

00104a10 <strlen>:
}

unsigned int strlen(const char* str) {
  104a10:	55                   	push   %ebp
  104a11:	89 e5                	mov    %esp,%ebp
  104a13:	83 ec 0c             	sub    $0xc,%esp
  104a16:	8b 45 08             	mov    0x8(%ebp),%eax
  104a19:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
  104a1c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104a23:	0f 85 0c 00 00 00    	jne    104a35 <strlen+0x25>
        return 0;
  104a29:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104a30:	e9 37 00 00 00       	jmp    104a6c <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
  104a35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104a3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a3f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104a42:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  104a46:	3d 00 00 00 00       	cmp    $0x0,%eax
  104a4b:	0f 84 15 00 00 00    	je     104a66 <strlen+0x56>
  104a51:	e9 00 00 00 00       	jmp    104a56 <strlen+0x46>
  104a56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a59:	05 01 00 00 00       	add    $0x1,%eax
  104a5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104a61:	e9 d6 ff ff ff       	jmp    104a3c <strlen+0x2c>
        ;
    return i;
  104a66:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a69:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104a6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104a6f:	83 c4 0c             	add    $0xc,%esp
  104a72:	5d                   	pop    %ebp
  104a73:	c3                   	ret    
  104a74:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104a7b:	00 00 00 00 00 

00104a80 <strcpy>:

char* strcpy(char* dest, const char* src) {
  104a80:	55                   	push   %ebp
  104a81:	89 e5                	mov    %esp,%ebp
  104a83:	56                   	push   %esi
  104a84:	83 ec 24             	sub    $0x24,%esp
  104a87:	8b 45 0c             	mov    0xc(%ebp),%eax
  104a8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104a8d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104a90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
  104a93:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a96:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104a99:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104a9c:	89 e6                	mov    %esp,%esi
  104a9e:	89 16                	mov    %edx,(%esi)
  104aa0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104aa3:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104aa6:	e8 65 ff ff ff       	call   104a10 <strlen>
  104aab:	c1 e0 00             	shl    $0x0,%eax
  104aae:	05 01 00 00 00       	add    $0x1,%eax
  104ab3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104ab6:	89 0c 24             	mov    %ecx,(%esp)
  104ab9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  104abc:	89 54 24 04          	mov    %edx,0x4(%esp)
  104ac0:	89 44 24 08          	mov    %eax,0x8(%esp)
  104ac4:	e8 77 fd ff ff       	call   104840 <memcpy>
    return dest;
  104ac9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104acc:	83 c4 24             	add    $0x24,%esp
  104acf:	5e                   	pop    %esi
  104ad0:	5d                   	pop    %ebp
  104ad1:	c3                   	ret    
  104ad2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104ad9:	1f 84 00 00 00 00 00 

00104ae0 <strclone>:
}

char* strclone(char* str) {
  104ae0:	55                   	push   %ebp
  104ae1:	89 e5                	mov    %esp,%ebp
  104ae3:	83 ec 18             	sub    $0x18,%esp
  104ae6:	8b 45 08             	mov    0x8(%ebp),%eax
  104ae9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
  104aec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104aef:	89 e1                	mov    %esp,%ecx
  104af1:	89 01                	mov    %eax,(%ecx)
  104af3:	e8 18 ff ff ff       	call   104a10 <strlen>
  104af8:	c1 e0 00             	shl    $0x0,%eax
  104afb:	05 01 00 00 00       	add    $0x1,%eax
  104b00:	89 04 24             	mov    %eax,(%esp)
  104b03:	e8 68 f6 ff ff       	call   104170 <malloc>
  104b08:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
  104b0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b0e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104b11:	89 e2                	mov    %esp,%edx
  104b13:	89 4a 04             	mov    %ecx,0x4(%edx)
  104b16:	89 02                	mov    %eax,(%edx)
  104b18:	e8 63 ff ff ff       	call   104a80 <strcpy>

    return ret;
  104b1d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104b20:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104b23:	89 c8                	mov    %ecx,%eax
  104b25:	83 c4 18             	add    $0x18,%esp
  104b28:	5d                   	pop    %ebp
  104b29:	c3                   	ret    
  104b2a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104b30 <strtok>:
}

char* sp = NULL; /* the start position of the string */

char* strtok(char* str, const char* delimiters) {
  104b30:	55                   	push   %ebp
  104b31:	89 e5                	mov    %esp,%ebp
  104b33:	83 ec 18             	sub    $0x18,%esp
  104b36:	8b 45 0c             	mov    0xc(%ebp),%eax
  104b39:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104b3c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104b3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) {
  104b42:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104b49:	0f 84 22 00 00 00    	je     104b71 <strtok+0x41>
        return strtoknc(strclone(str), delimiters);
  104b4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b52:	89 04 24             	mov    %eax,(%esp)
  104b55:	e8 86 ff ff ff       	call   104ae0 <strclone>
  104b5a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104b5d:	89 04 24             	mov    %eax,(%esp)
  104b60:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104b64:	e8 37 00 00 00       	call   104ba0 <strtoknc>
  104b69:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104b6c:	e9 1e 00 00 00       	jmp    104b8f <strtok+0x5f>
  104b71:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
  104b76:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104b79:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104b80:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104b84:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104b87:	e8 14 00 00 00       	call   104ba0 <strtoknc>
  104b8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104b8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104b92:	83 c4 18             	add    $0x18,%esp
  104b95:	5d                   	pop    %ebp
  104b96:	c3                   	ret    
  104b97:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  104b9e:	00 00 

00104ba0 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
  104ba0:	55                   	push   %ebp
  104ba1:	89 e5                	mov    %esp,%ebp
  104ba3:	83 ec 28             	sub    $0x28,%esp
  104ba6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104ba9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104bac:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104baf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
  104bb2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
  104bb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104bbc:	89 e1                	mov    %esp,%ecx
  104bbe:	89 01                	mov    %eax,(%ecx)
  104bc0:	e8 4b fe ff ff       	call   104a10 <strlen>
  104bc5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
  104bc8:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104bcf:	0f 85 0c 00 00 00    	jne    104be1 <strtoknc+0x41>
        return 0;
  104bd5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104bdc:	e9 80 01 00 00       	jmp    104d61 <strtoknc+0x1c1>

    /* if the original string has nothing left */
    if (!str && !sp)
  104be1:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104be8:	0f 85 1c 00 00 00    	jne    104c0a <strtoknc+0x6a>
  104bee:	81 3d 48 a4 10 00 00 	cmpl   $0x0,0x10a448
  104bf5:	00 00 00 
  104bf8:	0f 85 0c 00 00 00    	jne    104c0a <strtoknc+0x6a>
        return 0;
  104bfe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104c05:	e9 57 01 00 00       	jmp    104d61 <strtoknc+0x1c1>

    /* initialize the sp during the first call */
    if (str && !sp)
  104c0a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104c11:	0f 84 18 00 00 00    	je     104c2f <strtoknc+0x8f>
  104c17:	81 3d 48 a4 10 00 00 	cmpl   $0x0,0x10a448
  104c1e:	00 00 00 
  104c21:	0f 85 08 00 00 00    	jne    104c2f <strtoknc+0x8f>
        sp = str;
  104c27:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c2a:	a3 48 a4 10 00       	mov    %eax,0x10a448

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
  104c2f:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104c34:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
  104c37:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104c3e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104c41:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104c44:	0f 8d 3d 00 00 00    	jge    104c87 <strtoknc+0xe7>
            if (*p_start == delimiters[i]) {
  104c4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c4d:	0f be 00             	movsbl (%eax),%eax
  104c50:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104c53:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104c56:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  104c5a:	39 c8                	cmp    %ecx,%eax
  104c5c:	0f 85 10 00 00 00    	jne    104c72 <strtoknc+0xd2>
                p_start++;
  104c62:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c65:	05 01 00 00 00       	add    $0x1,%eax
  104c6a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
  104c6d:	e9 15 00 00 00       	jmp    104c87 <strtoknc+0xe7>
            }
        }
  104c72:	e9 00 00 00 00       	jmp    104c77 <strtoknc+0xd7>
        sp = str;

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
  104c77:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104c7a:	05 01 00 00 00       	add    $0x1,%eax
  104c7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104c82:	e9 b7 ff ff ff       	jmp    104c3e <strtoknc+0x9e>
                p_start++;
                break;
            }
        }

        if (i == len) {
  104c87:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104c8a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104c8d:	0f 85 0d 00 00 00    	jne    104ca0 <strtoknc+0x100>
            sp = p_start;
  104c93:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104c96:	a3 48 a4 10 00       	mov    %eax,0x10a448
            break;
  104c9b:	e9 05 00 00 00       	jmp    104ca5 <strtoknc+0x105>
        }
    }
  104ca0:	e9 92 ff ff ff       	jmp    104c37 <strtoknc+0x97>

    /* return NULL if nothing left */
    if (*sp == '\0') {
  104ca5:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104caa:	0f be 00             	movsbl (%eax),%eax
  104cad:	3d 00 00 00 00       	cmp    $0x0,%eax
  104cb2:	0f 85 17 00 00 00    	jne    104ccf <strtoknc+0x12f>
        sp = NULL;
  104cb8:	c7 05 48 a4 10 00 00 	movl   $0x0,0x10a448
  104cbf:	00 00 00 
        return sp;
  104cc2:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104cc7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104cca:	e9 92 00 00 00       	jmp    104d61 <strtoknc+0x1c1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
  104ccf:	e9 00 00 00 00       	jmp    104cd4 <strtoknc+0x134>
  104cd4:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104cd9:	0f be 00             	movsbl (%eax),%eax
  104cdc:	3d 00 00 00 00       	cmp    $0x0,%eax
  104ce1:	0f 84 74 00 00 00    	je     104d5b <strtoknc+0x1bb>
        for (i = 0; i < len; i++) {
  104ce7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  104cee:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104cf1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104cf4:	0f 8d 3c 00 00 00    	jge    104d36 <strtoknc+0x196>
            if (*sp == delimiters[i]) {
  104cfa:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104cff:	0f be 00             	movsbl (%eax),%eax
  104d02:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104d05:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104d08:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  104d0c:	39 c8                	cmp    %ecx,%eax
  104d0e:	0f 85 0d 00 00 00    	jne    104d21 <strtoknc+0x181>
                *sp = '\0';
  104d14:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104d19:	c6 00 00             	movb   $0x0,(%eax)
                break;
  104d1c:	e9 15 00 00 00       	jmp    104d36 <strtoknc+0x196>
            }
        }
  104d21:	e9 00 00 00 00       	jmp    104d26 <strtoknc+0x186>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
  104d26:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d29:	05 01 00 00 00       	add    $0x1,%eax
  104d2e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104d31:	e9 b8 ff ff ff       	jmp    104cee <strtoknc+0x14e>
                *sp = '\0';
                break;
            }
        }

        sp++;
  104d36:	a1 48 a4 10 00       	mov    0x10a448,%eax
  104d3b:	05 01 00 00 00       	add    $0x1,%eax
  104d40:	a3 48 a4 10 00       	mov    %eax,0x10a448
        if (i < len)
  104d45:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104d48:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104d4b:	0f 8d 05 00 00 00    	jge    104d56 <strtoknc+0x1b6>
            break;
  104d51:	e9 05 00 00 00       	jmp    104d5b <strtoknc+0x1bb>
    }
  104d56:	e9 79 ff ff ff       	jmp    104cd4 <strtoknc+0x134>

    return p_start;
  104d5b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104d5e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104d61:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104d64:	83 c4 28             	add    $0x28,%esp
  104d67:	5d                   	pop    %ebp
  104d68:	c3                   	ret    
  104d69:	66 90                	xchg   %ax,%ax
  104d6b:	66 90                	xchg   %ax,%ax
  104d6d:	66 90                	xchg   %ax,%ax
  104d6f:	90                   	nop

00104d70 <vfs_create_dir>:
    }

    return child;
}

uint32_t vfs_create_dir(char* path) {
  104d70:	55                   	push   %ebp
  104d71:	89 e5                	mov    %esp,%ebp
  104d73:	83 ec 08             	sub    $0x8,%esp
  104d76:	8b 45 08             	mov    0x8(%ebp),%eax
  104d79:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return vfs_create_path(path);
  104d7c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104d7f:	89 04 24             	mov    %eax,(%esp)
  104d82:	e8 09 00 00 00       	call   104d90 <vfs_create_path>
  104d87:	83 c4 08             	add    $0x8,%esp
  104d8a:	5d                   	pop    %ebp
  104d8b:	c3                   	ret    
  104d8c:	0f 1f 40 00          	nopl   0x0(%eax)

00104d90 <vfs_create_path>:
    }

    return 1;
}

static int vfs_create_path(char* path) {
  104d90:	55                   	push   %ebp
  104d91:	89 e5                	mov    %esp,%ebp
  104d93:	83 ec 38             	sub    $0x38,%esp
  104d96:	8b 45 08             	mov    0x8(%ebp),%eax
  104d99:	8d 0d 17 86 10 00    	lea    0x108617,%ecx
  104d9f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  104da2:	a1 4c a4 10 00       	mov    0x10a44c,%eax
  104da7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  104daa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    int created = 0;
  104db1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    sub = strtok(path, "/");
  104db8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104dbb:	89 04 24             	mov    %eax,(%esp)
  104dbe:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104dc2:	e8 69 fd ff ff       	call   104b30 <strtok>
  104dc7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  104dca:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104dcd:	0f be 00             	movsbl (%eax),%eax
  104dd0:	3d 00 00 00 00       	cmp    $0x0,%eax
  104dd5:	0f 85 21 00 00 00    	jne    104dfc <vfs_create_path+0x6c>
  104ddb:	b8 00 00 00 00       	mov    $0x0,%eax
  104de0:	8d 0d 17 86 10 00    	lea    0x108617,%ecx
  104de6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104ded:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104df1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104df4:	e8 37 fd ff ff       	call   104b30 <strtok>
  104df9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  104dfc:	e9 00 00 00 00       	jmp    104e01 <vfs_create_path+0x71>
  104e01:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104e08:	0f 84 e8 00 00 00    	je     104ef6 <vfs_create_path+0x166>
    {
        child = vfs_find_node(parent, sub);
  104e0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e11:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104e14:	89 04 24             	mov    %eax,(%esp)
  104e17:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104e1b:	e8 90 0a 00 00       	call   1058b0 <vfs_find_node>
  104e20:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(child == 0) {
  104e23:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104e2a:	0f 85 9a 00 00 00    	jne    104eca <vfs_create_path+0x13a>
  104e30:	b8 10 01 00 00       	mov    $0x110,%eax
            child = malloc(sizeof(struct res_node));
  104e35:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  104e3c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104e3f:	e8 2c f3 ff ff       	call   104170 <malloc>
  104e44:	89 45 f0             	mov    %eax,-0x10(%ebp)

            strcpy(child->name, sub);
  104e47:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e4a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104e4d:	89 e2                	mov    %esp,%edx
  104e4f:	89 4a 04             	mov    %ecx,0x4(%edx)
  104e52:	89 02                	mov    %eax,(%edx)
  104e54:	e8 27 fc ff ff       	call   104a80 <strcpy>
            child->res_type = RES_SUBDIR;
  104e59:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104e5c:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  104e63:	00 00 00 
            child->res_ptr = 0;
  104e66:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104e69:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  104e70:	00 00 00 

            created++;
  104e73:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104e76:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104e7c:	89 4d ec             	mov    %ecx,-0x14(%ebp)

            if(vfs_insert_node(parent, child)) {
  104e7f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104e82:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104e85:	89 0c 24             	mov    %ecx,(%esp)
  104e88:	89 54 24 04          	mov    %edx,0x4(%esp)
  104e8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104e8f:	e8 ac 0a 00 00       	call   105940 <vfs_insert_node>
  104e94:	3d 00 00 00 00       	cmp    $0x0,%eax
  104e99:	0f 84 26 00 00 00    	je     104ec5 <vfs_create_path+0x135>
  104e9f:	b8 38 00 00 00       	mov    $0x38,%eax
                show_cod(malloc(sizeof(struct cpu_state)), "Tried to insert VFS node in non RES_SUBDIR parent");
  104ea4:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  104eab:	89 45 dc             	mov    %eax,-0x24(%ebp)
  104eae:	e8 bd f2 ff ff       	call   104170 <malloc>
  104eb3:	8d 0d 19 86 10 00    	lea    0x108619,%ecx
  104eb9:	89 04 24             	mov    %eax,(%esp)
  104ebc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104ec0:	e8 bb b4 ff ff       	call   100380 <show_cod>
            }
        }
  104ec5:	e9 00 00 00 00       	jmp    104eca <vfs_create_path+0x13a>
  104eca:	b8 00 00 00 00       	mov    $0x0,%eax
  104ecf:	8d 0d 17 86 10 00    	lea    0x108617,%ecx

        parent = child;
  104ed5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104ed8:	89 55 f4             	mov    %edx,-0xc(%ebp)

        sub = strtok(0, "/");
  104edb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104ee2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104ee6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104ee9:	e8 42 fc ff ff       	call   104b30 <strtok>
  104eee:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  104ef1:	e9 0b ff ff ff       	jmp    104e01 <vfs_create_path+0x71>

    return created;
  104ef6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104ef9:	83 c4 38             	add    $0x38,%esp
  104efc:	5d                   	pop    %ebp
  104efd:	c3                   	ret    
  104efe:	66 90                	xchg   %ax,%ax

00104f00 <vfs_create_kfile>:

uint32_t vfs_create_dir(char* path) {
    return vfs_create_path(path);
}

uint32_t vfs_create_kfile(char* path, struct kfs_driver* driver, uint32_t* params) {
  104f00:	55                   	push   %ebp
  104f01:	89 e5                	mov    %esp,%ebp
  104f03:	83 ec 28             	sub    $0x28,%esp
  104f06:	8b 45 10             	mov    0x10(%ebp),%eax
  104f09:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104f0c:	8b 55 08             	mov    0x8(%ebp),%edx
  104f0f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104f12:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104f15:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* pathc = malloc(strlen(path) + 1);
  104f18:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104f1b:	89 e1                	mov    %esp,%ecx
  104f1d:	89 01                	mov    %eax,(%ecx)
  104f1f:	e8 ec fa ff ff       	call   104a10 <strlen>
  104f24:	05 01 00 00 00       	add    $0x1,%eax
  104f29:	89 04 24             	mov    %eax,(%esp)
  104f2c:	e8 3f f2 ff ff       	call   104170 <malloc>
  104f31:	89 45 f0             	mov    %eax,-0x10(%ebp)
    strcpy(pathc, path);
  104f34:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104f37:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104f3a:	89 e2                	mov    %esp,%edx
  104f3c:	89 4a 04             	mov    %ecx,0x4(%edx)
  104f3f:	89 02                	mov    %eax,(%edx)
  104f41:	e8 3a fb ff ff       	call   104a80 <strcpy>

    uint32_t ret = vfs_create_path(pathc);
  104f46:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104f49:	89 0c 24             	mov    %ecx,(%esp)
  104f4c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104f4f:	e8 3c fe ff ff       	call   104d90 <vfs_create_path>
  104f54:	89 45 ec             	mov    %eax,-0x14(%ebp)

    static struct res_node* node;
    node = vfs_get_node(path);
  104f57:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104f5a:	89 04 24             	mov    %eax,(%esp)
  104f5d:	e8 4e 00 00 00       	call   104fb0 <vfs_get_node>
  104f62:	a3 58 a4 10 00       	mov    %eax,0x10a458

    node->res_type = RES_KERNDRV;
  104f67:	a1 58 a4 10 00       	mov    0x10a458,%eax
  104f6c:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  104f73:	00 00 00 
    node->res_ptr = driver->create(params);
  104f76:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f79:	8b 40 14             	mov    0x14(%eax),%eax
  104f7c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104f7f:	89 0c 24             	mov    %ecx,(%esp)
  104f82:	ff d0                	call   *%eax
  104f84:	8b 0d 58 a4 10 00    	mov    0x10a458,%ecx
  104f8a:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)
    ((struct res_kfile*) node->res_ptr)->driver = driver;
  104f90:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f93:	8b 0d 58 a4 10 00    	mov    0x10a458,%ecx
  104f99:	8b 89 04 01 00 00    	mov    0x104(%ecx),%ecx
  104f9f:	89 41 04             	mov    %eax,0x4(%ecx)

    return ret;
  104fa2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104fa5:	83 c4 28             	add    $0x28,%esp
  104fa8:	5d                   	pop    %ebp
  104fa9:	c3                   	ret    
  104faa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104fb0 <vfs_get_node>:
    }

    return created;
}

static struct res_node* vfs_get_node(char* path) {
  104fb0:	55                   	push   %ebp
  104fb1:	89 e5                	mov    %esp,%ebp
  104fb3:	83 ec 28             	sub    $0x28,%esp
  104fb6:	8b 45 08             	mov    0x8(%ebp),%eax
  104fb9:	8d 0d 17 86 10 00    	lea    0x108617,%ecx
  104fbf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  104fc2:	a1 4c a4 10 00       	mov    0x10a44c,%eax
  104fc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  104fca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    sub = strtok(path, "/");
  104fd1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104fd4:	89 04 24             	mov    %eax,(%esp)
  104fd7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104fdb:	e8 50 fb ff ff       	call   104b30 <strtok>
  104fe0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  104fe3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104fe6:	0f be 00             	movsbl (%eax),%eax
  104fe9:	3d 00 00 00 00       	cmp    $0x0,%eax
  104fee:	0f 85 21 00 00 00    	jne    105015 <vfs_get_node+0x65>
  104ff4:	b8 00 00 00 00       	mov    $0x0,%eax
  104ff9:	8d 0d 17 86 10 00    	lea    0x108617,%ecx
  104fff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105006:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10500a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10500d:	e8 1e fb ff ff       	call   104b30 <strtok>
  105012:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  105015:	e9 00 00 00 00       	jmp    10501a <vfs_get_node+0x6a>
  10501a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105021:	0f 84 41 00 00 00    	je     105068 <vfs_get_node+0xb8>
    {
        child = vfs_find_node(parent, sub);
  105027:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10502a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10502d:	89 04 24             	mov    %eax,(%esp)
  105030:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105034:	e8 77 08 00 00       	call   1058b0 <vfs_find_node>
  105039:	b9 00 00 00 00       	mov    $0x0,%ecx
  10503e:	8d 15 17 86 10 00    	lea    0x108617,%edx
  105044:	89 45 f0             	mov    %eax,-0x10(%ebp)
        parent = child;
  105047:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10504a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        sub = strtok(0, "/");
  10504d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105054:	89 54 24 04          	mov    %edx,0x4(%esp)
  105058:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10505b:	e8 d0 fa ff ff       	call   104b30 <strtok>
  105060:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  105063:	e9 b2 ff ff ff       	jmp    10501a <vfs_get_node+0x6a>

    return child;
  105068:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10506b:	83 c4 28             	add    $0x28,%esp
  10506e:	5d                   	pop    %ebp
  10506f:	c3                   	ret    

00105070 <vfs_open>:
    ((struct res_kfile*) node->res_ptr)->driver = driver;

    return ret;
}

struct res_handle* vfs_open(char* path, uint32_t filemode) {
  105070:	55                   	push   %ebp
  105071:	89 e5                	mov    %esp,%ebp
  105073:	83 ec 28             	sub    $0x28,%esp
  105076:	8b 45 0c             	mov    0xc(%ebp),%eax
  105079:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10507c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10507f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    static struct res_node* node;

    node = vfs_get_node(path);
  105082:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105085:	89 04 24             	mov    %eax,(%esp)
  105088:	e8 23 ff ff ff       	call   104fb0 <vfs_get_node>
  10508d:	a3 5c a4 10 00       	mov    %eax,0x10a45c

    if(node->res_type == RES_KERNDRV) {
  105092:	a1 5c a4 10 00       	mov    0x10a45c,%eax
  105097:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  10509e:	00 00 00 
  1050a1:	0f 85 34 00 00 00    	jne    1050db <vfs_open+0x6b>
        struct res_kfile* kf = (struct res_kfile*)node->res_ptr;
  1050a7:	a1 5c a4 10 00       	mov    0x10a45c,%eax
  1050ac:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1050b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct res_handle* handle = kf->driver->open(kf, filemode);
  1050b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1050b8:	8b 40 04             	mov    0x4(%eax),%eax
  1050bb:	8b 40 08             	mov    0x8(%eax),%eax
  1050be:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1050c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1050c4:	89 0c 24             	mov    %ecx,(%esp)
  1050c7:	89 54 24 04          	mov    %edx,0x4(%esp)
  1050cb:	ff d0                	call   *%eax
  1050cd:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return handle;
  1050d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1050d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1050d6:	e9 07 00 00 00       	jmp    1050e2 <vfs_open+0x72>
    }

    return 0;
  1050db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1050e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1050e5:	83 c4 28             	add    $0x28,%esp
  1050e8:	5d                   	pop    %ebp
  1050e9:	c3                   	ret    
  1050ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001050f0 <vfs_close>:

uint32_t vfs_close(struct res_handle* handle) {
  1050f0:	55                   	push   %ebp
  1050f1:	89 e5                	mov    %esp,%ebp
  1050f3:	83 ec 18             	sub    $0x18,%esp
  1050f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1050f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle->res_type == RES_KERNDRV) {
  1050fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1050ff:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105105:	0f 85 22 00 00 00    	jne    10512d <vfs_close+0x3d>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  10510b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10510e:	8b 40 04             	mov    0x4(%eax),%eax
  105111:	89 45 f4             	mov    %eax,-0xc(%ebp)

       return kf->driver->close(handle);
  105114:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105117:	8b 40 04             	mov    0x4(%eax),%eax
  10511a:	8b 40 0c             	mov    0xc(%eax),%eax
  10511d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105120:	89 0c 24             	mov    %ecx,(%esp)
  105123:	ff d0                	call   *%eax
  105125:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105128:	e9 07 00 00 00       	jmp    105134 <vfs_close+0x44>
    }

    return 0;
  10512d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105134:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105137:	83 c4 18             	add    $0x18,%esp
  10513a:	5d                   	pop    %ebp
  10513b:	c3                   	ret    
  10513c:	0f 1f 40 00          	nopl   0x0(%eax)

00105140 <vfs_read>:

uint32_t vfs_read(struct res_handle* handle, void* dest, uint32_t size, uint32_t count) {
  105140:	55                   	push   %ebp
  105141:	89 e5                	mov    %esp,%ebp
  105143:	56                   	push   %esi
  105144:	83 ec 34             	sub    $0x34,%esp
  105147:	8b 45 14             	mov    0x14(%ebp),%eax
  10514a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10514d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105150:	8b 75 08             	mov    0x8(%ebp),%esi
  105153:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105156:	89 55 f0             	mov    %edx,-0x10(%ebp)
  105159:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10515c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10515f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105166:	0f 85 0c 00 00 00    	jne    105178 <vfs_read+0x38>
  10516c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  105173:	e9 94 00 00 00       	jmp    10520c <vfs_read+0xcc>

    if(handle->res_type == RES_KERNDRV) {
  105178:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10517b:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105181:	0f 85 7e 00 00 00    	jne    105205 <vfs_read+0xc5>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  105187:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10518a:	8b 40 04             	mov    0x4(%eax),%eax
  10518d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rread(handle, dest, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  105190:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105193:	8b 40 04             	mov    0x4(%eax),%eax
  105196:	8b 00                	mov    (%eax),%eax
  105198:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10519b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10519e:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1051a1:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  1051a5:	89 0c 24             	mov    %ecx,(%esp)
  1051a8:	89 54 24 04          	mov    %edx,0x4(%esp)
  1051ac:	89 74 24 08          	mov    %esi,0x8(%esp)
  1051b0:	ff d0                	call   *%eax
  1051b2:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  1051b5:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1051bc:	0f 85 1e 00 00 00    	jne    1051e0 <vfs_read+0xa0>
           handle->position += size * count;
  1051c2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1051c5:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1051c9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1051cc:	8b 51 08             	mov    0x8(%ecx),%edx
  1051cf:	01 c2                	add    %eax,%edx
  1051d1:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1051d4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1051db:	e9 2c 00 00 00       	jmp    10520c <vfs_read+0xcc>
       }

       if(res == RW_BLOCK) {
  1051e0:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  1051e7:	0f 85 0c 00 00 00    	jne    1051f9 <vfs_read+0xb9>
           return RW_BLOCK;
  1051ed:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1051f4:	e9 13 00 00 00       	jmp    10520c <vfs_read+0xcc>
       }

       return RW_ERR_DRIVER;
  1051f9:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  105200:	e9 07 00 00 00       	jmp    10520c <vfs_read+0xcc>
    }

    return RW_ERR_VFS;
  105205:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  10520c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10520f:	83 c4 34             	add    $0x34,%esp
  105212:	5e                   	pop    %esi
  105213:	5d                   	pop    %ebp
  105214:	c3                   	ret    
  105215:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10521c:	00 00 00 00 

00105220 <vfs_write>:

uint32_t vfs_write(struct res_handle* handle, void* src,  uint32_t size, uint32_t count) {
  105220:	55                   	push   %ebp
  105221:	89 e5                	mov    %esp,%ebp
  105223:	56                   	push   %esi
  105224:	83 ec 34             	sub    $0x34,%esp
  105227:	8b 45 14             	mov    0x14(%ebp),%eax
  10522a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10522d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105230:	8b 75 08             	mov    0x8(%ebp),%esi
  105233:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105236:	89 55 f0             	mov    %edx,-0x10(%ebp)
  105239:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10523c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10523f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105246:	0f 85 0c 00 00 00    	jne    105258 <vfs_write+0x38>
  10524c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  105253:	e9 95 00 00 00       	jmp    1052ed <vfs_write+0xcd>

    if(handle->res_type == RES_KERNDRV) {
  105258:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10525b:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105261:	0f 85 7f 00 00 00    	jne    1052e6 <vfs_write+0xc6>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  105267:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10526a:	8b 40 04             	mov    0x4(%eax),%eax
  10526d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rwrite(handle, src, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  105270:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105273:	8b 40 04             	mov    0x4(%eax),%eax
  105276:	8b 40 04             	mov    0x4(%eax),%eax
  105279:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10527c:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10527f:	8b 75 ec             	mov    -0x14(%ebp),%esi
  105282:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  105286:	89 0c 24             	mov    %ecx,(%esp)
  105289:	89 54 24 04          	mov    %edx,0x4(%esp)
  10528d:	89 74 24 08          	mov    %esi,0x8(%esp)
  105291:	ff d0                	call   *%eax
  105293:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  105296:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10529d:	0f 85 1e 00 00 00    	jne    1052c1 <vfs_write+0xa1>
           handle->position += size * count;
  1052a3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1052a6:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1052aa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1052ad:	8b 51 08             	mov    0x8(%ecx),%edx
  1052b0:	01 c2                	add    %eax,%edx
  1052b2:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1052b5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1052bc:	e9 2c 00 00 00       	jmp    1052ed <vfs_write+0xcd>
       }

       if(res == RW_BLOCK) {
  1052c1:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  1052c8:	0f 85 0c 00 00 00    	jne    1052da <vfs_write+0xba>
           return RW_BLOCK;
  1052ce:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1052d5:	e9 13 00 00 00       	jmp    1052ed <vfs_write+0xcd>
       }

       return RW_ERR_DRIVER;
  1052da:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  1052e1:	e9 07 00 00 00       	jmp    1052ed <vfs_write+0xcd>
    }

    return RW_ERR_VFS;
  1052e6:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  1052ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1052f0:	83 c4 34             	add    $0x34,%esp
  1052f3:	5e                   	pop    %esi
  1052f4:	5d                   	pop    %ebp
  1052f5:	c3                   	ret    
  1052f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1052fd:	00 00 00 

00105300 <vfs_available>:

uint32_t vfs_available(struct res_handle* handle) {
  105300:	55                   	push   %ebp
  105301:	89 e5                	mov    %esp,%ebp
  105303:	83 ec 18             	sub    $0x18,%esp
  105306:	8b 45 08             	mov    0x8(%ebp),%eax
  105309:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle == 0) return 0;
  10530c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105313:	0f 85 0c 00 00 00    	jne    105325 <vfs_available+0x25>
  105319:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105320:	e9 38 00 00 00       	jmp    10535d <vfs_available+0x5d>

    if(handle->res_type == RES_KERNDRV) {
  105325:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105328:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  10532e:	0f 85 22 00 00 00    	jne    105356 <vfs_available+0x56>
        struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  105334:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105337:	8b 40 04             	mov    0x4(%eax),%eax
  10533a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        return kf->driver->available(handle);
  10533d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105340:	8b 40 04             	mov    0x4(%eax),%eax
  105343:	8b 40 10             	mov    0x10(%eax),%eax
  105346:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105349:	89 0c 24             	mov    %ecx,(%esp)
  10534c:	ff d0                	call   *%eax
  10534e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105351:	e9 07 00 00 00       	jmp    10535d <vfs_available+0x5d>
    }

    return 0;
  105356:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  10535d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105360:	83 c4 18             	add    $0x18,%esp
  105363:	5d                   	pop    %ebp
  105364:	c3                   	ret    
  105365:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10536c:	00 00 00 00 

00105370 <vfs_exists>:

uint32_t vfs_exists(char* path) {
  105370:	55                   	push   %ebp
  105371:	89 e5                	mov    %esp,%ebp
  105373:	83 ec 18             	sub    $0x18,%esp
  105376:	8b 45 08             	mov    0x8(%ebp),%eax
  105379:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(vfs_get_node(path) != 0) return 1;
  10537c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10537f:	89 04 24             	mov    %eax,(%esp)
  105382:	e8 29 fc ff ff       	call   104fb0 <vfs_get_node>
  105387:	3d 00 00 00 00       	cmp    $0x0,%eax
  10538c:	0f 84 0c 00 00 00    	je     10539e <vfs_exists+0x2e>
  105392:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  105399:	e9 07 00 00 00       	jmp    1053a5 <vfs_exists+0x35>
    return 0;
  10539e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1053a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1053a8:	83 c4 18             	add    $0x18,%esp
  1053ab:	5d                   	pop    %ebp
  1053ac:	c3                   	ret    
  1053ad:	0f 1f 00             	nopl   (%eax)

001053b0 <vfs_seek>:

void vfs_seek(struct res_handle* handle, uint32_t offset, uint32_t origin) {
  1053b0:	55                   	push   %ebp
  1053b1:	89 e5                	mov    %esp,%ebp
  1053b3:	83 ec 0c             	sub    $0xc,%esp
  1053b6:	8b 45 10             	mov    0x10(%ebp),%eax
  1053b9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1053bc:	8b 55 08             	mov    0x8(%ebp),%edx
  1053bf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1053c2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1053c5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(origin == SEEK_SET) {
  1053c8:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1053cf:	0f 85 09 00 00 00    	jne    1053de <vfs_seek+0x2e>
        handle->position = offset;
  1053d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1053d8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1053db:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if(origin == SEEK_CUR) {
  1053de:	81 7d f4 01 00 00 00 	cmpl   $0x1,-0xc(%ebp)
  1053e5:	0f 85 0e 00 00 00    	jne    1053f9 <vfs_seek+0x49>
        handle->position += offset;
  1053eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1053ee:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1053f1:	8b 51 08             	mov    0x8(%ecx),%edx
  1053f4:	01 c2                	add    %eax,%edx
  1053f6:	89 51 08             	mov    %edx,0x8(%ecx)
    }
}
  1053f9:	83 c4 0c             	add    $0xc,%esp
  1053fc:	5d                   	pop    %ebp
  1053fd:	c3                   	ret    
  1053fe:	66 90                	xchg   %ax,%ax

00105400 <vfs_exec>:

void vfs_exec(char* ip, char* args[], struct task* task) {
  105400:	55                   	push   %ebp
  105401:	89 e5                	mov    %esp,%ebp
  105403:	56                   	push   %esi
  105404:	81 ec 94 00 00 00    	sub    $0x94,%esp
  10540a:	8b 45 10             	mov    0x10(%ebp),%eax
  10540d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105410:	8b 55 08             	mov    0x8(%ebp),%edx
  105413:	89 55 f8             	mov    %edx,-0x8(%ebp)
  105416:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  105419:	89 45 f0             	mov    %eax,-0x10(%ebp)
    char* path = strclone(ip);
  10541c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10541f:	89 04 24             	mov    %eax,(%esp)
  105422:	e8 b9 f6 ff ff       	call   104ae0 <strclone>
  105427:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(vfs_exists(path)) {
  10542a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10542d:	89 04 24             	mov    %eax,(%esp)
  105430:	e8 3b ff ff ff       	call   105370 <vfs_exists>
  105435:	3d 00 00 00 00       	cmp    $0x0,%eax
  10543a:	0f 84 eb 02 00 00    	je     10572b <vfs_exec+0x32b>
        uint32_t elf_mod_pdir;

        if(task == 0) {
  105440:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105447:	0f 85 35 00 00 00    	jne    105482 <vfs_exec+0x82>
            elf_mod_pdir = vmm_create_pagedir();
  10544d:	e8 de 0a 00 00       	call   105f30 <vmm_create_pagedir>
  105452:	b9 01 00 00 00       	mov    $0x1,%ecx
  105457:	89 45 e8             	mov    %eax,-0x18(%ebp)
            task = init_task(elf_mod_pdir, (void*)1);
  10545a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10545d:	89 04 24             	mov    %eax,(%esp)
  105460:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105464:	e8 37 ea ff ff       	call   103ea0 <init_task>
  105469:	8d 0d 3e 85 10 00    	lea    0x10853e,%ecx
  10546f:	89 45 f0             	mov    %eax,-0x10(%ebp)
            kprintf("[exec] Initialized new task...\n");
  105472:	89 0c 24             	mov    %ecx,(%esp)
  105475:	e8 f6 b0 ff ff       	call   100570 <kprintf>
        }
  10547a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  10547d:	e9 1a 00 00 00       	jmp    10549c <vfs_exec+0x9c>
  105482:	8d 05 5e 85 10 00    	lea    0x10855e,%eax
        else
        {
            elf_mod_pdir = task->phys_pdir;
  105488:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10548b:	8b 49 14             	mov    0x14(%ecx),%ecx
  10548e:	89 4d e8             	mov    %ecx,-0x18(%ebp)
            kprintf("[exec] Replacing old task...\n");
  105491:	89 04 24             	mov    %eax,(%esp)
  105494:	e8 d7 b0 ff ff       	call   100570 <kprintf>
  105499:	89 45 b0             	mov    %eax,-0x50(%ebp)
  10549c:	b8 05 00 00 00       	mov    $0x5,%eax
        }

        struct res_handle* handle = vfs_open(path, FM_EXEC | FM_READ);
  1054a1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1054a4:	89 0c 24             	mov    %ecx,(%esp)
  1054a7:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  1054ae:	00 
  1054af:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1054b2:	e8 b9 fb ff ff       	call   105070 <vfs_open>
  1054b7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        if(handle) {
  1054ba:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  1054c1:	0f 84 47 02 00 00    	je     10570e <vfs_exec+0x30e>
            uint32_t size = vfs_available(handle);
  1054c7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1054ca:	89 04 24             	mov    %eax,(%esp)
  1054cd:	e8 2e fe ff ff       	call   105300 <vfs_available>
  1054d2:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(size == 0) {
  1054d5:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1054dc:	0f 85 1d 00 00 00    	jne    1054ff <vfs_exec+0xff>
  1054e2:	8d 05 7c 85 10 00    	lea    0x10857c,%eax
                kprintf("[exec] %s is empty\n", path);
  1054e8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1054eb:	89 04 24             	mov    %eax,(%esp)
  1054ee:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1054f2:	e8 79 b0 ff ff       	call   100570 <kprintf>
                return;
  1054f7:	89 45 a8             	mov    %eax,-0x58(%ebp)
  1054fa:	e9 2c 02 00 00       	jmp    10572b <vfs_exec+0x32b>
            }

            void* modsrc = malloc(size);
  1054ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105502:	89 04 24             	mov    %eax,(%esp)
  105505:	e8 66 ec ff ff       	call   104170 <malloc>
  10550a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10550f:	89 45 dc             	mov    %eax,-0x24(%ebp)

            uint32_t res = vfs_read(handle, modsrc, size, 1);
  105512:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105515:	8b 55 dc             	mov    -0x24(%ebp),%edx
  105518:	8b 75 e0             	mov    -0x20(%ebp),%esi
  10551b:	89 04 24             	mov    %eax,(%esp)
  10551e:	89 54 24 04          	mov    %edx,0x4(%esp)
  105522:	89 74 24 08          	mov    %esi,0x8(%esp)
  105526:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10552d:	00 
  10552e:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  105531:	e8 0a fc ff ff       	call   105140 <vfs_read>
  105536:	89 45 d8             	mov    %eax,-0x28(%ebp)

            if(res != RW_OK) {
  105539:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  105540:	0f 84 21 00 00 00    	je     105567 <vfs_exec+0x167>
  105546:	8d 05 90 85 10 00    	lea    0x108590,%eax
                kprintf("[exec] Error while reading %s\n");
  10554c:	89 04 24             	mov    %eax,(%esp)
  10554f:	e8 1c b0 ff ff       	call   100570 <kprintf>
                free(modsrc);
  105554:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  105557:	89 0c 24             	mov    %ecx,(%esp)
  10555a:	89 45 a0             	mov    %eax,-0x60(%ebp)
  10555d:	e8 de ef ff ff       	call   104540 <free>
                return;
  105562:	e9 c4 01 00 00       	jmp    10572b <vfs_exec+0x32b>
            }

            uint32_t old_pdir = vmm_get_current_pagedir();
  105567:	e8 64 04 00 00       	call   1059d0 <vmm_get_current_pagedir>
  10556c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

            //**********************************************************************************************************
            if(task != get_current_task())  vmm_activate_pagedir(elf_mod_pdir);
  10556f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105572:	89 45 9c             	mov    %eax,-0x64(%ebp)
  105575:	e8 46 e5 ff ff       	call   103ac0 <get_current_task>
  10557a:	8b 4d 9c             	mov    -0x64(%ebp),%ecx
  10557d:	39 c1                	cmp    %eax,%ecx
  10557f:	0f 84 0b 00 00 00    	je     105590 <vfs_exec+0x190>
  105585:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105588:	89 04 24             	mov    %eax,(%esp)
  10558b:	e8 80 0f 00 00       	call   106510 <vmm_activate_pagedir>

            struct elf_header* header = modsrc;
  105590:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105593:	89 45 d0             	mov    %eax,-0x30(%ebp)
            struct elf_program_header* ph;

            /* Ist es ueberhaupt eine ELF-Datei? */
            if (header->magic != ELF_MAGIC) {
  105596:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105599:	81 38 7f 45 4c 46    	cmpl   $0x464c457f,(%eax)
  10559f:	0f 84 28 00 00 00    	je     1055cd <vfs_exec+0x1cd>
  1055a5:	8d 05 af 85 10 00    	lea    0x1085af,%eax
                kprintf("[exec] Invalid ELF-Magic in %s!\n", path);
  1055ab:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1055ae:	89 04 24             	mov    %eax,(%esp)
  1055b1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1055b5:	e8 b6 af ff ff       	call   100570 <kprintf>
                free(modsrc);
  1055ba:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1055bd:	89 0c 24             	mov    %ecx,(%esp)
  1055c0:	89 45 98             	mov    %eax,-0x68(%ebp)
  1055c3:	e8 78 ef ff ff       	call   104540 <free>
                return;
  1055c8:	e9 5e 01 00 00       	jmp    10572b <vfs_exec+0x32b>
            }

            void* elf_mod_entry = (void*) (header->entry);
  1055cd:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1055d0:	8b 40 18             	mov    0x18(%eax),%eax
  1055d3:	89 45 c8             	mov    %eax,-0x38(%ebp)

            ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);
  1055d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
  1055d9:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  1055dc:	03 41 1c             	add    0x1c(%ecx),%eax
  1055df:	89 45 cc             	mov    %eax,-0x34(%ebp)

            for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  1055e2:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  1055e9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  1055ec:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  1055ef:	0f b7 49 2c          	movzwl 0x2c(%ecx),%ecx
  1055f3:	39 c8                	cmp    %ecx,%eax
  1055f5:	0f 83 b5 00 00 00    	jae    1056b0 <vfs_exec+0x2b0>
                void* dest = (void*) ph->virt_addr;
  1055fb:	8b 45 cc             	mov    -0x34(%ebp),%eax
  1055fe:	8b 40 08             	mov    0x8(%eax),%eax
  105601:	89 45 c0             	mov    %eax,-0x40(%ebp)
                void* src = ((char*) header) + ph->offset;
  105604:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105607:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  10560a:	03 41 04             	add    0x4(%ecx),%eax
  10560d:	89 45 bc             	mov    %eax,-0x44(%ebp)

                /* Nur Program Header vom Typ LOAD laden */
                if (ph->type != 1) {
  105610:	8b 45 cc             	mov    -0x34(%ebp),%eax
  105613:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105619:	0f 84 05 00 00 00    	je     105624 <vfs_exec+0x224>
                    continue;
  10561f:	e9 71 00 00 00       	jmp    105695 <vfs_exec+0x295>
                }

                for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  105624:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  10562b:	8b 45 b8             	mov    -0x48(%ebp),%eax
  10562e:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  105631:	3b 41 14             	cmp    0x14(%ecx),%eax
  105634:	0f 83 3f 00 00 00    	jae    105679 <vfs_exec+0x279>
                    vmm_free(dest + offset);
  10563a:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10563d:	03 45 b8             	add    -0x48(%ebp),%eax
  105640:	89 04 24             	mov    %eax,(%esp)
  105643:	e8 58 0a 00 00       	call   1060a0 <vmm_free>
  105648:	b8 00 00 00 00       	mov    $0x0,%eax
                    vmm_alloc_addr(dest + offset, 0);
  10564d:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  105650:	03 4d b8             	add    -0x48(%ebp),%ecx
  105653:	89 0c 24             	mov    %ecx,(%esp)
  105656:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10565d:	00 
  10565e:	89 45 94             	mov    %eax,-0x6c(%ebp)
  105661:	e8 aa 0d 00 00       	call   106410 <vmm_alloc_addr>
  105666:	89 45 90             	mov    %eax,-0x70(%ebp)
                /* Nur Program Header vom Typ LOAD laden */
                if (ph->type != 1) {
                    continue;
                }

                for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  105669:	8b 45 b8             	mov    -0x48(%ebp),%eax
  10566c:	05 00 10 00 00       	add    $0x1000,%eax
  105671:	89 45 b8             	mov    %eax,-0x48(%ebp)
  105674:	e9 b2 ff ff ff       	jmp    10562b <vfs_exec+0x22b>
                    vmm_free(dest + offset);
                    vmm_alloc_addr(dest + offset, 0);
                }

                memcpy(dest, src, ph->file_size);
  105679:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10567c:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  10567f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  105682:	8b 52 10             	mov    0x10(%edx),%edx
  105685:	89 04 24             	mov    %eax,(%esp)
  105688:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10568c:	89 54 24 08          	mov    %edx,0x8(%esp)
  105690:	e8 ab f1 ff ff       	call   104840 <memcpy>

            void* elf_mod_entry = (void*) (header->entry);

            ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);

            for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  105695:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  105698:	05 01 00 00 00       	add    $0x1,%eax
  10569d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1056a0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  1056a3:	05 20 00 00 00       	add    $0x20,%eax
  1056a8:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1056ab:	e9 39 ff ff ff       	jmp    1055e9 <vfs_exec+0x1e9>
                }

                memcpy(dest, src, ph->file_size);
            }

            task->args = args;
  1056b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1056b3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1056b6:	89 41 18             	mov    %eax,0x18(%ecx)
            task->cpuState->eip = (uint32_t) elf_mod_entry;
  1056b9:	8b 45 c8             	mov    -0x38(%ebp),%eax
  1056bc:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1056bf:	8b 49 04             	mov    0x4(%ecx),%ecx
  1056c2:	89 41 24             	mov    %eax,0x24(%ecx)

            if(task != get_current_task()) vmm_activate_pagedir(old_pdir);
  1056c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1056c8:	89 45 8c             	mov    %eax,-0x74(%ebp)
  1056cb:	e8 f0 e3 ff ff       	call   103ac0 <get_current_task>
  1056d0:	8b 4d 8c             	mov    -0x74(%ebp),%ecx
  1056d3:	39 c1                	cmp    %eax,%ecx
  1056d5:	0f 84 0b 00 00 00    	je     1056e6 <vfs_exec+0x2e6>
  1056db:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1056de:	89 04 24             	mov    %eax,(%esp)
  1056e1:	e8 2a 0e 00 00       	call   106510 <vmm_activate_pagedir>
  1056e6:	8d 05 d0 85 10 00    	lea    0x1085d0,%eax

            kprintf("[exec] Executed %s\n", path);
  1056ec:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1056ef:	89 04 24             	mov    %eax,(%esp)
  1056f2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1056f6:	e8 75 ae ff ff       	call   100570 <kprintf>
            free(modsrc);
  1056fb:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1056fe:	89 0c 24             	mov    %ecx,(%esp)
  105701:	89 45 88             	mov    %eax,-0x78(%ebp)
  105704:	e8 37 ee ff ff       	call   104540 <free>
        }
  105709:	e9 18 00 00 00       	jmp    105726 <vfs_exec+0x326>
  10570e:	8d 05 e4 85 10 00    	lea    0x1085e4,%eax
        else
        {
            kprintf("[exec] %s doesn't exist\n", path);
  105714:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105717:	89 04 24             	mov    %eax,(%esp)
  10571a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10571e:	e8 4d ae ff ff       	call   100570 <kprintf>
  105723:	89 45 84             	mov    %eax,-0x7c(%ebp)
        }
    }
  105726:	e9 00 00 00 00       	jmp    10572b <vfs_exec+0x32b>
}
  10572b:	81 c4 94 00 00 00    	add    $0x94,%esp
  105731:	5e                   	pop    %esi
  105732:	5d                   	pop    %ebp
  105733:	c3                   	ret    
  105734:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10573b:	00 00 00 00 00 

00105740 <vfs_init_root>:

void vfs_init_root() {
  105740:	55                   	push   %ebp
  105741:	89 e5                	mov    %esp,%ebp
    if(root == 0) {
  105743:	83 ec 18             	sub    $0x18,%esp
  105746:	81 3d 4c a4 10 00 00 	cmpl   $0x0,0x10a44c
  10574d:	00 00 00 
  105750:	0f 85 6f 00 00 00    	jne    1057c5 <vfs_init_root+0x85>
  105756:	b8 10 01 00 00       	mov    $0x110,%eax
        root = malloc(sizeof(struct res_node));
  10575b:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  105762:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105765:	e8 06 ea ff ff       	call   104170 <malloc>
  10576a:	a3 4c a4 10 00       	mov    %eax,0x10a44c
        root->next = 0;
  10576f:	a1 4c a4 10 00       	mov    0x10a44c,%eax
  105774:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  10577b:	00 00 00 
        root->parent = 0;
  10577e:	a1 4c a4 10 00       	mov    0x10a44c,%eax
  105783:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  10578a:	00 00 00 
        strcpy(root->name, "$");
  10578d:	a1 4c a4 10 00       	mov    0x10a44c,%eax
  105792:	89 e1                	mov    %esp,%ecx
  105794:	89 01                	mov    %eax,(%ecx)
  105796:	c7 41 04 fd 85 10 00 	movl   $0x1085fd,0x4(%ecx)
  10579d:	e8 de f2 ff ff       	call   104a80 <strcpy>
        root->res_ptr = 0;
  1057a2:	8b 0d 4c a4 10 00    	mov    0x10a44c,%ecx
  1057a8:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  1057af:	00 00 00 
        root->res_type = RES_SUBDIR;
  1057b2:	8b 0d 4c a4 10 00    	mov    0x10a44c,%ecx
  1057b8:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  1057bf:	00 00 00 
  1057c2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  1057c5:	83 c4 18             	add    $0x18,%esp
  1057c8:	5d                   	pop    %ebp
  1057c9:	c3                   	ret    
  1057ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001057d0 <vfs_debug_ls>:

void vfs_debug_ls(char* path) {
  1057d0:	55                   	push   %ebp
  1057d1:	89 e5                	mov    %esp,%ebp
  1057d3:	56                   	push   %esi
  1057d4:	83 ec 24             	sub    $0x24,%esp
  1057d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1057da:	89 45 f8             	mov    %eax,-0x8(%ebp)
    static struct res_node* node;
    node = vfs_get_node(path);
  1057dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057e0:	89 04 24             	mov    %eax,(%esp)
  1057e3:	e8 c8 f7 ff ff       	call   104fb0 <vfs_get_node>
  1057e8:	a3 60 a4 10 00       	mov    %eax,0x10a460
    node = node->res_ptr;
  1057ed:	a1 60 a4 10 00       	mov    0x10a460,%eax
  1057f2:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1057f8:	a3 60 a4 10 00       	mov    %eax,0x10a460

    while(node != 0) {
  1057fd:	81 3d 60 a4 10 00 00 	cmpl   $0x0,0x10a460
  105804:	00 00 00 
  105807:	0f 84 90 00 00 00    	je     10589d <vfs_debug_ls+0xcd>
  10580d:	8d 05 ff 85 10 00    	lea    0x1085ff,%eax
        char* type = "N/A";
  105813:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(node->res_type == RES_SUBDIR) {
  105816:	a1 60 a4 10 00       	mov    0x10a460,%eax
  10581b:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  105822:	00 00 00 
  105825:	0f 85 09 00 00 00    	jne    105834 <vfs_debug_ls+0x64>
  10582b:	8d 05 03 86 10 00    	lea    0x108603,%eax
            type = "DIR";
  105831:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        if(node->res_type == RES_KERNDRV) {
  105834:	a1 60 a4 10 00       	mov    0x10a460,%eax
  105839:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  105840:	00 00 00 
  105843:	0f 85 14 00 00 00    	jne    10585d <vfs_debug_ls+0x8d>
            type = ((struct res_kfile*)node->res_ptr)->driver->drvname;
  105849:	a1 60 a4 10 00       	mov    0x10a460,%eax
  10584e:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105854:	8b 40 04             	mov    0x4(%eax),%eax
  105857:	8b 40 18             	mov    0x18(%eax),%eax
  10585a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10585d:	8d 05 07 86 10 00    	lea    0x108607,%eax
        }

        kprintf("LS %s: %s [%s]\n", path, node->name, type);
  105863:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105866:	8b 15 60 a4 10 00    	mov    0x10a460,%edx
  10586c:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10586f:	89 04 24             	mov    %eax,(%esp)
  105872:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105876:	89 54 24 08          	mov    %edx,0x8(%esp)
  10587a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10587e:	e8 ed ac ff ff       	call   100570 <kprintf>

        node = node->next;
  105883:	8b 0d 60 a4 10 00    	mov    0x10a460,%ecx
  105889:	8b 89 08 01 00 00    	mov    0x108(%ecx),%ecx
  10588f:	89 0d 60 a4 10 00    	mov    %ecx,0x10a460
    }
  105895:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105898:	e9 60 ff ff ff       	jmp    1057fd <vfs_debug_ls+0x2d>
}
  10589d:	83 c4 24             	add    $0x24,%esp
  1058a0:	5e                   	pop    %esi
  1058a1:	5d                   	pop    %ebp
  1058a2:	c3                   	ret    
  1058a3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1058aa:	84 00 00 00 00 00 

001058b0 <vfs_find_node>:

struct res_node* root = 0;
struct res_node* current = 0;
struct res_node* temp = 0;

static struct res_node* vfs_find_node(struct res_node* parent, char* name) {
  1058b0:	55                   	push   %ebp
  1058b1:	89 e5                	mov    %esp,%ebp
  1058b3:	83 ec 18             	sub    $0x18,%esp
  1058b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1058b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1058bc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1058bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_type == RES_SUBDIR) {
  1058c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1058c5:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  1058cc:	00 00 00 
  1058cf:	0f 85 57 00 00 00    	jne    10592c <vfs_find_node+0x7c>
        struct res_node* ptr = parent->res_ptr;
  1058d5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1058d8:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1058de:	89 45 f0             	mov    %eax,-0x10(%ebp)

        while(ptr != 0) {
  1058e1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1058e8:	0f 84 39 00 00 00    	je     105927 <vfs_find_node+0x77>
            if(strcmp(name, ptr->name) == 0) {
  1058ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1058f1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1058f4:	89 e2                	mov    %esp,%edx
  1058f6:	89 4a 04             	mov    %ecx,0x4(%edx)
  1058f9:	89 02                	mov    %eax,(%edx)
  1058fb:	e8 90 f0 ff ff       	call   104990 <strcmp>
  105900:	3d 00 00 00 00       	cmp    $0x0,%eax
  105905:	0f 85 0b 00 00 00    	jne    105916 <vfs_find_node+0x66>
                return ptr;
  10590b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10590e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105911:	e9 1d 00 00 00       	jmp    105933 <vfs_find_node+0x83>
            }

            ptr = ptr->next;
  105916:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105919:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  10591f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
  105922:	e9 ba ff ff ff       	jmp    1058e1 <vfs_find_node+0x31>
    }
  105927:	e9 00 00 00 00       	jmp    10592c <vfs_find_node+0x7c>

    return 0;
  10592c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105933:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105936:	83 c4 18             	add    $0x18,%esp
  105939:	5d                   	pop    %ebp
  10593a:	c3                   	ret    
  10593b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105940 <vfs_insert_node>:

static int vfs_insert_node(struct res_node* parent, struct res_node* child) {
  105940:	55                   	push   %ebp
  105941:	89 e5                	mov    %esp,%ebp
  105943:	83 ec 0c             	sub    $0xc,%esp
  105946:	8b 45 0c             	mov    0xc(%ebp),%eax
  105949:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10594c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10594f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_ptr == 0) {
  105952:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105955:	81 b8 04 01 00 00 00 	cmpl   $0x0,0x104(%eax)
  10595c:	00 00 00 
  10595f:	0f 85 0d 00 00 00    	jne    105972 <vfs_insert_node+0x32>
        parent->res_type = RES_SUBDIR;
  105965:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105968:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  10596f:	00 00 00 
    }

    if(parent->res_type == RES_SUBDIR) {
  105972:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105975:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  10597c:	00 00 00 
  10597f:	0f 85 36 00 00 00    	jne    1059bb <vfs_insert_node+0x7b>
        child->next = parent->res_ptr;
  105985:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105988:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  10598e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105991:	89 81 08 01 00 00    	mov    %eax,0x108(%ecx)
        child->parent = parent;
  105997:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10599a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10599d:	89 81 0c 01 00 00    	mov    %eax,0x10c(%ecx)
        parent->res_ptr = child;
  1059a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1059a6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1059a9:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)

        return 0;
  1059af:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1059b6:	e9 07 00 00 00       	jmp    1059c2 <vfs_insert_node+0x82>
    }

    return 1;
  1059bb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
}
  1059c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1059c5:	83 c4 0c             	add    $0xc,%esp
  1059c8:	5d                   	pop    %ebp
  1059c9:	c3                   	ret    
  1059ca:	66 90                	xchg   %ax,%ax
  1059cc:	66 90                	xchg   %ax,%ax
  1059ce:	66 90                	xchg   %ax,%ax

001059d0 <vmm_get_current_pagedir>:
	}

	vmm_unmap(pagedir_ptr);
}

uint32_t vmm_get_current_pagedir(void) {
  1059d0:	55                   	push   %ebp
  1059d1:	89 e5                	mov    %esp,%ebp
	return active_pagedir;
  1059d3:	a1 64 a4 10 00       	mov    0x10a464,%eax
  1059d8:	5d                   	pop    %ebp
  1059d9:	c3                   	ret    
  1059da:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001059e0 <vmm_fork_current>:
}

uint32_t vmm_fork_current(void) {
  1059e0:	55                   	push   %ebp
  1059e1:	89 e5                	mov    %esp,%ebp
  1059e3:	56                   	push   %esi
  1059e4:	83 ec 34             	sub    $0x34,%esp
  1059e7:	8d 45 f8             	lea    -0x8(%ebp),%eax
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  1059ea:	89 04 24             	mov    %eax,(%esp)
  1059ed:	e8 ce 00 00 00       	call   105ac0 <vmm_create_vpdraw>
  1059f2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  1059f5:	c7 45 f0 00 10 40 20 	movl   $0x20401000,-0x10(%ebp)
  1059fc:	81 7d f0 00 f0 ff ff 	cmpl   $0xfffff000,-0x10(%ebp)
  105a03:	0f 83 98 00 00 00    	jae    105aa1 <vmm_fork_current+0xc1>
		if (active_pagetables[i >> 12] & PT_PRESENT) {
  105a09:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105a0c:	c1 e8 0c             	shr    $0xc,%eax
  105a0f:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105a15:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105a18:	25 01 00 00 00       	and    $0x1,%eax
  105a1d:	3d 00 00 00 00       	cmp    $0x0,%eax
  105a22:	0f 84 64 00 00 00    	je     105a8c <vmm_fork_current+0xac>
  105a28:	8d 45 f4             	lea    -0xc(%ebp),%eax
			void* newp = vmm_alloc_user(&paddr);
  105a2b:	89 04 24             	mov    %eax,(%esp)
  105a2e:	e8 4d 03 00 00       	call   105d80 <vmm_alloc_user>
  105a33:	b9 00 00 00 00       	mov    $0x0,%ecx
  105a38:	ba 00 10 00 00       	mov    $0x1000,%edx
  105a3d:	89 45 e8             	mov    %eax,-0x18(%ebp)

			memcpy(newp, (void*) i, 0x1000);
  105a40:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105a43:	8b 75 f0             	mov    -0x10(%ebp),%esi
  105a46:	89 04 24             	mov    %eax,(%esp)
  105a49:	89 74 24 04          	mov    %esi,0x4(%esp)
  105a4d:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  105a54:	00 
  105a55:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  105a58:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  105a5b:	e8 e0 ed ff ff       	call   104840 <memcpy>
			map_address_context(pdptr, i, paddr, 0);
  105a60:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105a63:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105a66:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105a69:	89 04 24             	mov    %eax,(%esp)
  105a6c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105a70:	89 54 24 08          	mov    %edx,0x8(%esp)
  105a74:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105a7b:	00 
  105a7c:	e8 4f 03 00 00       	call   105dd0 <map_address_context>

			vmm_unmap(newp);
  105a81:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105a84:	89 04 24             	mov    %eax,(%esp)
  105a87:	e8 d4 03 00 00       	call   105e60 <vmm_unmap>
		}

	}
  105a8c:	e9 00 00 00 00       	jmp    105a91 <vmm_fork_current+0xb1>

uint32_t vmm_fork_current(void) {
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  105a91:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105a94:	05 00 10 00 00       	add    $0x1000,%eax
  105a99:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105a9c:	e9 5b ff ff ff       	jmp    1059fc <vmm_fork_current+0x1c>
			vmm_unmap(newp);
		}

	}

	vmm_free_pdptr(pdptr);
  105aa1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105aa4:	89 04 24             	mov    %eax,(%esp)
  105aa7:	e8 24 04 00 00       	call   105ed0 <vmm_free_pdptr>

	return phys_pagedir;
  105aac:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105aaf:	83 c4 34             	add    $0x34,%esp
  105ab2:	5e                   	pop    %esi
  105ab3:	5d                   	pop    %ebp
  105ab4:	c3                   	ret    
  105ab5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  105abc:	00 00 00 00 

00105ac0 <vmm_create_vpdraw>:
uint32_t* active_pagetables = (uint32_t*) (ACTIVE_PAGETBL_VADDR);
struct vmm_context* active_context = (void*) (ACTIVE_CONTEXT_VADDR);

uint32_t active_pagedir = 0;

static uint32_t* vmm_create_vpdraw(uint32_t* pagedir) {
  105ac0:	55                   	push   %ebp
  105ac1:	89 e5                	mov    %esp,%ebp
  105ac3:	53                   	push   %ebx
  105ac4:	57                   	push   %edi
  105ac5:	56                   	push   %esi
  105ac6:	83 ec 4c             	sub    $0x4c,%esp
  105ac9:	8b 45 08             	mov    0x8(%ebp),%eax
  105acc:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  105acf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t phys_context = 0;
  105ad2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct vmm_context* context = vmm_alloc(&phys_context);
  105ad9:	89 0c 24             	mov    %ecx,(%esp)
  105adc:	e8 6f 05 00 00       	call   106050 <vmm_alloc>
  105ae1:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  105ae4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32_t phys_pagedir = 0;
  105ae7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	context->pagedir = vmm_alloc(&phys_pagedir);
  105aee:	89 0c 24             	mov    %ecx,(%esp)
  105af1:	e8 5a 05 00 00       	call   106050 <vmm_alloc>
  105af6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  105af9:	89 01                	mov    %eax,(%ecx)
	if (pagedir != 0)
  105afb:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105b02:	0f 84 08 00 00 00    	je     105b10 <vmm_create_vpdraw+0x50>
		*pagedir = phys_pagedir;
  105b08:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105b0b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105b0e:	89 01                	mov    %eax,(%ecx)
  105b10:	b8 00 00 00 00       	mov    $0x0,%eax

	uint32_t* pagedir_ptr = vmm_alloc(0);
  105b15:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105b1c:	89 45 c8             	mov    %eax,-0x38(%ebp)
  105b1f:	e8 2c 05 00 00       	call   106050 <vmm_alloc>
  105b24:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  105b27:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  105b2e:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  105b35:	0f 83 25 01 00 00    	jae    105c60 <vmm_create_vpdraw+0x1a0>
  105b3b:	8d 45 dc             	lea    -0x24(%ebp),%eax
		pagedir_ptr[i] = (uint32_t) vmm_alloc(&paddr);
  105b3e:	89 04 24             	mov    %eax,(%esp)
  105b41:	e8 0a 05 00 00       	call   106050 <vmm_alloc>
  105b46:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105b49:	8b 55 e0             	mov    -0x20(%ebp),%edx
  105b4c:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i < PMEM_TABLES) {
  105b4f:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  105b56:	0f 83 4d 00 00 00    	jae    105ba9 <vmm_create_vpdraw+0xe9>
			vmm_free((void*) (pagedir_ptr[i]));
  105b5c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105b5f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105b62:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105b65:	89 04 24             	mov    %eax,(%esp)
  105b68:	e8 33 05 00 00       	call   1060a0 <vmm_free>
  105b6d:	b8 00 00 00 00       	mov    $0x0,%eax
			map_address_active(pagedir_ptr[i], kernel_pagetables[i], 0); //Can reuse pagedir_ptr[i] cause of vmm_free
  105b72:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105b75:	8b 55 e0             	mov    -0x20(%ebp),%edx
  105b78:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105b7b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  105b7e:	8b 14 95 98 a4 18 00 	mov    0x18a498(,%edx,4),%edx
  105b85:	89 0c 24             	mov    %ecx,(%esp)
  105b88:	89 54 24 04          	mov    %edx,0x4(%esp)
  105b8c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105b93:	00 
  105b94:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  105b97:	e8 84 05 00 00       	call   106120 <map_address_active>
			paddr = kernel_pagetables[i];
  105b9c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105b9f:	8b 04 85 98 a4 18 00 	mov    0x18a498(,%eax,4),%eax
  105ba6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;
  105ba9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105bac:	0d 01 00 00 00       	or     $0x1,%eax
  105bb1:	0d 02 00 00 00       	or     $0x2,%eax
  105bb6:	0d 04 00 00 00       	or     $0x4,%eax
  105bbb:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105bbe:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105bc1:	8b 12                	mov    (%edx),%edx
  105bc3:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
  105bc6:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  105bcd:	0f 82 78 00 00 00    	jb     105c4b <vmm_create_vpdraw+0x18b>
			for (i2 = 0; i2 < 1024; i2++) {
  105bd3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  105bda:	81 7d d4 00 04 00 00 	cmpl   $0x400,-0x2c(%ebp)
  105be1:	0f 83 5f 00 00 00    	jae    105c46 <vmm_create_vpdraw+0x186>
  105be7:	b8 04 00 00 00       	mov    $0x4,%eax
  105bec:	b9 00 00 00 00       	mov    $0x0,%ecx
  105bf1:	ba 00 02 00 00       	mov    $0x200,%edx
				uint32_t vaddr = (i << 22) + (i2 << 12);
  105bf6:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105bf9:	c1 e6 16             	shl    $0x16,%esi
  105bfc:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  105bff:	c1 e7 0c             	shl    $0xc,%edi
  105c02:	01 fe                	add    %edi,%esi
  105c04:	89 75 d0             	mov    %esi,-0x30(%ebp)

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
  105c07:	81 7d d0 00 00 00 01 	cmpl   $0x1000000,-0x30(%ebp)
  105c0e:	0f 97 c3             	seta   %bl
  105c11:	84 db                	test   %bl,%bl
  105c13:	0f 44 d1             	cmove  %ecx,%edx
  105c16:	81 7d d0 00 10 40 20 	cmpl   $0x20401000,-0x30(%ebp)
  105c1d:	0f 97 c3             	seta   %bl
  105c20:	84 db                	test   %bl,%bl
  105c22:	0f 44 c1             	cmove  %ecx,%eax
  105c25:	09 c2                	or     %eax,%edx
  105c27:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  105c2a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105c2d:	8b 75 e0             	mov    -0x20(%ebp),%esi
  105c30:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  105c33:	89 14 81             	mov    %edx,(%ecx,%eax,4)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
			for (i2 = 0; i2 < 1024; i2++) {
  105c36:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  105c39:	05 01 00 00 00       	add    $0x1,%eax
  105c3e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  105c41:	e9 94 ff ff ff       	jmp    105bda <vmm_create_vpdraw+0x11a>

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
						(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
  105c46:	e9 00 00 00 00       	jmp    105c4b <vmm_create_vpdraw+0x18b>
	}
  105c4b:	e9 00 00 00 00       	jmp    105c50 <vmm_create_vpdraw+0x190>
		*pagedir = phys_pagedir;

	uint32_t* pagedir_ptr = vmm_alloc(0);
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  105c50:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105c53:	05 01 00 00 00       	add    $0x1,%eax
  105c58:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105c5b:	e9 ce fe ff ff       	jmp    105b2e <vmm_create_vpdraw+0x6e>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  105c60:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  105c67:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  105c6e:	0f 83 58 00 00 00    	jae    105ccc <vmm_create_vpdraw+0x20c>
  105c74:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
  105c79:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105c7c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105c7f:	8b 12                	mov    (%edx),%edx
  105c81:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105c84:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  105c8a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		map_address_context(pagedir_ptr,
  105c8d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105c90:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105c96:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105c99:	c1 e6 0c             	shl    $0xc,%esi
  105c9c:	01 f2                	add    %esi,%edx
  105c9e:	8b 75 dc             	mov    -0x24(%ebp),%esi
  105ca1:	89 0c 24             	mov    %ecx,(%esp)
  105ca4:	89 54 24 04          	mov    %edx,0x4(%esp)
  105ca8:	89 74 24 08          	mov    %esi,0x8(%esp)
  105cac:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105cb3:	00 
  105cb4:	89 45 c0             	mov    %eax,-0x40(%ebp)
  105cb7:	e8 14 01 00 00       	call   105dd0 <map_address_context>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  105cbc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105cbf:	05 01 00 00 00       	add    $0x1,%eax
  105cc4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105cc7:	e9 9b ff ff ff       	jmp    105c67 <vmm_create_vpdraw+0x1a7>
  105ccc:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(pagedir_ptr,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
  105cd1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105cd4:	8b 15 e8 71 10 00    	mov    0x1071e8,%edx
  105cda:	8b 75 ec             	mov    -0x14(%ebp),%esi
  105cdd:	89 0c 24             	mov    %ecx,(%esp)
  105ce0:	89 54 24 04          	mov    %edx,0x4(%esp)
  105ce4:	89 74 24 08          	mov    %esi,0x8(%esp)
  105ce8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105cef:	00 
  105cf0:	89 45 bc             	mov    %eax,-0x44(%ebp)
  105cf3:	e8 d8 00 00 00       	call   105dd0 <map_address_context>
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105cf8:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
  105cff:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
  105d05:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  105d08:	0f 83 39 00 00 00    	jae    105d47 <vmm_create_vpdraw+0x287>
  105d0e:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(pagedir_ptr, i, i, 0);
  105d13:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105d16:	8b 55 d8             	mov    -0x28(%ebp),%edx
  105d19:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105d1c:	89 0c 24             	mov    %ecx,(%esp)
  105d1f:	89 54 24 04          	mov    %edx,0x4(%esp)
  105d23:	89 74 24 08          	mov    %esi,0x8(%esp)
  105d27:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105d2e:	00 
  105d2f:	89 45 b8             	mov    %eax,-0x48(%ebp)
  105d32:	e8 99 00 00 00       	call   105dd0 <map_address_context>
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105d37:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105d3a:	05 00 10 00 00       	add    $0x1000,%eax
  105d3f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105d42:	e9 b8 ff ff ff       	jmp    105cff <vmm_create_vpdraw+0x23f>
		map_address_context(pagedir_ptr, i, i, 0);
	}

	uint32_t* pd_ptr = context->pagedir;
  105d47:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105d4a:	8b 00                	mov    (%eax),%eax
  105d4c:	89 45 cc             	mov    %eax,-0x34(%ebp)
	context->pagedir = (uint32_t*) phys_pagedir;
  105d4f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105d52:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  105d55:	89 01                	mov    %eax,(%ecx)

	vmm_unmap(pd_ptr);
  105d57:	8b 45 cc             	mov    -0x34(%ebp),%eax
  105d5a:	89 04 24             	mov    %eax,(%esp)
  105d5d:	e8 fe 00 00 00       	call   105e60 <vmm_unmap>
	vmm_unmap(context);
  105d62:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105d65:	89 04 24             	mov    %eax,(%esp)
  105d68:	e8 f3 00 00 00       	call   105e60 <vmm_unmap>

	return pagedir_ptr;
  105d6d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105d70:	83 c4 4c             	add    $0x4c,%esp
  105d73:	5e                   	pop    %esi
  105d74:	5f                   	pop    %edi
  105d75:	5b                   	pop    %ebx
  105d76:	5d                   	pop    %ebp
  105d77:	c3                   	ret    
  105d78:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  105d7f:	00 

00105d80 <vmm_alloc_user>:

void* vmm_alloc_ucont(uint32_t cont) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
}

void* vmm_alloc_user(uint32_t* retpaddr) {
  105d80:	55                   	push   %ebp
  105d81:	89 e5                	mov    %esp,%ebp
  105d83:	56                   	push   %esi
  105d84:	83 ec 24             	sub    $0x24,%esp
  105d87:	8b 45 08             	mov    0x8(%ebp),%eax
  105d8a:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  105d8f:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  105d94:	be 01 00 00 00       	mov    $0x1,%esi
  105d99:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
  105d9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105d9f:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  105da6:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  105dad:	ff 
  105dae:	89 44 24 08          	mov    %eax,0x8(%esp)
  105db2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105db9:	00 
  105dba:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105dbd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105dc0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  105dc3:	e8 b8 04 00 00       	call   106280 <vmm_alloc_in_range>
  105dc8:	83 c4 24             	add    $0x24,%esp
  105dcb:	5e                   	pop    %esi
  105dcc:	5d                   	pop    %ebp
  105dcd:	c3                   	ret    
  105dce:	66 90                	xchg   %ax,%ax

00105dd0 <map_address_context>:
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}

void map_address_context(uint32_t* pagedir, uint32_t vaddr, uint32_t paddr,
		uint32_t flags) {
  105dd0:	55                   	push   %ebp
  105dd1:	89 e5                	mov    %esp,%ebp
  105dd3:	56                   	push   %esi
  105dd4:	83 ec 18             	sub    $0x18,%esp
  105dd7:	8b 45 14             	mov    0x14(%ebp),%eax
  105dda:	8b 4d 10             	mov    0x10(%ebp),%ecx
  105ddd:	8b 55 0c             	mov    0xc(%ebp),%edx
  105de0:	8b 75 08             	mov    0x8(%ebp),%esi
  105de3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  105de6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  105de9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105dec:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32_t pd_entry = vaddr >> 22;
  105def:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105df2:	c1 e8 16             	shr    $0x16,%eax
  105df5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pt_entry = (vaddr >> 12) % 1024;
  105df8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105dfb:	c1 e8 0c             	shr    $0xc,%eax
  105dfe:	25 ff 03 00 00       	and    $0x3ff,%eax
  105e03:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry] = (paddr
  105e06:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105e09:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105e0e:	0d 01 00 00 00       	or     $0x1,%eax
  105e13:	0d 02 00 00 00       	or     $0x2,%eax
  105e18:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105e1b:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  105e21:	09 c8                	or     %ecx,%eax
  105e23:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105e26:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105e29:	8b 75 f8             	mov    -0x8(%ebp),%esi
  105e2c:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105e2f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  105e35:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105e38:	81 e1 04 02 00 00    	and    $0x204,%ecx
  105e3e:	09 c8                	or     %ecx,%eax
  105e40:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  105e43:	8b 55 e8             	mov    -0x18(%ebp),%edx
  105e46:	8b 75 f8             	mov    -0x8(%ebp),%esi
  105e49:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105e4c:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  105e52:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}
  105e55:	83 c4 18             	add    $0x18,%esp
  105e58:	5e                   	pop    %esi
  105e59:	5d                   	pop    %ebp
  105e5a:	c3                   	ret    
  105e5b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105e60 <vmm_unmap>:
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

void vmm_unmap(void* p_vaddr) { //USE ONLY IF YOU KNOW WHAT YOU DO. POTENTIAL MEMORY LEAK!
  105e60:	55                   	push   %ebp
  105e61:	89 e5                	mov    %esp,%ebp
  105e63:	83 ec 08             	sub    $0x8,%esp
  105e66:	8b 45 08             	mov    0x8(%ebp),%eax
  105e69:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  105e6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105e6f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  105e72:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105e75:	c1 e8 0c             	shr    $0xc,%eax
  105e78:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105e7e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105e81:	25 01 02 00 00       	and    $0x201,%eax
  105e86:	3d 01 02 00 00       	cmp    $0x201,%eax
  105e8b:	0f 85 2e 00 00 00    	jne    105ebf <vmm_unmap+0x5f>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  105e91:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105e94:	c1 e8 0c             	shr    $0xc,%eax
  105e97:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105e9d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105ea0:	25 04 00 00 00       	and    $0x4,%eax
  105ea5:	0d 00 02 00 00       	or     $0x200,%eax
  105eaa:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105ead:	c1 e9 0c             	shr    $0xc,%ecx
  105eb0:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  105eb6:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  105eb9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ebc:	0f 01 38             	invlpg (%eax)
	}
}
  105ebf:	83 c4 08             	add    $0x8,%esp
  105ec2:	5d                   	pop    %ebp
  105ec3:	c3                   	ret    
  105ec4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105ecb:	00 00 00 00 00 

00105ed0 <vmm_free_pdptr>:
	vmm_unmap(context);

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
  105ed0:	55                   	push   %ebp
  105ed1:	89 e5                	mov    %esp,%ebp
  105ed3:	83 ec 18             	sub    $0x18,%esp
  105ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  105ed9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (uint32_t i = 0; i < 1024; i++) {
  105edc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  105ee3:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
  105eea:	0f 83 21 00 00 00    	jae    105f11 <vmm_free_pdptr+0x41>
		vmm_unmap((void*) pagedir_ptr[i]);
  105ef0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ef3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105ef6:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105ef9:	89 04 24             	mov    %eax,(%esp)
  105efc:	e8 5f ff ff ff       	call   105e60 <vmm_unmap>

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
	for (uint32_t i = 0; i < 1024; i++) {
  105f01:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f04:	05 01 00 00 00       	add    $0x1,%eax
  105f09:	89 45 f8             	mov    %eax,-0x8(%ebp)
  105f0c:	e9 d2 ff ff ff       	jmp    105ee3 <vmm_free_pdptr+0x13>
		vmm_unmap((void*) pagedir_ptr[i]);
	}

	vmm_unmap(pagedir_ptr);
  105f11:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105f14:	89 04 24             	mov    %eax,(%esp)
  105f17:	e8 44 ff ff ff       	call   105e60 <vmm_unmap>
}
  105f1c:	83 c4 18             	add    $0x18,%esp
  105f1f:	5d                   	pop    %ebp
  105f20:	c3                   	ret    
  105f21:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105f28:	0f 1f 84 00 00 00 00 
  105f2f:	00 

00105f30 <vmm_create_pagedir>:
	vmm_free_pdptr(pdptr);

	return phys_pagedir;
}

uint32_t vmm_create_pagedir() {
  105f30:	55                   	push   %ebp
  105f31:	89 e5                	mov    %esp,%ebp
  105f33:	83 ec 18             	sub    $0x18,%esp
  105f36:	8d 45 fc             	lea    -0x4(%ebp),%eax
	uint32_t phys_pagedir;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  105f39:	89 04 24             	mov    %eax,(%esp)
  105f3c:	e8 7f fb ff ff       	call   105ac0 <vmm_create_vpdraw>
  105f41:	89 45 f8             	mov    %eax,-0x8(%ebp)
	vmm_free_pdptr(pdptr);
  105f44:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f47:	89 04 24             	mov    %eax,(%esp)
  105f4a:	e8 81 ff ff ff       	call   105ed0 <vmm_free_pdptr>

	return phys_pagedir;
  105f4f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105f52:	83 c4 18             	add    $0x18,%esp
  105f55:	5d                   	pop    %ebp
  105f56:	c3                   	ret    
  105f57:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  105f5e:	00 00 

00105f60 <vmm_resolve>:
}

uint32_t vmm_resolve(void* vaddr) {
  105f60:	55                   	push   %ebp
  105f61:	89 e5                	mov    %esp,%ebp
  105f63:	50                   	push   %eax
  105f64:	8b 45 08             	mov    0x8(%ebp),%eax
  105f67:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return active_pagetables[(uint32_t) vaddr >> 12] & 0xFFFFF000;
  105f6a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105f6d:	c1 e8 0c             	shr    $0xc,%eax
  105f70:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  105f76:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105f79:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105f7e:	83 c4 04             	add    $0x4,%esp
  105f81:	5d                   	pop    %ebp
  105f82:	c3                   	ret    
  105f83:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105f8a:	84 00 00 00 00 00 

00105f90 <vmm_resolve_ppd>:
}

uint32_t vmm_resolve_ppd(uint32_t pdir, void* vaddr) {
  105f90:	55                   	push   %ebp
  105f91:	89 e5                	mov    %esp,%ebp
  105f93:	83 ec 38             	sub    $0x38,%esp
  105f96:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f99:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105f9c:	ba 00 00 00 00       	mov    $0x0,%edx
  105fa1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  105fa4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32_t pd_entry = (uint32_t) vaddr >> 22;
  105fa7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105faa:	c1 e8 16             	shr    $0x16,%eax
  105fad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t pt_entry = ((uint32_t) vaddr >> 12) % 1024;
  105fb0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105fb3:	c1 e8 0c             	shr    $0xc,%eax
  105fb6:	25 ff 03 00 00       	and    $0x3ff,%eax
  105fbb:	89 45 f0             	mov    %eax,-0x10(%ebp)

	uint32_t* vpd = vmm_alloc(0);
  105fbe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105fc5:	89 55 e0             	mov    %edx,-0x20(%ebp)
  105fc8:	e8 83 00 00 00       	call   106050 <vmm_alloc>
  105fcd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	vmm_free(vpd);
  105fd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105fd3:	89 04 24             	mov    %eax,(%esp)
  105fd6:	e8 c5 00 00 00       	call   1060a0 <vmm_free>
  105fdb:	b8 00 00 00 00       	mov    $0x0,%eax

	map_address_active((uint32_t) vpd, pdir, 0);
  105fe0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105fe3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  105fe6:	89 0c 24             	mov    %ecx,(%esp)
  105fe9:	89 54 24 04          	mov    %edx,0x4(%esp)
  105fed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105ff4:	00 
  105ff5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  105ff8:	e8 23 01 00 00       	call   106120 <map_address_active>
  105ffd:	b8 00 00 00 00       	mov    $0x0,%eax
	uint32_t table = vpd[pd_entry] & 0xFFFFF000;
  106002:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106005:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106008:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  10600b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  106011:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	map_address_active((uint32_t) vpd, table, 0);
  106014:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106017:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10601a:	89 0c 24             	mov    %ecx,(%esp)
  10601d:	89 54 24 04          	mov    %edx,0x4(%esp)
  106021:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106028:	00 
  106029:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10602c:	e8 ef 00 00 00       	call   106120 <map_address_active>
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;
  106031:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106034:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106037:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10603a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10603f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	return addr & 0xFFFFF000;
  106042:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106045:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10604a:	83 c4 38             	add    $0x38,%esp
  10604d:	5d                   	pop    %ebp
  10604e:	c3                   	ret    
  10604f:	90                   	nop

00106050 <vmm_alloc>:

void* vmm_alloc_cont(uint32_t cont) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
}

void* vmm_alloc(uint32_t* retpaddr) {
  106050:	55                   	push   %ebp
  106051:	89 e5                	mov    %esp,%ebp
  106053:	56                   	push   %esi
  106054:	83 ec 24             	sub    $0x24,%esp
  106057:	8b 45 08             	mov    0x8(%ebp),%eax
  10605a:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  10605f:	ba 00 00 00 20       	mov    $0x20000000,%edx
  106064:	be 01 00 00 00       	mov    $0x1,%esi
  106069:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
  10606c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10606f:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
  106076:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  10607d:	20 
  10607e:	89 44 24 08          	mov    %eax,0x8(%esp)
  106082:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  106089:	00 
  10608a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10608d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106090:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106093:	e8 e8 01 00 00       	call   106280 <vmm_alloc_in_range>
  106098:	83 c4 24             	add    $0x24,%esp
  10609b:	5e                   	pop    %esi
  10609c:	5d                   	pop    %ebp
  10609d:	c3                   	ret    
  10609e:	66 90                	xchg   %ax,%ax

001060a0 <vmm_free>:
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
}

void vmm_free(void* p_vaddr) {
  1060a0:	55                   	push   %ebp
  1060a1:	89 e5                	mov    %esp,%ebp
  1060a3:	83 ec 18             	sub    $0x18,%esp
  1060a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1060a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  1060ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1060af:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  1060b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1060b5:	c1 e8 0c             	shr    $0xc,%eax
  1060b8:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  1060be:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1060c1:	25 01 02 00 00       	and    $0x201,%eax
  1060c6:	3d 01 02 00 00       	cmp    $0x201,%eax
  1060cb:	0f 85 4a 00 00 00    	jne    10611b <vmm_free+0x7b>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		pmm_free((void*) (active_pagetables[vaddr >> 12] & 0xFFFFF000));
  1060d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1060d4:	c1 e8 0c             	shr    $0xc,%eax
  1060d7:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  1060dd:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1060e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1060e5:	89 04 24             	mov    %eax,(%esp)
  1060e8:	e8 53 c7 ff ff       	call   102840 <pmm_free>

		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  1060ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1060f0:	c1 e8 0c             	shr    $0xc,%eax
  1060f3:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  1060f9:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1060fc:	25 04 00 00 00       	and    $0x4,%eax
  106101:	0d 00 02 00 00       	or     $0x200,%eax
  106106:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106109:	c1 e9 0c             	shr    $0xc,%ecx
  10610c:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  106112:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  106115:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106118:	0f 01 38             	invlpg (%eax)
	}
}
  10611b:	83 c4 18             	add    $0x18,%esp
  10611e:	5d                   	pop    %ebp
  10611f:	c3                   	ret    

00106120 <map_address_active>:
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}

void map_address_active(uint32_t vaddr, uint32_t paddr, uint32_t flags) {
  106120:	55                   	push   %ebp
  106121:	89 e5                	mov    %esp,%ebp
  106123:	83 ec 0c             	sub    $0xc,%esp
  106126:	8b 45 10             	mov    0x10(%ebp),%eax
  106129:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10612c:	8b 55 08             	mov    0x8(%ebp),%edx
  10612f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  106132:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  106135:	89 45 f4             	mov    %eax,-0xc(%ebp)
	active_pagetables[vaddr >> 12] = (paddr & 0xFFFFF000) | PT_PRESENT
  106138:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10613b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  106140:	0d 01 00 00 00       	or     $0x1,%eax
  106145:	0d 02 00 00 00       	or     $0x2,%eax
  10614a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10614d:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  106153:	09 c8                	or     %ecx,%eax
  106155:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  106158:	c1 e9 0c             	shr    $0xc,%ecx
  10615b:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  106161:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106164:	81 e1 04 02 00 00    	and    $0x204,%ecx
  10616a:	09 c8                	or     %ecx,%eax
  10616c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10616f:	c1 e9 0c             	shr    $0xc,%ecx
  106172:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  106178:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  10617b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10617e:	0f 01 38             	invlpg (%eax)
}
  106181:	83 c4 0c             	add    $0xc,%esp
  106184:	5d                   	pop    %ebp
  106185:	c3                   	ret    
  106186:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10618d:	00 00 00 

00106190 <vmm_map_range>:
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;

	return addr & 0xFFFFF000;
}

void vmm_map_range(void* vaddr, void* paddr, uint32_t length, uint32_t flags) {
  106190:	55                   	push   %ebp
  106191:	89 e5                	mov    %esp,%ebp
  106193:	56                   	push   %esi
  106194:	83 ec 24             	sub    $0x24,%esp
  106197:	8b 45 14             	mov    0x14(%ebp),%eax
  10619a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10619d:	8b 55 0c             	mov    0xc(%ebp),%edx
  1061a0:	8b 75 08             	mov    0x8(%ebp),%esi
  1061a3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  1061a6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  1061a9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1061ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((uint32_t) vaddr & 0xFFF)
  1061af:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1061b2:	25 ff 0f 00 00       	and    $0xfff,%eax
  1061b7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1061bc:	0f 84 05 00 00 00    	je     1061c7 <vmm_map_range+0x37>
		return;
  1061c2:	e9 5a 00 00 00       	jmp    106221 <vmm_map_range+0x91>
	if ((uint32_t) paddr & 0xFFF)
  1061c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1061ca:	25 ff 0f 00 00       	and    $0xfff,%eax
  1061cf:	3d 00 00 00 00       	cmp    $0x0,%eax
  1061d4:	0f 84 05 00 00 00    	je     1061df <vmm_map_range+0x4f>
		return;
  1061da:	e9 42 00 00 00       	jmp    106221 <vmm_map_range+0x91>

	for (uint32_t i = 0; i < length; i += 0x1000) {
  1061df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1061e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1061e9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  1061ec:	0f 83 2f 00 00 00    	jae    106221 <vmm_map_range+0x91>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
  1061f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1061f5:	03 45 e8             	add    -0x18(%ebp),%eax
  1061f8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1061fb:	03 4d e8             	add    -0x18(%ebp),%ecx
  1061fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106201:	89 04 24             	mov    %eax,(%esp)
  106204:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106208:	89 54 24 08          	mov    %edx,0x8(%esp)
  10620c:	e8 0f ff ff ff       	call   106120 <map_address_active>
	if ((uint32_t) vaddr & 0xFFF)
		return;
	if ((uint32_t) paddr & 0xFFF)
		return;

	for (uint32_t i = 0; i < length; i += 0x1000) {
  106211:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106214:	05 00 10 00 00       	add    $0x1000,%eax
  106219:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10621c:	e9 c5 ff ff ff       	jmp    1061e6 <vmm_map_range+0x56>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}
  106221:	83 c4 24             	add    $0x24,%esp
  106224:	5e                   	pop    %esi
  106225:	5d                   	pop    %ebp
  106226:	c3                   	ret    
  106227:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10622e:	00 00 

00106230 <vmm_alloc_ucont>:
	}

	return vaddr;
}

void* vmm_alloc_ucont(uint32_t cont) {
  106230:	55                   	push   %ebp
  106231:	89 e5                	mov    %esp,%ebp
  106233:	56                   	push   %esi
  106234:	83 ec 24             	sub    $0x24,%esp
  106237:	8b 45 08             	mov    0x8(%ebp),%eax
  10623a:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  10623f:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  106244:	be 00 00 00 00       	mov    $0x0,%esi
  106249:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
  10624c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10624f:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  106256:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  10625d:	ff 
  10625e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106265:	00 
  106266:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10626a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10626d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106270:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106273:	e8 08 00 00 00       	call   106280 <vmm_alloc_in_range>
  106278:	83 c4 24             	add    $0x24,%esp
  10627b:	5e                   	pop    %esi
  10627c:	5d                   	pop    %ebp
  10627d:	c3                   	ret    
  10627e:	66 90                	xchg   %ax,%ax

00106280 <vmm_alloc_in_range>:
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

static void* vmm_alloc_in_range(uint32_t low, uint32_t high, uint32_t* retpaddr,
		uint32_t cont) {
  106280:	55                   	push   %ebp
  106281:	89 e5                	mov    %esp,%ebp
  106283:	56                   	push   %esi
  106284:	83 ec 34             	sub    $0x34,%esp
  106287:	8b 45 14             	mov    0x14(%ebp),%eax
  10628a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10628d:	8b 55 0c             	mov    0xc(%ebp),%edx
  106290:	8b 75 08             	mov    0x8(%ebp),%esi
  106293:	89 75 f8             	mov    %esi,-0x8(%ebp)
  106296:	89 55 f4             	mov    %edx,-0xc(%ebp)
  106299:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10629c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	void* vaddr = 0;
  10629f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32_t i = 0;
  1062a6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32_t c = 0;
  1062ad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  1062b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1062b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1062bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1062bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1062c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  1062c5:	0f 83 6f 00 00 00    	jae    10633a <vmm_alloc_in_range+0xba>
		if ((active_pagetables[i >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  1062cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1062ce:	c1 e8 0c             	shr    $0xc,%eax
  1062d1:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  1062d7:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1062da:	25 01 02 00 00       	and    $0x201,%eax
  1062df:	3d 00 02 00 00       	cmp    $0x200,%eax
  1062e4:	0f 85 34 00 00 00    	jne    10631e <vmm_alloc_in_range+0x9e>
				== PT_ALLOCATABLE) {
			if (c == 0)
  1062ea:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1062f1:	0f 85 06 00 00 00    	jne    1062fd <vmm_alloc_in_range+0x7d>
				vaddr = (void*) i;
  1062f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1062fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
			c++;
  1062fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  106300:	05 01 00 00 00       	add    $0x1,%eax
  106305:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (c >= cont)
  106308:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10630b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10630e:	0f 82 05 00 00 00    	jb     106319 <vmm_alloc_in_range+0x99>
				break;
  106314:	e9 21 00 00 00       	jmp    10633a <vmm_alloc_in_range+0xba>
		} else {
  106319:	e9 07 00 00 00       	jmp    106325 <vmm_alloc_in_range+0xa5>
			c = 0;
  10631e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
	}
  106325:	e9 00 00 00 00       	jmp    10632a <vmm_alloc_in_range+0xaa>
		uint32_t cont) {
	void* vaddr = 0;
	uint32_t i = 0;
	uint32_t c = 0;

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  10632a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10632d:	05 00 10 00 00       	add    $0x1000,%eax
  106332:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106335:	e9 85 ff ff ff       	jmp    1062bf <vmm_alloc_in_range+0x3f>
		} else {
			c = 0;
		}
	}

	uint32_t off = 0;
  10633a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	while (c--) {
  106341:	8b 45 e0             	mov    -0x20(%ebp),%eax
  106344:	89 c1                	mov    %eax,%ecx
  106346:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  10634c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10634f:	3d 00 00 00 00       	cmp    $0x0,%eax
  106354:	0f 84 59 00 00 00    	je     1063b3 <vmm_alloc_in_range+0x133>
		vmm_alloc_addr(vaddr + off * 0x1000, off == 0 ? retpaddr : 0);
  10635a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10635d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  106360:	c1 e1 0c             	shl    $0xc,%ecx
  106363:	01 c8                	add    %ecx,%eax
  106365:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  10636c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10636f:	0f 85 0b 00 00 00    	jne    106380 <vmm_alloc_in_range+0x100>
  106375:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106378:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10637b:	e9 0d 00 00 00       	jmp    10638d <vmm_alloc_in_range+0x10d>
  106380:	b8 00 00 00 00       	mov    $0x0,%eax
  106385:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  106388:	e9 00 00 00 00       	jmp    10638d <vmm_alloc_in_range+0x10d>
  10638d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  106390:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  106393:	89 0c 24             	mov    %ecx,(%esp)
  106396:	89 44 24 04          	mov    %eax,0x4(%esp)
  10639a:	e8 71 00 00 00       	call   106410 <vmm_alloc_addr>
		off++;
  10639f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1063a2:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1063a8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	}
  1063ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1063ae:	e9 8e ff ff ff       	jmp    106341 <vmm_alloc_in_range+0xc1>

	return vaddr;
  1063b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1063b6:	83 c4 34             	add    $0x34,%esp
  1063b9:	5e                   	pop    %esi
  1063ba:	5d                   	pop    %ebp
  1063bb:	c3                   	ret    
  1063bc:	0f 1f 40 00          	nopl   0x0(%eax)

001063c0 <vmm_alloc_cont>:

void* vmm_alloc_user(uint32_t* retpaddr) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
}

void* vmm_alloc_cont(uint32_t cont) {
  1063c0:	55                   	push   %ebp
  1063c1:	89 e5                	mov    %esp,%ebp
  1063c3:	56                   	push   %esi
  1063c4:	83 ec 24             	sub    $0x24,%esp
  1063c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1063ca:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  1063cf:	ba 00 00 00 20       	mov    $0x20000000,%edx
  1063d4:	be 00 00 00 00       	mov    $0x0,%esi
  1063d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
  1063dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1063df:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
  1063e6:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  1063ed:	20 
  1063ee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1063f5:	00 
  1063f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1063fa:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1063fd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106400:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106403:	e8 78 fe ff ff       	call   106280 <vmm_alloc_in_range>
  106408:	83 c4 24             	add    $0x24,%esp
  10640b:	5e                   	pop    %esi
  10640c:	5d                   	pop    %ebp
  10640d:	c3                   	ret    
  10640e:	66 90                	xchg   %ax,%ax

00106410 <vmm_alloc_addr>:

void* vmm_alloc(uint32_t* retpaddr) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
}

void* vmm_alloc_addr(void* reqvaddr, uint32_t* retpaddr) {
  106410:	55                   	push   %ebp
  106411:	89 e5                	mov    %esp,%ebp
  106413:	56                   	push   %esi
  106414:	83 ec 34             	sub    $0x34,%esp
  106417:	8b 45 0c             	mov    0xc(%ebp),%eax
  10641a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10641d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  106420:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (reqvaddr == 0) {
  106423:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  10642a:	0f 85 34 00 00 00    	jne    106464 <vmm_alloc_addr+0x54>
  106430:	8d 05 4b 86 10 00    	lea    0x10864b,%eax
  106436:	b9 00 00 00 00       	mov    $0x0,%ecx
		kprintf(
  10643b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10643e:	89 04 24             	mov    %eax,(%esp)
  106441:	89 54 24 04          	mov    %edx,0x4(%esp)
  106445:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10644c:	00 
  10644d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  106450:	e8 1b a1 ff ff       	call   100570 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, 0);
		return 0;
  106455:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10645c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10645f:	e9 9b 00 00 00       	jmp    1064ff <vmm_alloc_addr+0xef>
	}

	if ((active_pagetables[(uint32_t) reqvaddr >> 12]
  106464:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106467:	c1 e8 0c             	shr    $0xc,%eax
  10646a:	8b 0d e4 71 10 00    	mov    0x1071e4,%ecx
  106470:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106473:	25 01 02 00 00       	and    $0x201,%eax
  106478:	3d 00 02 00 00       	cmp    $0x200,%eax
  10647d:	0f 84 37 00 00 00    	je     1064ba <vmm_alloc_addr+0xaa>
  106483:	8d 05 4b 86 10 00    	lea    0x10864b,%eax
			& (PT_ALLOCATABLE | PT_PRESENT)) != PT_ALLOCATABLE) {
		kprintf(
  106489:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10648c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10648f:	c1 ea 0c             	shr    $0xc,%edx
  106492:	8b 35 e4 71 10 00    	mov    0x1071e4,%esi
  106498:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10649b:	89 04 24             	mov    %eax,(%esp)
  10649e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1064a2:	89 54 24 08          	mov    %edx,0x8(%esp)
  1064a6:	e8 c5 a0 ff ff       	call   100570 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, active_pagetables[(uint32_t) reqvaddr >> 12]);
		return 0;
  1064ab:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1064b2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1064b5:	e9 45 00 00 00       	jmp    1064ff <vmm_alloc_addr+0xef>
  1064ba:	b8 04 02 00 00       	mov    $0x204,%eax
	}

	uint32_t paddr = (uint32_t) pmm_alloc();
  1064bf:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1064c2:	e8 59 c1 ff ff       	call   102620 <pmm_alloc>
  1064c7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	map_address_active((uint32_t) reqvaddr, paddr, PT_PUBLIC | PT_ALLOCATABLE);
  1064ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1064cd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1064d0:	89 04 24             	mov    %eax,(%esp)
  1064d3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1064d7:	c7 44 24 08 04 02 00 	movl   $0x204,0x8(%esp)
  1064de:	00 
  1064df:	e8 3c fc ff ff       	call   106120 <map_address_active>

	if (retpaddr != 0)
  1064e4:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1064eb:	0f 84 08 00 00 00    	je     1064f9 <vmm_alloc_addr+0xe9>
		*retpaddr = paddr;
  1064f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1064f4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1064f7:	89 01                	mov    %eax,(%ecx)

	return reqvaddr;
  1064f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1064fc:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  1064ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106502:	83 c4 34             	add    $0x34,%esp
  106505:	5e                   	pop    %esi
  106506:	5d                   	pop    %ebp
  106507:	c3                   	ret    
  106508:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10650f:	00 

00106510 <vmm_activate_pagedir>:

void vmm_activate_pagedir(uint32_t pdpaddr) {
  106510:	55                   	push   %ebp
  106511:	89 e5                	mov    %esp,%ebp
  106513:	50                   	push   %eax
  106514:	8b 45 08             	mov    0x8(%ebp),%eax
  106517:	89 45 fc             	mov    %eax,-0x4(%ebp)
	active_pagedir = pdpaddr;
  10651a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10651d:	a3 64 a4 10 00       	mov    %eax,0x10a464
	asm volatile("mov %0, %%cr3" : : "r" (pdpaddr));
  106522:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106525:	0f 22 d8             	mov    %eax,%cr3
}
  106528:	83 c4 04             	add    $0x4,%esp
  10652b:	5d                   	pop    %ebp
  10652c:	c3                   	ret    
  10652d:	0f 1f 00             	nopl   (%eax)

00106530 <vmm_init>:

uint32_t vmm_init(void) {
  106530:	55                   	push   %ebp
  106531:	89 e5                	mov    %esp,%ebp
	//CREATE CONTEXT ************************************************************

	struct vmm_context* context = pmm_alloc();
  106533:	53                   	push   %ebx
  106534:	57                   	push   %edi
  106535:	56                   	push   %esi
  106536:	83 ec 3c             	sub    $0x3c,%esp
  106539:	e8 e2 c0 ff ff       	call   102620 <pmm_alloc>
  10653e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t i, i2;

	context->pagedir = pmm_alloc();
  106541:	e8 da c0 ff ff       	call   102620 <pmm_alloc>
  106546:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106549:	89 01                	mov    %eax,(%ecx)

	for (i = 0; i < 1024; i++) {
  10654b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106552:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  106559:	0f 83 d6 00 00 00    	jae    106635 <vmm_init+0x105>
		context->pagedir[i] = ((uint32_t) pmm_alloc());
  10655f:	e8 bc c0 ff ff       	call   102620 <pmm_alloc>
  106564:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106567:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10656a:	8b 12                	mov    (%edx),%edx
  10656c:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		if (i < PMEM_TABLES) {
  10656f:	81 7d ec 80 00 00 00 	cmpl   $0x80,-0x14(%ebp)
  106576:	0f 83 15 00 00 00    	jae    106591 <vmm_init+0x61>
			kernel_pagetables[i] = context->pagedir[i];
  10657c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10657f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106582:	8b 09                	mov    (%ecx),%ecx
  106584:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106587:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10658a:	89 04 8d 98 a4 18 00 	mov    %eax,0x18a498(,%ecx,4)
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;
  106591:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106594:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106597:	8b 09                	mov    (%ecx),%ecx
  106599:	8b 14 81             	mov    (%ecx,%eax,4),%edx
  10659c:	81 ca 07 00 00 00    	or     $0x7,%edx
  1065a2:	89 14 81             	mov    %edx,(%ecx,%eax,4)

		for (i2 = 0; i2 < 1024; i2++) {
  1065a5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1065ac:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
  1065b3:	0f 83 67 00 00 00    	jae    106620 <vmm_init+0xf0>
  1065b9:	b8 04 00 00 00       	mov    $0x4,%eax
  1065be:	b9 00 00 00 00       	mov    $0x0,%ecx
  1065c3:	ba 00 02 00 00       	mov    $0x200,%edx
			uint32_t vaddr = (i << 22) + (i2 << 12);
  1065c8:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1065cb:	c1 e6 16             	shl    $0x16,%esi
  1065ce:	8b 7d e8             	mov    -0x18(%ebp),%edi
  1065d1:	c1 e7 0c             	shl    $0xc,%edi
  1065d4:	01 fe                	add    %edi,%esi
  1065d6:	89 75 e4             	mov    %esi,-0x1c(%ebp)

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
  1065d9:	81 7d e4 00 00 00 01 	cmpl   $0x1000000,-0x1c(%ebp)
  1065e0:	0f 97 c3             	seta   %bl
  1065e3:	84 db                	test   %bl,%bl
  1065e5:	0f 44 d1             	cmove  %ecx,%edx
  1065e8:	81 7d e4 00 10 40 20 	cmpl   $0x20401000,-0x1c(%ebp)
  1065ef:	0f 97 c3             	seta   %bl
  1065f2:	84 db                	test   %bl,%bl
  1065f4:	0f 44 c1             	cmove  %ecx,%eax
  1065f7:	09 c2                	or     %eax,%edx
  1065f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1065fc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1065ff:	8b 75 f0             	mov    -0x10(%ebp),%esi
  106602:	8b 36                	mov    (%esi),%esi
  106604:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  106607:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  10660d:	89 14 81             	mov    %edx,(%ecx,%eax,4)
			kernel_pagetables[i] = context->pagedir[i];
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;

		for (i2 = 0; i2 < 1024; i2++) {
  106610:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106613:	05 01 00 00 00       	add    $0x1,%eax
  106618:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10661b:	e9 8c ff ff ff       	jmp    1065ac <vmm_init+0x7c>

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}
  106620:	e9 00 00 00 00       	jmp    106625 <vmm_init+0xf5>
	struct vmm_context* context = pmm_alloc();
	uint32_t i, i2;

	context->pagedir = pmm_alloc();

	for (i = 0; i < 1024; i++) {
  106625:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106628:	05 01 00 00 00       	add    $0x1,%eax
  10662d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106630:	e9 1d ff ff ff       	jmp    106552 <vmm_init+0x22>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  106635:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10663c:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  106643:	0f 83 5a 00 00 00    	jae    1066a3 <vmm_init+0x173>
  106649:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
  10664e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106651:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106654:	8b 12                	mov    (%edx),%edx
  106656:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106659:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  10665f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		map_address_context(context->pagedir,
  106662:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106665:	8b 09                	mov    (%ecx),%ecx
  106667:	8b 15 e4 71 10 00    	mov    0x1071e4,%edx
  10666d:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106670:	c1 e6 0c             	shl    $0xc,%esi
  106673:	01 f2                	add    %esi,%edx
  106675:	8b 75 e0             	mov    -0x20(%ebp),%esi
  106678:	89 0c 24             	mov    %ecx,(%esp)
  10667b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10667f:	89 74 24 08          	mov    %esi,0x8(%esp)
  106683:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10668a:	00 
  10668b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10668e:	e8 3d f7 ff ff       	call   105dd0 <map_address_context>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  106693:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106696:	05 01 00 00 00       	add    $0x1,%eax
  10669b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10669e:	e9 99 ff ff ff       	jmp    10663c <vmm_init+0x10c>
  1066a3:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(context->pagedir,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
  1066a8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1066ab:	8b 09                	mov    (%ecx),%ecx
  1066ad:	8b 15 e8 71 10 00    	mov    0x1071e8,%edx
  1066b3:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1066b6:	89 0c 24             	mov    %ecx,(%esp)
  1066b9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1066bd:	89 74 24 08          	mov    %esi,0x8(%esp)
  1066c1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1066c8:	00 
  1066c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  1066cc:	e8 ff f6 ff ff       	call   105dd0 <map_address_context>
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  1066d1:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
  1066d8:	8d 05 00 b0 18 00    	lea    0x18b000,%eax
  1066de:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  1066e1:	0f 83 3b 00 00 00    	jae    106722 <vmm_init+0x1f2>
  1066e7:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(context->pagedir, i, i, 0);
  1066ec:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1066ef:	8b 09                	mov    (%ecx),%ecx
  1066f1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1066f4:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1066f7:	89 0c 24             	mov    %ecx,(%esp)
  1066fa:	89 54 24 04          	mov    %edx,0x4(%esp)
  1066fe:	89 74 24 08          	mov    %esi,0x8(%esp)
  106702:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106709:	00 
  10670a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10670d:	e8 be f6 ff ff       	call   105dd0 <map_address_context>
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  106712:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106715:	05 00 10 00 00       	add    $0x1000,%eax
  10671a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10671d:	e9 b6 ff ff ff       	jmp    1066d8 <vmm_init+0x1a8>
		map_address_context(context->pagedir, i, i, 0);
	}

	//END CREATE CONTEXT ********************************************************

	vmm_activate_pagedir((uint32_t) context->pagedir);
  106722:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106725:	8b 00                	mov    (%eax),%eax
  106727:	89 04 24             	mov    %eax,(%esp)
  10672a:	e8 e1 fd ff ff       	call   106510 <vmm_activate_pagedir>

	uint32_t cr0;

	asm volatile("mov %%cr0, %0" : "=r" (cr0));
  10672f:	0f 20 c0             	mov    %cr0,%eax
  106732:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= (1 << 31);
  106735:	8b 45 dc             	mov    -0x24(%ebp),%eax
  106738:	0d 00 00 00 80       	or     $0x80000000,%eax
  10673d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	asm volatile("mov %0, %%cr0" : : "r" (cr0));
  106740:	8b 45 dc             	mov    -0x24(%ebp),%eax
  106743:	0f 22 c0             	mov    %eax,%cr0

	return (uint32_t) active_context->pagedir;
  106746:	a1 e8 71 10 00       	mov    0x1071e8,%eax
  10674b:	8b 00                	mov    (%eax),%eax
  10674d:	83 c4 3c             	add    $0x3c,%esp
  106750:	5e                   	pop    %esi
  106751:	5f                   	pop    %edi
  106752:	5b                   	pop    %ebx
  106753:	5d                   	pop    %ebp
  106754:	c3                   	ret    
  106755:	66 90                	xchg   %ax,%ax
  106757:	90                   	nop

00106758 <_start>:
  106758:	bc 68 a4 11 00       	mov    $0x11a468,%esp
  10675d:	53                   	push   %ebx
  10675e:	e8 ad 98 ff ff       	call   100010 <init>

00106763 <_stop>:
  106763:	fa                   	cli    
  106764:	f4                   	hlt    
  106765:	eb fc                	jmp    106763 <_stop>

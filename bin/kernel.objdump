
kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <kernel_start>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 66                	in     $0x66,%al
  10000d:	90                   	nop
  10000e:	66 90                	xchg   %ax,%ax

00100010 <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaUSpaceDev 1.02"

void init(struct multiboot_info* mb_info) {
  100010:	55                   	push   %ebp
  100011:	89 e5                	mov    %esp,%ebp
  100013:	83 ec 28             	sub    $0x28,%esp
  100016:	8b 45 08             	mov    0x8(%ebp),%eax
  100019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	clrscr();
  10001c:	e8 0f 02 00 00       	call   100230 <clrscr>
	pmm_init(mb_info);
  100021:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100024:	89 04 24             	mov    %eax,(%esp)
  100027:	e8 d4 2c 00 00       	call   102d00 <pmm_init>
  10002c:	8d 05 98 80 10 00    	lea    0x108098,%eax
  100032:	8d 0d bb 80 10 00    	lea    0x1080bb,%ecx

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100038:	89 04 24             	mov    %eax,(%esp)
  10003b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10003f:	e8 6c 02 00 00       	call   1002b0 <kprintf>
  100044:	8d 0d cf 80 10 00    	lea    0x1080cf,%ecx
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10004a:	89 0c 24             	mov    %ecx,(%esp)
  10004d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100050:	e8 5b 02 00 00       	call   1002b0 <kprintf>
  100055:	8d 0d 0e 81 10 00    	lea    0x10810e,%ecx

	kprintf("Initializing GDT...\n");
  10005b:	89 0c 24             	mov    %ecx,(%esp)
  10005e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100061:	e8 4a 02 00 00       	call   1002b0 <kprintf>

	init_gdt();
  100066:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100069:	e8 b2 0f 00 00       	call   101020 <init_gdt>
  10006e:	8d 05 23 81 10 00    	lea    0x108123,%eax

	kprintf("Initializing IDT...\n");
  100074:	89 04 24             	mov    %eax,(%esp)
  100077:	e8 34 02 00 00       	call   1002b0 <kprintf>
  10007c:	8d 0d 38 81 10 00    	lea    0x108138,%ecx

	init_idt();
  100082:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100085:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100088:	e8 b3 11 00 00       	call   101240 <init_idt>

	kprintf("Initializing Kernel...\n");
  10008d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100090:	89 04 24             	mov    %eax,(%esp)
  100093:	e8 18 02 00 00       	call   1002b0 <kprintf>

	pmm_print_stats();
  100098:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10009b:	e8 70 2a 00 00       	call   102b10 <pmm_print_stats>

	kernel_main(mb_info);
  1000a0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000a3:	89 04 24             	mov    %eax,(%esp)
  1000a6:	e8 c5 26 00 00       	call   102770 <kernel_main>

	return;
  1000ab:	83 c4 28             	add    $0x28,%esp
  1000ae:	5d                   	pop    %ebp
  1000af:	c3                   	ret    

001000b0 <in_cod>:
#include "catofdeath.h"

static uint32_t icod = 0;

uint32_t in_cod() {
  1000b0:	55                   	push   %ebp
  1000b1:	89 e5                	mov    %esp,%ebp
    return icod;
  1000b3:	a1 00 90 10 00       	mov    0x109000,%eax
  1000b8:	5d                   	pop    %ebp
  1000b9:	c3                   	ret    
  1000ba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001000c0 <show_cod>:
}

void show_cod(struct cpu_state* cpu, char* fstr) {
  1000c0:	55                   	push   %ebp
  1000c1:	89 e5                	mov    %esp,%ebp
  1000c3:	56                   	push   %esi
  1000c4:	83 ec 24             	sub    $0x24,%esp
  1000c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1000ca:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1000cd:	ba 04 00 00 00       	mov    $0x4,%edx
  1000d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1000d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    icod = 1;
  1000d8:	c7 05 00 90 10 00 01 	movl   $0x1,0x109000
  1000df:	00 00 00 
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
  1000e2:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1000e9:	89 55 f0             	mov    %edx,-0x10(%ebp)
  1000ec:	e8 9f 01 00 00       	call   100290 <setclr>
    kprintf(fstr);
  1000f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1000f4:	89 04 24             	mov    %eax,(%esp)
  1000f7:	e8 b4 01 00 00       	call   1002b0 <kprintf>
  1000fc:	8d 0d 50 81 10 00    	lea    0x108150,%ecx
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  100102:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100105:	8b 52 1c             	mov    0x1c(%edx),%edx
  100108:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10010b:	8b 76 20             	mov    0x20(%esi),%esi
  10010e:	89 0c 24             	mov    %ecx,(%esp)
  100111:	89 54 24 04          	mov    %edx,0x4(%esp)
  100115:	89 74 24 08          	mov    %esi,0x8(%esp)
  100119:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10011c:	e8 8f 01 00 00       	call   1002b0 <kprintf>
    show_dump(cpu);
  100121:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100124:	89 0c 24             	mov    %ecx,(%esp)
  100127:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10012a:	e8 11 00 00 00       	call   100140 <show_dump>

    while (1) {
        asm volatile("cli; hlt");
  10012f:	fa                   	cli    
  100130:	f4                   	hlt    
    }
  100131:	e9 f9 ff ff ff       	jmp    10012f <show_cod+0x6f>
  100136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10013d:	00 00 00 

00100140 <show_dump>:
}

void show_dump(struct cpu_state* cpu) {
  100140:	55                   	push   %ebp
  100141:	89 e5                	mov    %esp,%ebp
  100143:	53                   	push   %ebx
  100144:	57                   	push   %edi
  100145:	56                   	push   %esi
  100146:	83 ec 2c             	sub    $0x2c,%esp
  100149:	8b 45 08             	mov    0x8(%ebp),%eax
  10014c:	8d 0d 75 81 10 00    	lea    0x108175,%ecx
  100152:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  100155:	8b 45 f0             	mov    -0x10(%ebp),%eax
  100158:	8b 00                	mov    (%eax),%eax
  10015a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10015d:	8b 52 04             	mov    0x4(%edx),%edx
  100160:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100163:	8b 76 08             	mov    0x8(%esi),%esi
  100166:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100169:	8b 7f 0c             	mov    0xc(%edi),%edi
  10016c:	89 0c 24             	mov    %ecx,(%esp)
  10016f:	89 44 24 04          	mov    %eax,0x4(%esp)
  100173:	89 54 24 08          	mov    %edx,0x8(%esp)
  100177:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10017b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10017f:	e8 2c 01 00 00       	call   1002b0 <kprintf>
  100184:	8d 0d 96 81 10 00    	lea    0x108196,%ecx
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  10018a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10018d:	8b 52 10             	mov    0x10(%edx),%edx
  100190:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100193:	8b 76 14             	mov    0x14(%esi),%esi
  100196:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100199:	8b 7f 18             	mov    0x18(%edi),%edi
  10019c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10019f:	8b 5b 24             	mov    0x24(%ebx),%ebx
  1001a2:	89 0c 24             	mov    %ecx,(%esp)
  1001a5:	89 54 24 04          	mov    %edx,0x4(%esp)
  1001a9:	89 74 24 08          	mov    %esi,0x8(%esp)
  1001ad:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1001b1:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1001b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1001b8:	e8 f3 00 00 00       	call   1002b0 <kprintf>
  1001bd:	8d 0d b7 81 10 00    	lea    0x1081b7,%ecx
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
  1001c3:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1001c6:	8b 52 28             	mov    0x28(%edx),%edx
  1001c9:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1001cc:	8b 76 2c             	mov    0x2c(%esi),%esi
  1001cf:	8b 7d f0             	mov    -0x10(%ebp),%edi
  1001d2:	8b 7f 30             	mov    0x30(%edi),%edi
  1001d5:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  1001d8:	8b 5b 34             	mov    0x34(%ebx),%ebx
  1001db:	89 0c 24             	mov    %ecx,(%esp)
  1001de:	89 54 24 04          	mov    %edx,0x4(%esp)
  1001e2:	89 74 24 08          	mov    %esi,0x8(%esp)
  1001e6:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  1001ea:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  1001ee:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1001f1:	e8 ba 00 00 00       	call   1002b0 <kprintf>
  1001f6:	8d 0d d9 81 10 00    	lea    0x1081d9,%ecx
            cpu->esp, cpu->ss);

    uint32_t cr2 = 0;
  1001fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  100203:	0f 20 d2             	mov    %cr2,%edx
  100206:	89 55 ec             	mov    %edx,-0x14(%ebp)

    kprintf("CR2: %x \n", cr2);
  100209:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10020c:	89 0c 24             	mov    %ecx,(%esp)
  10020f:	89 54 24 04          	mov    %edx,0x4(%esp)
  100213:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100216:	e8 95 00 00 00       	call   1002b0 <kprintf>
}
  10021b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10021e:	83 c4 2c             	add    $0x2c,%esp
  100221:	5e                   	pop    %esi
  100222:	5f                   	pop    %edi
  100223:	5b                   	pop    %ebx
  100224:	5d                   	pop    %ebp
  100225:	c3                   	ret    
  100226:	66 90                	xchg   %ax,%ax
  100228:	66 90                	xchg   %ax,%ax
  10022a:	66 90                	xchg   %ax,%ax
  10022c:	66 90                	xchg   %ax,%ax
  10022e:	66 90                	xchg   %ax,%ax

00100230 <clrscr>:
        x /= base;
    } while (x);
    kputs(p);
}

void clrscr(void) {
  100230:	55                   	push   %ebp
  100231:	89 e5                	mov    %esp,%ebp
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  100233:	50                   	push   %eax
  100234:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10023b:	81 7d fc a0 0f 00 00 	cmpl   $0xfa0,-0x4(%ebp)
  100242:	0f 8d 1d 00 00 00    	jge    100265 <clrscr+0x35>
        video[i] = 0;
  100248:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10024b:	8b 0d 00 70 10 00    	mov    0x107000,%ecx
  100251:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    kputs(p);
}

void clrscr(void) {
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  100255:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100258:	05 01 00 00 00       	add    $0x1,%eax
  10025d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100260:	e9 d6 ff ff ff       	jmp    10023b <clrscr+0xb>
        video[i] = 0;
    }

    color = 0x07;
  100265:	c6 05 04 70 10 00 07 	movb   $0x7,0x107004

    x = y = 0;
  10026c:	c7 05 04 90 10 00 00 	movl   $0x0,0x109004
  100273:	00 00 00 
  100276:	c7 05 08 90 10 00 00 	movl   $0x0,0x109008
  10027d:	00 00 00 
}
  100280:	83 c4 04             	add    $0x4,%esp
  100283:	5d                   	pop    %ebp
  100284:	c3                   	ret    
  100285:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10028c:	00 00 00 00 

00100290 <setclr>:

void setclr(char clr) {
  100290:	55                   	push   %ebp
  100291:	89 e5                	mov    %esp,%ebp
  100293:	50                   	push   %eax
  100294:	8a 45 08             	mov    0x8(%ebp),%al
  100297:	88 45 ff             	mov    %al,-0x1(%ebp)
    color = clr;
  10029a:	8a 45 ff             	mov    -0x1(%ebp),%al
  10029d:	a2 04 70 10 00       	mov    %al,0x107004
}
  1002a2:	83 c4 04             	add    $0x4,%esp
  1002a5:	5d                   	pop    %ebp
  1002a6:	c3                   	ret    
  1002a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1002ae:	00 00 

001002b0 <kprintf>:

int kprintf(const char* fmt, ...) {
  1002b0:	55                   	push   %ebp
  1002b1:	89 e5                	mov    %esp,%ebp
  1002b3:	83 ec 58             	sub    $0x58,%esp
  1002b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1002b9:	8d 4d f8             	lea    -0x8(%ebp),%ecx
  1002bc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1002bf:	8d 45 0c             	lea    0xc(%ebp),%eax
    va_list ap;
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
  1002c2:	89 01                	mov    %eax,(%ecx)
    kprintf_res = 0;
  1002c4:	c7 05 0c 90 10 00 00 	movl   $0x0,0x10900c
  1002cb:	00 00 00 
    while (*fmt) {
  1002ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002d1:	80 38 00             	cmpb   $0x0,(%eax)
  1002d4:	0f 84 dd 01 00 00    	je     1004b7 <kprintf+0x207>
        if (*fmt == '%') {
  1002da:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002dd:	0f be 00             	movsbl (%eax),%eax
  1002e0:	3d 25 00 00 00       	cmp    $0x25,%eax
  1002e5:	0f 85 ae 01 00 00    	jne    100499 <kprintf+0x1e9>
            fmt++;
  1002eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1002ee:	89 c1                	mov    %eax,%ecx
  1002f0:	41                   	inc    %ecx
  1002f1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
            switch (*fmt) {
  1002f4:	0f be 40 01          	movsbl 0x1(%eax),%eax
  1002f8:	89 c1                	mov    %eax,%ecx
  1002fa:	83 e9 24             	sub    $0x24,%ecx
  1002fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100300:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100303:	0f 8f 15 00 00 00    	jg     10031e <kprintf+0x6e>
  100309:	e9 00 00 00 00       	jmp    10030e <kprintf+0x5e>
  10030e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100311:	85 c0                	test   %eax,%eax
  100313:	0f 84 54 01 00 00    	je     10046d <kprintf+0x1bd>
  100319:	e9 54 01 00 00       	jmp    100472 <kprintf+0x1c2>
  10031e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100321:	83 e8 62             	sub    $0x62,%eax
  100324:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100327:	0f 8f 19 00 00 00    	jg     100346 <kprintf+0x96>
  10032d:	e9 00 00 00 00       	jmp    100332 <kprintf+0x82>
  100332:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100335:	83 e8 25             	sub    $0x25,%eax
  100338:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10033b:	0f 84 13 01 00 00    	je     100454 <kprintf+0x1a4>
  100341:	e9 2c 01 00 00       	jmp    100472 <kprintf+0x1c2>
  100346:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100349:	83 e8 6f             	sub    $0x6f,%eax
  10034c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10034f:	0f 8f 2d 00 00 00    	jg     100382 <kprintf+0xd2>
  100355:	e9 00 00 00 00       	jmp    10035a <kprintf+0xaa>
  10035a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10035d:	83 e8 63             	sub    $0x63,%eax
  100360:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100363:	0f 84 c5 00 00 00    	je     10042e <kprintf+0x17e>
  100369:	e9 00 00 00 00       	jmp    10036e <kprintf+0xbe>
  10036e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100371:	83 e8 64             	sub    $0x64,%eax
  100374:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100377:	0f 84 4b 00 00 00    	je     1003c8 <kprintf+0x118>
  10037d:	e9 f0 00 00 00       	jmp    100472 <kprintf+0x1c2>
  100382:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100385:	83 c0 90             	add    $0xffffff90,%eax
  100388:	89 c1                	mov    %eax,%ecx
  10038a:	83 e9 08             	sub    $0x8,%ecx
  10038d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100390:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  100393:	0f 87 d9 00 00 00    	ja     100472 <kprintf+0x1c2>
  100399:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10039c:	8b 0c 85 00 80 10 00 	mov    0x108000(,%eax,4),%ecx
  1003a3:	ff e1                	jmp    *%ecx
            case 's':
                s = va_arg(ap, char*);
  1003a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1003a8:	89 c1                	mov    %eax,%ecx
  1003aa:	81 c1 04 00 00 00    	add    $0x4,%ecx
  1003b0:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1003b3:	8b 00                	mov    (%eax),%eax
  1003b5:	89 45 f4             	mov    %eax,-0xc(%ebp)
                kputs(s);
  1003b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1003bb:	89 04 24             	mov    %eax,(%esp)
  1003be:	e8 0d 01 00 00       	call   1004d0 <kputs>
                break;
  1003c3:	e9 cc 00 00 00       	jmp    100494 <kprintf+0x1e4>
  1003c8:	b8 0a 00 00 00       	mov    $0xa,%eax
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
  1003cd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1003d0:	89 ca                	mov    %ecx,%edx
  1003d2:	81 c2 04 00 00 00    	add    $0x4,%edx
  1003d8:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1003db:	8b 09                	mov    (%ecx),%ecx
  1003dd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 10);
  1003e0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1003e3:	89 0c 24             	mov    %ecx,(%esp)
  1003e6:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  1003ed:	00 
  1003ee:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1003f1:	e8 1a 01 00 00       	call   100510 <kputn>
                break;
  1003f6:	e9 99 00 00 00       	jmp    100494 <kprintf+0x1e4>
  1003fb:	b8 10 00 00 00       	mov    $0x10,%eax
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
  100400:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100403:	89 ca                	mov    %ecx,%edx
  100405:	81 c2 04 00 00 00    	add    $0x4,%edx
  10040b:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10040e:	8b 09                	mov    (%ecx),%ecx
  100410:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 16);
  100413:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100416:	89 0c 24             	mov    %ecx,(%esp)
  100419:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  100420:	00 
  100421:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100424:	e8 e7 00 00 00       	call   100510 <kputn>
                break;
  100429:	e9 66 00 00 00       	jmp    100494 <kprintf+0x1e4>
            case 'c':
                c = va_arg(ap, int);
  10042e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100431:	89 c1                	mov    %eax,%ecx
  100433:	81 c1 04 00 00 00    	add    $0x4,%ecx
  100439:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10043c:	8b 00                	mov    (%eax),%eax
  10043e:	88 c2                	mov    %al,%dl
  100440:	88 55 ef             	mov    %dl,-0x11(%ebp)
                kputc(c);
  100443:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  100447:	89 04 24             	mov    %eax,(%esp)
  10044a:	e8 61 01 00 00       	call   1005b0 <kputc>
                break;
  10044f:	e9 40 00 00 00       	jmp    100494 <kprintf+0x1e4>
  100454:	b8 25 00 00 00       	mov    $0x25,%eax
            case '%':
                kputc('%');
  100459:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100460:	89 45 bc             	mov    %eax,-0x44(%ebp)
  100463:	e8 48 01 00 00       	call   1005b0 <kputc>
                break;
  100468:	e9 27 00 00 00       	jmp    100494 <kprintf+0x1e4>
            case '\0':
                goto out;
  10046d:	e9 4a 00 00 00       	jmp    1004bc <kprintf+0x20c>
  100472:	b8 25 00 00 00       	mov    $0x25,%eax
            default:
                kputc('%');
  100477:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10047e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100481:	e8 2a 01 00 00       	call   1005b0 <kputc>
                kputc(*fmt);
  100486:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100489:	0f be 00             	movsbl (%eax),%eax
  10048c:	89 04 24             	mov    %eax,(%esp)
  10048f:	e8 1c 01 00 00       	call   1005b0 <kputc>
                break;
            }
        } else {
  100494:	e9 0e 00 00 00       	jmp    1004a7 <kprintf+0x1f7>
            kputc(*fmt);
  100499:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10049c:	0f be 00             	movsbl (%eax),%eax
  10049f:	89 04 24             	mov    %eax,(%esp)
  1004a2:	e8 09 01 00 00       	call   1005b0 <kputc>
        }

        fmt++;
  1004a7:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004aa:	05 01 00 00 00       	add    $0x1,%eax
  1004af:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  1004b2:	e9 17 fe ff ff       	jmp    1002ce <kprintf+0x1e>
  1004b7:	e9 00 00 00 00       	jmp    1004bc <kprintf+0x20c>

    out:
    va_end(ap);

    return kprintf_res;
  1004bc:	a1 0c 90 10 00       	mov    0x10900c,%eax
  1004c1:	83 c4 58             	add    $0x58,%esp
  1004c4:	5d                   	pop    %ebp
  1004c5:	c3                   	ret    
  1004c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1004cd:	00 00 00 

001004d0 <kputs>:

    x++;
    kprintf_res++;
}

static void kputs(const char* s) {
  1004d0:	55                   	push   %ebp
  1004d1:	89 e5                	mov    %esp,%ebp
  1004d3:	83 ec 08             	sub    $0x8,%esp
  1004d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1004d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*s) {
  1004dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004df:	80 38 00             	cmpb   $0x0,(%eax)
  1004e2:	0f 84 1e 00 00 00    	je     100506 <kputs+0x36>
        kputc(*s++);
  1004e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004eb:	89 c1                	mov    %eax,%ecx
  1004ed:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1004f3:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1004f6:	0f be 00             	movsbl (%eax),%eax
  1004f9:	89 04 24             	mov    %eax,(%esp)
  1004fc:	e8 af 00 00 00       	call   1005b0 <kputc>
    }
  100501:	e9 d6 ff ff ff       	jmp    1004dc <kputs+0xc>
}
  100506:	83 c4 08             	add    $0x8,%esp
  100509:	5d                   	pop    %ebp
  10050a:	c3                   	ret    
  10050b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00100510 <kputn>:

static void kputn(unsigned long x, int base) {
  100510:	55                   	push   %ebp
  100511:	89 e5                	mov    %esp,%ebp
  100513:	56                   	push   %esi
  100514:	83 ec 64             	sub    $0x64,%esp
  100517:	8b 45 0c             	mov    0xc(%ebp),%eax
  10051a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10051d:	8d 15 e3 81 10 00    	lea    0x1081e3,%edx
  100523:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100526:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  100529:	89 55 ac             	mov    %edx,-0x54(%ebp)
    char* p;

    if (base > 36) {
  10052c:	81 7d f4 24 00 00 00 	cmpl   $0x24,-0xc(%ebp)
  100533:	0f 8e 05 00 00 00    	jle    10053e <kputn+0x2e>
        return;
  100539:	e9 5d 00 00 00       	jmp    10059b <kputn+0x8b>
  10053e:	8d 45 b3             	lea    -0x4d(%ebp),%eax
    }

    p = buf + 64;
  100541:	05 40 00 00 00       	add    $0x40,%eax
  100546:	89 45 a8             	mov    %eax,-0x58(%ebp)
    *p = '\0';
  100549:	8b 45 a8             	mov    -0x58(%ebp),%eax
  10054c:	c6 00 00             	movb   $0x0,(%eax)
    do {
        *--p = digits[x % base];
  10054f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100552:	31 d2                	xor    %edx,%edx
  100554:	f7 75 f4             	divl   -0xc(%ebp)
  100557:	8b 45 ac             	mov    -0x54(%ebp),%eax
  10055a:	8a 0c 10             	mov    (%eax,%edx,1),%cl
  10055d:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100560:	89 c2                	mov    %eax,%edx
  100562:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
  100568:	89 55 a8             	mov    %edx,-0x58(%ebp)
  10056b:	88 48 ff             	mov    %cl,-0x1(%eax)
        x /= base;
  10056e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100571:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100574:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  100577:	89 d0                	mov    %edx,%eax
  100579:	31 d2                	xor    %edx,%edx
  10057b:	8b 75 a4             	mov    -0x5c(%ebp),%esi
  10057e:	f7 f6                	div    %esi
  100580:	89 45 f8             	mov    %eax,-0x8(%ebp)
    } while (x);
  100583:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10058a:	0f 85 bf ff ff ff    	jne    10054f <kputn+0x3f>
    kputs(p);
  100590:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100593:	89 04 24             	mov    %eax,(%esp)
  100596:	e8 35 ff ff ff       	call   1004d0 <kputs>
}
  10059b:	83 c4 64             	add    $0x64,%esp
  10059e:	5e                   	pop    %esi
  10059f:	5d                   	pop    %ebp
  1005a0:	c3                   	ret    
  1005a1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1005a8:	0f 1f 84 00 00 00 00 
  1005af:	00 

001005b0 <kputc>:
static int kprintf_res = 0;
static char color = 0x07;

static char* video = (char*) 0xb8000;

static void kputc(char c) {
  1005b0:	55                   	push   %ebp
  1005b1:	89 e5                	mov    %esp,%ebp
  1005b3:	83 ec 38             	sub    $0x38,%esp
  1005b6:	8a 45 08             	mov    0x8(%ebp),%al
  1005b9:	88 45 ff             	mov    %al,-0x1(%ebp)
    if(in_cod()) {
  1005bc:	e8 ef fa ff ff       	call   1000b0 <in_cod>
  1005c1:	3d 00 00 00 00       	cmp    $0x0,%eax
  1005c6:	0f 84 05 00 00 00    	je     1005d1 <kputc+0x21>
        goto doKPutc;
  1005cc:	e9 e3 00 00 00       	jmp    1006b4 <kputc+0x104>
    }

    if(get_current_task() != 0) {
  1005d1:	e8 ea 38 00 00       	call   103ec0 <get_current_task>
  1005d6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1005db:	0f 84 b9 00 00 00    	je     10069a <kputc+0xea>
        if(get_current_task()->stdout != 0) {
  1005e1:	e8 da 38 00 00       	call   103ec0 <get_current_task>
  1005e6:	81 78 1c 00 00 00 00 	cmpl   $0x0,0x1c(%eax)
  1005ed:	0f 84 a2 00 00 00    	je     100695 <kputc+0xe5>
            vfs_write(get_current_task()->stdout, &(char){0x11}, sizeof(char), 1);
  1005f3:	e8 c8 38 00 00       	call   103ec0 <get_current_task>
  1005f8:	8d 4d fe             	lea    -0x2(%ebp),%ecx
  1005fb:	ba 01 00 00 00       	mov    $0x1,%edx
  100600:	8b 40 1c             	mov    0x1c(%eax),%eax
  100603:	c6 45 fe 11          	movb   $0x11,-0x2(%ebp)
  100607:	89 04 24             	mov    %eax,(%esp)
  10060a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10060e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100615:	00 
  100616:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  10061d:	00 
  10061e:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100621:	e8 1a 50 00 00       	call   105640 <vfs_write>
            vfs_write(get_current_task()->stdout, &color, sizeof(char), 1);
  100626:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100629:	e8 92 38 00 00       	call   103ec0 <get_current_task>
  10062e:	8d 0d 04 70 10 00    	lea    0x107004,%ecx
  100634:	ba 01 00 00 00       	mov    $0x1,%edx
  100639:	8b 40 1c             	mov    0x1c(%eax),%eax
  10063c:	89 04 24             	mov    %eax,(%esp)
  10063f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100643:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10064a:	00 
  10064b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100652:	00 
  100653:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100656:	e8 e5 4f 00 00       	call   105640 <vfs_write>
            vfs_write(get_current_task()->stdout, &c, sizeof(char), 1);
  10065b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10065e:	e8 5d 38 00 00       	call   103ec0 <get_current_task>
  100663:	8d 4d ff             	lea    -0x1(%ebp),%ecx
  100666:	ba 01 00 00 00       	mov    $0x1,%edx
  10066b:	8b 40 1c             	mov    0x1c(%eax),%eax
  10066e:	89 04 24             	mov    %eax,(%esp)
  100671:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100675:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  10067c:	00 
  10067d:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100684:	00 
  100685:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  100688:	e8 b3 4f 00 00       	call   105640 <vfs_write>

            return;
  10068d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100690:	e9 5e 01 00 00       	jmp    1007f3 <kputc+0x243>
        }
    }
  100695:	e9 00 00 00 00       	jmp    10069a <kputc+0xea>

    if(ramfs_vga_writers()) {
  10069a:	e8 f1 37 00 00       	call   103e90 <ramfs_vga_writers>
  10069f:	3d 00 00 00 00       	cmp    $0x0,%eax
  1006a4:	0f 84 05 00 00 00    	je     1006af <kputc+0xff>
        return;
  1006aa:	e9 44 01 00 00       	jmp    1007f3 <kputc+0x243>
    }
  1006af:	e9 00 00 00 00       	jmp    1006b4 <kputc+0x104>

    doKPutc:

    if ((c == '\n') || (x > 79)) {
  1006b4:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  1006b8:	3d 0a 00 00 00       	cmp    $0xa,%eax
  1006bd:	0f 84 10 00 00 00    	je     1006d3 <kputc+0x123>
  1006c3:	81 3d 08 90 10 00 4f 	cmpl   $0x4f,0x109008
  1006ca:	00 00 00 
  1006cd:	0f 8e 19 00 00 00    	jle    1006ec <kputc+0x13c>
        x = 0;
  1006d3:	c7 05 08 90 10 00 00 	movl   $0x0,0x109008
  1006da:	00 00 00 
        y++;
  1006dd:	a1 04 90 10 00       	mov    0x109004,%eax
  1006e2:	05 01 00 00 00       	add    $0x1,%eax
  1006e7:	a3 04 90 10 00       	mov    %eax,0x109004
    }

    if (c == '\n') {
  1006ec:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  1006f0:	3d 0a 00 00 00       	cmp    $0xa,%eax
  1006f5:	0f 85 05 00 00 00    	jne    100700 <kputc+0x150>
        return;
  1006fb:	e9 f3 00 00 00       	jmp    1007f3 <kputc+0x243>
    }

    if (y > 24) {
  100700:	81 3d 04 90 10 00 18 	cmpl   $0x18,0x109004
  100707:	00 00 00 
  10070a:	0f 8e 7e 00 00 00    	jle    10078e <kputc+0x1de>
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  100710:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  100717:	81 7d f8 00 0f 00 00 	cmpl   $0xf00,-0x8(%ebp)
  10071e:	0f 8d 2c 00 00 00    	jge    100750 <kputc+0x1a0>
            video[i] = video[i + 160];
  100724:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100727:	8b 0d 00 70 10 00    	mov    0x107000,%ecx
  10072d:	8a 94 01 a0 00 00 00 	mov    0xa0(%ecx,%eax,1),%dl
  100734:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100737:	8b 0d 00 70 10 00    	mov    0x107000,%ecx
  10073d:	88 14 01             	mov    %dl,(%ecx,%eax,1)
        return;
    }

    if (y > 24) {
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  100740:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100743:	05 01 00 00 00       	add    $0x1,%eax
  100748:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10074b:	e9 c7 ff ff ff       	jmp    100717 <kputc+0x167>
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  100750:	e9 00 00 00 00       	jmp    100755 <kputc+0x1a5>
  100755:	81 7d f8 a0 0f 00 00 	cmpl   $0xfa0,-0x8(%ebp)
  10075c:	0f 8d 1d 00 00 00    	jge    10077f <kputc+0x1cf>
            video[i] = 0;
  100762:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100765:	8b 0d 00 70 10 00    	mov    0x107000,%ecx
  10076b:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  10076f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100772:	05 01 00 00 00       	add    $0x1,%eax
  100777:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10077a:	e9 d6 ff ff ff       	jmp    100755 <kputc+0x1a5>
            video[i] = 0;
        }
        y--;
  10077f:	a1 04 90 10 00       	mov    0x109004,%eax
  100784:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100789:	a3 04 90 10 00       	mov    %eax,0x109004
    }

    video[2 * (y * 80 + x)] = c;
  10078e:	8a 45 ff             	mov    -0x1(%ebp),%al
  100791:	69 0d 04 90 10 00 50 	imul   $0x50,0x109004,%ecx
  100798:	00 00 00 
  10079b:	03 0d 08 90 10 00    	add    0x109008,%ecx
  1007a1:	c1 e1 01             	shl    $0x1,%ecx
  1007a4:	8b 15 00 70 10 00    	mov    0x107000,%edx
  1007aa:	88 04 0a             	mov    %al,(%edx,%ecx,1)
    video[2 * (y * 80 + x) + 1] = color;
  1007ad:	a0 04 70 10 00       	mov    0x107004,%al
  1007b2:	69 0d 04 90 10 00 50 	imul   $0x50,0x109004,%ecx
  1007b9:	00 00 00 
  1007bc:	03 0d 08 90 10 00    	add    0x109008,%ecx
  1007c2:	c1 e1 01             	shl    $0x1,%ecx
  1007c5:	8b 15 00 70 10 00    	mov    0x107000,%edx
  1007cb:	88 44 0a 01          	mov    %al,0x1(%edx,%ecx,1)

    x++;
  1007cf:	8b 0d 08 90 10 00    	mov    0x109008,%ecx
  1007d5:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1007db:	89 0d 08 90 10 00    	mov    %ecx,0x109008
    kprintf_res++;
  1007e1:	8b 0d 0c 90 10 00    	mov    0x10900c,%ecx
  1007e7:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1007ed:	89 0d 0c 90 10 00    	mov    %ecx,0x10900c
}
  1007f3:	83 c4 38             	add    $0x38,%esp
  1007f6:	5d                   	pop    %ebp
  1007f7:	c3                   	ret    
  1007f8:	66 90                	xchg   %ax,%ax
  1007fa:	66 90                	xchg   %ax,%ax
  1007fc:	66 90                	xchg   %ax,%ax
  1007fe:	66 90                	xchg   %ax,%ax

00100800 <irq_handler>:
        while ((inb(0x64) & 0x1) == 0) {
        }
    } while (inb(0x60) == 0xfe);
}

void irq_handler() {
  100800:	55                   	push   %ebp
  100801:	89 e5                	mov    %esp,%ebp
    uint8_t scancode;
    uint8_t keycode = 0;
  100803:	57                   	push   %edi
  100804:	56                   	push   %esi
  100805:	83 ec 40             	sub    $0x40,%esp
  100808:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
    int break_code = 0;
  10080c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    static int      e0_code = 0;
    static int      e1_code = 0;
    static uint16_t e1_prev = 0;

    if(!init_done) return;
  100813:	81 3d 10 90 10 00 00 	cmpl   $0x0,0x109010
  10081a:	00 00 00 
  10081d:	0f 85 05 00 00 00    	jne    100828 <irq_handler+0x28>
  100823:	e9 bf 02 00 00       	jmp    100ae7 <irq_handler+0x2e7>
  100828:	b8 60 00 00 00       	mov    $0x60,%eax

    scancode = inb(0x60);
  10082d:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100834:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100837:	e8 b4 02 00 00       	call   100af0 <inb>
  10083c:	88 45 f7             	mov    %al,-0x9(%ebp)

    // Um einen Breakcode handelt es sich, wenn das oberste Bit gesetzt ist und
    // es kein e0 oder e1 fuer einen Extended-scancode ist
    if ((scancode & 0x80) &&
  10083f:	0f b6 4d f7          	movzbl -0x9(%ebp),%ecx
  100843:	81 e1 80 00 00 00    	and    $0x80,%ecx
  100849:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  10084f:	0f 84 53 00 00 00    	je     1008a8 <irq_handler+0xa8>
  100855:	81 3d 1c 90 10 00 00 	cmpl   $0x0,0x10901c
  10085c:	00 00 00 
  10085f:	0f 85 0f 00 00 00    	jne    100874 <irq_handler+0x74>
  100865:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100869:	3d e1 00 00 00       	cmp    $0xe1,%eax
  10086e:	0f 84 34 00 00 00    	je     1008a8 <irq_handler+0xa8>
  100874:	81 3d 18 90 10 00 00 	cmpl   $0x0,0x109018
  10087b:	00 00 00 
  10087e:	0f 85 0f 00 00 00    	jne    100893 <irq_handler+0x93>
  100884:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100888:	3d e0 00 00 00       	cmp    $0xe0,%eax
  10088d:	0f 84 15 00 00 00    	je     1008a8 <irq_handler+0xa8>
        (e1_code || (scancode != 0xE1)) &&
        (e0_code || (scancode != 0xE0)))
    {
        break_code = 1;
  100893:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
        scancode &= ~0x80;
  10089a:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  10089e:	25 7f ff ff ff       	and    $0xffffff7f,%eax
  1008a3:	88 c1                	mov    %al,%cl
  1008a5:	88 4d f7             	mov    %cl,-0x9(%ebp)
    }

    if (e0_code) {
  1008a8:	81 3d 18 90 10 00 00 	cmpl   $0x0,0x109018
  1008af:	00 00 00 
  1008b2:	0f 84 63 00 00 00    	je     10091b <irq_handler+0x11b>
        // Fake shift abfangen und ignorieren
        if ((scancode == 0x2A) || (scancode == 0x36)) {
  1008b8:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1008bc:	3d 2a 00 00 00       	cmp    $0x2a,%eax
  1008c1:	0f 84 0f 00 00 00    	je     1008d6 <irq_handler+0xd6>
  1008c7:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1008cb:	3d 36 00 00 00       	cmp    $0x36,%eax
  1008d0:	0f 85 0f 00 00 00    	jne    1008e5 <irq_handler+0xe5>
            e0_code = 0;
  1008d6:	c7 05 18 90 10 00 00 	movl   $0x0,0x109018
  1008dd:	00 00 00 
            return;
  1008e0:	e9 02 02 00 00       	jmp    100ae7 <irq_handler+0x2e7>
  1008e5:	b8 01 00 00 00       	mov    $0x1,%eax
        }

        keycode = translate_scancode(1, scancode);
  1008ea:	8a 4d f7             	mov    -0x9(%ebp),%cl
  1008ed:	0f b6 d1             	movzbl %cl,%edx
  1008f0:	66 89 d6             	mov    %dx,%si
  1008f3:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  1008fa:	0f b7 d6             	movzwl %si,%edx
  1008fd:	89 54 24 04          	mov    %edx,0x4(%esp)
  100901:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100904:	e8 07 02 00 00       	call   100b10 <translate_scancode>
  100909:	88 45 f6             	mov    %al,-0xa(%ebp)
        e0_code = 0;
  10090c:	c7 05 18 90 10 00 00 	movl   $0x0,0x109018
  100913:	00 00 00 
    } else if (e1_code == 2) {
  100916:	e9 11 01 00 00       	jmp    100a2c <irq_handler+0x22c>
  10091b:	81 3d 1c 90 10 00 02 	cmpl   $0x2,0x10901c
  100922:	00 00 00 
  100925:	0f 85 53 00 00 00    	jne    10097e <irq_handler+0x17e>
  10092b:	b8 02 00 00 00       	mov    $0x2,%eax
        // Fertiger e1-Scancode
        // Zweiten Scancode in hoeherwertiges Byte packen
        e1_prev |= ((uint16_t) scancode << 8);
  100930:	8a 4d f7             	mov    -0x9(%ebp),%cl
  100933:	0f b6 d1             	movzbl %cl,%edx
  100936:	66 89 d6             	mov    %dx,%si
  100939:	0f b7 d6             	movzwl %si,%edx
  10093c:	c1 e2 08             	shl    $0x8,%edx
  10093f:	0f b7 3d 20 90 10 00 	movzwl 0x109020,%edi
  100946:	09 d7                	or     %edx,%edi
  100948:	66 89 fe             	mov    %di,%si
  10094b:	66 89 35 20 90 10 00 	mov    %si,0x109020
        keycode = translate_scancode(2, e1_prev);
  100952:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100959:	0f b7 15 20 90 10 00 	movzwl 0x109020,%edx
  100960:	89 54 24 04          	mov    %edx,0x4(%esp)
  100964:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100967:	e8 a4 01 00 00       	call   100b10 <translate_scancode>
  10096c:	88 45 f6             	mov    %al,-0xa(%ebp)
        e1_code = 0;
  10096f:	c7 05 1c 90 10 00 00 	movl   $0x0,0x10901c
  100976:	00 00 00 
    } else if (e1_code == 1) {
  100979:	e9 a9 00 00 00       	jmp    100a27 <irq_handler+0x227>
  10097e:	81 3d 1c 90 10 00 01 	cmpl   $0x1,0x10901c
  100985:	00 00 00 
  100988:	0f 85 27 00 00 00    	jne    1009b5 <irq_handler+0x1b5>
        // Erstes Byte fuer e1-Scancode
        e1_prev = scancode;
  10098e:	8a 45 f7             	mov    -0x9(%ebp),%al
  100991:	0f b6 c8             	movzbl %al,%ecx
  100994:	66 89 ca             	mov    %cx,%dx
  100997:	66 89 15 20 90 10 00 	mov    %dx,0x109020
        e1_code++;
  10099e:	8b 0d 1c 90 10 00    	mov    0x10901c,%ecx
  1009a4:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1009aa:	89 0d 1c 90 10 00    	mov    %ecx,0x10901c
    } else if (scancode == 0xE0) {
  1009b0:	e9 6d 00 00 00       	jmp    100a22 <irq_handler+0x222>
  1009b5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1009b9:	3d e0 00 00 00       	cmp    $0xe0,%eax
  1009be:	0f 85 0f 00 00 00    	jne    1009d3 <irq_handler+0x1d3>
        // Anfang eines e0-Codes
        e0_code = 1;
  1009c4:	c7 05 18 90 10 00 01 	movl   $0x1,0x109018
  1009cb:	00 00 00 
    } else if (scancode == 0xE1) {
  1009ce:	e9 4a 00 00 00       	jmp    100a1d <irq_handler+0x21d>
  1009d3:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  1009d7:	3d e1 00 00 00       	cmp    $0xe1,%eax
  1009dc:	0f 85 0f 00 00 00    	jne    1009f1 <irq_handler+0x1f1>
        // Anfang eines e1-Codes
        e1_code = 1;
  1009e2:	c7 05 1c 90 10 00 01 	movl   $0x1,0x10901c
  1009e9:	00 00 00 
    } else {
  1009ec:	e9 27 00 00 00       	jmp    100a18 <irq_handler+0x218>
  1009f1:	b8 00 00 00 00       	mov    $0x0,%eax
        // Normaler Scancode
        keycode = translate_scancode(0, scancode);
  1009f6:	8a 4d f7             	mov    -0x9(%ebp),%cl
  1009f9:	0f b6 d1             	movzbl %cl,%edx
  1009fc:	66 89 d6             	mov    %dx,%si
  1009ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100a06:	0f b7 d6             	movzwl %si,%edx
  100a09:	89 54 24 04          	mov    %edx,0x4(%esp)
  100a0d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  100a10:	e8 fb 00 00 00       	call   100b10 <translate_scancode>
  100a15:	88 45 f6             	mov    %al,-0xa(%ebp)
  100a18:	e9 00 00 00 00       	jmp    100a1d <irq_handler+0x21d>
  100a1d:	e9 00 00 00 00       	jmp    100a22 <irq_handler+0x222>
  100a22:	e9 00 00 00 00       	jmp    100a27 <irq_handler+0x227>
  100a27:	e9 00 00 00 00       	jmp    100a2c <irq_handler+0x22c>
    }

    if(break_code) {
  100a2c:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  100a33:	0f 84 1d 00 00 00    	je     100a56 <irq_handler+0x256>
        key_flags[keycode] &= ~KF_PRESSED;
  100a39:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
  100a3d:	8b 0c 85 68 94 12 00 	mov    0x129468(,%eax,4),%ecx
  100a44:	81 e1 fe ff ff ff    	and    $0xfffffffe,%ecx
  100a4a:	89 0c 85 68 94 12 00 	mov    %ecx,0x129468(,%eax,4)
    }
  100a51:	e9 18 00 00 00       	jmp    100a6e <irq_handler+0x26e>
    else
    {
        key_flags[keycode] |= KF_PRESSED;
  100a56:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
  100a5a:	8b 0c 85 68 94 12 00 	mov    0x129468(,%eax,4),%ecx
  100a61:	81 c9 01 00 00 00    	or     $0x1,%ecx
  100a67:	89 0c 85 68 94 12 00 	mov    %ecx,0x129468(,%eax,4)
    }

    char chr = getchar(keycode);
  100a6e:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
  100a72:	89 04 24             	mov    %eax,(%esp)
  100a75:	e8 76 01 00 00       	call   100bf0 <getchar>
  100a7a:	88 45 ef             	mov    %al,-0x11(%ebp)

    if(!break_code && chr) {
  100a7d:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  100a84:	0f 85 5d 00 00 00    	jne    100ae7 <irq_handler+0x2e7>
  100a8a:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  100a8e:	3d 00 00 00 00       	cmp    $0x0,%eax
  100a93:	0f 84 4e 00 00 00    	je     100ae7 <irq_handler+0x2e7>
  100a99:	8d 45 ef             	lea    -0x11(%ebp),%eax
  100a9c:	b9 01 00 00 00       	mov    $0x1,%ecx
        if(vfs_write(charout, &chr, sizeof(char), 1)) {
  100aa1:	8b 15 14 90 10 00    	mov    0x109014,%edx
  100aa7:	89 14 24             	mov    %edx,(%esp)
  100aaa:	89 44 24 04          	mov    %eax,0x4(%esp)
  100aae:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  100ab5:	00 
  100ab6:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  100abd:	00 
  100abe:	89 4d d8             	mov    %ecx,-0x28(%ebp)
  100ac1:	e8 7a 4b 00 00       	call   105640 <vfs_write>
  100ac6:	3d 00 00 00 00       	cmp    $0x0,%eax
  100acb:	0f 84 11 00 00 00    	je     100ae2 <irq_handler+0x2e2>
  100ad1:	8d 05 08 82 10 00    	lea    0x108208,%eax
            kprintf("[keyboard] BUFFER OVERFLOW! \n");
  100ad7:	89 04 24             	mov    %eax,(%esp)
  100ada:	e8 d1 f7 ff ff       	call   1002b0 <kprintf>
  100adf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        }
    }
  100ae2:	e9 00 00 00 00       	jmp    100ae7 <irq_handler+0x2e7>
}
  100ae7:	83 c4 40             	add    $0x40,%esp
  100aea:	5e                   	pop    %esi
  100aeb:	5f                   	pop    %edi
  100aec:	5d                   	pop    %ebp
  100aed:	c3                   	ret    
  100aee:	66 90                	xchg   %ax,%ax

00100af0 <inb>:
    uint16_t result;
    asm volatile ("inw %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline uint8_t inb(uint16_t _port) {
  100af0:	55                   	push   %ebp
  100af1:	89 e5                	mov    %esp,%ebp
  100af3:	50                   	push   %eax
  100af4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100af8:	66 89 c1             	mov    %ax,%cx
  100afb:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
    uint8_t result;
    asm volatile ("inb %1, %0" : "=a" (result) : "Nd" (_port));
  100aff:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  100b03:	ec                   	in     (%dx),%al
  100b04:	88 45 fd             	mov    %al,-0x3(%ebp)
    return result;
  100b07:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  100b0b:	83 c4 04             	add    $0x4,%esp
  100b0e:	5d                   	pop    %ebp
  100b0f:	c3                   	ret    

00100b10 <translate_scancode>:
uint32_t key_flags[256];

struct res_handle* charout = 0;

static uint8_t translate_scancode(int set, uint16_t scancode)
{
  100b10:	55                   	push   %ebp
  100b11:	89 e5                	mov    %esp,%ebp
  100b13:	83 ec 28             	sub    $0x28,%esp
  100b16:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  100b1a:	66 89 c1             	mov    %ax,%cx
  100b1d:	8b 45 08             	mov    0x8(%ebp),%eax
  100b20:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100b23:	66 89 4d fa          	mov    %cx,-0x6(%ebp)
    uint8_t keycode = 0;
  100b27:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)

    switch (set) {
  100b2b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100b2e:	89 c2                	mov    %eax,%edx
  100b30:	83 ea 02             	sub    $0x2,%edx
  100b33:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100b36:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100b39:	0f 84 4f 00 00 00    	je     100b8e <translate_scancode+0x7e>
  100b3f:	e9 00 00 00 00       	jmp    100b44 <translate_scancode+0x34>
  100b44:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b47:	83 e8 01             	sub    $0x1,%eax
  100b4a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100b4d:	0f 84 28 00 00 00    	je     100b7b <translate_scancode+0x6b>
  100b53:	e9 00 00 00 00       	jmp    100b58 <translate_scancode+0x48>
  100b58:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100b5b:	85 c0                	test   %eax,%eax
  100b5d:	0f 85 54 00 00 00    	jne    100bb7 <translate_scancode+0xa7>
  100b63:	e9 00 00 00 00       	jmp    100b68 <translate_scancode+0x58>
        // Normal scancodes
        case 0:
            keycode = sc_to_kc[0][scancode];
  100b68:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100b6c:	8a 0c 05 08 71 10 00 	mov    0x107108(,%eax,1),%cl
  100b73:	88 4d f9             	mov    %cl,-0x7(%ebp)
            break;
  100b76:	e9 3c 00 00 00       	jmp    100bb7 <translate_scancode+0xa7>

        // e0-Scancodes
        case 1:
            keycode = sc_to_kc[1][scancode];
  100b7b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100b7f:	8a 0c 05 88 71 10 00 	mov    0x107188(,%eax,1),%cl
  100b86:	88 4d f9             	mov    %cl,-0x7(%ebp)
            break;
  100b89:	e9 29 00 00 00       	jmp    100bb7 <translate_scancode+0xa7>

        // e1-Scancodes
        case 2:
            switch (scancode) {
  100b8e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100b92:	2d 1d 45 00 00       	sub    $0x451d,%eax
  100b97:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100b9a:	0f 85 0e 00 00 00    	jne    100bae <translate_scancode+0x9e>
  100ba0:	e9 00 00 00 00       	jmp    100ba5 <translate_scancode+0x95>
                // Pause
                case 0x451D:
                    keycode = 119;
  100ba5:	c6 45 f9 77          	movb   $0x77,-0x7(%ebp)
                    break;
  100ba9:	e9 04 00 00 00       	jmp    100bb2 <translate_scancode+0xa2>

                default:
                    keycode = 0x0;
  100bae:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)
            };
            break;
  100bb2:	e9 00 00 00 00       	jmp    100bb7 <translate_scancode+0xa7>
    }

    if (keycode == 0) {
  100bb7:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  100bbb:	3d 00 00 00 00       	cmp    $0x0,%eax
  100bc0:	0f 85 20 00 00 00    	jne    100be6 <translate_scancode+0xd6>
  100bc6:	8d 05 34 82 10 00    	lea    0x108234,%eax
        kprintf("kbc: Unknown Scancode: 0x%x (%d)\n", scancode, set);
  100bcc:	0f b7 4d fa          	movzwl -0x6(%ebp),%ecx
  100bd0:	8b 55 fc             	mov    -0x4(%ebp),%edx
  100bd3:	89 04 24             	mov    %eax,(%esp)
  100bd6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100bda:	89 54 24 08          	mov    %edx,0x8(%esp)
  100bde:	e8 cd f6 ff ff       	call   1002b0 <kprintf>
  100be3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }

    return keycode;
  100be6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  100bea:	83 c4 28             	add    $0x28,%esp
  100bed:	5d                   	pop    %ebp
  100bee:	c3                   	ret    
  100bef:	90                   	nop

00100bf0 <getchar>:
}

static char getchar(uint8_t keycode) {
  100bf0:	55                   	push   %ebp
  100bf1:	89 e5                	mov    %esp,%ebp
  100bf3:	83 ec 08             	sub    $0x8,%esp
  100bf6:	8a 45 08             	mov    0x8(%ebp),%al
  100bf9:	88 45 ff             	mov    %al,-0x1(%ebp)
    uint32_t index = 0;
  100bfc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

    if(key_flags[0x2A] & KF_PRESSED) index = 1; //LSHIFT
  100c03:	8b 0d 10 95 12 00    	mov    0x129510,%ecx
  100c09:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100c0f:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100c15:	0f 84 07 00 00 00    	je     100c22 <getchar+0x32>
  100c1b:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
    if(key_flags[0x36] & KF_PRESSED) index = 1; //RSHIFT
  100c22:	a1 40 95 12 00       	mov    0x129540,%eax
  100c27:	25 01 00 00 00       	and    $0x1,%eax
  100c2c:	3d 00 00 00 00       	cmp    $0x0,%eax
  100c31:	0f 84 07 00 00 00    	je     100c3e <getchar+0x4e>
  100c37:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  100c3e:	8d 05 08 70 10 00    	lea    0x107008,%eax

    return kc_to_char[index][keycode];
  100c44:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  100c48:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100c4b:	c1 e2 07             	shl    $0x7,%edx
  100c4e:	01 d0                	add    %edx,%eax
  100c50:	0f be 04 08          	movsbl (%eax,%ecx,1),%eax
  100c54:	83 c4 08             	add    $0x8,%esp
  100c57:	5d                   	pop    %ebp
  100c58:	c3                   	ret    
  100c59:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00100c60 <driver_keyboard_init>:
        }
    }
}

void driver_keyboard_init(void)
{
  100c60:	55                   	push   %ebp
  100c61:	89 e5                	mov    %esp,%ebp
  100c63:	56                   	push   %esi
  100c64:	83 ec 54             	sub    $0x54,%esp
  100c67:	b8 21 00 00 00       	mov    $0x21,%eax
  100c6c:	8d 0d 00 08 10 00    	lea    0x100800,%ecx
    register_intr_handler(0x21, &irq_handler);
  100c72:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100c79:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100c7d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100c80:	e8 eb 11 00 00       	call   101e70 <register_intr_handler>
  100c85:	b8 64 00 00 00       	mov    $0x64,%eax

    while (inb(0x64) & 0x1) {
  100c8a:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100c91:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100c94:	e8 57 fe ff ff       	call   100af0 <inb>
  100c99:	0f b6 c8             	movzbl %al,%ecx
  100c9c:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100ca2:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100ca8:	0f 84 1c 00 00 00    	je     100cca <driver_keyboard_init+0x6a>
  100cae:	b8 60 00 00 00       	mov    $0x60,%eax
        inb(0x60);
  100cb3:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100cba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100cbd:	e8 2e fe ff ff       	call   100af0 <inb>
    }
  100cc2:	88 45 eb             	mov    %al,-0x15(%ebp)
  100cc5:	e9 bb ff ff ff       	jmp    100c85 <driver_keyboard_init+0x25>
  100cca:	b8 ed 00 00 00       	mov    $0xed,%eax
  100ccf:	8d 0d 68 94 12 00    	lea    0x129468,%ecx
  100cd5:	ba 00 00 00 00       	mov    $0x0,%edx
  100cda:	be 04 00 00 00       	mov    $0x4,%esi

    memset(key_flags, 256, sizeof(uint32_t));
  100cdf:	89 0c 24             	mov    %ecx,(%esp)
  100ce2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ce9:	00 
  100cea:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  100cf1:	00 
  100cf2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100cf5:	89 75 e0             	mov    %esi,-0x20(%ebp)
  100cf8:	89 55 dc             	mov    %edx,-0x24(%ebp)
  100cfb:	e8 e0 3e 00 00       	call   104be0 <memset>

    // Leds alle ausloeschen
    send_command(0xED);
  100d00:	c7 04 24 ed 00 00 00 	movl   $0xed,(%esp)
  100d07:	e8 c4 00 00 00       	call   100dd0 <send_command>
  100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
    send_command(0);
  100d11:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100d18:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100d1b:	e8 b0 00 00 00       	call   100dd0 <send_command>
  100d20:	b8 f3 00 00 00       	mov    $0xf3,%eax

    // Schnellste Wiederholrate
    send_command(0xF3);
  100d25:	c7 04 24 f3 00 00 00 	movl   $0xf3,(%esp)
  100d2c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100d2f:	e8 9c 00 00 00       	call   100dd0 <send_command>
  100d34:	b8 00 00 00 00       	mov    $0x0,%eax
    send_command(0);
  100d39:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100d40:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100d43:	e8 88 00 00 00       	call   100dd0 <send_command>
  100d48:	b8 f4 00 00 00       	mov    $0xf4,%eax

    send_command(0xF4);
  100d4d:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp)
  100d54:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100d57:	e8 74 00 00 00       	call   100dd0 <send_command>
  100d5c:	8d 05 26 82 10 00    	lea    0x108226,%eax
  100d62:	8d 4d f8             	lea    -0x8(%ebp),%ecx

    vfs_create_kfile("/dev/keyboard", ramfs_fifo_driver_struct(), &(uint32_t){512});
  100d65:	89 45 c8             	mov    %eax,-0x38(%ebp)
  100d68:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  100d6b:	e8 a0 2b 00 00       	call   103910 <ramfs_fifo_driver_struct>
  100d70:	c7 45 f8 00 02 00 00 	movl   $0x200,-0x8(%ebp)
  100d77:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  100d7a:	89 0c 24             	mov    %ecx,(%esp)
  100d7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  100d81:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  100d84:	89 44 24 08          	mov    %eax,0x8(%esp)
  100d88:	e8 73 45 00 00       	call   105300 <vfs_create_kfile>
  100d8d:	8d 0d 26 82 10 00    	lea    0x108226,%ecx
  100d93:	ba 02 00 00 00       	mov    $0x2,%edx
    charout = vfs_open("/dev/keyboard", FM_WRITE);
  100d98:	89 0c 24             	mov    %ecx,(%esp)
  100d9b:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  100da2:	00 
  100da3:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100da6:	89 55 bc             	mov    %edx,-0x44(%ebp)
  100da9:	e8 c2 46 00 00       	call   105470 <vfs_open>
  100dae:	a3 14 90 10 00       	mov    %eax,0x109014

    init_done = 1;
  100db3:	c7 05 10 90 10 00 01 	movl   $0x1,0x109010
  100dba:	00 00 00 
}
  100dbd:	83 c4 54             	add    $0x54,%esp
  100dc0:	5e                   	pop    %esi
  100dc1:	5d                   	pop    %ebp
  100dc2:	c3                   	ret    
  100dc3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  100dca:	84 00 00 00 00 00 

00100dd0 <send_command>:

    return kc_to_char[index][keycode];
}

static void send_command(uint8_t command)
{
  100dd0:	55                   	push   %ebp
  100dd1:	89 e5                	mov    %esp,%ebp
  100dd3:	83 ec 28             	sub    $0x28,%esp
  100dd6:	8a 45 08             	mov    0x8(%ebp),%al
  100dd9:	88 45 ff             	mov    %al,-0x1(%ebp)
    do {
        while (inb(0x64) & 0x2) {
  100ddc:	e9 00 00 00 00       	jmp    100de1 <send_command+0x11>
  100de1:	b8 64 00 00 00       	mov    $0x64,%eax
  100de6:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100ded:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100df0:	e8 fb fc ff ff       	call   100af0 <inb>
  100df5:	0f b6 c8             	movzbl %al,%ecx
  100df8:	81 e1 02 00 00 00    	and    $0x2,%ecx
  100dfe:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100e04:	0f 84 05 00 00 00    	je     100e0f <send_command+0x3f>
        }
  100e0a:	e9 d2 ff ff ff       	jmp    100de1 <send_command+0x11>
  100e0f:	b8 60 00 00 00       	mov    $0x60,%eax

        outb(0x60, command);
  100e14:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100e1b:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  100e1f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100e23:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100e26:	e8 65 00 00 00       	call   100e90 <outb>
  100e2b:	b8 64 00 00 00       	mov    $0x64,%eax

        while ((inb(0x64) & 0x1) == 0) {
  100e30:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100e37:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100e3a:	e8 b1 fc ff ff       	call   100af0 <inb>
  100e3f:	0f b6 c8             	movzbl %al,%ecx
  100e42:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100e48:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100e4e:	0f 85 05 00 00 00    	jne    100e59 <send_command+0x89>
        }
  100e54:	e9 d2 ff ff ff       	jmp    100e2b <send_command+0x5b>
    } while (inb(0x60) == 0xfe);
  100e59:	e9 00 00 00 00       	jmp    100e5e <send_command+0x8e>
  100e5e:	b8 60 00 00 00       	mov    $0x60,%eax
  100e63:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100e6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100e6d:	e8 7e fc ff ff       	call   100af0 <inb>
  100e72:	0f b6 c8             	movzbl %al,%ecx
  100e75:	81 f9 fe 00 00 00    	cmp    $0xfe,%ecx
  100e7b:	0f 84 5b ff ff ff    	je     100ddc <send_command+0xc>
}
  100e81:	83 c4 28             	add    $0x28,%esp
  100e84:	5d                   	pop    %ebp
  100e85:	c3                   	ret    
  100e86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  100e8d:	00 00 00 

00100e90 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  100e90:	55                   	push   %ebp
  100e91:	89 e5                	mov    %esp,%ebp
  100e93:	50                   	push   %eax
  100e94:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100e98:	66 89 c1             	mov    %ax,%cx
  100e9b:	8a 55 0c             	mov    0xc(%ebp),%dl
  100e9e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  100ea2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  100ea5:	8a 45 fd             	mov    -0x3(%ebp),%al
  100ea8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  100eac:	ee                   	out    %al,(%dx)
}
  100ead:	83 c4 04             	add    $0x4,%esp
  100eb0:	5d                   	pop    %ebp
  100eb1:	c3                   	ret    
  100eb2:	66 90                	xchg   %ax,%ax
  100eb4:	66 90                	xchg   %ax,%ax
  100eb6:	66 90                	xchg   %ax,%ax
  100eb8:	66 90                	xchg   %ax,%ax
  100eba:	66 90                	xchg   %ax,%ax
  100ebc:	66 90                	xchg   %ax,%ax
  100ebe:	66 90                	xchg   %ax,%ax

00100ec0 <load_gdt>:

#define GDT_ENTRIES 6

uint64_t gdt[GDT_ENTRIES];

void load_gdt() {
  100ec0:	55                   	push   %ebp
  100ec1:	89 e5                	mov    %esp,%ebp
	struct {
  100ec3:	83 ec 08             	sub    $0x8,%esp
  100ec6:	a1 24 80 10 00       	mov    0x108024,%eax
  100ecb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100ece:	66 8b 0d 28 80 10 00 	mov    0x108028,%cx
  100ed5:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
		uint16_t limit;
		void* pointer;
	}__attribute__((packed)) gdtp = { .limit = GDT_ENTRIES * 8 - 1, .pointer =
			gdt, };

	asm volatile("lgdt %0" : : "m" (gdtp));
  100ed9:	0f 01 55 f8          	lgdtl  -0x8(%ebp)

	asm ("mov $0x10, %ax");
  100edd:	66 b8 10 00          	mov    $0x10,%ax
	asm ("mov %ax, %ds");
  100ee1:	66 8e d8             	mov    %ax,%ds
	asm ("mov %ax, %es");
  100ee4:	66 8e c0             	mov    %ax,%es
	asm ("mov %ax, %fs");
  100ee7:	66 8e e0             	mov    %ax,%fs
	asm ("mov %ax, %gs");
  100eea:	66 8e e8             	mov    %ax,%gs
	asm ("mov %ax, %ss");
  100eed:	66 8e d0             	mov    %ax,%ss
	//asm ("ljmp $0x8, $.1");
	//asm (".1:");
}
  100ef0:	83 c4 08             	add    $0x8,%esp
  100ef3:	5d                   	pop    %ebp
  100ef4:	c3                   	ret    
  100ef5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  100efc:	00 00 00 00 

00100f00 <set_gdt_entry>:

void set_gdt_entry(int i, unsigned int base, unsigned int limit, int flags) {
  100f00:	55                   	push   %ebp
  100f01:	89 e5                	mov    %esp,%ebp
  100f03:	56                   	push   %esi
  100f04:	83 ec 10             	sub    $0x10,%esp
  100f07:	8b 45 14             	mov    0x14(%ebp),%eax
  100f0a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  100f0d:	8b 55 0c             	mov    0xc(%ebp),%edx
  100f10:	8b 75 08             	mov    0x8(%ebp),%esi
  100f13:	89 75 f8             	mov    %esi,-0x8(%ebp)
  100f16:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100f19:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100f1c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gdt[i] = limit & 0xffffLL;
  100f1f:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  100f23:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100f26:	89 04 cd 68 98 12 00 	mov    %eax,0x129868(,%ecx,8)
  100f2d:	c7 04 cd 6c 98 12 00 	movl   $0x0,0x12986c(,%ecx,8)
  100f34:	00 00 00 00 
	gdt[i] |= (base & 0xffffffLL) << 16;
  100f38:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100f3b:	25 ff ff ff 00       	and    $0xffffff,%eax
  100f40:	89 c1                	mov    %eax,%ecx
  100f42:	c1 e1 10             	shl    $0x10,%ecx
  100f45:	c1 e8 10             	shr    $0x10,%eax
  100f48:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100f4b:	8b 34 d5 6c 98 12 00 	mov    0x12986c(,%edx,8),%esi
  100f52:	09 f0                	or     %esi,%eax
  100f54:	8b 34 d5 68 98 12 00 	mov    0x129868(,%edx,8),%esi
  100f5b:	09 ce                	or     %ecx,%esi
  100f5d:	89 04 d5 6c 98 12 00 	mov    %eax,0x12986c(,%edx,8)
  100f64:	89 34 d5 68 98 12 00 	mov    %esi,0x129868(,%edx,8)
	gdt[i] |= (flags & 0xffLL) << 40;
  100f6b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100f6f:	c1 e0 08             	shl    $0x8,%eax
  100f72:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100f75:	8b 14 cd 68 98 12 00 	mov    0x129868(,%ecx,8),%edx
  100f7c:	8b 34 cd 6c 98 12 00 	mov    0x12986c(,%ecx,8),%esi
  100f83:	09 c6                	or     %eax,%esi
  100f85:	89 14 cd 68 98 12 00 	mov    %edx,0x129868(,%ecx,8)
  100f8c:	89 34 cd 6c 98 12 00 	mov    %esi,0x12986c(,%ecx,8)
	gdt[i] |= ((limit >> 16) & 0xfLL) << 48;
  100f93:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  100f97:	83 e0 0f             	and    $0xf,%eax
  100f9a:	c1 e0 10             	shl    $0x10,%eax
  100f9d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100fa0:	8b 14 cd 68 98 12 00 	mov    0x129868(,%ecx,8),%edx
  100fa7:	8b 34 cd 6c 98 12 00 	mov    0x12986c(,%ecx,8),%esi
  100fae:	09 c6                	or     %eax,%esi
  100fb0:	89 14 cd 68 98 12 00 	mov    %edx,0x129868(,%ecx,8)
  100fb7:	89 34 cd 6c 98 12 00 	mov    %esi,0x12986c(,%ecx,8)
	gdt[i] |= ((flags >> 8) & 0xffLL) << 52;
  100fbe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100fc1:	c1 e0 0c             	shl    $0xc,%eax
  100fc4:	25 00 00 f0 0f       	and    $0xff00000,%eax
  100fc9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100fcc:	8b 14 cd 68 98 12 00 	mov    0x129868(,%ecx,8),%edx
  100fd3:	8b 34 cd 6c 98 12 00 	mov    0x12986c(,%ecx,8),%esi
  100fda:	09 c6                	or     %eax,%esi
  100fdc:	89 14 cd 68 98 12 00 	mov    %edx,0x129868(,%ecx,8)
  100fe3:	89 34 cd 6c 98 12 00 	mov    %esi,0x12986c(,%ecx,8)
	gdt[i] |= ((base >> 24) & 0xffLL) << 56;
  100fea:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100fee:	c1 e0 18             	shl    $0x18,%eax
  100ff1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100ff4:	8b 14 cd 68 98 12 00 	mov    0x129868(,%ecx,8),%edx
  100ffb:	8b 34 cd 6c 98 12 00 	mov    0x12986c(,%ecx,8),%esi
  101002:	09 c6                	or     %eax,%esi
  101004:	89 14 cd 68 98 12 00 	mov    %edx,0x129868(,%ecx,8)
  10100b:	89 34 cd 6c 98 12 00 	mov    %esi,0x12986c(,%ecx,8)
}
  101012:	83 c4 10             	add    $0x10,%esp
  101015:	5e                   	pop    %esi
  101016:	5d                   	pop    %ebp
  101017:	c3                   	ret    
  101018:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10101f:	00 

00101020 <init_gdt>:

void init_gdt(void) {
  101020:	55                   	push   %ebp
  101021:	89 e5                	mov    %esp,%ebp
  101023:	56                   	push   %esi
  101024:	83 ec 54             	sub    $0x54,%esp
  101027:	b8 00 00 00 00       	mov    $0x0,%eax
	set_gdt_entry(0, 0, 0, 0);
  10102c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  101033:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10103a:	00 
  10103b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101042:	00 
  101043:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10104a:	00 
  10104b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10104e:	e8 ad fe ff ff       	call   100f00 <set_gdt_entry>
  101053:	b8 01 00 00 00       	mov    $0x1,%eax
  101058:	b9 00 00 00 00       	mov    $0x0,%ecx
  10105d:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  101062:	be 9a 0c 00 00       	mov    $0xc9a,%esi
	set_gdt_entry(1, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  101067:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  10106e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101075:	00 
  101076:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  10107d:	00 
  10107e:	c7 44 24 0c 9a 0c 00 	movl   $0xc9a,0xc(%esp)
  101085:	00 
  101086:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101089:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10108c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  10108f:	89 75 e8             	mov    %esi,-0x18(%ebp)
  101092:	e8 69 fe ff ff       	call   100f00 <set_gdt_entry>
  101097:	b8 02 00 00 00       	mov    $0x2,%eax
  10109c:	b9 00 00 00 00       	mov    $0x0,%ecx
  1010a1:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  1010a6:	be 92 0c 00 00       	mov    $0xc92,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(2, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  1010ab:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  1010b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1010b9:	00 
  1010ba:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  1010c1:	00 
  1010c2:	c7 44 24 0c 92 0c 00 	movl   $0xc92,0xc(%esp)
  1010c9:	00 
  1010ca:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1010cd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1010d0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  1010d3:	89 75 d8             	mov    %esi,-0x28(%ebp)
  1010d6:	e8 25 fe ff ff       	call   100f00 <set_gdt_entry>
  1010db:	b8 03 00 00 00       	mov    $0x3,%eax
  1010e0:	b9 00 00 00 00       	mov    $0x0,%ecx
  1010e5:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  1010ea:	be fa 0c 00 00       	mov    $0xcfa,%esi
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(3, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  1010ef:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1010f6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1010fd:	00 
  1010fe:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  101105:	00 
  101106:	c7 44 24 0c fa 0c 00 	movl   $0xcfa,0xc(%esp)
  10110d:	00 
  10110e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  101111:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  101114:	89 55 cc             	mov    %edx,-0x34(%ebp)
  101117:	89 75 c8             	mov    %esi,-0x38(%ebp)
  10111a:	e8 e1 fd ff ff       	call   100f00 <set_gdt_entry>
  10111f:	b8 04 00 00 00       	mov    $0x4,%eax
  101124:	b9 00 00 00 00       	mov    $0x0,%ecx
  101129:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  10112e:	be f2 0c 00 00       	mov    $0xcf2,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);
	set_gdt_entry(4, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  101133:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10113a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101141:	00 
  101142:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  101149:	00 
  10114a:	c7 44 24 0c f2 0c 00 	movl   $0xcf2,0xc(%esp)
  101151:	00 
  101152:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  101155:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  101158:	89 55 bc             	mov    %edx,-0x44(%ebp)
  10115b:	89 75 b8             	mov    %esi,-0x48(%ebp)
  10115e:	e8 9d fd ff ff       	call   100f00 <set_gdt_entry>
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	load_gdt();
  101163:	e8 58 fd ff ff       	call   100ec0 <load_gdt>
}
  101168:	83 c4 54             	add    $0x54,%esp
  10116b:	5e                   	pop    %esi
  10116c:	5d                   	pop    %ebp
  10116d:	c3                   	ret    
  10116e:	66 90                	xchg   %ax,%ax

00101170 <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  101170:	55                   	push   %ebp
  101171:	89 e5                	mov    %esp,%ebp
  101173:	53                   	push   %ebx
  101174:	57                   	push   %edi
  101175:	56                   	push   %esi
  101176:	83 ec 10             	sub    $0x10,%esp
  101179:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  10117d:	66 89 c1             	mov    %ax,%cx
  101180:	8a 55 14             	mov    0x14(%ebp),%dl
  101183:	8b 45 0c             	mov    0xc(%ebp),%eax
  101186:	8b 75 08             	mov    0x8(%ebp),%esi
  101189:	89 75 f0             	mov    %esi,-0x10(%ebp)
  10118c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10118f:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  101193:	88 55 e9             	mov    %dl,-0x17(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  101196:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101199:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	idt[i] = handler & 0xffffLL;
  10119c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  1011a0:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1011a3:	89 04 f5 28 90 10 00 	mov    %eax,0x109028(,%esi,8)
  1011aa:	c7 04 f5 2c 90 10 00 	movl   $0x0,0x10902c(,%esi,8)
  1011b1:	00 00 00 00 
	idt[i] |= (selector & 0xffffLL) << 16;
  1011b5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
  1011b9:	c1 e0 10             	shl    $0x10,%eax
  1011bc:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1011bf:	8b 3c f5 2c 90 10 00 	mov    0x10902c(,%esi,8),%edi
  1011c6:	8b 1c f5 28 90 10 00 	mov    0x109028(,%esi,8),%ebx
  1011cd:	09 c3                	or     %eax,%ebx
  1011cf:	89 3c f5 2c 90 10 00 	mov    %edi,0x10902c(,%esi,8)
  1011d6:	89 1c f5 28 90 10 00 	mov    %ebx,0x109028(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  1011dd:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  1011e1:	c1 e0 08             	shl    $0x8,%eax
  1011e4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1011e7:	8b 3c f5 28 90 10 00 	mov    0x109028(,%esi,8),%edi
  1011ee:	8b 1c f5 2c 90 10 00 	mov    0x10902c(,%esi,8),%ebx
  1011f5:	09 c3                	or     %eax,%ebx
  1011f7:	89 3c f5 28 90 10 00 	mov    %edi,0x109028(,%esi,8)
  1011fe:	89 1c f5 2c 90 10 00 	mov    %ebx,0x10902c(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  101205:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  101209:	c1 e0 10             	shl    $0x10,%eax
  10120c:	8b 75 f0             	mov    -0x10(%ebp),%esi
  10120f:	8b 3c f5 28 90 10 00 	mov    0x109028(,%esi,8),%edi
  101216:	8b 1c f5 2c 90 10 00 	mov    0x10902c(,%esi,8),%ebx
  10121d:	09 c3                	or     %eax,%ebx
  10121f:	89 3c f5 28 90 10 00 	mov    %edi,0x109028(,%esi,8)
  101226:	89 1c f5 2c 90 10 00 	mov    %ebx,0x10902c(,%esi,8)
}
  10122d:	83 c4 10             	add    $0x10,%esp
  101230:	5e                   	pop    %esi
  101231:	5f                   	pop    %edi
  101232:	5b                   	pop    %ebx
  101233:	5d                   	pop    %ebp
  101234:	c3                   	ret    
  101235:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10123c:	00 00 00 00 

00101240 <init_idt>:

void init_idt() {
  101240:	55                   	push   %ebp
  101241:	89 e5                	mov    %esp,%ebp
	struct {
  101243:	56                   	push   %esi
  101244:	81 ec 34 02 00 00    	sub    $0x234,%esp
  10124a:	a1 2a 80 10 00       	mov    0x10802a,%eax
  10124f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101252:	66 8b 0d 2e 80 10 00 	mov    0x10802e,%cx
  101259:	66 89 4d f4          	mov    %cx,-0xc(%ebp)
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;
  10125d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  101264:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  10126b:	81 7d ec 40 00 00 00 	cmpl   $0x40,-0x14(%ebp)
  101272:	0f 8d 1e 00 00 00    	jge    101296 <init_idt+0x56>
		handler_set[i] = 0;
  101278:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10127b:	c7 04 85 28 92 10 00 	movl   $0x0,0x109228(,%eax,4)
  101282:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  101286:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101289:	05 01 00 00 00       	add    $0x1,%eax
  10128e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101291:	e9 d5 ff ff ff       	jmp    10126b <init_idt+0x2b>
  101296:	b8 20 00 00 00       	mov    $0x20,%eax
  10129b:	b9 11 00 00 00       	mov    $0x11,%ecx
		handler_set[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  1012a0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1012a7:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  1012ae:	00 
  1012af:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1012b2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1012b5:	e8 86 0b 00 00       	call   101e40 <outb>
  1012ba:	b8 21 00 00 00       	mov    $0x21,%eax
  1012bf:	b9 20 00 00 00       	mov    $0x20,%ecx
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  1012c4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1012cb:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  1012d2:	00 
  1012d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1012d6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1012d9:	e8 62 0b 00 00       	call   101e40 <outb>
  1012de:	b8 21 00 00 00       	mov    $0x21,%eax
  1012e3:	b9 04 00 00 00       	mov    $0x4,%ecx
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  1012e8:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1012ef:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  1012f6:	00 
  1012f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1012fa:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  1012fd:	e8 3e 0b 00 00       	call   101e40 <outb>
  101302:	b8 21 00 00 00       	mov    $0x21,%eax
  101307:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0x21, 0x01); // ICW 4
  10130c:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101313:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  10131a:	00 
  10131b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10131e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  101321:	e8 1a 0b 00 00       	call   101e40 <outb>
  101326:	b8 a0 00 00 00       	mov    $0xa0,%eax
  10132b:	b9 11 00 00 00       	mov    $0x11,%ecx

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  101330:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  101337:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  10133e:	00 
  10133f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  101342:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  101345:	e8 f6 0a 00 00       	call   101e40 <outb>
  10134a:	b8 a1 00 00 00       	mov    $0xa1,%eax
  10134f:	b9 28 00 00 00       	mov    $0x28,%ecx
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  101354:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  10135b:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  101362:	00 
  101363:	89 45 c0             	mov    %eax,-0x40(%ebp)
  101366:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  101369:	e8 d2 0a 00 00       	call   101e40 <outb>
  10136e:	b8 a1 00 00 00       	mov    $0xa1,%eax
  101373:	b9 02 00 00 00       	mov    $0x2,%ecx
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  101378:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  10137f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  101386:	00 
  101387:	89 45 b8             	mov    %eax,-0x48(%ebp)
  10138a:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  10138d:	e8 ae 0a 00 00       	call   101e40 <outb>
  101392:	b8 a1 00 00 00       	mov    $0xa1,%eax
  101397:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0xa1, 0x01); // ICW 4
  10139c:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  1013a3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  1013aa:	00 
  1013ab:	89 45 b0             	mov    %eax,-0x50(%ebp)
  1013ae:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  1013b1:	e8 8a 0a 00 00       	call   101e40 <outb>
  1013b6:	b8 20 00 00 00       	mov    $0x20,%eax
  1013bb:	b9 00 00 00 00       	mov    $0x0,%ecx

	outb(0x20, 0x0);
  1013c0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  1013c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1013ce:	00 
  1013cf:	89 45 a8             	mov    %eax,-0x58(%ebp)
  1013d2:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  1013d5:	e8 66 0a 00 00       	call   101e40 <outb>
  1013da:	b8 a0 00 00 00       	mov    $0xa0,%eax
  1013df:	b9 00 00 00 00       	mov    $0x0,%ecx
	outb(0xa0, 0x0);
  1013e4:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  1013eb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1013f2:	00 
  1013f3:	89 45 a0             	mov    %eax,-0x60(%ebp)
  1013f6:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  1013f9:	e8 42 0a 00 00       	call   101e40 <outb>
  1013fe:	b8 00 00 00 00       	mov    $0x0,%eax
  101403:	8d 0d 1c 20 10 00    	lea    0x10201c,%ecx
  101409:	ba 08 00 00 00       	mov    $0x8,%edx
  10140e:	be 8e 00 00 00       	mov    $0x8e,%esi

	idt_set_entry(0, intr_stub_0, 0x8,
  101413:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10141a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10141e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101425:	00 
  101426:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10142d:	00 
  10142e:	89 45 98             	mov    %eax,-0x68(%ebp)
  101431:	89 75 94             	mov    %esi,-0x6c(%ebp)
  101434:	89 55 90             	mov    %edx,-0x70(%ebp)
  101437:	e8 34 fd ff ff       	call   101170 <idt_set_entry>
  10143c:	b8 01 00 00 00       	mov    $0x1,%eax
  101441:	8d 0d 25 20 10 00    	lea    0x102025,%ecx
  101447:	ba 08 00 00 00       	mov    $0x8,%edx
  10144c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  101451:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  101458:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10145c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101463:	00 
  101464:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10146b:	00 
  10146c:	89 45 8c             	mov    %eax,-0x74(%ebp)
  10146f:	89 75 88             	mov    %esi,-0x78(%ebp)
  101472:	89 55 84             	mov    %edx,-0x7c(%ebp)
  101475:	e8 f6 fc ff ff       	call   101170 <idt_set_entry>
  10147a:	b8 02 00 00 00       	mov    $0x2,%eax
  10147f:	8d 0d 2e 20 10 00    	lea    0x10202e,%ecx
  101485:	ba 08 00 00 00       	mov    $0x8,%edx
  10148a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  10148f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  101496:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10149a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014a1:	00 
  1014a2:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014a9:	00 
  1014aa:	89 45 80             	mov    %eax,-0x80(%ebp)
  1014ad:	89 b5 7c ff ff ff    	mov    %esi,-0x84(%ebp)
  1014b3:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
  1014b9:	e8 b2 fc ff ff       	call   101170 <idt_set_entry>
  1014be:	b8 03 00 00 00       	mov    $0x3,%eax
  1014c3:	8d 0d 37 20 10 00    	lea    0x102037,%ecx
  1014c9:	ba 08 00 00 00       	mov    $0x8,%edx
  1014ce:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  1014d3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  1014da:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014de:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014e5:	00 
  1014e6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014ed:	00 
  1014ee:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  1014f4:	89 b5 70 ff ff ff    	mov    %esi,-0x90(%ebp)
  1014fa:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  101500:	e8 6b fc ff ff       	call   101170 <idt_set_entry>
  101505:	b8 04 00 00 00       	mov    $0x4,%eax
  10150a:	8d 0d 40 20 10 00    	lea    0x102040,%ecx
  101510:	ba 08 00 00 00       	mov    $0x8,%edx
  101515:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  10151a:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  101521:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101525:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10152c:	00 
  10152d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101534:	00 
  101535:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  10153b:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
  101541:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
  101547:	e8 24 fc ff ff       	call   101170 <idt_set_entry>
  10154c:	b8 05 00 00 00       	mov    $0x5,%eax
  101551:	8d 0d 49 20 10 00    	lea    0x102049,%ecx
  101557:	ba 08 00 00 00       	mov    $0x8,%edx
  10155c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  101561:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101568:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10156c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101573:	00 
  101574:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10157b:	00 
  10157c:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  101582:	89 b5 58 ff ff ff    	mov    %esi,-0xa8(%ebp)
  101588:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
  10158e:	e8 dd fb ff ff       	call   101170 <idt_set_entry>
  101593:	b8 06 00 00 00       	mov    $0x6,%eax
  101598:	8d 0d 52 20 10 00    	lea    0x102052,%ecx
  10159e:	ba 08 00 00 00       	mov    $0x8,%edx
  1015a3:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  1015a8:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  1015af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015b3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1015ba:	00 
  1015bb:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015c2:	00 
  1015c3:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  1015c9:	89 b5 4c ff ff ff    	mov    %esi,-0xb4(%ebp)
  1015cf:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
  1015d5:	e8 96 fb ff ff       	call   101170 <idt_set_entry>
  1015da:	b8 07 00 00 00       	mov    $0x7,%eax
  1015df:	8d 0d 5b 20 10 00    	lea    0x10205b,%ecx
  1015e5:	ba 08 00 00 00       	mov    $0x8,%edx
  1015ea:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  1015ef:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  1015f6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015fa:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101601:	00 
  101602:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101609:	00 
  10160a:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  101610:	89 b5 40 ff ff ff    	mov    %esi,-0xc0(%ebp)
  101616:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
  10161c:	e8 4f fb ff ff       	call   101170 <idt_set_entry>
  101621:	b8 08 00 00 00       	mov    $0x8,%eax
  101626:	8d 0d 64 20 10 00    	lea    0x102064,%ecx
  10162c:	ba 8e 00 00 00       	mov    $0x8e,%edx
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  101631:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  101638:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10163c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101643:	00 
  101644:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10164b:	00 
  10164c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
  101652:	89 95 34 ff ff ff    	mov    %edx,-0xcc(%ebp)
  101658:	e8 13 fb ff ff       	call   101170 <idt_set_entry>
  10165d:	b8 09 00 00 00       	mov    $0x9,%eax
  101662:	8d 0d 6b 20 10 00    	lea    0x10206b,%ecx
  101668:	ba 08 00 00 00       	mov    $0x8,%edx
  10166d:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  101672:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  101679:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10167d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101684:	00 
  101685:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10168c:	00 
  10168d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
  101693:	89 b5 2c ff ff ff    	mov    %esi,-0xd4(%ebp)
  101699:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%ebp)
  10169f:	e8 cc fa ff ff       	call   101170 <idt_set_entry>
  1016a4:	b8 0a 00 00 00       	mov    $0xa,%eax
  1016a9:	8d 0d 74 20 10 00    	lea    0x102074,%ecx
  1016af:	ba 08 00 00 00       	mov    $0x8,%edx
  1016b4:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  1016b9:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1016c0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016c4:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1016cb:	00 
  1016cc:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1016d3:	00 
  1016d4:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  1016da:	89 b5 20 ff ff ff    	mov    %esi,-0xe0(%ebp)
  1016e0:	89 95 1c ff ff ff    	mov    %edx,-0xe4(%ebp)
  1016e6:	e8 85 fa ff ff       	call   101170 <idt_set_entry>
  1016eb:	b8 0b 00 00 00       	mov    $0xb,%eax
  1016f0:	8d 0d 7b 20 10 00    	lea    0x10207b,%ecx
  1016f6:	ba 08 00 00 00       	mov    $0x8,%edx
  1016fb:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  101700:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  101707:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10170b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101712:	00 
  101713:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10171a:	00 
  10171b:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  101721:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%ebp)
  101727:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
  10172d:	e8 3e fa ff ff       	call   101170 <idt_set_entry>
  101732:	b8 0c 00 00 00       	mov    $0xc,%eax
  101737:	8d 0d 82 20 10 00    	lea    0x102082,%ecx
  10173d:	ba 08 00 00 00       	mov    $0x8,%edx
  101742:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  101747:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10174e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101752:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101759:	00 
  10175a:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101761:	00 
  101762:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  101768:	89 b5 08 ff ff ff    	mov    %esi,-0xf8(%ebp)
  10176e:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
  101774:	e8 f7 f9 ff ff       	call   101170 <idt_set_entry>
  101779:	b8 0d 00 00 00       	mov    $0xd,%eax
  10177e:	8d 0d 89 20 10 00    	lea    0x102089,%ecx
  101784:	ba 08 00 00 00       	mov    $0x8,%edx
  101789:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  10178e:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  101795:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101799:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017a0:	00 
  1017a1:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017a8:	00 
  1017a9:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
  1017af:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
  1017b5:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
  1017bb:	e8 b0 f9 ff ff       	call   101170 <idt_set_entry>
  1017c0:	b8 0e 00 00 00       	mov    $0xe,%eax
  1017c5:	8d 0d 90 20 10 00    	lea    0x102090,%ecx
  1017cb:	ba 08 00 00 00       	mov    $0x8,%edx
  1017d0:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  1017d5:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  1017dc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1017e0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017e7:	00 
  1017e8:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017ef:	00 
  1017f0:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
  1017f6:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
  1017fc:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
  101802:	e8 69 f9 ff ff       	call   101170 <idt_set_entry>
  101807:	b8 0f 00 00 00       	mov    $0xf,%eax
  10180c:	8d 0d 94 20 10 00    	lea    0x102094,%ecx
  101812:	ba 08 00 00 00       	mov    $0x8,%edx
  101817:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  10181c:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  101823:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101827:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10182e:	00 
  10182f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101836:	00 
  101837:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
  10183d:	89 b5 e4 fe ff ff    	mov    %esi,-0x11c(%ebp)
  101843:	89 95 e0 fe ff ff    	mov    %edx,-0x120(%ebp)
  101849:	e8 22 f9 ff ff       	call   101170 <idt_set_entry>
  10184e:	b8 10 00 00 00       	mov    $0x10,%eax
  101853:	8d 0d 9a 20 10 00    	lea    0x10209a,%ecx
  101859:	ba 08 00 00 00       	mov    $0x8,%edx
  10185e:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  101863:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10186a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10186e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101875:	00 
  101876:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10187d:	00 
  10187e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
  101884:	89 b5 d8 fe ff ff    	mov    %esi,-0x128(%ebp)
  10188a:	89 95 d4 fe ff ff    	mov    %edx,-0x12c(%ebp)
  101890:	e8 db f8 ff ff       	call   101170 <idt_set_entry>
  101895:	b8 11 00 00 00       	mov    $0x11,%eax
  10189a:	8d 0d a0 20 10 00    	lea    0x1020a0,%ecx
  1018a0:	ba 08 00 00 00       	mov    $0x8,%edx
  1018a5:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  1018aa:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  1018b1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018b5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1018bc:	00 
  1018bd:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1018c4:	00 
  1018c5:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
  1018cb:	89 b5 cc fe ff ff    	mov    %esi,-0x134(%ebp)
  1018d1:	89 95 c8 fe ff ff    	mov    %edx,-0x138(%ebp)
  1018d7:	e8 94 f8 ff ff       	call   101170 <idt_set_entry>
  1018dc:	b8 12 00 00 00       	mov    $0x12,%eax
  1018e1:	8d 0d a4 20 10 00    	lea    0x1020a4,%ecx
  1018e7:	ba 08 00 00 00       	mov    $0x8,%edx
  1018ec:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  1018f1:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  1018f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018fc:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101903:	00 
  101904:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10190b:	00 
  10190c:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  101912:	89 b5 c0 fe ff ff    	mov    %esi,-0x140(%ebp)
  101918:	89 95 bc fe ff ff    	mov    %edx,-0x144(%ebp)
  10191e:	e8 4d f8 ff ff       	call   101170 <idt_set_entry>
  101923:	b8 20 00 00 00       	mov    $0x20,%eax
  101928:	8d 0d aa 20 10 00    	lea    0x1020aa,%ecx
  10192e:	ba 08 00 00 00       	mov    $0x8,%edx
  101933:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  101938:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10193f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101943:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10194a:	00 
  10194b:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101952:	00 
  101953:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
  101959:	89 b5 b4 fe ff ff    	mov    %esi,-0x14c(%ebp)
  10195f:	89 95 b0 fe ff ff    	mov    %edx,-0x150(%ebp)
  101965:	e8 06 f8 ff ff       	call   101170 <idt_set_entry>
  10196a:	b8 21 00 00 00       	mov    $0x21,%eax
  10196f:	8d 0d b0 20 10 00    	lea    0x1020b0,%ecx
  101975:	ba 08 00 00 00       	mov    $0x8,%edx
  10197a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  10197f:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101986:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10198a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101991:	00 
  101992:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101999:	00 
  10199a:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
  1019a0:	89 b5 a8 fe ff ff    	mov    %esi,-0x158(%ebp)
  1019a6:	89 95 a4 fe ff ff    	mov    %edx,-0x15c(%ebp)
  1019ac:	e8 bf f7 ff ff       	call   101170 <idt_set_entry>
  1019b1:	b8 22 00 00 00       	mov    $0x22,%eax
  1019b6:	8d 0d b6 20 10 00    	lea    0x1020b6,%ecx
  1019bc:	ba 08 00 00 00       	mov    $0x8,%edx
  1019c1:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  1019c6:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1019cd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1019d1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1019d8:	00 
  1019d9:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1019e0:	00 
  1019e1:	89 85 a0 fe ff ff    	mov    %eax,-0x160(%ebp)
  1019e7:	89 b5 9c fe ff ff    	mov    %esi,-0x164(%ebp)
  1019ed:	89 95 98 fe ff ff    	mov    %edx,-0x168(%ebp)
  1019f3:	e8 78 f7 ff ff       	call   101170 <idt_set_entry>
  1019f8:	b8 23 00 00 00       	mov    $0x23,%eax
  1019fd:	8d 0d bc 20 10 00    	lea    0x1020bc,%ecx
  101a03:	ba 08 00 00 00       	mov    $0x8,%edx
  101a08:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  101a0d:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  101a14:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101a18:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101a1f:	00 
  101a20:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101a27:	00 
  101a28:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
  101a2e:	89 b5 90 fe ff ff    	mov    %esi,-0x170(%ebp)
  101a34:	89 95 8c fe ff ff    	mov    %edx,-0x174(%ebp)
  101a3a:	e8 31 f7 ff ff       	call   101170 <idt_set_entry>
  101a3f:	b8 24 00 00 00       	mov    $0x24,%eax
  101a44:	8d 0d c2 20 10 00    	lea    0x1020c2,%ecx
  101a4a:	ba 08 00 00 00       	mov    $0x8,%edx
  101a4f:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  101a54:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  101a5b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101a5f:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101a66:	00 
  101a67:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101a6e:	00 
  101a6f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
  101a75:	89 b5 84 fe ff ff    	mov    %esi,-0x17c(%ebp)
  101a7b:	89 95 80 fe ff ff    	mov    %edx,-0x180(%ebp)
  101a81:	e8 ea f6 ff ff       	call   101170 <idt_set_entry>
  101a86:	b8 25 00 00 00       	mov    $0x25,%eax
  101a8b:	8d 0d c8 20 10 00    	lea    0x1020c8,%ecx
  101a91:	ba 08 00 00 00       	mov    $0x8,%edx
  101a96:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  101a9b:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  101aa2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101aa6:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101aad:	00 
  101aae:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101ab5:	00 
  101ab6:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
  101abc:	89 b5 78 fe ff ff    	mov    %esi,-0x188(%ebp)
  101ac2:	89 95 74 fe ff ff    	mov    %edx,-0x18c(%ebp)
  101ac8:	e8 a3 f6 ff ff       	call   101170 <idt_set_entry>
  101acd:	b8 26 00 00 00       	mov    $0x26,%eax
  101ad2:	8d 0d ce 20 10 00    	lea    0x1020ce,%ecx
  101ad8:	ba 08 00 00 00       	mov    $0x8,%edx
  101add:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  101ae2:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  101ae9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101aed:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101af4:	00 
  101af5:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101afc:	00 
  101afd:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
  101b03:	89 b5 6c fe ff ff    	mov    %esi,-0x194(%ebp)
  101b09:	89 95 68 fe ff ff    	mov    %edx,-0x198(%ebp)
  101b0f:	e8 5c f6 ff ff       	call   101170 <idt_set_entry>
  101b14:	b8 27 00 00 00       	mov    $0x27,%eax
  101b19:	8d 0d d4 20 10 00    	lea    0x1020d4,%ecx
  101b1f:	ba 08 00 00 00       	mov    $0x8,%edx
  101b24:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  101b29:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
  101b30:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101b34:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101b3b:	00 
  101b3c:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101b43:	00 
  101b44:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%ebp)
  101b4a:	89 b5 60 fe ff ff    	mov    %esi,-0x1a0(%ebp)
  101b50:	89 95 5c fe ff ff    	mov    %edx,-0x1a4(%ebp)
  101b56:	e8 15 f6 ff ff       	call   101170 <idt_set_entry>
  101b5b:	b8 28 00 00 00       	mov    $0x28,%eax
  101b60:	8d 0d da 20 10 00    	lea    0x1020da,%ecx
  101b66:	ba 08 00 00 00       	mov    $0x8,%edx
  101b6b:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  101b70:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  101b77:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101b7b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101b82:	00 
  101b83:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101b8a:	00 
  101b8b:	89 85 58 fe ff ff    	mov    %eax,-0x1a8(%ebp)
  101b91:	89 b5 54 fe ff ff    	mov    %esi,-0x1ac(%ebp)
  101b97:	89 95 50 fe ff ff    	mov    %edx,-0x1b0(%ebp)
  101b9d:	e8 ce f5 ff ff       	call   101170 <idt_set_entry>
  101ba2:	b8 29 00 00 00       	mov    $0x29,%eax
  101ba7:	8d 0d e0 20 10 00    	lea    0x1020e0,%ecx
  101bad:	ba 08 00 00 00       	mov    $0x8,%edx
  101bb2:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  101bb7:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
  101bbe:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101bc2:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101bc9:	00 
  101bca:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101bd1:	00 
  101bd2:	89 85 4c fe ff ff    	mov    %eax,-0x1b4(%ebp)
  101bd8:	89 b5 48 fe ff ff    	mov    %esi,-0x1b8(%ebp)
  101bde:	89 95 44 fe ff ff    	mov    %edx,-0x1bc(%ebp)
  101be4:	e8 87 f5 ff ff       	call   101170 <idt_set_entry>
  101be9:	b8 2a 00 00 00       	mov    $0x2a,%eax
  101bee:	8d 0d e6 20 10 00    	lea    0x1020e6,%ecx
  101bf4:	ba 08 00 00 00       	mov    $0x8,%edx
  101bf9:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  101bfe:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
  101c05:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101c09:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101c10:	00 
  101c11:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101c18:	00 
  101c19:	89 85 40 fe ff ff    	mov    %eax,-0x1c0(%ebp)
  101c1f:	89 b5 3c fe ff ff    	mov    %esi,-0x1c4(%ebp)
  101c25:	89 95 38 fe ff ff    	mov    %edx,-0x1c8(%ebp)
  101c2b:	e8 40 f5 ff ff       	call   101170 <idt_set_entry>
  101c30:	b8 2b 00 00 00       	mov    $0x2b,%eax
  101c35:	8d 0d ec 20 10 00    	lea    0x1020ec,%ecx
  101c3b:	ba 08 00 00 00       	mov    $0x8,%edx
  101c40:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  101c45:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  101c4c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101c50:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101c57:	00 
  101c58:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101c5f:	00 
  101c60:	89 85 34 fe ff ff    	mov    %eax,-0x1cc(%ebp)
  101c66:	89 b5 30 fe ff ff    	mov    %esi,-0x1d0(%ebp)
  101c6c:	89 95 2c fe ff ff    	mov    %edx,-0x1d4(%ebp)
  101c72:	e8 f9 f4 ff ff       	call   101170 <idt_set_entry>
  101c77:	b8 2c 00 00 00       	mov    $0x2c,%eax
  101c7c:	8d 0d f2 20 10 00    	lea    0x1020f2,%ecx
  101c82:	ba 08 00 00 00       	mov    $0x8,%edx
  101c87:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  101c8c:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  101c93:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101c97:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101c9e:	00 
  101c9f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101ca6:	00 
  101ca7:	89 85 28 fe ff ff    	mov    %eax,-0x1d8(%ebp)
  101cad:	89 b5 24 fe ff ff    	mov    %esi,-0x1dc(%ebp)
  101cb3:	89 95 20 fe ff ff    	mov    %edx,-0x1e0(%ebp)
  101cb9:	e8 b2 f4 ff ff       	call   101170 <idt_set_entry>
  101cbe:	b8 2d 00 00 00       	mov    $0x2d,%eax
  101cc3:	8d 0d f8 20 10 00    	lea    0x1020f8,%ecx
  101cc9:	ba 08 00 00 00       	mov    $0x8,%edx
  101cce:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  101cd3:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  101cda:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101cde:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101ce5:	00 
  101ce6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101ced:	00 
  101cee:	89 85 1c fe ff ff    	mov    %eax,-0x1e4(%ebp)
  101cf4:	89 b5 18 fe ff ff    	mov    %esi,-0x1e8(%ebp)
  101cfa:	89 95 14 fe ff ff    	mov    %edx,-0x1ec(%ebp)
  101d00:	e8 6b f4 ff ff       	call   101170 <idt_set_entry>
  101d05:	b8 2e 00 00 00       	mov    $0x2e,%eax
  101d0a:	8d 0d fe 20 10 00    	lea    0x1020fe,%ecx
  101d10:	ba 08 00 00 00       	mov    $0x8,%edx
  101d15:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  101d1a:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
  101d21:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d25:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101d2c:	00 
  101d2d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101d34:	00 
  101d35:	89 85 10 fe ff ff    	mov    %eax,-0x1f0(%ebp)
  101d3b:	89 b5 0c fe ff ff    	mov    %esi,-0x1f4(%ebp)
  101d41:	89 95 08 fe ff ff    	mov    %edx,-0x1f8(%ebp)
  101d47:	e8 24 f4 ff ff       	call   101170 <idt_set_entry>
  101d4c:	b8 2f 00 00 00       	mov    $0x2f,%eax
  101d51:	8d 0d 04 21 10 00    	lea    0x102104,%ecx
  101d57:	ba 08 00 00 00       	mov    $0x8,%edx
  101d5c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  101d61:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
  101d68:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d6c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101d73:	00 
  101d74:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101d7b:	00 
  101d7c:	89 85 04 fe ff ff    	mov    %eax,-0x1fc(%ebp)
  101d82:	89 b5 00 fe ff ff    	mov    %esi,-0x200(%ebp)
  101d88:	89 95 fc fd ff ff    	mov    %edx,-0x204(%ebp)
  101d8e:	e8 dd f3 ff ff       	call   101170 <idt_set_entry>
  101d93:	b8 30 00 00 00       	mov    $0x30,%eax
  101d98:	8d 0d 0a 21 10 00    	lea    0x10210a,%ecx
  101d9e:	ba 08 00 00 00       	mov    $0x8,%edx
  101da3:	be ee 00 00 00       	mov    $0xee,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  101da8:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  101daf:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101db3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101dba:	00 
  101dbb:	c7 44 24 0c ee 00 00 	movl   $0xee,0xc(%esp)
  101dc2:	00 
  101dc3:	89 85 f8 fd ff ff    	mov    %eax,-0x208(%ebp)
  101dc9:	89 b5 f4 fd ff ff    	mov    %esi,-0x20c(%ebp)
  101dcf:	89 95 f0 fd ff ff    	mov    %edx,-0x210(%ebp)
  101dd5:	e8 96 f3 ff ff       	call   101170 <idt_set_entry>
  101dda:	b8 05 00 00 00       	mov    $0x5,%eax
  101ddf:	8d 0d 08 72 10 00    	lea    0x107208,%ecx
  101de5:	ba 80 00 00 00       	mov    $0x80,%edx
  101dea:	be e9 00 00 00       	mov    $0xe9,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  101def:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101df6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101dfa:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  101e01:	00 
  101e02:	c7 44 24 0c e9 00 00 	movl   $0xe9,0xc(%esp)
  101e09:	00 
  101e0a:	89 85 ec fd ff ff    	mov    %eax,-0x214(%ebp)
  101e10:	89 b5 e8 fd ff ff    	mov    %esi,-0x218(%ebp)
  101e16:	89 95 e4 fd ff ff    	mov    %edx,-0x21c(%ebp)
  101e1c:	e8 df f0 ff ff       	call   100f00 <set_gdt_entry>
  101e21:	b8 28 00 00 00       	mov    $0x28,%eax
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101e26:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  101e29:	0f 01 5d f0          	lidtl  -0x10(%ebp)
	asm volatile("sti");
  101e2d:	fb                   	sti    
}
  101e2e:	81 c4 34 02 00 00    	add    $0x234,%esp
  101e34:	5e                   	pop    %esi
  101e35:	5d                   	pop    %ebp
  101e36:	c3                   	ret    
  101e37:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  101e3e:	00 00 

00101e40 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  101e40:	55                   	push   %ebp
  101e41:	89 e5                	mov    %esp,%ebp
  101e43:	50                   	push   %eax
  101e44:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  101e48:	66 89 c1             	mov    %ax,%cx
  101e4b:	8a 55 0c             	mov    0xc(%ebp),%dl
  101e4e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  101e52:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  101e55:	8a 45 fd             	mov    -0x3(%ebp),%al
  101e58:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  101e5c:	ee                   	out    %al,(%dx)
}
  101e5d:	83 c4 04             	add    $0x4,%esp
  101e60:	5d                   	pop    %ebp
  101e61:	c3                   	ret    
  101e62:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101e69:	1f 84 00 00 00 00 00 

00101e70 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  101e70:	55                   	push   %ebp
  101e71:	89 e5                	mov    %esp,%ebp
  101e73:	83 ec 08             	sub    $0x8,%esp
  101e76:	8b 45 0c             	mov    0xc(%ebp),%eax
  101e79:	8b 4d 08             	mov    0x8(%ebp),%ecx
  101e7c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  101e7f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	handlers[i] = fn;
  101e82:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e85:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101e88:	89 04 8d 28 93 10 00 	mov    %eax,0x109328(,%ecx,4)
	handler_set[i] = 1;
  101e8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101e92:	c7 04 85 28 92 10 00 	movl   $0x1,0x109228(,%eax,4)
  101e99:	01 00 00 00 
}
  101e9d:	83 c4 08             	add    $0x8,%esp
  101ea0:	5d                   	pop    %ebp
  101ea1:	c3                   	ret    
  101ea2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101ea9:	1f 84 00 00 00 00 00 

00101eb0 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  101eb0:	55                   	push   %ebp
  101eb1:	89 e5                	mov    %esp,%ebp
  101eb3:	83 ec 28             	sub    $0x28,%esp
  101eb6:	8b 45 08             	mov    0x8(%ebp),%eax
  101eb9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	struct cpu_state* new_cpu = cpu;
  101ebc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ebf:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (cpu->intr <= 0x1f) {
  101ec2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ec5:	81 78 1c 1f 00 00 00 	cmpl   $0x1f,0x1c(%eax)
  101ecc:	0f 87 3d 00 00 00    	ja     101f0f <handle_interrupt+0x5f>
		if (!isSchedulingEnabled()) {
  101ed2:	e8 d9 1f 00 00       	call   103eb0 <isSchedulingEnabled>
  101ed7:	3d 00 00 00 00       	cmp    $0x0,%eax
  101edc:	0f 85 1a 00 00 00    	jne    101efc <handle_interrupt+0x4c>
  101ee2:	8d 05 56 82 10 00    	lea    0x108256,%eax
			show_cod(cpu, "Kernel PANIC!");
  101ee8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101eeb:	89 0c 24             	mov    %ecx,(%esp)
  101eee:	89 44 24 04          	mov    %eax,0x4(%esp)
  101ef2:	e8 c9 e1 ff ff       	call   1000c0 <show_cod>
		} else {
  101ef7:	e9 0e 00 00 00       	jmp    101f0a <handle_interrupt+0x5a>
			new_cpu = schedule_exception(cpu);
  101efc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101eff:	89 04 24             	mov    %eax,(%esp)
  101f02:	e8 19 21 00 00       	call   104020 <schedule_exception>
  101f07:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  101f0a:	e9 03 01 00 00       	jmp    102012 <handle_interrupt+0x162>
  101f0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f12:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101f19:	0f 82 b1 00 00 00    	jb     101fd0 <handle_interrupt+0x120>
  101f1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f22:	81 78 1c 2f 00 00 00 	cmpl   $0x2f,0x1c(%eax)
  101f29:	0f 87 a1 00 00 00    	ja     101fd0 <handle_interrupt+0x120>
		if (cpu->intr >= 0x28) {
  101f2f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f32:	81 78 1c 28 00 00 00 	cmpl   $0x28,0x1c(%eax)
  101f39:	0f 82 24 00 00 00    	jb     101f63 <handle_interrupt+0xb3>
  101f3f:	b8 a0 00 00 00       	mov    $0xa0,%eax
  101f44:	b9 20 00 00 00       	mov    $0x20,%ecx
			outb(0xa0, 0x20);
  101f49:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  101f50:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101f57:	00 
  101f58:	89 45 f4             	mov    %eax,-0xc(%ebp)
  101f5b:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  101f5e:	e8 dd fe ff ff       	call   101e40 <outb>
		}

		if (cpu->intr == 0x20) {
  101f63:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f66:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101f6d:	0f 85 13 00 00 00    	jne    101f86 <handle_interrupt+0xd6>
			new_cpu = schedule(cpu);
  101f73:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f76:	89 04 24             	mov    %eax,(%esp)
  101f79:	e8 22 25 00 00       	call   1044a0 <schedule>
  101f7e:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  101f81:	e9 29 00 00 00       	jmp    101faf <handle_interrupt+0xff>
		else
		{
            if (handler_set[cpu->intr]) {
  101f86:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101f89:	8b 40 1c             	mov    0x1c(%eax),%eax
  101f8c:	81 3c 85 28 92 10 00 	cmpl   $0x0,0x109228(,%eax,4)
  101f93:	00 00 00 00 
  101f97:	0f 84 0d 00 00 00    	je     101faa <handle_interrupt+0xfa>
                handlers[cpu->intr]();
  101f9d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101fa0:	8b 40 1c             	mov    0x1c(%eax),%eax
  101fa3:	ff 14 85 28 93 10 00 	call   *0x109328(,%eax,4)
  101faa:	e9 00 00 00 00       	jmp    101faf <handle_interrupt+0xff>
  101faf:	b8 20 00 00 00       	mov    $0x20,%eax
            }
		}

        outb(0x20, 0x20);
  101fb4:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  101fbb:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101fc2:	00 
  101fc3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101fc6:	e8 75 fe ff ff       	call   101e40 <outb>
	} else if (cpu->intr == 0x30) {
  101fcb:	e9 3d 00 00 00       	jmp    10200d <handle_interrupt+0x15d>
  101fd0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101fd3:	81 78 1c 30 00 00 00 	cmpl   $0x30,0x1c(%eax)
  101fda:	0f 85 13 00 00 00    	jne    101ff3 <handle_interrupt+0x143>
		new_cpu = syscall(new_cpu);
  101fe0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101fe3:	89 04 24             	mov    %eax,(%esp)
  101fe6:	e8 55 01 00 00       	call   102140 <syscall>
  101feb:	89 45 f8             	mov    %eax,-0x8(%ebp)
	} else {
  101fee:	e9 15 00 00 00       	jmp    102008 <handle_interrupt+0x158>
  101ff3:	8d 05 64 82 10 00    	lea    0x108264,%eax
		show_cod(cpu, "Unknown Interrupt!");
  101ff9:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101ffc:	89 0c 24             	mov    %ecx,(%esp)
  101fff:	89 44 24 04          	mov    %eax,0x4(%esp)
  102003:	e8 b8 e0 ff ff       	call   1000c0 <show_cod>
  102008:	e9 00 00 00 00       	jmp    10200d <handle_interrupt+0x15d>
  10200d:	e9 00 00 00 00       	jmp    102012 <handle_interrupt+0x162>
	}

	return new_cpu;
  102012:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102015:	83 c4 28             	add    $0x28,%esp
  102018:	5d                   	pop    %ebp
  102019:	c3                   	ret    
  10201a:	66 90                	xchg   %ax,%ax

0010201c <intr_stub_0>:
  10201c:	6a 00                	push   $0x0
  10201e:	6a 00                	push   $0x0
  102020:	e9 eb 00 00 00       	jmp    102110 <intr_common_handler>

00102025 <intr_stub_1>:
  102025:	6a 00                	push   $0x0
  102027:	6a 01                	push   $0x1
  102029:	e9 e2 00 00 00       	jmp    102110 <intr_common_handler>

0010202e <intr_stub_2>:
  10202e:	6a 00                	push   $0x0
  102030:	6a 02                	push   $0x2
  102032:	e9 d9 00 00 00       	jmp    102110 <intr_common_handler>

00102037 <intr_stub_3>:
  102037:	6a 00                	push   $0x0
  102039:	6a 03                	push   $0x3
  10203b:	e9 d0 00 00 00       	jmp    102110 <intr_common_handler>

00102040 <intr_stub_4>:
  102040:	6a 00                	push   $0x0
  102042:	6a 04                	push   $0x4
  102044:	e9 c7 00 00 00       	jmp    102110 <intr_common_handler>

00102049 <intr_stub_5>:
  102049:	6a 00                	push   $0x0
  10204b:	6a 05                	push   $0x5
  10204d:	e9 be 00 00 00       	jmp    102110 <intr_common_handler>

00102052 <intr_stub_6>:
  102052:	6a 00                	push   $0x0
  102054:	6a 06                	push   $0x6
  102056:	e9 b5 00 00 00       	jmp    102110 <intr_common_handler>

0010205b <intr_stub_7>:
  10205b:	6a 00                	push   $0x0
  10205d:	6a 07                	push   $0x7
  10205f:	e9 ac 00 00 00       	jmp    102110 <intr_common_handler>

00102064 <intr_stub_8>:
  102064:	6a 08                	push   $0x8
  102066:	e9 a5 00 00 00       	jmp    102110 <intr_common_handler>

0010206b <intr_stub_9>:
  10206b:	6a 00                	push   $0x0
  10206d:	6a 09                	push   $0x9
  10206f:	e9 9c 00 00 00       	jmp    102110 <intr_common_handler>

00102074 <intr_stub_10>:
  102074:	6a 0a                	push   $0xa
  102076:	e9 95 00 00 00       	jmp    102110 <intr_common_handler>

0010207b <intr_stub_11>:
  10207b:	6a 0b                	push   $0xb
  10207d:	e9 8e 00 00 00       	jmp    102110 <intr_common_handler>

00102082 <intr_stub_12>:
  102082:	6a 0c                	push   $0xc
  102084:	e9 87 00 00 00       	jmp    102110 <intr_common_handler>

00102089 <intr_stub_13>:
  102089:	6a 0d                	push   $0xd
  10208b:	e9 80 00 00 00       	jmp    102110 <intr_common_handler>

00102090 <intr_stub_14>:
  102090:	6a 0e                	push   $0xe
  102092:	eb 7c                	jmp    102110 <intr_common_handler>

00102094 <intr_stub_15>:
  102094:	6a 00                	push   $0x0
  102096:	6a 0f                	push   $0xf
  102098:	eb 76                	jmp    102110 <intr_common_handler>

0010209a <intr_stub_16>:
  10209a:	6a 00                	push   $0x0
  10209c:	6a 10                	push   $0x10
  10209e:	eb 70                	jmp    102110 <intr_common_handler>

001020a0 <intr_stub_17>:
  1020a0:	6a 11                	push   $0x11
  1020a2:	eb 6c                	jmp    102110 <intr_common_handler>

001020a4 <intr_stub_18>:
  1020a4:	6a 00                	push   $0x0
  1020a6:	6a 12                	push   $0x12
  1020a8:	eb 66                	jmp    102110 <intr_common_handler>

001020aa <intr_stub_32>:
  1020aa:	6a 00                	push   $0x0
  1020ac:	6a 20                	push   $0x20
  1020ae:	eb 60                	jmp    102110 <intr_common_handler>

001020b0 <intr_stub_33>:
  1020b0:	6a 00                	push   $0x0
  1020b2:	6a 21                	push   $0x21
  1020b4:	eb 5a                	jmp    102110 <intr_common_handler>

001020b6 <intr_stub_34>:
  1020b6:	6a 00                	push   $0x0
  1020b8:	6a 22                	push   $0x22
  1020ba:	eb 54                	jmp    102110 <intr_common_handler>

001020bc <intr_stub_35>:
  1020bc:	6a 00                	push   $0x0
  1020be:	6a 23                	push   $0x23
  1020c0:	eb 4e                	jmp    102110 <intr_common_handler>

001020c2 <intr_stub_36>:
  1020c2:	6a 00                	push   $0x0
  1020c4:	6a 24                	push   $0x24
  1020c6:	eb 48                	jmp    102110 <intr_common_handler>

001020c8 <intr_stub_37>:
  1020c8:	6a 00                	push   $0x0
  1020ca:	6a 25                	push   $0x25
  1020cc:	eb 42                	jmp    102110 <intr_common_handler>

001020ce <intr_stub_38>:
  1020ce:	6a 00                	push   $0x0
  1020d0:	6a 26                	push   $0x26
  1020d2:	eb 3c                	jmp    102110 <intr_common_handler>

001020d4 <intr_stub_39>:
  1020d4:	6a 00                	push   $0x0
  1020d6:	6a 27                	push   $0x27
  1020d8:	eb 36                	jmp    102110 <intr_common_handler>

001020da <intr_stub_40>:
  1020da:	6a 00                	push   $0x0
  1020dc:	6a 28                	push   $0x28
  1020de:	eb 30                	jmp    102110 <intr_common_handler>

001020e0 <intr_stub_41>:
  1020e0:	6a 00                	push   $0x0
  1020e2:	6a 29                	push   $0x29
  1020e4:	eb 2a                	jmp    102110 <intr_common_handler>

001020e6 <intr_stub_42>:
  1020e6:	6a 00                	push   $0x0
  1020e8:	6a 2a                	push   $0x2a
  1020ea:	eb 24                	jmp    102110 <intr_common_handler>

001020ec <intr_stub_43>:
  1020ec:	6a 00                	push   $0x0
  1020ee:	6a 2b                	push   $0x2b
  1020f0:	eb 1e                	jmp    102110 <intr_common_handler>

001020f2 <intr_stub_44>:
  1020f2:	6a 00                	push   $0x0
  1020f4:	6a 2c                	push   $0x2c
  1020f6:	eb 18                	jmp    102110 <intr_common_handler>

001020f8 <intr_stub_45>:
  1020f8:	6a 00                	push   $0x0
  1020fa:	6a 2d                	push   $0x2d
  1020fc:	eb 12                	jmp    102110 <intr_common_handler>

001020fe <intr_stub_46>:
  1020fe:	6a 00                	push   $0x0
  102100:	6a 2e                	push   $0x2e
  102102:	eb 0c                	jmp    102110 <intr_common_handler>

00102104 <intr_stub_47>:
  102104:	6a 00                	push   $0x0
  102106:	6a 2f                	push   $0x2f
  102108:	eb 06                	jmp    102110 <intr_common_handler>

0010210a <intr_stub_48>:
  10210a:	6a 00                	push   $0x0
  10210c:	6a 30                	push   $0x30
  10210e:	eb 00                	jmp    102110 <intr_common_handler>

00102110 <intr_common_handler>:
  102110:	55                   	push   %ebp
  102111:	57                   	push   %edi
  102112:	56                   	push   %esi
  102113:	52                   	push   %edx
  102114:	51                   	push   %ecx
  102115:	53                   	push   %ebx
  102116:	50                   	push   %eax
  102117:	54                   	push   %esp
  102118:	66 b8 10 00          	mov    $0x10,%ax
  10211c:	66 8e d8             	mov    %ax,%ds
  10211f:	66 8e c0             	mov    %ax,%es
  102122:	e8 89 fd ff ff       	call   101eb0 <handle_interrupt>
  102127:	89 c4                	mov    %eax,%esp
  102129:	66 b8 23 00          	mov    $0x23,%ax
  10212d:	66 8e d8             	mov    %ax,%ds
  102130:	66 8e c0             	mov    %ax,%es
  102133:	58                   	pop    %eax
  102134:	5b                   	pop    %ebx
  102135:	59                   	pop    %ecx
  102136:	5a                   	pop    %edx
  102137:	5e                   	pop    %esi
  102138:	5f                   	pop    %edi
  102139:	5d                   	pop    %ebp
  10213a:	83 c4 08             	add    $0x8,%esp
  10213d:	cf                   	iret   
  10213e:	66 90                	xchg   %ax,%ax

00102140 <syscall>:
#include "ramfs/block.h"
#include "ramfs/tar.h"
#include "ramfs/vgacntrl.h"
#include "drivers/keyboard.h"

struct cpu_state* syscall(struct cpu_state* cpu) {
  102140:	55                   	push   %ebp
  102141:	89 e5                	mov    %esp,%ebp
  102143:	56                   	push   %esi
  102144:	81 ec d4 00 00 00    	sub    $0xd4,%esp
  10214a:	8b 45 08             	mov    0x8(%ebp),%eax
  10214d:	89 45 f8             	mov    %eax,-0x8(%ebp)
    save_cpu_state(cpu);
  102150:	89 e1                	mov    %esp,%ecx
  102152:	89 01                	mov    %eax,(%ecx)
  102154:	e8 07 23 00 00       	call   104460 <save_cpu_state>

    cpu = get_current_task()->cpuState;
  102159:	e8 62 1d 00 00       	call   103ec0 <get_current_task>
  10215e:	8b 40 04             	mov    0x4(%eax),%eax
  102161:	89 45 f8             	mov    %eax,-0x8(%ebp)

	switch (cpu->eax) {
  102164:	8b 00                	mov    (%eax),%eax
  102166:	89 c1                	mov    %eax,%ecx
  102168:	81 e9 c8 00 00 00    	sub    $0xc8,%ecx
  10216e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  102171:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  102174:	0f 8f 26 00 00 00    	jg     1021a0 <syscall+0x60>
  10217a:	e9 00 00 00 00       	jmp    10217f <syscall+0x3f>
  10217f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  102182:	48                   	dec    %eax
  102183:	89 c1                	mov    %eax,%ecx
  102185:	83 e9 14             	sub    $0x14,%ecx
  102188:	89 45 ac             	mov    %eax,-0x54(%ebp)
  10218b:	89 4d a8             	mov    %ecx,-0x58(%ebp)
  10218e:	0f 87 b1 05 00 00    	ja     102745 <syscall+0x605>
  102194:	8b 45 ac             	mov    -0x54(%ebp),%eax
  102197:	8b 0c 85 44 80 10 00 	mov    0x108044(,%eax,4),%ecx
  10219e:	ff e1                	jmp    *%ecx
  1021a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  1021a3:	05 37 ff ff ff       	add    $0xffffff37,%eax
  1021a8:	89 c1                	mov    %eax,%ecx
  1021aa:	83 e9 04             	sub    $0x4,%ecx
  1021ad:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  1021b0:	89 4d a0             	mov    %ecx,-0x60(%ebp)
  1021b3:	0f 87 8c 05 00 00    	ja     102745 <syscall+0x605>
  1021b9:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  1021bc:	8b 0c 85 30 80 10 00 	mov    0x108030(,%eax,4),%ecx
  1021c3:	ff e1                	jmp    *%ecx
	case 1: /* exit */
		cpu = terminate_current(cpu);
  1021c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1021c8:	89 04 24             	mov    %eax,(%esp)
  1021cb:	e8 80 1f 00 00       	call   104150 <terminate_current>
  1021d0:	89 45 f8             	mov    %eax,-0x8(%ebp)
		break;
  1021d3:	e9 8a 05 00 00       	jmp    102762 <syscall+0x622>

	case 2: /* fork */
	{

		uint32_t forkpdir = vmm_fork_current();
  1021d8:	e8 03 3e 00 00       	call   105fe0 <vmm_fork_current>
  1021dd:	b9 00 00 00 00       	mov    $0x0,%ecx
  1021e2:	89 45 f4             	mov    %eax,-0xc(%ebp)

		struct task* ntask = init_task(forkpdir, 0);
  1021e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1021e8:	89 04 24             	mov    %eax,(%esp)
  1021eb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1021f2:	00 
  1021f3:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  1021f6:	e8 a5 20 00 00       	call   1042a0 <init_task>
  1021fb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		fork_task_state(ntask);
  1021fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102201:	89 04 24             	mov    %eax,(%esp)
  102204:	e8 17 20 00 00       	call   104220 <fork_task_state>

		cpu->eax = ntask->PID;
  102209:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10220c:	8b 00                	mov    (%eax),%eax
  10220e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102211:	89 01                	mov    %eax,(%ecx)
	}
        break;
  102213:	e9 4a 05 00 00       	jmp    102762 <syscall+0x622>

    case 3: /* exec */
    {
        vfs_exec((char*) cpu->ebx, (char**) cpu->ecx, get_current_task());
  102218:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10221b:	8b 40 04             	mov    0x4(%eax),%eax
  10221e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102221:	8b 49 08             	mov    0x8(%ecx),%ecx
  102224:	89 45 98             	mov    %eax,-0x68(%ebp)
  102227:	89 4d 94             	mov    %ecx,-0x6c(%ebp)
  10222a:	e8 91 1c 00 00       	call   103ec0 <get_current_task>
  10222f:	8b 4d 98             	mov    -0x68(%ebp),%ecx
  102232:	89 0c 24             	mov    %ecx,(%esp)
  102235:	8b 55 94             	mov    -0x6c(%ebp),%edx
  102238:	89 54 24 04          	mov    %edx,0x4(%esp)
  10223c:	89 44 24 08          	mov    %eax,0x8(%esp)
  102240:	e8 fb 35 00 00       	call   105840 <vfs_exec>
    }
        break;
  102245:	e9 18 05 00 00       	jmp    102762 <syscall+0x622>

    case 4: /* getargs */
    {
        cpu->eax = (uint32_t) get_current_task()->args;
  10224a:	e8 71 1c 00 00       	call   103ec0 <get_current_task>
  10224f:	8b 40 18             	mov    0x18(%eax),%eax
  102252:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102255:	89 01                	mov    %eax,(%ecx)
    }
        break;
  102257:	e9 06 05 00 00       	jmp    102762 <syscall+0x622>

    case 5: /* yield */
    {
        cpu = schedule(cpu);
  10225c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10225f:	89 04 24             	mov    %eax,(%esp)
  102262:	e8 39 22 00 00       	call   1044a0 <schedule>
  102267:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
        break;
  10226a:	e9 f3 04 00 00       	jmp    102762 <syscall+0x622>

	case 10: /* fopen */
	{
	    char* name = strclone((char*) cpu->ebx);
  10226f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102272:	8b 40 04             	mov    0x4(%eax),%eax
  102275:	89 04 24             	mov    %eax,(%esp)
  102278:	e8 63 2c 00 00       	call   104ee0 <strclone>
  10227d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  102280:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102283:	8b 40 08             	mov    0x8(%eax),%eax
  102286:	89 45 e8             	mov    %eax,-0x18(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  102289:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10228c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  10228f:	89 04 24             	mov    %eax,(%esp)
  102292:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102296:	e8 d5 31 00 00       	call   105470 <vfs_open>
  10229b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    if(handle) {
  10229e:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  1022a5:	0f 84 1b 00 00 00    	je     1022c6 <syscall+0x186>
	        register_handle(handle);
  1022ab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1022ae:	89 04 24             	mov    %eax,(%esp)
  1022b1:	e8 1a 1c 00 00       	call   103ed0 <register_handle>
	        cpu->eax = (uint32_t) handle;
  1022b6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1022b9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1022bc:	89 0a                	mov    %ecx,(%edx)
	    }
  1022be:	89 45 90             	mov    %eax,-0x70(%ebp)
  1022c1:	e9 09 00 00 00       	jmp    1022cf <syscall+0x18f>
	    else
	    {
	        cpu->eax = 0;
  1022c6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1022c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }

	    free(name);
  1022cf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1022d2:	89 04 24             	mov    %eax,(%esp)
  1022d5:	e8 66 26 00 00       	call   104940 <free>
	}
	    break;
  1022da:	e9 83 04 00 00       	jmp    102762 <syscall+0x622>

	case 11: /* fclose */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  1022df:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1022e2:	8b 40 04             	mov    0x4(%eax),%eax
  1022e5:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    if(!unregister_handle(handle)) {
  1022e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1022eb:	89 04 24             	mov    %eax,(%esp)
  1022ee:	e8 3d 1c 00 00       	call   103f30 <unregister_handle>
  1022f3:	3d 00 00 00 00       	cmp    $0x0,%eax
  1022f8:	0f 85 1c 00 00 00    	jne    10231a <syscall+0x1da>
	        vfs_close(handle);
  1022fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
  102301:	89 04 24             	mov    %eax,(%esp)
  102304:	e8 e7 31 00 00       	call   1054f0 <vfs_close>

	        cpu->eax = 0;
  102309:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10230c:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	    }
  102312:	89 45 8c             	mov    %eax,-0x74(%ebp)
  102315:	e9 09 00 00 00       	jmp    102323 <syscall+0x1e3>
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  10231a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10231d:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  102323:	e9 3a 04 00 00       	jmp    102762 <syscall+0x622>

	case 12: /* fwrite */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  102328:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10232b:	8b 40 04             	mov    0x4(%eax),%eax
  10232e:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    if(handle != 0) {
  102331:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  102338:	0f 84 39 00 00 00    	je     102377 <syscall+0x237>
  10233e:	b8 01 00 00 00       	mov    $0x1,%eax
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  102343:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  102346:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102349:	8b 52 08             	mov    0x8(%edx),%edx
  10234c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10234f:	8b 76 0c             	mov    0xc(%esi),%esi
  102352:	89 0c 24             	mov    %ecx,(%esp)
  102355:	89 54 24 04          	mov    %edx,0x4(%esp)
  102359:	89 74 24 08          	mov    %esi,0x8(%esp)
  10235d:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  102364:	00 
  102365:	89 45 88             	mov    %eax,-0x78(%ebp)
  102368:	e8 d3 32 00 00       	call   105640 <vfs_write>
  10236d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102370:	89 01                	mov    %eax,(%ecx)
	    }
  102372:	e9 09 00 00 00       	jmp    102380 <syscall+0x240>
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  102377:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10237a:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  102380:	e9 dd 03 00 00       	jmp    102762 <syscall+0x622>

	case 13: /* fread */
	{
        struct res_handle* handle = (void*) cpu->ebx;
  102385:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102388:	8b 40 04             	mov    0x4(%eax),%eax
  10238b:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(handle != 0) {
  10238e:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  102395:	0f 84 39 00 00 00    	je     1023d4 <syscall+0x294>
  10239b:	b8 01 00 00 00       	mov    $0x1,%eax
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  1023a0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1023a3:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1023a6:	8b 52 08             	mov    0x8(%edx),%edx
  1023a9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1023ac:	8b 76 0c             	mov    0xc(%esi),%esi
  1023af:	89 0c 24             	mov    %ecx,(%esp)
  1023b2:	89 54 24 04          	mov    %edx,0x4(%esp)
  1023b6:	89 74 24 08          	mov    %esi,0x8(%esp)
  1023ba:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1023c1:	00 
  1023c2:	89 45 84             	mov    %eax,-0x7c(%ebp)
  1023c5:	e8 76 31 00 00       	call   105540 <vfs_read>
  1023ca:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1023cd:	89 01                	mov    %eax,(%ecx)
        }
  1023cf:	e9 09 00 00 00       	jmp    1023dd <syscall+0x29d>
        else
        {
            cpu->eax = RW_ERR_VFS;
  1023d4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1023d7:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  1023dd:	e9 80 03 00 00       	jmp    102762 <syscall+0x622>

	case 14: /* fmkfifo */
	{
        char* name = strclone((char*) cpu->ebx);
  1023e2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1023e5:	8b 40 04             	mov    0x4(%eax),%eax
  1023e8:	89 04 24             	mov    %eax,(%esp)
  1023eb:	e8 f0 2a 00 00       	call   104ee0 <strclone>
  1023f0:	8d 4d d0             	lea    -0x30(%ebp),%ecx
  1023f3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        vfs_create_kfile(name, ramfs_fifo_driver_struct(), &(uint32_t){4096}); //default to 4k Buffer-size
  1023f6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1023f9:	89 4d 80             	mov    %ecx,-0x80(%ebp)
  1023fc:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  102402:	e8 09 15 00 00       	call   103910 <ramfs_fifo_driver_struct>
  102407:	c7 45 d0 00 10 00 00 	movl   $0x1000,-0x30(%ebp)
  10240e:	8b 8d 7c ff ff ff    	mov    -0x84(%ebp),%ecx
  102414:	89 0c 24             	mov    %ecx,(%esp)
  102417:	89 44 24 04          	mov    %eax,0x4(%esp)
  10241b:	8b 45 80             	mov    -0x80(%ebp),%eax
  10241e:	89 44 24 08          	mov    %eax,0x8(%esp)
  102422:	e8 d9 2e 00 00       	call   105300 <vfs_create_kfile>
  102427:	b9 03 00 00 00       	mov    $0x3,%ecx

        struct res_handle* handle = vfs_open(name, FM_READ | FM_WRITE);
  10242c:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  10242f:	89 14 24             	mov    %edx,(%esp)
  102432:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  102439:	00 
  10243a:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  102440:	89 8d 74 ff ff ff    	mov    %ecx,-0x8c(%ebp)
  102446:	e8 25 30 00 00       	call   105470 <vfs_open>
  10244b:	89 45 cc             	mov    %eax,-0x34(%ebp)
        if(handle) {
  10244e:	81 7d cc 00 00 00 00 	cmpl   $0x0,-0x34(%ebp)
  102455:	0f 84 1e 00 00 00    	je     102479 <syscall+0x339>
            register_handle(handle);
  10245b:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10245e:	89 04 24             	mov    %eax,(%esp)
  102461:	e8 6a 1a 00 00       	call   103ed0 <register_handle>
            cpu->eax = (uint32_t) handle;
  102466:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  102469:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10246c:	89 0a                	mov    %ecx,(%edx)
        }
  10246e:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
  102474:	e9 09 00 00 00       	jmp    102482 <syscall+0x342>
        else
        {
            cpu->eax = 0;
  102479:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10247c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
        }

        free(name);
  102482:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102485:	89 04 24             	mov    %eax,(%esp)
  102488:	e8 b3 24 00 00       	call   104940 <free>
	}
	    break;
  10248d:	e9 d0 02 00 00       	jmp    102762 <syscall+0x622>

	case 20: /* getpmhandle */
	{
	    struct res_handle* handle = 0;
  102492:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)

	    switch(cpu->ebx) {
  102499:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10249c:	8b 40 04             	mov    0x4(%eax),%eax
  10249f:	89 c1                	mov    %eax,%ecx
  1024a1:	83 e9 02             	sub    $0x2,%ecx
  1024a4:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
  1024aa:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
  1024b0:	0f 84 52 00 00 00    	je     102508 <syscall+0x3c8>
  1024b6:	e9 00 00 00 00       	jmp    1024bb <syscall+0x37b>
  1024bb:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  1024c1:	83 e8 01             	sub    $0x1,%eax
  1024c4:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  1024ca:	0f 84 28 00 00 00    	je     1024f8 <syscall+0x3b8>
  1024d0:	e9 00 00 00 00       	jmp    1024d5 <syscall+0x395>
  1024d5:	8b 85 6c ff ff ff    	mov    -0x94(%ebp),%eax
  1024db:	85 c0                	test   %eax,%eax
  1024dd:	0f 85 35 00 00 00    	jne    102518 <syscall+0x3d8>
  1024e3:	e9 00 00 00 00       	jmp    1024e8 <syscall+0x3a8>
	    case PMID_STDOUT:
	        handle = get_current_task()->stdout;
  1024e8:	e8 d3 19 00 00       	call   103ec0 <get_current_task>
  1024ed:	8b 40 1c             	mov    0x1c(%eax),%eax
  1024f0:	89 45 c8             	mov    %eax,-0x38(%ebp)
	        break;
  1024f3:	e9 2b 00 00 00       	jmp    102523 <syscall+0x3e3>
        case PMID_STDIN:
            handle = get_current_task()->stdin;
  1024f8:	e8 c3 19 00 00       	call   103ec0 <get_current_task>
  1024fd:	8b 40 24             	mov    0x24(%eax),%eax
  102500:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
  102503:	e9 1b 00 00 00       	jmp    102523 <syscall+0x3e3>
        case PMID_STDERR:
            handle = get_current_task()->stderr;
  102508:	e8 b3 19 00 00       	call   103ec0 <get_current_task>
  10250d:	8b 40 20             	mov    0x20(%eax),%eax
  102510:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
  102513:	e9 0b 00 00 00       	jmp    102523 <syscall+0x3e3>
        default:
            handle = get_current_task()->stdout;
  102518:	e8 a3 19 00 00       	call   103ec0 <get_current_task>
  10251d:	8b 40 1c             	mov    0x1c(%eax),%eax
  102520:	89 45 c8             	mov    %eax,-0x38(%ebp)
            break;
	    }

	    cpu->eax = (uint32_t) handle;
  102523:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102526:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102529:	89 01                	mov    %eax,(%ecx)
	}
	    break;
  10252b:	e9 32 02 00 00       	jmp    102762 <syscall+0x622>

	case 21: /* fopenpmhandle */
	{
	    char* path = strclone((char*)cpu->ecx);
  102530:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102533:	8b 40 08             	mov    0x8(%eax),%eax
  102536:	89 04 24             	mov    %eax,(%esp)
  102539:	e8 a2 29 00 00       	call   104ee0 <strclone>
  10253e:	89 45 c4             	mov    %eax,-0x3c(%ebp)

	    struct res_handle* open;
	    uint32_t fm = FM_WRITE;
  102541:	c7 45 bc 02 00 00 00 	movl   $0x2,-0x44(%ebp)

	    if(cpu->ebx == PMID_STDIN) {
  102548:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10254b:	81 78 04 01 00 00 00 	cmpl   $0x1,0x4(%eax)
  102552:	0f 85 07 00 00 00    	jne    10255f <syscall+0x41f>
	        fm = FM_READ;
  102558:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%ebp)
	    }

	    open = vfs_open(path, fm);
  10255f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  102562:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  102565:	89 04 24             	mov    %eax,(%esp)
  102568:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10256c:	e8 ff 2e 00 00       	call   105470 <vfs_open>
  102571:	89 45 c0             	mov    %eax,-0x40(%ebp)

	    free(path);
  102574:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  102577:	89 04 24             	mov    %eax,(%esp)
  10257a:	e8 c1 23 00 00       	call   104940 <free>

	    if(!open) {
  10257f:	81 7d c0 00 00 00 00 	cmpl   $0x0,-0x40(%ebp)
  102586:	0f 85 0e 00 00 00    	jne    10259a <syscall+0x45a>
	        cpu->eax = (uint32_t) -1;
  10258c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10258f:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	        break;
  102595:	e9 c8 01 00 00       	jmp    102762 <syscall+0x622>
	    }

	    struct res_handle* oldhandle = 0;
  10259a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)

        switch(cpu->ebx) {
  1025a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1025a4:	8b 40 04             	mov    0x4(%eax),%eax
  1025a7:	89 c1                	mov    %eax,%ecx
  1025a9:	83 e9 02             	sub    $0x2,%ecx
  1025ac:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
  1025b2:	89 8d 5c ff ff ff    	mov    %ecx,-0xa4(%ebp)
  1025b8:	0f 84 80 00 00 00    	je     10263e <syscall+0x4fe>
  1025be:	e9 00 00 00 00       	jmp    1025c3 <syscall+0x483>
  1025c3:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1025c9:	83 e8 01             	sub    $0x1,%eax
  1025cc:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
  1025d2:	0f 84 3f 00 00 00    	je     102617 <syscall+0x4d7>
  1025d8:	e9 00 00 00 00       	jmp    1025dd <syscall+0x49d>
  1025dd:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
  1025e3:	85 c0                	test   %eax,%eax
  1025e5:	0f 85 7a 00 00 00    	jne    102665 <syscall+0x525>
  1025eb:	e9 00 00 00 00       	jmp    1025f0 <syscall+0x4b0>
        case PMID_STDOUT:
            oldhandle = get_current_task()->stdout;
  1025f0:	e8 cb 18 00 00       	call   103ec0 <get_current_task>
  1025f5:	8b 40 1c             	mov    0x1c(%eax),%eax
  1025f8:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdout = open;
  1025fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1025fe:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
  102604:	e8 b7 18 00 00       	call   103ec0 <get_current_task>
  102609:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
  10260f:	89 48 1c             	mov    %ecx,0x1c(%eax)
            break;
  102612:	e9 70 00 00 00       	jmp    102687 <syscall+0x547>
        case PMID_STDIN:
            oldhandle = get_current_task()->stdin;
  102617:	e8 a4 18 00 00       	call   103ec0 <get_current_task>
  10261c:	8b 40 24             	mov    0x24(%eax),%eax
  10261f:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdin = open;
  102622:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102625:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  10262b:	e8 90 18 00 00       	call   103ec0 <get_current_task>
  102630:	8b 8d 50 ff ff ff    	mov    -0xb0(%ebp),%ecx
  102636:	89 48 24             	mov    %ecx,0x24(%eax)
            break;
  102639:	e9 49 00 00 00       	jmp    102687 <syscall+0x547>
        case PMID_STDERR:
            oldhandle = get_current_task()->stderr;
  10263e:	e8 7d 18 00 00       	call   103ec0 <get_current_task>
  102643:	8b 40 20             	mov    0x20(%eax),%eax
  102646:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stderr = open;
  102649:	8b 45 c0             	mov    -0x40(%ebp),%eax
  10264c:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)
  102652:	e8 69 18 00 00       	call   103ec0 <get_current_task>
  102657:	8b 8d 4c ff ff ff    	mov    -0xb4(%ebp),%ecx
  10265d:	89 48 20             	mov    %ecx,0x20(%eax)
            break;
  102660:	e9 22 00 00 00       	jmp    102687 <syscall+0x547>
        default:
            oldhandle = get_current_task()->stdout;
  102665:	e8 56 18 00 00       	call   103ec0 <get_current_task>
  10266a:	8b 40 1c             	mov    0x1c(%eax),%eax
  10266d:	89 45 b8             	mov    %eax,-0x48(%ebp)
            get_current_task()->stdout = open;
  102670:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102673:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
  102679:	e8 42 18 00 00       	call   103ec0 <get_current_task>
  10267e:	8b 8d 48 ff ff ff    	mov    -0xb8(%ebp),%ecx
  102684:	89 48 1c             	mov    %ecx,0x1c(%eax)
            break;
        }

        if(oldhandle != 0) {
  102687:	81 7d b8 00 00 00 00 	cmpl   $0x0,-0x48(%ebp)
  10268e:	0f 84 11 00 00 00    	je     1026a5 <syscall+0x565>
            vfs_close(oldhandle);
  102694:	8b 45 b8             	mov    -0x48(%ebp),%eax
  102697:	89 04 24             	mov    %eax,(%esp)
  10269a:	e8 51 2e 00 00       	call   1054f0 <vfs_close>
  10269f:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
        }

        cpu->eax = 0;
  1026a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1026a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	}
	    break;
  1026ae:	e9 af 00 00 00       	jmp    102762 <syscall+0x622>
  1026b3:	8d 05 77 82 10 00    	lea    0x108277,%eax

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  1026b9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1026bc:	8b 49 04             	mov    0x4(%ecx),%ecx
  1026bf:	89 04 24             	mov    %eax,(%esp)
  1026c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1026c6:	e8 e5 db ff ff       	call   1002b0 <kprintf>
  1026cb:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1026ce:	89 01                	mov    %eax,(%ecx)
		break;
  1026d0:	e9 8d 00 00 00       	jmp    102762 <syscall+0x622>
  1026d5:	8d 05 7a 82 10 00    	lea    0x10827a,%eax

	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  1026db:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1026de:	8b 49 04             	mov    0x4(%ecx),%ecx
  1026e1:	89 04 24             	mov    %eax,(%esp)
  1026e4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1026e8:	e8 c3 db ff ff       	call   1002b0 <kprintf>
  1026ed:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1026f0:	89 01                	mov    %eax,(%ecx)
		break;
  1026f2:	e9 6b 00 00 00       	jmp    102762 <syscall+0x622>

	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  1026f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1026fa:	8b 40 04             	mov    0x4(%eax),%eax
  1026fd:	89 04 24             	mov    %eax,(%esp)
  102700:	e8 2b 41 00 00       	call   106830 <vmm_alloc_ucont>
  102705:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102708:	89 01                	mov    %eax,(%ecx)
		break;
  10270a:	e9 53 00 00 00       	jmp    102762 <syscall+0x622>

	case 204: /* vmm_free */
		cpu->eax = 0;
  10270f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102712:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  102718:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10271b:	81 78 04 00 10 40 20 	cmpl   $0x20401000,0x4(%eax)
  102722:	0f 82 0e 00 00 00    	jb     102736 <syscall+0x5f6>
			vmm_free((void*) cpu->ebx);
  102728:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10272b:	8b 40 04             	mov    0x4(%eax),%eax
  10272e:	89 04 24             	mov    %eax,(%esp)
  102731:	e8 6a 3f 00 00       	call   1066a0 <vmm_free>
		}
		break;
  102736:	e9 27 00 00 00       	jmp    102762 <syscall+0x622>

	case 205: /* pmm_print_stats */
		pmm_print_stats();
  10273b:	e8 d0 03 00 00       	call   102b10 <pmm_print_stats>
		break;
  102740:	e9 1d 00 00 00       	jmp    102762 <syscall+0x622>
  102745:	8d 05 7d 82 10 00    	lea    0x10827d,%eax

	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  10274b:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10274e:	8b 09                	mov    (%ecx),%ecx
  102750:	89 04 24             	mov    %eax,(%esp)
  102753:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102757:	e8 54 db ff ff       	call   1002b0 <kprintf>
  10275c:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%ebp)
		break;
	}

	return cpu;
  102762:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102765:	81 c4 d4 00 00 00    	add    $0xd4,%esp
  10276b:	5e                   	pop    %esi
  10276c:	5d                   	pop    %ebp
  10276d:	c3                   	ret    
  10276e:	66 90                	xchg   %ax,%ax

00102770 <kernel_main>:
}

void kernel_main(struct multiboot_info* mb_info) {
  102770:	55                   	push   %ebp
  102771:	89 e5                	mov    %esp,%ebp
  102773:	57                   	push   %edi
  102774:	56                   	push   %esi
  102775:	83 ec 60             	sub    $0x60,%esp
  102778:	8b 45 08             	mov    0x8(%ebp),%eax
  10277b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t kernel_init_pdir = vmm_init();
  10277e:	e8 ad 43 00 00       	call   106b30 <vmm_init>
  102783:	8d 0d 93 82 10 00    	lea    0x108293,%ecx
  102789:	89 45 f0             	mov    %eax,-0x10(%ebp)

	kprintf("Setting PIT interval...\n");
  10278c:	89 0c 24             	mov    %ecx,(%esp)
  10278f:	e8 1c db ff ff       	call   1002b0 <kprintf>
  102794:	b9 43 00 00 00       	mov    $0x43,%ecx
  102799:	ba 36 00 00 00       	mov    $0x36,%edx

	outb(0x43, 0x36);
  10279e:	c7 04 24 43 00 00 00 	movl   $0x43,(%esp)
  1027a5:	c7 44 24 04 36 00 00 	movl   $0x36,0x4(%esp)
  1027ac:	00 
  1027ad:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1027b0:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1027b3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  1027b6:	e8 05 02 00 00       	call   1029c0 <outb>
  1027bb:	b8 40 00 00 00       	mov    $0x40,%eax
  1027c0:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
	outw(0x40, 1000);
  1027c5:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  1027cc:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  1027d3:	00 
  1027d4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1027d7:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  1027da:	e8 11 02 00 00       	call   1029f0 <outw>
  1027df:	8d 05 ac 82 10 00    	lea    0x1082ac,%eax

    kprintf("Initializing vfs...\n");
  1027e5:	89 04 24             	mov    %eax,(%esp)
  1027e8:	e8 c3 da ff ff       	call   1002b0 <kprintf>

    vfs_init_root();
  1027ed:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1027f0:	e8 4b 35 00 00       	call   105d40 <vfs_init_root>
    ramfs_fifo_init();
  1027f5:	e8 a6 0b 00 00       	call   1033a0 <ramfs_fifo_init>
    ramfs_block_init();
  1027fa:	e8 f1 06 00 00       	call   102ef0 <ramfs_block_init>

    driver_keyboard_init();
  1027ff:	e8 5c e4 ff ff       	call   100c60 <driver_keyboard_init>
  102804:	b8 00 00 00 00       	mov    $0x0,%eax


    map_address_active((uint32_t) mb_info,
  102809:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10280c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10280f:	89 0c 24             	mov    %ecx,(%esp)
  102812:	89 54 24 04          	mov    %edx,0x4(%esp)
  102816:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  10281d:	00 
  10281e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102821:	e8 fa 3e 00 00       	call   106720 <map_address_active>
  102826:	b8 00 00 00 00       	mov    $0x0,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  10282b:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10282e:	8b 49 18             	mov    0x18(%ecx),%ecx
  102831:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102834:	8b 52 18             	mov    0x18(%edx),%edx
  102837:	89 0c 24             	mov    %ecx,(%esp)
  10283a:	89 54 24 04          	mov    %edx,0x4(%esp)
  10283e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102845:	00 
  102846:	89 45 d0             	mov    %eax,-0x30(%ebp)
  102849:	e8 d2 3e 00 00       	call   106720 <map_address_active>
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  10284e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102851:	8b 00                	mov    (%eax),%eax
  102853:	25 08 00 00 00       	and    $0x8,%eax
  102858:	3d 00 00 00 00       	cmp    $0x0,%eax
  10285d:	0f 84 aa 00 00 00    	je     10290d <kernel_main+0x19d>
  102863:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  102868:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10286b:	8b 49 18             	mov    0x18(%ecx),%ecx
  10286e:	8b 09                	mov    (%ecx),%ecx
  102870:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102873:	8b 52 18             	mov    0x18(%edx),%edx
  102876:	8b 12                	mov    (%edx),%edx
  102878:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10287b:	8b 76 18             	mov    0x18(%esi),%esi
  10287e:	8b 76 04             	mov    0x4(%esi),%esi
  102881:	8b 7d f4             	mov    -0xc(%ebp),%edi
  102884:	8b 7f 18             	mov    0x18(%edi),%edi
  102887:	8b 3f                	mov    (%edi),%edi
  102889:	29 fe                	sub    %edi,%esi
  10288b:	89 0c 24             	mov    %ecx,(%esp)
  10288e:	89 54 24 04          	mov    %edx,0x4(%esp)
  102892:	89 74 24 08          	mov    %esi,0x8(%esp)
  102896:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10289d:	00 
  10289e:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1028a1:	e8 ea 3e 00 00       	call   106790 <vmm_map_range>
  1028a6:	8d 05 c1 82 10 00    	lea    0x1082c1,%eax
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it... \n", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  1028ac:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1028af:	8b 49 18             	mov    0x18(%ecx),%ecx
  1028b2:	8b 49 04             	mov    0x4(%ecx),%ecx
  1028b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1028b8:	8b 52 18             	mov    0x18(%edx),%edx
  1028bb:	8b 12                	mov    (%edx),%edx
  1028bd:	29 d1                	sub    %edx,%ecx
  1028bf:	89 04 24             	mov    %eax,(%esp)
  1028c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1028c6:	e8 e5 d9 ff ff       	call   1002b0 <kprintf>
  1028cb:	8d 0d 01 83 10 00    	lea    0x108301,%ecx
        kprintf("Mapped mod from %x to %x\n", mb_info->mi_mods_addr[0].start, mb_info->mi_mods_addr[0].end);
  1028d1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1028d4:	8b 52 18             	mov    0x18(%edx),%edx
  1028d7:	8b 12                	mov    (%edx),%edx
  1028d9:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1028dc:	8b 76 18             	mov    0x18(%esi),%esi
  1028df:	8b 76 04             	mov    0x4(%esi),%esi
  1028e2:	89 0c 24             	mov    %ecx,(%esp)
  1028e5:	89 54 24 04          	mov    %edx,0x4(%esp)
  1028e9:	89 74 24 08          	mov    %esi,0x8(%esp)
  1028ed:	89 45 c8             	mov    %eax,-0x38(%ebp)
  1028f0:	e8 bb d9 ff ff       	call   1002b0 <kprintf>

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  1028f5:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1028f8:	8b 49 18             	mov    0x18(%ecx),%ecx
  1028fb:	8b 09                	mov    (%ecx),%ecx
  1028fd:	89 0c 24             	mov    %ecx,(%esp)
  102900:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  102903:	e8 18 10 00 00       	call   103920 <tar_load_ramfs>
    } else {
  102908:	e9 11 00 00 00       	jmp    10291e <kernel_main+0x1ae>
  10290d:	8d 05 1b 83 10 00    	lea    0x10831b,%eax
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  102913:	89 04 24             	mov    %eax,(%esp)
  102916:	e8 95 d9 ff ff       	call   1002b0 <kprintf>
  10291b:	89 45 c0             	mov    %eax,-0x40(%ebp)
  10291e:	8d 05 4d 83 10 00    	lea    0x10834d,%eax
    }

    kprintf("[kernel_res] Creating /dev/vga\n");
  102924:	89 04 24             	mov    %eax,(%esp)
  102927:	e8 84 d9 ff ff       	call   1002b0 <kprintf>
  10292c:	8d 0d 6d 83 10 00    	lea    0x10836d,%ecx
  102932:	ba 00 00 00 00       	mov    $0x0,%edx
    vfs_create_kfile("/dev/vga", ramfs_vga_driver_struct(), 0);
  102937:	89 45 bc             	mov    %eax,-0x44(%ebp)
  10293a:	89 4d b8             	mov    %ecx,-0x48(%ebp)
  10293d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  102940:	e8 3b 15 00 00       	call   103e80 <ramfs_vga_driver_struct>
  102945:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  102948:	89 0c 24             	mov    %ecx,(%esp)
  10294b:	89 44 24 04          	mov    %eax,0x4(%esp)
  10294f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  102956:	00 
  102957:	e8 a4 29 00 00       	call   105300 <vfs_create_kfile>
  10295c:	8d 0d 76 83 10 00    	lea    0x108376,%ecx

    if(vfs_exists("/ibin/init")) {
  102962:	89 0c 24             	mov    %ecx,(%esp)
  102965:	89 45 b0             	mov    %eax,-0x50(%ebp)
  102968:	e8 43 2e 00 00       	call   1057b0 <vfs_exists>
  10296d:	3d 00 00 00 00       	cmp    $0x0,%eax
  102972:	0f 84 3c 00 00 00    	je     1029b4 <kernel_main+0x244>
  102978:	8d 05 81 83 10 00    	lea    0x108381,%eax
        kprintf("[init] /ibin/init found. Executing...\n");
  10297e:	89 04 24             	mov    %eax,(%esp)
  102981:	e8 2a d9 ff ff       	call   1002b0 <kprintf>
  102986:	8d 0d 76 83 10 00    	lea    0x108376,%ecx
  10298c:	ba 00 00 00 00       	mov    $0x0,%edx

        vfs_exec("/ibin/init", 0, 0);
  102991:	89 0c 24             	mov    %ecx,(%esp)
  102994:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10299b:	00 
  10299c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1029a3:	00 
  1029a4:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1029a7:	89 55 a8             	mov    %edx,-0x58(%ebp)
  1029aa:	e8 91 2e 00 00       	call   105840 <vfs_exec>
        enableScheduling();
  1029af:	e8 ec 14 00 00       	call   103ea0 <enableScheduling>
    }

	while(1);
  1029b4:	e9 00 00 00 00       	jmp    1029b9 <kernel_main+0x249>
  1029b9:	e9 fb ff ff ff       	jmp    1029b9 <kernel_main+0x249>
  1029be:	66 90                	xchg   %ax,%ax

001029c0 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  1029c0:	55                   	push   %ebp
  1029c1:	89 e5                	mov    %esp,%ebp
  1029c3:	50                   	push   %eax
  1029c4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1029c8:	66 89 c1             	mov    %ax,%cx
  1029cb:	8a 55 0c             	mov    0xc(%ebp),%dl
  1029ce:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  1029d2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  1029d5:	8a 45 fd             	mov    -0x3(%ebp),%al
  1029d8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1029dc:	ee                   	out    %al,(%dx)
}
  1029dd:	83 c4 04             	add    $0x4,%esp
  1029e0:	5d                   	pop    %ebp
  1029e1:	c3                   	ret    
  1029e2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1029e9:	1f 84 00 00 00 00 00 

001029f0 <outw>:
    uint32_t result;
    asm volatile ("inl %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline void outw(uint16_t _port, uint16_t _data) {
  1029f0:	55                   	push   %ebp
  1029f1:	89 e5                	mov    %esp,%ebp
  1029f3:	50                   	push   %eax
  1029f4:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  1029f8:	66 89 c1             	mov    %ax,%cx
  1029fb:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1029ff:	66 89 c2             	mov    %ax,%dx
  102a02:	66 89 55 fe          	mov    %dx,-0x2(%ebp)
  102a06:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
  102a0a:	66 8b 45 fc          	mov    -0x4(%ebp),%ax
  102a0e:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  102a12:	66 ef                	out    %ax,(%dx)
}
  102a14:	83 c4 04             	add    $0x4,%esp
  102a17:	5d                   	pop    %ebp
  102a18:	c3                   	ret    
  102a19:	66 90                	xchg   %ax,%ax
  102a1b:	66 90                	xchg   %ax,%ax
  102a1d:	66 90                	xchg   %ax,%ax
  102a1f:	90                   	nop

00102a20 <pmm_alloc>:
#define BITMAP_SIZE 32768

uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
  102a20:	55                   	push   %ebp
  102a21:	89 e5                	mov    %esp,%ebp
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102a23:	56                   	push   %esi
  102a24:	83 ec 10             	sub    $0x10,%esp
  102a27:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102a2e:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102a35:	0f 8d b7 00 00 00    	jge    102af2 <pmm_alloc+0xd2>
		if (allocatable[i]) {
  102a3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102a3e:	81 3c 85 98 98 12 00 	cmpl   $0x0,0x129898(,%eax,4)
  102a45:	00 00 00 00 
  102a49:	0f 84 8e 00 00 00    	je     102add <pmm_alloc+0xbd>
			int s;
			for (s = 0; s < 32; s++) {
  102a4f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102a56:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  102a5d:	0f 8d 75 00 00 00    	jge    102ad8 <pmm_alloc+0xb8>
  102a63:	b8 01 00 00 00       	mov    $0x1,%eax
				if (allocatable[i] & (1 << s)) {
  102a68:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102a6b:	8b 0c 8d 98 98 12 00 	mov    0x129898(,%ecx,4),%ecx
  102a72:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102a75:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102a78:	89 d1                	mov    %edx,%ecx
  102a7a:	d3 e0                	shl    %cl,%eax
  102a7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102a7f:	21 c2                	and    %eax,%edx
  102a81:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  102a87:	0f 84 36 00 00 00    	je     102ac3 <pmm_alloc+0xa3>
  102a8d:	b8 01 00 00 00       	mov    $0x1,%eax
					allocatable[i] &= ~(1 << s);
  102a92:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102a95:	d3 e0                	shl    %cl,%eax
  102a97:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  102a9c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  102a9f:	8b 34 95 98 98 12 00 	mov    0x129898(,%edx,4),%esi
  102aa6:	21 c6                	and    %eax,%esi
  102aa8:	89 34 95 98 98 12 00 	mov    %esi,0x129898(,%edx,4)
					return (uint8_t*) ((i * 32 + s) * 4096);
  102aaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ab2:	c1 e0 05             	shl    $0x5,%eax
  102ab5:	03 45 f0             	add    -0x10(%ebp),%eax
  102ab8:	c1 e0 0c             	shl    $0xc,%eax
  102abb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102abe:	e9 36 00 00 00       	jmp    102af9 <pmm_alloc+0xd9>
				}
			}
  102ac3:	e9 00 00 00 00       	jmp    102ac8 <pmm_alloc+0xa8>
void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
		if (allocatable[i]) {
			int s;
			for (s = 0; s < 32; s++) {
  102ac8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102acb:	05 01 00 00 00       	add    $0x1,%eax
  102ad0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102ad3:	e9 7e ff ff ff       	jmp    102a56 <pmm_alloc+0x36>
				if (allocatable[i] & (1 << s)) {
					allocatable[i] &= ~(1 << s);
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
  102ad8:	e9 00 00 00 00       	jmp    102add <pmm_alloc+0xbd>
	}
  102add:	e9 00 00 00 00       	jmp    102ae2 <pmm_alloc+0xc2>
uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102ae2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102ae5:	05 01 00 00 00       	add    $0x1,%eax
  102aea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102aed:	e9 3c ff ff ff       	jmp    102a2e <pmm_alloc+0xe>
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
	}
	return NULL ;
  102af2:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  102af9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102afc:	83 c4 10             	add    $0x10,%esp
  102aff:	5e                   	pop    %esi
  102b00:	5d                   	pop    %ebp
  102b01:	c3                   	ret    
  102b02:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102b09:	1f 84 00 00 00 00 00 

00102b10 <pmm_print_stats>:

void pmm_print_stats() {
  102b10:	55                   	push   %ebp
  102b11:	89 e5                	mov    %esp,%ebp
  102b13:	56                   	push   %esi
  102b14:	83 ec 34             	sub    $0x34,%esp
  102b17:	b8 00 00 10 00       	mov    $0x100000,%eax
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
  102b1c:	c7 04 24 00 00 10 00 	movl   $0x100000,(%esp)
  102b23:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102b26:	e8 65 00 00 00       	call   102b90 <pmm_get_free_space>
  102b2b:	b9 00 04 00 00       	mov    $0x400,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102b30:	8b 15 28 94 10 00    	mov    0x109428,%edx
  102b36:	c1 ea 14             	shr    $0x14,%edx
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
  102b39:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
  102b40:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102b43:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  102b46:	89 55 ec             	mov    %edx,-0x14(%ebp)
  102b49:	e8 42 00 00 00       	call   102b90 <pmm_get_free_space>
  102b4e:	8d 0d a8 83 10 00    	lea    0x1083a8,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102b54:	8b 15 28 94 10 00    	mov    0x109428,%edx
  102b5a:	c1 ea 0a             	shr    $0xa,%edx
  102b5d:	89 0c 24             	mov    %ecx,(%esp)
  102b60:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102b63:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102b67:	8b 75 ec             	mov    -0x14(%ebp),%esi
  102b6a:	89 74 24 08          	mov    %esi,0x8(%esp)
  102b6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  102b72:	89 54 24 10          	mov    %edx,0x10(%esp)
  102b76:	e8 35 d7 ff ff       	call   1002b0 <kprintf>
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
}
  102b7b:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102b7e:	83 c4 34             	add    $0x34,%esp
  102b81:	5e                   	pop    %esi
  102b82:	5d                   	pop    %ebp
  102b83:	c3                   	ret    
  102b84:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102b8b:	00 00 00 00 00 

00102b90 <pmm_get_free_space>:

uint32_t pmm_get_free_space(uint32_t div) {
  102b90:	55                   	push   %ebp
  102b91:	89 e5                	mov    %esp,%ebp
  102b93:	83 ec 14             	sub    $0x14,%esp
  102b96:	8b 45 08             	mov    0x8(%ebp),%eax
  102b99:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t free = 0;
  102b9c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  102ba3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  102baa:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102bb1:	0f 83 73 00 00 00    	jae    102c2a <pmm_get_free_space+0x9a>
		for (uint32_t s = 0; s < 32; s++) {
  102bb7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102bbe:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  102bc5:	0f 83 4a 00 00 00    	jae    102c15 <pmm_get_free_space+0x85>
  102bcb:	b8 01 00 00 00       	mov    $0x1,%eax
			if (allocatable[i] & (1 << s))
  102bd0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102bd3:	8b 0c 8d 98 98 12 00 	mov    0x129898(,%ecx,4),%ecx
  102bda:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102bdd:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102be0:	89 d1                	mov    %edx,%ecx
  102be2:	d3 e0                	shl    %cl,%eax
  102be4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102be7:	21 c2                	and    %eax,%edx
  102be9:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  102bef:	0f 84 0b 00 00 00    	je     102c00 <pmm_get_free_space+0x70>
				free += 0x1000;
  102bf5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102bf8:	05 00 10 00 00       	add    $0x1000,%eax
  102bfd:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  102c00:	e9 00 00 00 00       	jmp    102c05 <pmm_get_free_space+0x75>

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
		for (uint32_t s = 0; s < 32; s++) {
  102c05:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c08:	05 01 00 00 00       	add    $0x1,%eax
  102c0d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102c10:	e9 a9 ff ff ff       	jmp    102bbe <pmm_get_free_space+0x2e>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}
  102c15:	e9 00 00 00 00       	jmp    102c1a <pmm_get_free_space+0x8a>
}

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  102c1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c1d:	05 01 00 00 00       	add    $0x1,%eax
  102c22:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102c25:	e9 80 ff ff ff       	jmp    102baa <pmm_get_free_space+0x1a>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}

	return free / div;
  102c2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c2d:	31 d2                	xor    %edx,%edx
  102c2f:	f7 75 fc             	divl   -0x4(%ebp)
  102c32:	83 c4 14             	add    $0x14,%esp
  102c35:	5d                   	pop    %ebp
  102c36:	c3                   	ret    
  102c37:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  102c3e:	00 00 

00102c40 <pmm_free>:
}

void pmm_free(void* addr) {
  102c40:	55                   	push   %ebp
  102c41:	89 e5                	mov    %esp,%ebp
  102c43:	56                   	push   %esi
  102c44:	83 ec 14             	sub    $0x14,%esp
  102c47:	8b 45 08             	mov    0x8(%ebp),%eax
  102c4a:	b9 01 00 00 00       	mov    $0x1,%ecx
  102c4f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  102c52:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c55:	c1 e8 0c             	shr    $0xc,%eax
  102c58:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  102c5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c5e:	25 1f 00 00 00       	and    $0x1f,%eax
  102c63:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  102c66:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c69:	c1 e8 05             	shr    $0x5,%eax
  102c6c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] |= (1 << s);
  102c6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c72:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102c75:	89 c1                	mov    %eax,%ecx
  102c77:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102c7a:	d3 e0                	shl    %cl,%eax
  102c7c:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102c7f:	8b 34 95 98 98 12 00 	mov    0x129898(,%edx,4),%esi
  102c86:	09 c6                	or     %eax,%esi
  102c88:	89 34 95 98 98 12 00 	mov    %esi,0x129898(,%edx,4)
}
  102c8f:	83 c4 14             	add    $0x14,%esp
  102c92:	5e                   	pop    %esi
  102c93:	5d                   	pop    %ebp
  102c94:	c3                   	ret    
  102c95:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  102c9c:	00 00 00 00 

00102ca0 <pmm_mark_used>:

void pmm_mark_used(void* addr) {
  102ca0:	55                   	push   %ebp
  102ca1:	89 e5                	mov    %esp,%ebp
  102ca3:	56                   	push   %esi
  102ca4:	83 ec 14             	sub    $0x14,%esp
  102ca7:	8b 45 08             	mov    0x8(%ebp),%eax
  102caa:	b9 01 00 00 00       	mov    $0x1,%ecx
  102caf:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  102cb2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102cb5:	c1 e8 0c             	shr    $0xc,%eax
  102cb8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  102cbb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cbe:	25 1f 00 00 00       	and    $0x1f,%eax
  102cc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  102cc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cc9:	c1 e8 05             	shr    $0x5,%eax
  102ccc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] &= ~(1 << s);
  102ccf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102cd2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102cd5:	89 c1                	mov    %eax,%ecx
  102cd7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102cda:	d3 e0                	shl    %cl,%eax
  102cdc:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  102ce1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102ce4:	8b 34 95 98 98 12 00 	mov    0x129898(,%edx,4),%esi
  102ceb:	21 c6                	and    %eax,%esi
  102ced:	89 34 95 98 98 12 00 	mov    %esi,0x129898(,%edx,4)
}
  102cf4:	83 c4 14             	add    $0x14,%esp
  102cf7:	5e                   	pop    %esi
  102cf8:	5d                   	pop    %ebp
  102cf9:	c3                   	ret    
  102cfa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00102d00 <pmm_init>:

void pmm_init(struct multiboot_info* mb_info) {
  102d00:	55                   	push   %ebp
  102d01:	89 e5                	mov    %esp,%ebp
  102d03:	53                   	push   %ebx
  102d04:	57                   	push   %edi
  102d05:	56                   	push   %esi
  102d06:	83 ec 5c             	sub    $0x5c,%esp
  102d09:	8b 45 08             	mov    0x8(%ebp),%eax
  102d0c:	8d 0d e5 83 10 00    	lea    0x1083e5,%ecx
  102d12:	8d 15 98 98 12 00    	lea    0x129898,%edx
  102d18:	89 d6                	mov    %edx,%esi
  102d1a:	81 c6 00 00 02 00    	add    $0x20000,%esi
  102d20:	89 d7                	mov    %edx,%edi
  102d22:	bb 00 00 00 00       	mov    $0x0,%ebx
  102d27:	89 45 d0             	mov    %eax,-0x30(%ebp)
  102d2a:	b8 00 00 02 00       	mov    $0x20000,%eax
  102d2f:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102d32:	8b 45 d0             	mov    -0x30(%ebp),%eax
  102d35:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct multiboot_mmap* mmap = mb_info->mi_mmap_addr;
  102d38:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d3b:	8b 40 30             	mov    0x30(%eax),%eax
  102d3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct multiboot_mmap* mmap_end = (void*) ((uintptr_t) mb_info->mi_mmap_addr
  102d41:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d44:	8b 40 30             	mov    0x30(%eax),%eax
  102d47:	89 45 c8             	mov    %eax,-0x38(%ebp)
  102d4a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d4d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  102d50:	8b 45 c8             	mov    -0x38(%ebp),%eax
  102d53:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  102d56:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  102d59:	03 41 2c             	add    0x2c(%ecx),%eax
  102d5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
			+ mb_info->mi_mmap_length);

	memset(allocatable, 0, sizeof(allocatable));
  102d5f:	89 3c 24             	mov    %edi,(%esp)
  102d62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102d69:	00 
  102d6a:	c7 44 24 08 00 00 02 	movl   $0x20000,0x8(%esp)
  102d71:	00 
  102d72:	89 5d bc             	mov    %ebx,-0x44(%ebp)
  102d75:	89 55 b8             	mov    %edx,-0x48(%ebp)
  102d78:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  102d7b:	e8 60 1e 00 00       	call   104be0 <memset>

	kprintf("Mem-Bitmap: %x to %x\n", allocatable, &(allocatable[BITMAP_SIZE]));
  102d80:	8b 45 c0             	mov    -0x40(%ebp),%eax
  102d83:	89 04 24             	mov    %eax,(%esp)
  102d86:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  102d89:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102d8d:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  102d90:	89 54 24 08          	mov    %edx,0x8(%esp)
  102d94:	e8 17 d5 ff ff       	call   1002b0 <kprintf>
  102d99:	89 45 b0             	mov    %eax,-0x50(%ebp)

	while (mmap < mmap_end) {
  102d9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102d9f:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  102da2:	0f 83 77 00 00 00    	jae    102e1f <pmm_init+0x11f>
		if (mmap->mm_type == 1) {
  102da8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102dab:	81 78 14 01 00 00 00 	cmpl   $0x1,0x14(%eax)
  102db2:	0f 85 57 00 00 00    	jne    102e0f <pmm_init+0x10f>
			uintptr_t addr = mmap->mm_base_addr;
  102db8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102dbb:	8b 40 04             	mov    0x4(%eax),%eax
  102dbe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uintptr_t end_addr = addr + mmap->mm_length;
  102dc1:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102dc4:	8b 49 0c             	mov    0xc(%ecx),%ecx
  102dc7:	01 c8                	add    %ecx,%eax
  102dc9:	89 45 e0             	mov    %eax,-0x20(%ebp)

			while (addr < end_addr) {
  102dcc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102dcf:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  102dd2:	0f 83 32 00 00 00    	jae    102e0a <pmm_init+0x10a>
				pmm_free((void*) addr);
  102dd8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102ddb:	89 04 24             	mov    %eax,(%esp)
  102dde:	e8 5d fe ff ff       	call   102c40 <pmm_free>
				if (addr > upper_limit)
  102de3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102de6:	3b 05 28 94 10 00    	cmp    0x109428,%eax
  102dec:	0f 86 08 00 00 00    	jbe    102dfa <pmm_init+0xfa>
					upper_limit = addr;
  102df2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102df5:	a3 28 94 10 00       	mov    %eax,0x109428
				addr += 0x1000;
  102dfa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102dfd:	05 00 10 00 00       	add    $0x1000,%eax
  102e02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			}
  102e05:	e9 c2 ff ff ff       	jmp    102dcc <pmm_init+0xcc>
		}
  102e0a:	e9 00 00 00 00       	jmp    102e0f <pmm_init+0x10f>
		mmap++;
  102e0f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102e12:	05 18 00 00 00       	add    $0x18,%eax
  102e17:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}
  102e1a:	e9 7d ff ff ff       	jmp    102d9c <pmm_init+0x9c>
  102e1f:	8d 05 00 00 10 00    	lea    0x100000,%eax

	extern const void kernel_start;
	extern const void kernel_end;

	uintptr_t addr = (uintptr_t) &kernel_start;
  102e25:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102e28:	8d 05 00 a0 18 00    	lea    0x18a000,%eax
	while (addr < (uintptr_t) &kernel_end) {
  102e2e:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  102e31:	0f 83 1b 00 00 00    	jae    102e52 <pmm_init+0x152>
		pmm_mark_used((void*) addr);
  102e37:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102e3a:	89 04 24             	mov    %eax,(%esp)
  102e3d:	e8 5e fe ff ff       	call   102ca0 <pmm_mark_used>
		addr += 0x1000;
  102e42:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102e45:	05 00 10 00 00       	add    $0x1000,%eax
  102e4a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
  102e4d:	e9 d6 ff ff ff       	jmp    102e28 <pmm_init+0x128>

	struct multiboot_module* modules = mb_info->mi_mods_addr;
  102e52:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102e55:	8b 40 18             	mov    0x18(%eax),%eax
  102e58:	89 45 d8             	mov    %eax,-0x28(%ebp)

	pmm_mark_used(mb_info);
  102e5b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102e5e:	89 04 24             	mov    %eax,(%esp)
  102e61:	e8 3a fe ff ff       	call   102ca0 <pmm_mark_used>
	pmm_mark_used(modules);
  102e66:	8b 45 d8             	mov    -0x28(%ebp),%eax
  102e69:	89 04 24             	mov    %eax,(%esp)
  102e6c:	e8 2f fe ff ff       	call   102ca0 <pmm_mark_used>

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  102e71:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  102e78:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102e7b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102e7e:	3b 41 14             	cmp    0x14(%ecx),%eax
  102e81:	0f 83 59 00 00 00    	jae    102ee0 <pmm_init+0x1e0>
		addr = (uintptr_t) modules[i].start;
  102e87:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102e8a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  102e8d:	c1 e0 04             	shl    $0x4,%eax
  102e90:	01 c1                	add    %eax,%ecx
  102e92:	8b 01                	mov    (%ecx),%eax
  102e94:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while (addr < (uintptr_t) modules[i].end) {
  102e97:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102e9a:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  102e9d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  102ea0:	c1 e1 04             	shl    $0x4,%ecx
  102ea3:	01 ca                	add    %ecx,%edx
  102ea5:	8b 4a 04             	mov    0x4(%edx),%ecx
  102ea8:	39 c8                	cmp    %ecx,%eax
  102eaa:	0f 83 1b 00 00 00    	jae    102ecb <pmm_init+0x1cb>
			pmm_mark_used((void*) addr);
  102eb0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102eb3:	89 04 24             	mov    %eax,(%esp)
  102eb6:	e8 e5 fd ff ff       	call   102ca0 <pmm_mark_used>
			addr += 0x1000;
  102ebb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102ebe:	05 00 10 00 00       	add    $0x1000,%eax
  102ec3:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
  102ec6:	e9 cc ff ff ff       	jmp    102e97 <pmm_init+0x197>
	}
  102ecb:	e9 00 00 00 00       	jmp    102ed0 <pmm_init+0x1d0>

	pmm_mark_used(mb_info);
	pmm_mark_used(modules);

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  102ed0:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102ed3:	05 01 00 00 00       	add    $0x1,%eax
  102ed8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  102edb:	e9 98 ff ff ff       	jmp    102e78 <pmm_init+0x178>
		while (addr < (uintptr_t) modules[i].end) {
			pmm_mark_used((void*) addr);
			addr += 0x1000;
		}
	}
}
  102ee0:	83 c4 5c             	add    $0x5c,%esp
  102ee3:	5e                   	pop    %esi
  102ee4:	5f                   	pop    %edi
  102ee5:	5b                   	pop    %ebx
  102ee6:	5d                   	pop    %ebp
  102ee7:	c3                   	ret    
  102ee8:	66 90                	xchg   %ax,%ax
  102eea:	66 90                	xchg   %ax,%ax
  102eec:	66 90                	xchg   %ax,%ax
  102eee:	66 90                	xchg   %ax,%ax

00102ef0 <ramfs_block_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  102ef0:	55                   	push   %ebp
  102ef1:	89 e5                	mov    %esp,%ebp
  102ef3:	83 ec 18             	sub    $0x18,%esp
  102ef6:	8d 05 98 98 14 00    	lea    0x149898,%eax
  102efc:	b9 00 00 00 00       	mov    $0x0,%ecx
  102f01:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102f06:	89 04 24             	mov    %eax,(%esp)
  102f09:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102f10:	00 
  102f11:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102f18:	00 
  102f19:	89 55 fc             	mov    %edx,-0x4(%ebp)
  102f1c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102f1f:	e8 bc 1c 00 00       	call   104be0 <memset>
}
  102f24:	83 c4 18             	add    $0x18,%esp
  102f27:	5d                   	pop    %ebp
  102f28:	c3                   	ret    
  102f29:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102f30 <ramfs_block_read>:
    }

    return 0;
}

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  102f30:	55                   	push   %ebp
  102f31:	89 e5                	mov    %esp,%ebp
  102f33:	83 ec 28             	sub    $0x28,%esp
  102f36:	8b 45 10             	mov    0x10(%ebp),%eax
  102f39:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102f3c:	8b 55 08             	mov    0x8(%ebp),%edx
  102f3f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102f42:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102f45:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102f48:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f4b:	8b 40 04             	mov    0x4(%eax),%eax
  102f4e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102f51:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102f54:	8b 00                	mov    (%eax),%eax
  102f56:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  102f5d:	00 00 00 00 
  102f61:	0f 84 70 00 00 00    	je     102fd7 <ramfs_block_read+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't read that much biatch
  102f67:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f6a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102f6d:	8b 09                	mov    (%ecx),%ecx
  102f6f:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  102f76:	8b 49 04             	mov    0x4(%ecx),%ecx
  102f79:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102f7c:	2b 4a 08             	sub    0x8(%edx),%ecx
  102f7f:	39 c8                	cmp    %ecx,%eax
  102f81:	0f 86 0c 00 00 00    	jbe    102f93 <ramfs_block_read+0x63>
  102f87:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102f8e:	e9 4b 00 00 00       	jmp    102fde <ramfs_block_read+0xae>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  102f93:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f96:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102f99:	8b 09                	mov    (%ecx),%ecx
  102f9b:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  102fa2:	8b 09                	mov    (%ecx),%ecx
  102fa4:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102fa7:	03 4a 08             	add    0x8(%edx),%ecx
  102faa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102fad:	89 04 24             	mov    %eax,(%esp)
  102fb0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102fb4:	89 54 24 08          	mov    %edx,0x8(%esp)
  102fb8:	e8 83 1c 00 00       	call   104c40 <memcpy>
        handle->position += length;
  102fbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102fc0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102fc3:	8b 51 08             	mov    0x8(%ecx),%edx
  102fc6:	01 c2                	add    %eax,%edx
  102fc8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102fcb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102fd2:	e9 07 00 00 00       	jmp    102fde <ramfs_block_read+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102fd7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102fde:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102fe1:	83 c4 28             	add    $0x28,%esp
  102fe4:	5d                   	pop    %ebp
  102fe5:	c3                   	ret    
  102fe6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  102fed:	00 00 00 

00102ff0 <ramfs_block_write>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  102ff0:	55                   	push   %ebp
  102ff1:	89 e5                	mov    %esp,%ebp
  102ff3:	83 ec 28             	sub    $0x28,%esp
  102ff6:	8b 45 10             	mov    0x10(%ebp),%eax
  102ff9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102ffc:	8b 55 08             	mov    0x8(%ebp),%edx
  102fff:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103002:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103005:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103008:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10300b:	8b 40 04             	mov    0x4(%eax),%eax
  10300e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  103011:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103014:	8b 00                	mov    (%eax),%eax
  103016:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  10301d:	00 00 00 00 
  103021:	0f 84 70 00 00 00    	je     103097 <ramfs_block_write+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't write  that much biatch TODO realloc so file may grow
  103027:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10302a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10302d:	8b 09                	mov    (%ecx),%ecx
  10302f:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  103036:	8b 49 04             	mov    0x4(%ecx),%ecx
  103039:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10303c:	2b 4a 08             	sub    0x8(%edx),%ecx
  10303f:	39 c8                	cmp    %ecx,%eax
  103041:	0f 86 0c 00 00 00    	jbe    103053 <ramfs_block_write+0x63>
  103047:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  10304e:	e9 4b 00 00 00       	jmp    10309e <ramfs_block_write+0xae>

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  103053:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103056:	8b 00                	mov    (%eax),%eax
  103058:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10305f:	8b 00                	mov    (%eax),%eax
  103061:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103064:	03 41 08             	add    0x8(%ecx),%eax
  103067:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10306a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10306d:	89 04 24             	mov    %eax,(%esp)
  103070:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103074:	89 54 24 08          	mov    %edx,0x8(%esp)
  103078:	e8 c3 1b 00 00       	call   104c40 <memcpy>
        handle->position += length;
  10307d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103080:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103083:	8b 51 08             	mov    0x8(%ecx),%edx
  103086:	01 c2                	add    %eax,%edx
  103088:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  10308b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103092:	e9 07 00 00 00       	jmp    10309e <ramfs_block_write+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103097:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  10309e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1030a1:	83 c4 28             	add    $0x28,%esp
  1030a4:	5d                   	pop    %ebp
  1030a5:	c3                   	ret    
  1030a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1030ad:	00 00 00 

001030b0 <ramfs_block_open>:

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  1030b0:	55                   	push   %ebp
  1030b1:	89 e5                	mov    %esp,%ebp
  1030b3:	83 ec 18             	sub    $0x18,%esp
  1030b6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1030b9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1030bc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1030bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  1030c2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030c5:	8b 00                	mov    (%eax),%eax
  1030c7:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  1030ce:	00 00 00 00 
  1030d2:	0f 84 9d 00 00 00    	je     103175 <ramfs_block_open+0xc5>
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  1030d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1030db:	25 01 00 00 00       	and    $0x1,%eax
  1030e0:	3d 00 00 00 00       	cmp    $0x0,%eax
  1030e5:	0f 84 18 00 00 00    	je     103103 <ramfs_block_open+0x53>
  1030eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1030ee:	8b 00                	mov    (%eax),%eax
  1030f0:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  1030f7:	8b 48 08             	mov    0x8(%eax),%ecx
  1030fa:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103100:	89 48 08             	mov    %ecx,0x8(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  103103:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103106:	25 02 00 00 00       	and    $0x2,%eax
  10310b:	3d 00 00 00 00       	cmp    $0x0,%eax
  103110:	0f 84 18 00 00 00    	je     10312e <ramfs_block_open+0x7e>
  103116:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103119:	8b 00                	mov    (%eax),%eax
  10311b:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  103122:	8b 48 0c             	mov    0xc(%eax),%ecx
  103125:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10312b:	89 48 0c             	mov    %ecx,0xc(%eax)
  10312e:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103133:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10313a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10313d:	e8 2e 14 00 00       	call   104570 <malloc>
  103142:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  103145:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103148:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10314b:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  10314e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103151:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  103158:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10315b:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  103161:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103164:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103167:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  10316a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10316d:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103170:	e9 08 00 00 00       	jmp    10317d <ramfs_block_open+0xcd>
  103175:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return (void*)1;
  10317a:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10317d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103180:	83 c4 18             	add    $0x18,%esp
  103183:	5d                   	pop    %ebp
  103184:	c3                   	ret    
  103185:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10318c:	00 00 00 00 

00103190 <ramfs_block_close>:

uint32_t ramfs_block_close(struct res_handle* handle) {
  103190:	55                   	push   %ebp
  103191:	89 e5                	mov    %esp,%ebp
  103193:	83 ec 18             	sub    $0x18,%esp
  103196:	8b 45 08             	mov    0x8(%ebp),%eax
  103199:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10319c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10319f:	8b 40 04             	mov    0x4(%eax),%eax
  1031a2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  1031a5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1031a8:	8b 00                	mov    (%eax),%eax
  1031aa:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  1031b1:	00 00 00 00 
  1031b5:	0f 84 61 00 00 00    	je     10321c <ramfs_block_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  1031bb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031be:	8b 40 0c             	mov    0xc(%eax),%eax
  1031c1:	25 01 00 00 00       	and    $0x1,%eax
  1031c6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1031cb:	0f 84 18 00 00 00    	je     1031e9 <ramfs_block_close+0x59>
  1031d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1031d4:	8b 00                	mov    (%eax),%eax
  1031d6:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  1031dd:	8b 48 08             	mov    0x8(%eax),%ecx
  1031e0:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1031e6:	89 48 08             	mov    %ecx,0x8(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  1031e9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1031ec:	8b 40 0c             	mov    0xc(%eax),%eax
  1031ef:	25 02 00 00 00       	and    $0x2,%eax
  1031f4:	3d 00 00 00 00       	cmp    $0x0,%eax
  1031f9:	0f 84 18 00 00 00    	je     103217 <ramfs_block_close+0x87>
  1031ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103202:	8b 00                	mov    (%eax),%eax
  103204:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10320b:	8b 48 0c             	mov    0xc(%eax),%ecx
  10320e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103214:	89 48 0c             	mov    %ecx,0xc(%eax)
    }
  103217:	e9 00 00 00 00       	jmp    10321c <ramfs_block_close+0x8c>

    free(handle);
  10321c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10321f:	89 04 24             	mov    %eax,(%esp)
  103222:	e8 19 17 00 00       	call   104940 <free>
  103227:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  10322c:	83 c4 18             	add    $0x18,%esp
  10322f:	5d                   	pop    %ebp
  103230:	c3                   	ret    
  103231:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103238:	0f 1f 84 00 00 00 00 
  10323f:	00 

00103240 <ramfs_block_available>:

struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
}

uint32_t ramfs_block_available(struct res_handle* handle) {
  103240:	55                   	push   %ebp
  103241:	89 e5                	mov    %esp,%ebp
  103243:	83 ec 0c             	sub    $0xc,%esp
  103246:	8b 45 08             	mov    0x8(%ebp),%eax
  103249:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10324c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10324f:	8b 40 04             	mov    0x4(%eax),%eax
  103252:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  103255:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103258:	8b 00                	mov    (%eax),%eax
  10325a:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  103261:	00 00 00 00 
  103265:	0f 84 1d 00 00 00    	je     103288 <ramfs_block_available+0x48>
        return buffer[kf->id]->size - handle->position;
  10326b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10326e:	8b 00                	mov    (%eax),%eax
  103270:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  103277:	8b 40 04             	mov    0x4(%eax),%eax
  10327a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10327d:	2b 41 08             	sub    0x8(%ecx),%eax
  103280:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103283:	e9 07 00 00 00       	jmp    10328f <ramfs_block_available+0x4f>
    }

    return 0;
  103288:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  10328f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103292:	83 c4 0c             	add    $0xc,%esp
  103295:	5d                   	pop    %ebp
  103296:	c3                   	ret    
  103297:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10329e:	00 00 

001032a0 <ramfs_block_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  1032a0:	55                   	push   %ebp
  1032a1:	89 e5                	mov    %esp,%ebp
  1032a3:	83 ec 28             	sub    $0x28,%esp
  1032a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1032a9:	b9 08 00 00 00       	mov    $0x8,%ecx
  1032ae:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  1032b1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  1032b8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1032bb:	e8 b0 12 00 00       	call   104570 <malloc>
  1032c0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  1032c3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1032ca:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  1032d1:	0f 8d a7 00 00 00    	jge    10337e <ramfs_block_create+0xde>
        if(buffer[i] == 0) {
  1032d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1032da:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  1032e1:	00 00 00 00 
  1032e5:	0f 85 7e 00 00 00    	jne    103369 <ramfs_block_create+0xc9>
  1032eb:	b8 10 00 00 00       	mov    $0x10,%eax
            buffer[i] = malloc(sizeof(struct block_buffer));
  1032f0:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  1032f7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1032fa:	e8 71 12 00 00       	call   104570 <malloc>
  1032ff:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103302:	89 04 8d 98 98 14 00 	mov    %eax,0x149898(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  103309:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10330c:	8b 00                	mov    (%eax),%eax
  10330e:	89 04 24             	mov    %eax,(%esp)
  103311:	e8 5a 12 00 00       	call   104570 <malloc>
  103316:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103319:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  103320:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  103322:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103325:	8b 00                	mov    (%eax),%eax
  103327:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10332a:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  103331:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->writers = 0;
  103334:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103337:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10333e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            buffer[i]->readers = 0;
  103345:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103348:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10334f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

            kfret->id = i;
  103356:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103359:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10335c:	89 01                	mov    %eax,(%ecx)

            return kfret;
  10335e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103361:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103364:	e9 1c 00 00 00       	jmp    103385 <ramfs_block_create+0xe5>
        }
    }
  103369:	e9 00 00 00 00       	jmp    10336e <ramfs_block_create+0xce>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  10336e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103371:	05 01 00 00 00       	add    $0x1,%eax
  103376:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103379:	e9 4c ff ff ff       	jmp    1032ca <ramfs_block_create+0x2a>

            return kfret;
        }
    }

    return 0;
  10337e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103385:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103388:	83 c4 28             	add    $0x28,%esp
  10338b:	5d                   	pop    %ebp
  10338c:	c3                   	ret    
  10338d:	0f 1f 00             	nopl   (%eax)

00103390 <ramfs_block_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  103390:	55                   	push   %ebp
  103391:	89 e5                	mov    %esp,%ebp
  103393:	8d 05 88 72 10 00    	lea    0x107288,%eax
    return &block_driver;
  103399:	5d                   	pop    %ebp
  10339a:	c3                   	ret    
  10339b:	66 90                	xchg   %ax,%ax
  10339d:	66 90                	xchg   %ax,%ax
  10339f:	90                   	nop

001033a0 <ramfs_fifo_init>:
#include "ramfs/fifo.h"

struct fifo_buffer* buffer[65536];

void ramfs_fifo_init() {
  1033a0:	55                   	push   %ebp
  1033a1:	89 e5                	mov    %esp,%ebp
  1033a3:	83 ec 18             	sub    $0x18,%esp
  1033a6:	8d 05 98 98 14 00    	lea    0x149898,%eax
  1033ac:	b9 00 00 00 00       	mov    $0x0,%ecx
  1033b1:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  1033b6:	89 04 24             	mov    %eax,(%esp)
  1033b9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1033c0:	00 
  1033c1:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  1033c8:	00 
  1033c9:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1033cc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1033cf:	e8 0c 18 00 00       	call   104be0 <memset>
}
  1033d4:	83 c4 18             	add    $0x18,%esp
  1033d7:	5d                   	pop    %ebp
  1033d8:	c3                   	ret    
  1033d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

001033e0 <ramfs_fifo_read>:
    }

    return 0;
}

uint32_t ramfs_fifo_read(struct res_handle* handle, void* dest, uint32_t length) {
  1033e0:	55                   	push   %ebp
  1033e1:	89 e5                	mov    %esp,%ebp
  1033e3:	83 ec 28             	sub    $0x28,%esp
  1033e6:	8b 45 10             	mov    0x10(%ebp),%eax
  1033e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1033ec:	8b 55 08             	mov    0x8(%ebp),%edx
  1033ef:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1033f2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1033f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1033f8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1033fb:	8b 40 04             	mov    0x4(%eax),%eax
  1033fe:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  103401:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103404:	8b 00                	mov    (%eax),%eax
  103406:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  10340d:	00 00 00 00 
  103411:	0f 84 d0 00 00 00    	je     1034e7 <ramfs_fifo_read+0x107>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't read cause buffer too small
  103417:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10341a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10341d:	8b 09                	mov    (%ecx),%ecx
  10341f:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  103426:	3b 41 04             	cmp    0x4(%ecx),%eax
  103429:	0f 86 0c 00 00 00    	jbe    10343b <ramfs_fifo_read+0x5b>
  10342f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103436:	e9 b3 00 00 00       	jmp    1034ee <ramfs_fifo_read+0x10e>
        if(length > buffer[kf->id]->pos)  return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has writers
  10343b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10343e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103441:	8b 09                	mov    (%ecx),%ecx
  103443:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  10344a:	3b 41 08             	cmp    0x8(%ecx),%eax
  10344d:	0f 86 0c 00 00 00    	jbe    10345f <ramfs_fifo_read+0x7f>
  103453:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10345a:	e9 8f 00 00 00       	jmp    1034ee <ramfs_fifo_read+0x10e>

        memcpy(dest, buffer[kf->id]->buffer, length);
  10345f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103462:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103465:	8b 09                	mov    (%ecx),%ecx
  103467:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  10346e:	8b 09                	mov    (%ecx),%ecx
  103470:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103473:	89 04 24             	mov    %eax,(%esp)
  103476:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10347a:	89 54 24 08          	mov    %edx,0x8(%esp)
  10347e:	e8 bd 17 00 00       	call   104c40 <memcpy>
        memcpy(buffer[kf->id]->buffer, buffer[kf->id]->buffer + length, buffer[kf->id]->pos - length);
  103483:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103486:	8b 00                	mov    (%eax),%eax
  103488:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10348f:	8b 00                	mov    (%eax),%eax
  103491:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103494:	8b 09                	mov    (%ecx),%ecx
  103496:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  10349d:	8b 09                	mov    (%ecx),%ecx
  10349f:	03 4d f0             	add    -0x10(%ebp),%ecx
  1034a2:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1034a5:	8b 12                	mov    (%edx),%edx
  1034a7:	8b 14 95 98 98 14 00 	mov    0x149898(,%edx,4),%edx
  1034ae:	8b 52 08             	mov    0x8(%edx),%edx
  1034b1:	2b 55 f0             	sub    -0x10(%ebp),%edx
  1034b4:	89 04 24             	mov    %eax,(%esp)
  1034b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1034bb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1034bf:	e8 7c 17 00 00       	call   104c40 <memcpy>
        buffer[kf->id]->pos -= length;
  1034c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1034c7:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1034ca:	8b 09                	mov    (%ecx),%ecx
  1034cc:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  1034d3:	8b 51 08             	mov    0x8(%ecx),%edx
  1034d6:	29 c2                	sub    %eax,%edx
  1034d8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  1034db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1034e2:	e9 07 00 00 00       	jmp    1034ee <ramfs_fifo_read+0x10e>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  1034e7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1034ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1034f1:	83 c4 28             	add    $0x28,%esp
  1034f4:	5d                   	pop    %ebp
  1034f5:	c3                   	ret    
  1034f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1034fd:	00 00 00 

00103500 <ramfs_fifo_write>:

uint32_t ramfs_fifo_write(struct res_handle* handle, void* src, uint32_t length) {
  103500:	55                   	push   %ebp
  103501:	89 e5                	mov    %esp,%ebp
  103503:	83 ec 28             	sub    $0x28,%esp
  103506:	8b 45 10             	mov    0x10(%ebp),%eax
  103509:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10350c:	8b 55 08             	mov    0x8(%ebp),%edx
  10350f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103512:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103515:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  103518:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10351b:	8b 40 04             	mov    0x4(%eax),%eax
  10351e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  103521:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103524:	8b 00                	mov    (%eax),%eax
  103526:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  10352d:	00 00 00 00 
  103531:	0f 84 af 00 00 00    	je     1035e6 <ramfs_fifo_write+0xe6>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't write cause buffer too small
  103537:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10353a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10353d:	8b 09                	mov    (%ecx),%ecx
  10353f:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  103546:	3b 41 04             	cmp    0x4(%ecx),%eax
  103549:	0f 86 0c 00 00 00    	jbe    10355b <ramfs_fifo_write+0x5b>
  10354f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103556:	e9 92 00 00 00       	jmp    1035ed <ramfs_fifo_write+0xed>
        if(length > (buffer[kf->id]->size - buffer[kf->id]->pos)) return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has readers
  10355b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10355e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103561:	8b 09                	mov    (%ecx),%ecx
  103563:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  10356a:	8b 49 04             	mov    0x4(%ecx),%ecx
  10356d:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103570:	8b 12                	mov    (%edx),%edx
  103572:	8b 14 95 98 98 14 00 	mov    0x149898(,%edx,4),%edx
  103579:	2b 4a 08             	sub    0x8(%edx),%ecx
  10357c:	39 c8                	cmp    %ecx,%eax
  10357e:	0f 86 0c 00 00 00    	jbe    103590 <ramfs_fifo_write+0x90>
  103584:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  10358b:	e9 5d 00 00 00       	jmp    1035ed <ramfs_fifo_write+0xed>

        memcpy(buffer[kf->id]->buffer + buffer[kf->id]->pos, src, length);
  103590:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103593:	8b 00                	mov    (%eax),%eax
  103595:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10359c:	8b 00                	mov    (%eax),%eax
  10359e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1035a1:	8b 09                	mov    (%ecx),%ecx
  1035a3:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  1035aa:	03 41 08             	add    0x8(%ecx),%eax
  1035ad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1035b0:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1035b3:	89 04 24             	mov    %eax,(%esp)
  1035b6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1035ba:	89 54 24 08          	mov    %edx,0x8(%esp)
  1035be:	e8 7d 16 00 00       	call   104c40 <memcpy>
        buffer[kf->id]->pos += length;
  1035c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1035c6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1035c9:	8b 09                	mov    (%ecx),%ecx
  1035cb:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  1035d2:	8b 51 08             	mov    0x8(%ecx),%edx
  1035d5:	01 c2                	add    %eax,%edx
  1035d7:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  1035da:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1035e1:	e9 07 00 00 00       	jmp    1035ed <ramfs_fifo_write+0xed>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  1035e6:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1035ed:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1035f0:	83 c4 28             	add    $0x28,%esp
  1035f3:	5d                   	pop    %ebp
  1035f4:	c3                   	ret    
  1035f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1035fc:	00 00 00 00 

00103600 <ramfs_fifo_open>:

struct res_handle* ramfs_fifo_open(struct res_kfile* kf, uint32_t filemode) {
  103600:	55                   	push   %ebp
  103601:	89 e5                	mov    %esp,%ebp
  103603:	83 ec 18             	sub    $0x18,%esp
  103606:	8b 45 0c             	mov    0xc(%ebp),%eax
  103609:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10360c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10360f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  103612:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103615:	8b 00                	mov    (%eax),%eax
  103617:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  10361e:	00 00 00 00 
  103622:	0f 84 bc 00 00 00    	je     1036e4 <ramfs_fifo_open+0xe4>
        if(filemode & FM_EXEC) return 0;
  103628:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10362b:	25 04 00 00 00       	and    $0x4,%eax
  103630:	3d 00 00 00 00       	cmp    $0x0,%eax
  103635:	0f 84 0c 00 00 00    	je     103647 <ramfs_fifo_open+0x47>
  10363b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103642:	e9 a4 00 00 00       	jmp    1036eb <ramfs_fifo_open+0xeb>

        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  103647:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10364a:	25 01 00 00 00       	and    $0x1,%eax
  10364f:	3d 00 00 00 00       	cmp    $0x0,%eax
  103654:	0f 84 18 00 00 00    	je     103672 <ramfs_fifo_open+0x72>
  10365a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10365d:	8b 00                	mov    (%eax),%eax
  10365f:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  103666:	8b 48 0c             	mov    0xc(%eax),%ecx
  103669:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10366f:	89 48 0c             	mov    %ecx,0xc(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  103672:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103675:	25 02 00 00 00       	and    $0x2,%eax
  10367a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10367f:	0f 84 18 00 00 00    	je     10369d <ramfs_fifo_open+0x9d>
  103685:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103688:	8b 00                	mov    (%eax),%eax
  10368a:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  103691:	8b 48 10             	mov    0x10(%eax),%ecx
  103694:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10369a:	89 48 10             	mov    %ecx,0x10(%eax)
  10369d:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  1036a2:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  1036a9:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1036ac:	e8 bf 0e 00 00       	call   104570 <malloc>
  1036b1:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  1036b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1036b7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1036ba:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  1036bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1036c0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  1036c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1036ca:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  1036d0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1036d3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1036d6:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  1036d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1036dc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1036df:	e9 07 00 00 00       	jmp    1036eb <ramfs_fifo_open+0xeb>
    }

    return 0;
  1036e4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1036eb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1036ee:	83 c4 18             	add    $0x18,%esp
  1036f1:	5d                   	pop    %ebp
  1036f2:	c3                   	ret    
  1036f3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1036fa:	84 00 00 00 00 00 

00103700 <ramfs_fifo_close>:

uint32_t ramfs_fifo_close(struct res_handle* handle) {
  103700:	55                   	push   %ebp
  103701:	89 e5                	mov    %esp,%ebp
  103703:	83 ec 18             	sub    $0x18,%esp
  103706:	8b 45 08             	mov    0x8(%ebp),%eax
  103709:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  10370c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10370f:	8b 40 04             	mov    0x4(%eax),%eax
  103712:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  103715:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103718:	8b 00                	mov    (%eax),%eax
  10371a:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  103721:	00 00 00 00 
  103725:	0f 84 61 00 00 00    	je     10378c <ramfs_fifo_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  10372b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10372e:	8b 40 0c             	mov    0xc(%eax),%eax
  103731:	25 01 00 00 00       	and    $0x1,%eax
  103736:	3d 00 00 00 00       	cmp    $0x0,%eax
  10373b:	0f 84 18 00 00 00    	je     103759 <ramfs_fifo_close+0x59>
  103741:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103744:	8b 00                	mov    (%eax),%eax
  103746:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10374d:	8b 48 0c             	mov    0xc(%eax),%ecx
  103750:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103756:	89 48 0c             	mov    %ecx,0xc(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  103759:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10375c:	8b 40 0c             	mov    0xc(%eax),%eax
  10375f:	25 02 00 00 00       	and    $0x2,%eax
  103764:	3d 00 00 00 00       	cmp    $0x0,%eax
  103769:	0f 84 18 00 00 00    	je     103787 <ramfs_fifo_close+0x87>
  10376f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103772:	8b 00                	mov    (%eax),%eax
  103774:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  10377b:	8b 48 10             	mov    0x10(%eax),%ecx
  10377e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103784:	89 48 10             	mov    %ecx,0x10(%eax)
    }
  103787:	e9 00 00 00 00       	jmp    10378c <ramfs_fifo_close+0x8c>

    free(handle);
  10378c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10378f:	89 04 24             	mov    %eax,(%esp)
  103792:	e8 a9 11 00 00       	call   104940 <free>
  103797:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  10379c:	83 c4 18             	add    $0x18,%esp
  10379f:	5d                   	pop    %ebp
  1037a0:	c3                   	ret    
  1037a1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1037a8:	0f 1f 84 00 00 00 00 
  1037af:	00 

001037b0 <ramfs_fifo_available>:

struct kfs_driver* ramfs_fifo_driver_struct() {
    return &fifo_driver;
}

uint32_t ramfs_fifo_available(struct res_handle* handle) {
  1037b0:	55                   	push   %ebp
  1037b1:	89 e5                	mov    %esp,%ebp
  1037b3:	83 ec 0c             	sub    $0xc,%esp
  1037b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1037b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1037bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1037bf:	8b 40 04             	mov    0x4(%eax),%eax
  1037c2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  1037c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037c8:	8b 00                	mov    (%eax),%eax
  1037ca:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  1037d1:	00 00 00 00 
  1037d5:	0f 84 17 00 00 00    	je     1037f2 <ramfs_fifo_available+0x42>
        return buffer[kf->id]->pos;
  1037db:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1037de:	8b 00                	mov    (%eax),%eax
  1037e0:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  1037e7:	8b 40 08             	mov    0x8(%eax),%eax
  1037ea:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1037ed:	e9 07 00 00 00       	jmp    1037f9 <ramfs_fifo_available+0x49>
    }

    return 0;
  1037f2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1037f9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1037fc:	83 c4 0c             	add    $0xc,%esp
  1037ff:	5d                   	pop    %ebp
  103800:	c3                   	ret    
  103801:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103808:	0f 1f 84 00 00 00 00 
  10380f:	00 

00103810 <ramfs_fifo_create>:

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
  103810:	55                   	push   %ebp
  103811:	89 e5                	mov    %esp,%ebp
  103813:	83 ec 28             	sub    $0x28,%esp
  103816:	8b 45 08             	mov    0x8(%ebp),%eax
  103819:	b9 08 00 00 00       	mov    $0x8,%ecx
  10381e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  103821:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103828:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10382b:	e8 40 0d 00 00       	call   104570 <malloc>
  103830:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  103833:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10383a:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  103841:	0f 8d b8 00 00 00    	jge    1038ff <ramfs_fifo_create+0xef>
        if(buffer[i] == 0) {
  103847:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10384a:	81 3c 85 98 98 14 00 	cmpl   $0x0,0x149898(,%eax,4)
  103851:	00 00 00 00 
  103855:	0f 85 8f 00 00 00    	jne    1038ea <ramfs_fifo_create+0xda>
  10385b:	b8 14 00 00 00       	mov    $0x14,%eax
            buffer[i] = malloc(sizeof(struct fifo_buffer));
  103860:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  103867:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10386a:	e8 01 0d 00 00       	call   104570 <malloc>
  10386f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103872:	89 04 8d 98 98 14 00 	mov    %eax,0x149898(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  103879:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10387c:	8b 00                	mov    (%eax),%eax
  10387e:	89 04 24             	mov    %eax,(%esp)
  103881:	e8 ea 0c 00 00       	call   104570 <malloc>
  103886:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103889:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  103890:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  103892:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103895:	8b 00                	mov    (%eax),%eax
  103897:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10389a:	8b 0c 8d 98 98 14 00 	mov    0x149898(,%ecx,4),%ecx
  1038a1:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->pos = 0;
  1038a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038a7:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  1038ae:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            buffer[i]->writers = 0;
  1038b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038b8:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  1038bf:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
            buffer[i]->readers = 0;
  1038c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038c9:	8b 04 85 98 98 14 00 	mov    0x149898(,%eax,4),%eax
  1038d0:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

            kfret->id = i;
  1038d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038da:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1038dd:	89 01                	mov    %eax,(%ecx)

            return kfret;
  1038df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1038e2:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1038e5:	e9 1c 00 00 00       	jmp    103906 <ramfs_fifo_create+0xf6>
        }
    }
  1038ea:	e9 00 00 00 00       	jmp    1038ef <ramfs_fifo_create+0xdf>
}

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  1038ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038f2:	05 01 00 00 00       	add    $0x1,%eax
  1038f7:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1038fa:	e9 3b ff ff ff       	jmp    10383a <ramfs_fifo_create+0x2a>

            return kfret;
        }
    }

    return 0;
  1038ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103906:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103909:	83 c4 28             	add    $0x28,%esp
  10390c:	5d                   	pop    %ebp
  10390d:	c3                   	ret    
  10390e:	66 90                	xchg   %ax,%ax

00103910 <ramfs_fifo_driver_struct>:
    .close     = ramfs_fifo_close,
    .available = ramfs_fifo_available,
    .drvname   = "FIFO"
};

struct kfs_driver* ramfs_fifo_driver_struct() {
  103910:	55                   	push   %ebp
  103911:	89 e5                	mov    %esp,%ebp
  103913:	8d 05 a4 72 10 00    	lea    0x1072a4,%eax
    return &fifo_driver;
  103919:	5d                   	pop    %ebp
  10391a:	c3                   	ret    
  10391b:	90                   	nop
  10391c:	66 90                	xchg   %ax,%ax
  10391e:	66 90                	xchg   %ax,%ax

00103920 <tar_load_ramfs>:

    return size;

}

void tar_load_ramfs(void* tarball) {
  103920:	55                   	push   %ebp
  103921:	89 e5                	mov    %esp,%ebp
  103923:	56                   	push   %esi
  103924:	83 ec 64             	sub    $0x64,%esp
  103927:	8b 45 08             	mov    0x8(%ebp),%eax
  10392a:	8d 0d 08 84 10 00    	lea    0x108408,%ecx
  103930:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* address = tarball;
  103933:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103936:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);
  103939:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10393c:	89 0c 24             	mov    %ecx,(%esp)
  10393f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103943:	e8 68 c9 ff ff       	call   1002b0 <kprintf>

    for (i = 0; ; i++)
  103948:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10394f:	89 45 dc             	mov    %eax,-0x24(%ebp)
    {

        struct tar_header *header = (struct tar_header*)address;
  103952:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103955:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (header->name[0] == '\0')
  103958:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10395b:	0f be 00             	movsbl (%eax),%eax
  10395e:	3d 00 00 00 00       	cmp    $0x0,%eax
  103963:	0f 85 05 00 00 00    	jne    10396e <tar_load_ramfs+0x4e>
            break;
  103969:	e9 67 01 00 00       	jmp    103ad5 <tar_load_ramfs+0x1b5>

        uint32_t size = tar_parse_number(header->size);
  10396e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103971:	05 7c 00 00 00       	add    $0x7c,%eax
  103976:	89 04 24             	mov    %eax,(%esp)
  103979:	e8 72 01 00 00       	call   103af0 <tar_parse_number>
  10397e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        address += 512;
  103981:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103984:	05 00 02 00 00       	add    $0x200,%eax
  103989:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(size != 0) {
  10398c:	81 7d e8 00 00 00 00 	cmpl   $0x0,-0x18(%ebp)
  103993:	0f 84 cb 00 00 00    	je     103a64 <tar_load_ramfs+0x144>
  103999:	8d 05 34 84 10 00    	lea    0x108434,%eax
            kprintf("[initrfs] Extracting %s (%d bytes)\n", header->name, size);
  10399f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1039a2:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1039a5:	89 04 24             	mov    %eax,(%esp)
  1039a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1039ac:	89 54 24 08          	mov    %edx,0x8(%esp)
  1039b0:	e8 fb c8 ff ff       	call   1002b0 <kprintf>
  1039b5:	8d 4d e8             	lea    -0x18(%ebp),%ecx

            vfs_create_kfile(header->name, ramfs_block_driver_struct(), &size);
  1039b8:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1039bb:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1039be:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  1039c1:	89 55 d0             	mov    %edx,-0x30(%ebp)
  1039c4:	e8 c7 f9 ff ff       	call   103390 <ramfs_block_driver_struct>
  1039c9:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  1039cc:	89 0c 24             	mov    %ecx,(%esp)
  1039cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  1039d3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1039d6:	89 44 24 08          	mov    %eax,0x8(%esp)
  1039da:	e8 21 19 00 00       	call   105300 <vfs_create_kfile>
  1039df:	b9 02 00 00 00       	mov    $0x2,%ecx
            struct res_handle* h = vfs_open(header->name, FM_WRITE);
  1039e4:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1039e7:	89 14 24             	mov    %edx,(%esp)
  1039ea:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  1039f1:	00 
  1039f2:	89 45 cc             	mov    %eax,-0x34(%ebp)
  1039f5:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  1039f8:	e8 73 1a 00 00       	call   105470 <vfs_open>
  1039fd:	b9 01 00 00 00       	mov    $0x1,%ecx
  103a02:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            uint32_t err = vfs_write(h, address, size, 1);
  103a05:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103a08:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103a0b:	8b 75 e8             	mov    -0x18(%ebp),%esi
  103a0e:	89 04 24             	mov    %eax,(%esp)
  103a11:	89 54 24 04          	mov    %edx,0x4(%esp)
  103a15:	89 74 24 08          	mov    %esi,0x8(%esp)
  103a19:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  103a20:	00 
  103a21:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  103a24:	e8 17 1c 00 00       	call   105640 <vfs_write>
  103a29:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(err) {
  103a2c:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  103a33:	0f 84 18 00 00 00    	je     103a51 <tar_load_ramfs+0x131>
  103a39:	8d 05 58 84 10 00    	lea    0x108458,%eax
                kprintf("[initrfs] VFS ERROR: %d\n", err);
  103a3f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  103a42:	89 04 24             	mov    %eax,(%esp)
  103a45:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103a49:	e8 62 c8 ff ff       	call   1002b0 <kprintf>
  103a4e:	89 45 c0             	mov    %eax,-0x40(%ebp)
            }

            vfs_close(h);
  103a51:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103a54:	89 04 24             	mov    %eax,(%esp)
  103a57:	e8 94 1a 00 00       	call   1054f0 <vfs_close>
        }
  103a5c:	89 45 bc             	mov    %eax,-0x44(%ebp)
  103a5f:	e9 2d 00 00 00       	jmp    103a91 <tar_load_ramfs+0x171>
  103a64:	8d 05 71 84 10 00    	lea    0x108471,%eax
        else
        {
            kprintf("[initrfs] Creating dir %s (%d bytes)\n", header->name, size);
  103a6a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a6d:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103a70:	89 04 24             	mov    %eax,(%esp)
  103a73:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103a77:	89 54 24 08          	mov    %edx,0x8(%esp)
  103a7b:	e8 30 c8 ff ff       	call   1002b0 <kprintf>
            vfs_create_dir(header->name);
  103a80:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103a83:	89 0c 24             	mov    %ecx,(%esp)
  103a86:	89 45 b8             	mov    %eax,-0x48(%ebp)
  103a89:	e8 e2 16 00 00       	call   105170 <vfs_create_dir>
  103a8e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        }

        address += (size / 512) * 512;
  103a91:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103a94:	c1 e8 09             	shr    $0x9,%eax
  103a97:	c1 e0 09             	shl    $0x9,%eax
  103a9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103a9d:	01 c1                	add    %eax,%ecx
  103a9f:	89 4d f4             	mov    %ecx,-0xc(%ebp)

        if (size % 512)
  103aa2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103aa5:	25 ff 01 00 00       	and    $0x1ff,%eax
  103aaa:	3d 00 00 00 00       	cmp    $0x0,%eax
  103aaf:	0f 84 0b 00 00 00    	je     103ac0 <tar_load_ramfs+0x1a0>
            address += 512;
  103ab5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ab8:	05 00 02 00 00       	add    $0x200,%eax
  103abd:	89 45 f4             	mov    %eax,-0xc(%ebp)

    }
  103ac0:	e9 00 00 00 00       	jmp    103ac5 <tar_load_ramfs+0x1a5>

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);

    for (i = 0; ; i++)
  103ac5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103ac8:	05 01 00 00 00       	add    $0x1,%eax
  103acd:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103ad0:	e9 7d fe ff ff       	jmp    103952 <tar_load_ramfs+0x32>
  103ad5:	8d 05 97 84 10 00    	lea    0x108497,%eax
        if (size % 512)
            address += 512;

    }

    kprintf("[initrfs] Finished unpacking tarball\n");
  103adb:	89 04 24             	mov    %eax,(%esp)
  103ade:	e8 cd c7 ff ff       	call   1002b0 <kprintf>
}
  103ae3:	89 45 b0             	mov    %eax,-0x50(%ebp)
  103ae6:	83 c4 64             	add    $0x64,%esp
  103ae9:	5e                   	pop    %esi
  103aea:	5d                   	pop    %ebp
  103aeb:	c3                   	ret    
  103aec:	0f 1f 40 00          	nopl   0x0(%eax)

00103af0 <tar_parse_number>:
#include "ramfs/tar.h"
#include "ramfs/block.h"
#include "vfs.h"

static uint32_t tar_parse_number(const char *in)
{
  103af0:	55                   	push   %ebp
  103af1:	89 e5                	mov    %esp,%ebp
  103af3:	83 ec 10             	sub    $0x10,%esp
  103af6:	8b 45 08             	mov    0x8(%ebp),%eax
  103af9:	89 45 fc             	mov    %eax,-0x4(%ebp)

    unsigned int size = 0;
  103afc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    unsigned int j;
    unsigned int count = 1;
  103b03:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

    for (j = 11; j > 0; j--, count *= 8)
  103b0a:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
  103b11:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103b18:	0f 86 39 00 00 00    	jbe    103b57 <tar_parse_number+0x67>
        size += ((in[j - 1] - '0') * count);
  103b1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b21:	2d 01 00 00 00       	sub    $0x1,%eax
  103b26:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103b29:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  103b2d:	2d 30 00 00 00       	sub    $0x30,%eax
  103b32:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  103b36:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103b39:	01 c1                	add    %eax,%ecx
  103b3b:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    unsigned int size = 0;
    unsigned int j;
    unsigned int count = 1;

    for (j = 11; j > 0; j--, count *= 8)
  103b3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103b41:	05 ff ff ff ff       	add    $0xffffffff,%eax
  103b46:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103b49:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103b4c:	c1 e0 03             	shl    $0x3,%eax
  103b4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103b52:	e9 ba ff ff ff       	jmp    103b11 <tar_parse_number+0x21>
        size += ((in[j - 1] - '0') * count);

    return size;
  103b57:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103b5a:	83 c4 10             	add    $0x10,%esp
  103b5d:	5d                   	pop    %ebp
  103b5e:	c3                   	ret    
  103b5f:	90                   	nop

00103b60 <ramfs_vga_read>:

struct res_kfile* ramfs_vga_create(uint32_t* args) {
    return malloc(sizeof(struct res_kfile));
}

uint32_t ramfs_vga_read(struct res_handle* handle, void* dest, uint32_t length) {
  103b60:	55                   	push   %ebp
  103b61:	89 e5                	mov    %esp,%ebp
  103b63:	56                   	push   %esi
  103b64:	83 ec 0c             	sub    $0xc,%esp
  103b67:	8b 45 10             	mov    0x10(%ebp),%eax
  103b6a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103b6d:	8b 55 08             	mov    0x8(%ebp),%edx
  103b70:	be 03 00 00 00       	mov    $0x3,%esi
  103b75:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103b78:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103b7b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  103b7e:	89 f0                	mov    %esi,%eax
  103b80:	83 c4 0c             	add    $0xc,%esp
  103b83:	5e                   	pop    %esi
  103b84:	5d                   	pop    %ebp
  103b85:	c3                   	ret    
  103b86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  103b8d:	00 00 00 

00103b90 <ramfs_vga_write>:
}

uint32_t ramfs_vga_write(struct res_handle* handle, void* src, uint32_t length) {
  103b90:	55                   	push   %ebp
  103b91:	89 e5                	mov    %esp,%ebp
  103b93:	83 ec 1c             	sub    $0x1c,%esp
  103b96:	8b 45 10             	mov    0x10(%ebp),%eax
  103b99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103b9c:	8b 55 08             	mov    0x8(%ebp),%edx
  103b9f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103ba2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103ba5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if(length != sizeof(struct vga_command)) return RW_ERR_DRIVER;
  103ba8:	81 7d f0 06 00 00 00 	cmpl   $0x6,-0x10(%ebp)
  103baf:	0f 84 0c 00 00 00    	je     103bc1 <ramfs_vga_write+0x31>
  103bb5:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  103bbc:	e9 1f 01 00 00       	jmp    103ce0 <ramfs_vga_write+0x150>

    struct vga_command* vgac = src;
  103bc1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bc4:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(vgac->command == CMD_SET) {
  103bc7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103bca:	0f b7 00             	movzwl (%eax),%eax
  103bcd:	3d 00 00 00 00       	cmp    $0x0,%eax
  103bd2:	0f 85 2f 00 00 00    	jne    103c07 <ramfs_vga_write+0x77>
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
  103bd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103bdb:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  103bdf:	3d d0 07 00 00       	cmp    $0x7d0,%eax
  103be4:	0f 8d 18 00 00 00    	jge    103c02 <ramfs_vga_write+0x72>
  103bea:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103bed:	66 8b 48 04          	mov    0x4(%eax),%cx
  103bf1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103bf4:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  103bf8:	8b 15 c0 72 10 00    	mov    0x1072c0,%edx
  103bfe:	66 89 0c 42          	mov    %cx,(%edx,%eax,2)
    }
  103c02:	e9 00 00 00 00       	jmp    103c07 <ramfs_vga_write+0x77>

    if(vgac->command == CMD_CLEAR) {
  103c07:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103c0a:	0f b7 00             	movzwl (%eax),%eax
  103c0d:	3d 01 00 00 00       	cmp    $0x1,%eax
  103c12:	0f 85 38 00 00 00    	jne    103c50 <ramfs_vga_write+0xc0>
        for(int i = 0; i < (80 * 25); i++) {
  103c18:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  103c1f:	81 7d e8 d0 07 00 00 	cmpl   $0x7d0,-0x18(%ebp)
  103c26:	0f 8d 1f 00 00 00    	jge    103c4b <ramfs_vga_write+0xbb>
            vga_buffer[i] = 0;
  103c2c:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103c2f:	8b 0d c0 72 10 00    	mov    0x1072c0,%ecx
  103c35:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
    if(vgac->command == CMD_SET) {
        if(vgac->offset < (25 * 80)) vga_buffer[vgac->offset] = vgac->value;
    }

    if(vgac->command == CMD_CLEAR) {
        for(int i = 0; i < (80 * 25); i++) {
  103c3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103c3e:	05 01 00 00 00       	add    $0x1,%eax
  103c43:	89 45 e8             	mov    %eax,-0x18(%ebp)
  103c46:	e9 d4 ff ff ff       	jmp    103c1f <ramfs_vga_write+0x8f>
            vga_buffer[i] = 0;
        }
    }
  103c4b:	e9 00 00 00 00       	jmp    103c50 <ramfs_vga_write+0xc0>

    if(vgac->command == CMD_SCROLL) {
  103c50:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103c53:	0f b7 00             	movzwl (%eax),%eax
  103c56:	3d 02 00 00 00       	cmp    $0x2,%eax
  103c5b:	0f 85 78 00 00 00    	jne    103cd9 <ramfs_vga_write+0x149>
        int i;
        for (i = 0; i < 24 * 80; i++) {
  103c61:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  103c68:	81 7d e4 80 07 00 00 	cmpl   $0x780,-0x1c(%ebp)
  103c6f:	0f 8d 2e 00 00 00    	jge    103ca3 <ramfs_vga_write+0x113>
            vga_buffer[i] = vga_buffer[i + 80];
  103c75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103c78:	8b 0d c0 72 10 00    	mov    0x1072c0,%ecx
  103c7e:	66 8b 94 41 a0 00 00 	mov    0xa0(%ecx,%eax,2),%dx
  103c85:	00 
  103c86:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103c89:	8b 0d c0 72 10 00    	mov    0x1072c0,%ecx
  103c8f:	66 89 14 41          	mov    %dx,(%ecx,%eax,2)
        }
    }

    if(vgac->command == CMD_SCROLL) {
        int i;
        for (i = 0; i < 24 * 80; i++) {
  103c93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103c96:	05 01 00 00 00       	add    $0x1,%eax
  103c9b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  103c9e:	e9 c5 ff ff ff       	jmp    103c68 <ramfs_vga_write+0xd8>
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  103ca3:	e9 00 00 00 00       	jmp    103ca8 <ramfs_vga_write+0x118>
  103ca8:	81 7d e4 d0 07 00 00 	cmpl   $0x7d0,-0x1c(%ebp)
  103caf:	0f 8d 1f 00 00 00    	jge    103cd4 <ramfs_vga_write+0x144>
            vga_buffer[i] = 0;
  103cb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103cb8:	8b 0d c0 72 10 00    	mov    0x1072c0,%ecx
  103cbe:	66 c7 04 41 00 00    	movw   $0x0,(%ecx,%eax,2)
        int i;
        for (i = 0; i < 24 * 80; i++) {
            vga_buffer[i] = vga_buffer[i + 80];
        }

        for (; i < 25 * 80; i++) {
  103cc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103cc7:	05 01 00 00 00       	add    $0x1,%eax
  103ccc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  103ccf:	e9 d4 ff ff ff       	jmp    103ca8 <ramfs_vga_write+0x118>
            vga_buffer[i] = 0;
        }
    }
  103cd4:	e9 00 00 00 00       	jmp    103cd9 <ramfs_vga_write+0x149>

    return RW_OK; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  103cd9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103ce0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103ce3:	83 c4 1c             	add    $0x1c,%esp
  103ce6:	5d                   	pop    %ebp
  103ce7:	c3                   	ret    
  103ce8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  103cef:	00 

00103cf0 <ramfs_vga_open>:

struct res_handle* ramfs_vga_open(struct res_kfile* kf, uint32_t filemode) {
  103cf0:	55                   	push   %ebp
  103cf1:	89 e5                	mov    %esp,%ebp
  103cf3:	83 ec 18             	sub    $0x18,%esp
  103cf6:	8b 45 0c             	mov    0xc(%ebp),%eax
  103cf9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103cfc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103cff:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(filemode & FM_EXEC) return 0;
  103d02:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d05:	25 04 00 00 00       	and    $0x4,%eax
  103d0a:	3d 00 00 00 00       	cmp    $0x0,%eax
  103d0f:	0f 84 0c 00 00 00    	je     103d21 <ramfs_vga_open+0x31>
  103d15:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103d1c:	e9 b2 00 00 00       	jmp    103dd3 <ramfs_vga_open+0xe3>
    if(filemode & FM_READ) return 0;
  103d21:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d24:	25 01 00 00 00       	and    $0x1,%eax
  103d29:	3d 00 00 00 00       	cmp    $0x0,%eax
  103d2e:	0f 84 0c 00 00 00    	je     103d40 <ramfs_vga_open+0x50>
  103d34:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103d3b:	e9 93 00 00 00       	jmp    103dd3 <ramfs_vga_open+0xe3>

    if((filemode & FM_WRITE) && vga_writers != 0) return 0;
  103d40:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d43:	25 02 00 00 00       	and    $0x2,%eax
  103d48:	3d 00 00 00 00       	cmp    $0x0,%eax
  103d4d:	0f 84 1c 00 00 00    	je     103d6f <ramfs_vga_open+0x7f>
  103d53:	81 3d 2c 94 10 00 00 	cmpl   $0x0,0x10942c
  103d5a:	00 00 00 
  103d5d:	0f 84 0c 00 00 00    	je     103d6f <ramfs_vga_open+0x7f>
  103d63:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103d6a:	e9 64 00 00 00       	jmp    103dd3 <ramfs_vga_open+0xe3>
    if((filemode & FM_WRITE)) vga_writers++;
  103d6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103d72:	25 02 00 00 00       	and    $0x2,%eax
  103d77:	3d 00 00 00 00       	cmp    $0x0,%eax
  103d7c:	0f 84 0f 00 00 00    	je     103d91 <ramfs_vga_open+0xa1>
  103d82:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103d87:	05 01 00 00 00       	add    $0x1,%eax
  103d8c:	a3 2c 94 10 00       	mov    %eax,0x10942c
  103d91:	b8 10 00 00 00       	mov    $0x10,%eax

    struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  103d96:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  103d9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103da0:	e8 cb 07 00 00       	call   104570 <malloc>
  103da5:	89 45 f0             	mov    %eax,-0x10(%ebp)

    rethandle->filemode = filemode;
  103da8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103dab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103dae:	89 41 0c             	mov    %eax,0xc(%ecx)
    rethandle->position = 0;
  103db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103db4:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    rethandle->res_type = RES_KERNDRV;
  103dbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103dbe:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    rethandle->res_ptr  = kf;
  103dc4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103dc7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103dca:	89 41 04             	mov    %eax,0x4(%ecx)

    return rethandle;
  103dcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103dd0:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  103dd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103dd6:	83 c4 18             	add    $0x18,%esp
  103dd9:	5d                   	pop    %ebp
  103dda:	c3                   	ret    
  103ddb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103de0 <ramfs_vga_close>:

uint32_t ramfs_vga_close(struct res_handle* handle) {
  103de0:	55                   	push   %ebp
  103de1:	89 e5                	mov    %esp,%ebp
  103de3:	83 ec 08             	sub    $0x8,%esp
  103de6:	8b 45 08             	mov    0x8(%ebp),%eax
  103de9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if(handle->filemode & FM_WRITE) vga_writers--;
  103dec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103def:	8b 40 0c             	mov    0xc(%eax),%eax
  103df2:	25 02 00 00 00       	and    $0x2,%eax
  103df7:	3d 00 00 00 00       	cmp    $0x0,%eax
  103dfc:	0f 84 0f 00 00 00    	je     103e11 <ramfs_vga_close+0x31>
  103e02:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103e07:	05 ff ff ff ff       	add    $0xffffffff,%eax
  103e0c:	a3 2c 94 10 00       	mov    %eax,0x10942c

    free(handle);
  103e11:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103e14:	89 04 24             	mov    %eax,(%esp)
  103e17:	e8 24 0b 00 00       	call   104940 <free>
  103e1c:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  103e21:	83 c4 08             	add    $0x8,%esp
  103e24:	5d                   	pop    %ebp
  103e25:	c3                   	ret    
  103e26:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  103e2d:	00 00 00 

00103e30 <ramfs_vga_available>:

uint32_t ramfs_vga_writers() {
    return vga_writers;
}

uint32_t ramfs_vga_available(struct res_handle* handle) {
  103e30:	55                   	push   %ebp
  103e31:	89 e5                	mov    %esp,%ebp
  103e33:	50                   	push   %eax
  103e34:	8b 45 08             	mov    0x8(%ebp),%eax
  103e37:	b9 06 00 00 00       	mov    $0x6,%ecx
  103e3c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return sizeof(struct vga_command);
  103e3f:	89 c8                	mov    %ecx,%eax
  103e41:	83 c4 04             	add    $0x4,%esp
  103e44:	5d                   	pop    %ebp
  103e45:	c3                   	ret    
  103e46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  103e4d:	00 00 00 

00103e50 <ramfs_vga_create>:
}

struct res_kfile* ramfs_vga_create(uint32_t* args) {
  103e50:	55                   	push   %ebp
  103e51:	89 e5                	mov    %esp,%ebp
  103e53:	83 ec 18             	sub    $0x18,%esp
  103e56:	8b 45 08             	mov    0x8(%ebp),%eax
  103e59:	b9 08 00 00 00       	mov    $0x8,%ecx
  103e5e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return malloc(sizeof(struct res_kfile));
  103e61:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103e68:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103e6b:	e8 00 07 00 00       	call   104570 <malloc>
  103e70:	83 c4 18             	add    $0x18,%esp
  103e73:	5d                   	pop    %ebp
  103e74:	c3                   	ret    
  103e75:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  103e7c:	00 00 00 00 

00103e80 <ramfs_vga_driver_struct>:
    .close     = ramfs_vga_close,
    .available = ramfs_vga_available,
    .drvname   = "VGA_CONTROL"
};

struct kfs_driver* ramfs_vga_driver_struct() {
  103e80:	55                   	push   %ebp
  103e81:	89 e5                	mov    %esp,%ebp
  103e83:	8d 05 c4 72 10 00    	lea    0x1072c4,%eax
    return &vga_driver;
  103e89:	5d                   	pop    %ebp
  103e8a:	c3                   	ret    
  103e8b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103e90 <ramfs_vga_writers>:
}

uint32_t ramfs_vga_writers() {
  103e90:	55                   	push   %ebp
  103e91:	89 e5                	mov    %esp,%ebp
    return vga_writers;
  103e93:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103e98:	5d                   	pop    %ebp
  103e99:	c3                   	ret    
  103e9a:	66 90                	xchg   %ax,%ax
  103e9c:	66 90                	xchg   %ax,%ax
  103e9e:	66 90                	xchg   %ax,%ax

00103ea0 <enableScheduling>:
struct task* first_task = 0;
struct task* current_task = 0;

int nextPID = 1;

void enableScheduling(void) {
  103ea0:	55                   	push   %ebp
  103ea1:	89 e5                	mov    %esp,%ebp
    schedulingEnabled = 1;
  103ea3:	c7 05 30 94 10 00 01 	movl   $0x1,0x109430
  103eaa:	00 00 00 
}
  103ead:	5d                   	pop    %ebp
  103eae:	c3                   	ret    
  103eaf:	90                   	nop

00103eb0 <isSchedulingEnabled>:

uint32_t isSchedulingEnabled(void) {
  103eb0:	55                   	push   %ebp
  103eb1:	89 e5                	mov    %esp,%ebp
    return schedulingEnabled;
  103eb3:	a1 30 94 10 00       	mov    0x109430,%eax
  103eb8:	5d                   	pop    %ebp
  103eb9:	c3                   	ret    
  103eba:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103ec0 <get_current_task>:
}

struct task* get_current_task(void) {
  103ec0:	55                   	push   %ebp
  103ec1:	89 e5                	mov    %esp,%ebp
    return current_task;
  103ec3:	a1 38 94 10 00       	mov    0x109438,%eax
  103ec8:	5d                   	pop    %ebp
  103ec9:	c3                   	ret    
  103eca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103ed0 <register_handle>:
}

uint32_t register_handle(struct res_handle* h) {
  103ed0:	55                   	push   %ebp
  103ed1:	89 e5                	mov    %esp,%ebp
  103ed3:	83 ec 18             	sub    $0x18,%esp
  103ed6:	8b 45 08             	mov    0x8(%ebp),%eax
  103ed9:	b9 08 00 00 00       	mov    $0x8,%ecx
  103ede:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct hl_node* old = current_task->handle_list;
  103ee1:	a1 38 94 10 00       	mov    0x109438,%eax
  103ee6:	8b 40 28             	mov    0x28(%eax),%eax
  103ee9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task->handle_list = malloc(sizeof(struct hl_node));
  103eec:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103ef3:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103ef6:	e8 75 06 00 00       	call   104570 <malloc>
  103efb:	b9 00 00 00 00       	mov    $0x0,%ecx
  103f00:	8b 15 38 94 10 00    	mov    0x109438,%edx
  103f06:	89 42 28             	mov    %eax,0x28(%edx)
    current_task->handle_list->next = old;
  103f09:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103f0c:	8b 15 38 94 10 00    	mov    0x109438,%edx
  103f12:	8b 52 28             	mov    0x28(%edx),%edx
  103f15:	89 42 04             	mov    %eax,0x4(%edx)
    current_task->handle_list->handle = h;
  103f18:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f1b:	8b 15 38 94 10 00    	mov    0x109438,%edx
  103f21:	8b 52 28             	mov    0x28(%edx),%edx
  103f24:	89 02                	mov    %eax,(%edx)

    return 0;
  103f26:	89 c8                	mov    %ecx,%eax
  103f28:	83 c4 18             	add    $0x18,%esp
  103f2b:	5d                   	pop    %ebp
  103f2c:	c3                   	ret    
  103f2d:	0f 1f 00             	nopl   (%eax)

00103f30 <unregister_handle>:
}

uint32_t unregister_handle(struct res_handle* h) {
  103f30:	55                   	push   %ebp
  103f31:	89 e5                	mov    %esp,%ebp
  103f33:	83 ec 18             	sub    $0x18,%esp
  103f36:	8b 45 08             	mov    0x8(%ebp),%eax
  103f39:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct hl_node* cur = current_task->handle_list;
  103f3c:	a1 38 94 10 00       	mov    0x109438,%eax
  103f41:	8b 40 28             	mov    0x28(%eax),%eax
  103f44:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(h == 0) return 2;
  103f47:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103f4e:	0f 85 0c 00 00 00    	jne    103f60 <unregister_handle+0x30>
  103f54:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
  103f5b:	e9 b4 00 00 00       	jmp    104014 <unregister_handle+0xe4>
    if(cur == 0) return 1;
  103f60:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103f67:	0f 85 0c 00 00 00    	jne    103f79 <unregister_handle+0x49>
  103f6d:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  103f74:	e9 9b 00 00 00       	jmp    104014 <unregister_handle+0xe4>

    if(cur->handle == h) {
  103f79:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f7c:	8b 00                	mov    (%eax),%eax
  103f7e:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103f81:	0f 85 26 00 00 00    	jne    103fad <unregister_handle+0x7d>
        current_task->handle_list = cur->next;
  103f87:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f8a:	8b 40 04             	mov    0x4(%eax),%eax
  103f8d:	8b 0d 38 94 10 00    	mov    0x109438,%ecx
  103f93:	89 41 28             	mov    %eax,0x28(%ecx)
        free(cur);
  103f96:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f99:	89 04 24             	mov    %eax,(%esp)
  103f9c:	e8 9f 09 00 00       	call   104940 <free>

        return 0;
  103fa1:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103fa8:	e9 67 00 00 00       	jmp    104014 <unregister_handle+0xe4>
    }

    while(cur != 0) {
  103fad:	e9 00 00 00 00       	jmp    103fb2 <unregister_handle+0x82>
  103fb2:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103fb9:	0f 84 4e 00 00 00    	je     10400d <unregister_handle+0xdd>
        if(cur->next->handle == h) {
  103fbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103fc2:	8b 40 04             	mov    0x4(%eax),%eax
  103fc5:	8b 00                	mov    (%eax),%eax
  103fc7:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103fca:	0f 85 2f 00 00 00    	jne    103fff <unregister_handle+0xcf>
            void* next = cur->next;
  103fd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103fd3:	8b 40 04             	mov    0x4(%eax),%eax
  103fd6:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cur->next =  cur->next->next;
  103fd9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103fdc:	8b 40 04             	mov    0x4(%eax),%eax
  103fdf:	8b 40 04             	mov    0x4(%eax),%eax
  103fe2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103fe5:	89 41 04             	mov    %eax,0x4(%ecx)

            free(next);
  103fe8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103feb:	89 04 24             	mov    %eax,(%esp)
  103fee:	e8 4d 09 00 00       	call   104940 <free>

            return 0;
  103ff3:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103ffa:	e9 15 00 00 00       	jmp    104014 <unregister_handle+0xe4>
        }

        cur = cur->next;
  103fff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104002:	8b 40 04             	mov    0x4(%eax),%eax
  104005:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  104008:	e9 a5 ff ff ff       	jmp    103fb2 <unregister_handle+0x82>

    return 3;
  10400d:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  104014:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104017:	83 c4 18             	add    $0x18,%esp
  10401a:	5d                   	pop    %ebp
  10401b:	c3                   	ret    
  10401c:	0f 1f 40 00          	nopl   0x0(%eax)

00104020 <schedule_exception>:

struct cpu_state* schedule_exception(struct cpu_state* cpu) {
  104020:	55                   	push   %ebp
  104021:	89 e5                	mov    %esp,%ebp
  104023:	56                   	push   %esi
  104024:	83 ec 34             	sub    $0x34,%esp
  104027:	8b 45 08             	mov    0x8(%ebp),%eax
  10402a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (current_task == first_task && current_task->next == 0) {
  10402d:	a1 38 94 10 00       	mov    0x109438,%eax
  104032:	3b 05 34 94 10 00    	cmp    0x109434,%eax
  104038:	0f 85 78 00 00 00    	jne    1040b6 <schedule_exception+0x96>
  10403e:	a1 38 94 10 00       	mov    0x109438,%eax
  104043:	81 78 08 00 00 00 00 	cmpl   $0x0,0x8(%eax)
  10404a:	0f 85 66 00 00 00    	jne    1040b6 <schedule_exception+0x96>
  104050:	b8 04 00 00 00       	mov    $0x4,%eax
        //Only one process is running, which just crashed. Stop system.
        setclr(0x04);
  104055:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10405c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10405f:	e8 2c c2 ff ff       	call   100290 <setclr>
  104064:	8d 05 c9 84 10 00    	lea    0x1084c9,%eax
        kprintf("\n~~~ Terminated task (PID=%d) due to exception %x:%x \n", current_task->PID, cpu->intr, cpu->error);
  10406a:	8b 0d 38 94 10 00    	mov    0x109438,%ecx
  104070:	8b 09                	mov    (%ecx),%ecx
  104072:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104075:	8b 52 1c             	mov    0x1c(%edx),%edx
  104078:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10407b:	8b 76 20             	mov    0x20(%esi),%esi
  10407e:	89 04 24             	mov    %eax,(%esp)
  104081:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104085:	89 54 24 08          	mov    %edx,0x8(%esp)
  104089:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10408d:	e8 1e c2 ff ff       	call   1002b0 <kprintf>
  104092:	8d 0d 00 85 10 00    	lea    0x108500,%ecx
        show_cod(cpu, "Last task crashed. Terminating kernel...");
  104098:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10409b:	89 14 24             	mov    %edx,(%esp)
  10409e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1040a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1040a5:	e8 16 c0 ff ff       	call   1000c0 <show_cod>

        //will never occur cause COD terminates execution
        return 0;
  1040aa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1040b1:	e9 83 00 00 00       	jmp    104139 <schedule_exception+0x119>
  1040b6:	b8 04 00 00 00       	mov    $0x4,%eax
    } else {
        //Potential security leaks available in following code.
        setclr(0x04);
  1040bb:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1040c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1040c5:	e8 c6 c1 ff ff       	call   100290 <setclr>
  1040ca:	8d 05 c9 84 10 00    	lea    0x1084c9,%eax
        kprintf("\n~~~ Terminated task (PID=%d) due to exception %x:%x \n", current_task->PID, cpu->intr, cpu->error);
  1040d0:	8b 0d 38 94 10 00    	mov    0x109438,%ecx
  1040d6:	8b 09                	mov    (%ecx),%ecx
  1040d8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1040db:	8b 52 1c             	mov    0x1c(%edx),%edx
  1040de:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1040e1:	8b 76 20             	mov    0x20(%esi),%esi
  1040e4:	89 04 24             	mov    %eax,(%esp)
  1040e7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1040eb:	89 54 24 08          	mov    %edx,0x8(%esp)
  1040ef:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1040f3:	e8 b8 c1 ff ff       	call   1002b0 <kprintf>
  1040f8:	8d 0d 24 82 10 00    	lea    0x108224,%ecx
        kprintf("\n");
  1040fe:	89 0c 24             	mov    %ecx,(%esp)
  104101:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104104:	e8 a7 c1 ff ff       	call   1002b0 <kprintf>
        show_dump(cpu);
  104109:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10410c:	89 0c 24             	mov    %ecx,(%esp)
  10410f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  104112:	e8 29 c0 ff ff       	call   100140 <show_dump>
  104117:	b8 07 00 00 00       	mov    $0x7,%eax
        setclr(0x07);
  10411c:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  104123:	89 45 dc             	mov    %eax,-0x24(%ebp)
  104126:	e8 65 c1 ff ff       	call   100290 <setclr>

        return terminate_current(cpu);
  10412b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10412e:	89 04 24             	mov    %eax,(%esp)
  104131:	e8 1a 00 00 00       	call   104150 <terminate_current>
  104136:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  104139:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10413c:	83 c4 34             	add    $0x34,%esp
  10413f:	5e                   	pop    %esi
  104140:	5d                   	pop    %ebp
  104141:	c3                   	ret    
  104142:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104149:	1f 84 00 00 00 00 00 

00104150 <terminate_current>:

struct cpu_state* terminate_current(struct cpu_state* cpu) {
  104150:	55                   	push   %ebp
  104151:	89 e5                	mov    %esp,%ebp
  104153:	83 ec 18             	sub    $0x18,%esp
  104156:	8b 45 08             	mov    0x8(%ebp),%eax
  104159:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct task* next = current_task->next;
  10415c:	a1 38 94 10 00       	mov    0x109438,%eax
  104161:	8b 40 08             	mov    0x8(%eax),%eax
  104164:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* prev = current_task->prev;
  104167:	a1 38 94 10 00       	mov    0x109438,%eax
  10416c:	8b 40 0c             	mov    0xc(%eax),%eax
  10416f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    //TODO: free resources here

    if (current_task == first_task) {
  104172:	a1 38 94 10 00       	mov    0x109438,%eax
  104177:	3b 05 34 94 10 00    	cmp    0x109434,%eax
  10417d:	0f 85 0d 00 00 00    	jne    104190 <terminate_current+0x40>
        first_task = current_task->next;
  104183:	a1 38 94 10 00       	mov    0x109438,%eax
  104188:	8b 40 08             	mov    0x8(%eax),%eax
  10418b:	a3 34 94 10 00       	mov    %eax,0x109434
    }

    if (next != 0) {
  104190:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104197:	0f 84 09 00 00 00    	je     1041a6 <terminate_current+0x56>
        next->prev = prev;
  10419d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1041a0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1041a3:	89 41 0c             	mov    %eax,0xc(%ecx)
    }

    if (prev != 0) {
  1041a6:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1041ad:	0f 84 09 00 00 00    	je     1041bc <terminate_current+0x6c>
        prev->next = next;
  1041b3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041b6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1041b9:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if (next == 0)
  1041bc:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1041c3:	0f 85 08 00 00 00    	jne    1041d1 <terminate_current+0x81>
        next = first_task;
  1041c9:	a1 34 94 10 00       	mov    0x109434,%eax
  1041ce:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task = next;
  1041d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041d4:	a3 38 94 10 00       	mov    %eax,0x109438

    if(current_task == 0) {
  1041d9:	81 3d 38 94 10 00 00 	cmpl   $0x0,0x109438
  1041e0:	00 00 00 
  1041e3:	0f 85 15 00 00 00    	jne    1041fe <terminate_current+0xae>
  1041e9:	8d 05 29 85 10 00    	lea    0x108529,%eax
        show_cod(cpu, "Last task terminated.");
  1041ef:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1041f2:	89 0c 24             	mov    %ecx,(%esp)
  1041f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  1041f9:	e8 c2 be ff ff       	call   1000c0 <show_cod>
    }

    vmm_activate_pagedir(current_task->phys_pdir);
  1041fe:	a1 38 94 10 00       	mov    0x109438,%eax
  104203:	8b 40 14             	mov    0x14(%eax),%eax
  104206:	89 04 24             	mov    %eax,(%esp)
  104209:	e8 02 29 00 00       	call   106b10 <vmm_activate_pagedir>
    return current_task->cpuState;
  10420e:	a1 38 94 10 00       	mov    0x109438,%eax
  104213:	8b 40 04             	mov    0x4(%eax),%eax
  104216:	83 c4 18             	add    $0x18,%esp
  104219:	5d                   	pop    %ebp
  10421a:	c3                   	ret    
  10421b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104220 <fork_task_state>:
}

void fork_task_state(struct task* new_task) {
  104220:	55                   	push   %ebp
  104221:	89 e5                	mov    %esp,%ebp
  104223:	83 ec 18             	sub    $0x18,%esp
  104226:	8b 45 08             	mov    0x8(%ebp),%eax
  104229:	b9 38 00 00 00       	mov    $0x38,%ecx
  10422e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    new_task->user_stack_bottom = current_task->user_stack_bottom;
  104231:	a1 38 94 10 00       	mov    0x109438,%eax
  104236:	8b 40 10             	mov    0x10(%eax),%eax
  104239:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10423c:	89 42 10             	mov    %eax,0x10(%edx)

    new_task->stdout = current_task->stdout;
  10423f:	a1 38 94 10 00       	mov    0x109438,%eax
  104244:	8b 40 1c             	mov    0x1c(%eax),%eax
  104247:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10424a:	89 42 1c             	mov    %eax,0x1c(%edx)
    new_task->stdin  = current_task->stdin;
  10424d:	a1 38 94 10 00       	mov    0x109438,%eax
  104252:	8b 40 24             	mov    0x24(%eax),%eax
  104255:	8b 55 fc             	mov    -0x4(%ebp),%edx
  104258:	89 42 24             	mov    %eax,0x24(%edx)
    new_task->stderr = current_task->stderr;
  10425b:	a1 38 94 10 00       	mov    0x109438,%eax
  104260:	8b 40 20             	mov    0x20(%eax),%eax
  104263:	8b 55 fc             	mov    -0x4(%ebp),%edx
  104266:	89 42 20             	mov    %eax,0x20(%edx)

    memcpy(new_task->cpuState, current_task->cpuState, sizeof(struct cpu_state));
  104269:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10426c:	8b 40 04             	mov    0x4(%eax),%eax
  10426f:	8b 15 38 94 10 00    	mov    0x109438,%edx
  104275:	8b 52 04             	mov    0x4(%edx),%edx
  104278:	89 04 24             	mov    %eax,(%esp)
  10427b:	89 54 24 04          	mov    %edx,0x4(%esp)
  10427f:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  104286:	00 
  104287:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10428a:	e8 b1 09 00 00       	call   104c40 <memcpy>

    new_task->cpuState->eax = 0;
  10428f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104292:	8b 40 04             	mov    0x4(%eax),%eax
  104295:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  10429b:	83 c4 18             	add    $0x18,%esp
  10429e:	5d                   	pop    %ebp
  10429f:	c3                   	ret    

001042a0 <init_task>:

struct task* init_task(uint32_t task_pagedir, void* entry) {
  1042a0:	55                   	push   %ebp
  1042a1:	89 e5                	mov    %esp,%ebp
  1042a3:	83 ec 68             	sub    $0x68,%esp
  1042a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  1042a9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1042ac:	ba 2c 00 00 00       	mov    $0x2c,%edx
  1042b1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1042b4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* ntask = malloc(sizeof(struct task));
  1042b7:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  1042be:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  1042c1:	e8 aa 02 00 00       	call   104570 <malloc>
  1042c6:	b9 38 00 00 00       	mov    $0x38,%ecx
  1042cb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ntask->cpuState = malloc(sizeof(struct cpu_state));
  1042ce:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  1042d5:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  1042d8:	e8 93 02 00 00       	call   104570 <malloc>
  1042dd:	b9 00 e0 ff ff       	mov    $0xffffe000,%ecx
  1042e2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1042e5:	89 42 04             	mov    %eax,0x4(%edx)

    ntask->phys_pdir = task_pagedir;
  1042e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1042eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1042ee:	89 42 14             	mov    %eax,0x14(%edx)
    ntask->user_stack_bottom = (void*) 0xFFFFE000;
  1042f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1042f4:	89 48 10             	mov    %ecx,0x10(%eax)
    ntask->PID = nextPID++;
  1042f7:	a1 e0 72 10 00       	mov    0x1072e0,%eax
  1042fc:	89 c1                	mov    %eax,%ecx
  1042fe:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104304:	89 0d e0 72 10 00    	mov    %ecx,0x1072e0
  10430a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10430d:	89 01                	mov    %eax,(%ecx)

    ntask->stdin  = 0;
  10430f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104312:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
    ntask->stdout = 0;
  104319:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10431c:	c7 40 1c 00 00 00 00 	movl   $0x0,0x1c(%eax)
    ntask->stderr = 0;
  104323:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104326:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)

    ntask->next = (void*) 0;
  10432d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104330:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    ntask->prev = (void*) 0;
  104337:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10433a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

    if (first_task == 0) {
  104341:	81 3d 34 94 10 00 00 	cmpl   $0x0,0x109434
  104348:	00 00 00 
  10434b:	0f 85 0d 00 00 00    	jne    10435e <init_task+0xbe>
        first_task = ntask;
  104351:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104354:	a3 34 94 10 00       	mov    %eax,0x109434
    } else {
  104359:	e9 1f 00 00 00       	jmp    10437d <init_task+0xdd>
        ntask->next = first_task;
  10435e:	a1 34 94 10 00       	mov    0x109434,%eax
  104363:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104366:	89 41 08             	mov    %eax,0x8(%ecx)
        first_task->prev = ntask;
  104369:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10436c:	8b 0d 34 94 10 00    	mov    0x109434,%ecx
  104372:	89 41 0c             	mov    %eax,0xc(%ecx)
        first_task = ntask;
  104375:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104378:	a3 34 94 10 00       	mov    %eax,0x109434
    }

    uint32_t rest_pdir = vmm_get_current_pagedir();
  10437d:	e8 4e 1c 00 00       	call   105fd0 <vmm_get_current_pagedir>
  104382:	89 45 f0             	mov    %eax,-0x10(%ebp)
    vmm_activate_pagedir(task_pagedir);
  104385:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104388:	89 04 24             	mov    %eax,(%esp)
  10438b:	e8 80 27 00 00       	call   106b10 <vmm_activate_pagedir>

    if (entry != 0) { //entry == 0 means that this will be forked
  104390:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104397:	0f 84 21 00 00 00    	je     1043be <init_task+0x11e>
  10439d:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_alloc_addr(ntask->user_stack_bottom, 0);
  1043a2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1043a5:	8b 49 10             	mov    0x10(%ecx),%ecx
  1043a8:	89 0c 24             	mov    %ecx,(%esp)
  1043ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1043b2:	00 
  1043b3:	89 45 ac             	mov    %eax,-0x54(%ebp)
  1043b6:	e8 55 26 00 00       	call   106a10 <vmm_alloc_addr>
  1043bb:	89 45 a8             	mov    %eax,-0x58(%ebp)
  1043be:	b8 38 00 00 00       	mov    $0x38,%eax
  1043c3:	8d 4d b8             	lea    -0x48(%ebp),%ecx
    }

    struct cpu_state nstate = { .eax = 0, .ebx = 0, .ecx = 0, .edx = 0,
  1043c6:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  1043cd:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  1043d4:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  1043db:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  1043e2:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  1043e9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  1043f0:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  1043f7:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  1043fe:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104405:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104408:	89 55 dc             	mov    %edx,-0x24(%ebp)
  10440b:	c7 45 e0 1b 00 00 00 	movl   $0x1b,-0x20(%ebp)
  104412:	c7 45 e4 00 02 00 00 	movl   $0x200,-0x1c(%ebp)
  104419:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10441c:	8b 52 10             	mov    0x10(%edx),%edx
  10441f:	81 c2 00 10 00 00    	add    $0x1000,%edx
  104425:	89 55 e8             	mov    %edx,-0x18(%ebp)
  104428:	c7 45 ec 23 00 00 00 	movl   $0x23,-0x14(%ebp)
            /* Ring-3-Segmentregister */
            .cs = 0x18 | 0x03, .ss = 0x20 | 0x03,

            .eflags = 0x200, };

    memcpy(ntask->cpuState, &nstate, sizeof(struct cpu_state));
  10442f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104432:	8b 52 04             	mov    0x4(%edx),%edx
  104435:	89 14 24             	mov    %edx,(%esp)
  104438:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10443c:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  104443:	00 
  104444:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  104447:	e8 f4 07 00 00       	call   104c40 <memcpy>

    vmm_activate_pagedir(rest_pdir);
  10444c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10444f:	89 04 24             	mov    %eax,(%esp)
  104452:	e8 b9 26 00 00       	call   106b10 <vmm_activate_pagedir>

    return ntask;
  104457:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10445a:	83 c4 68             	add    $0x68,%esp
  10445d:	5d                   	pop    %ebp
  10445e:	c3                   	ret    
  10445f:	90                   	nop

00104460 <save_cpu_state>:
}

void save_cpu_state(struct cpu_state* cpu) {
  104460:	55                   	push   %ebp
  104461:	89 e5                	mov    %esp,%ebp
  104463:	83 ec 18             	sub    $0x18,%esp
  104466:	8b 45 08             	mov    0x8(%ebp),%eax
  104469:	b9 38 00 00 00       	mov    $0x38,%ecx
  10446e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memcpy(current_task->cpuState, cpu, sizeof(struct cpu_state));
  104471:	a1 38 94 10 00       	mov    0x109438,%eax
  104476:	8b 40 04             	mov    0x4(%eax),%eax
  104479:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10447c:	89 04 24             	mov    %eax,(%esp)
  10447f:	89 54 24 04          	mov    %edx,0x4(%esp)
  104483:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  10448a:	00 
  10448b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10448e:	e8 ad 07 00 00       	call   104c40 <memcpy>
}
  104493:	83 c4 18             	add    $0x18,%esp
  104496:	5d                   	pop    %ebp
  104497:	c3                   	ret    
  104498:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10449f:	00 

001044a0 <schedule>:

struct cpu_state* schedule(struct cpu_state* cpu) {
  1044a0:	55                   	push   %ebp
  1044a1:	89 e5                	mov    %esp,%ebp
  1044a3:	83 ec 18             	sub    $0x18,%esp
  1044a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1044a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (first_task != 0 && schedulingEnabled) {
  1044ac:	81 3d 34 94 10 00 00 	cmpl   $0x0,0x109434
  1044b3:	00 00 00 
  1044b6:	0f 84 9d 00 00 00    	je     104559 <schedule+0xb9>
  1044bc:	81 3d 30 94 10 00 00 	cmpl   $0x0,0x109430
  1044c3:	00 00 00 
  1044c6:	0f 84 8d 00 00 00    	je     104559 <schedule+0xb9>
        if (current_task == 0) {
  1044cc:	81 3d 38 94 10 00 00 	cmpl   $0x0,0x109438
  1044d3:	00 00 00 
  1044d6:	0f 85 2a 00 00 00    	jne    104506 <schedule+0x66>
            current_task = first_task;
  1044dc:	a1 34 94 10 00       	mov    0x109434,%eax
  1044e1:	a3 38 94 10 00       	mov    %eax,0x109438
            vmm_activate_pagedir(current_task->phys_pdir);
  1044e6:	a1 38 94 10 00       	mov    0x109438,%eax
  1044eb:	8b 40 14             	mov    0x14(%eax),%eax
  1044ee:	89 04 24             	mov    %eax,(%esp)
  1044f1:	e8 1a 26 00 00       	call   106b10 <vmm_activate_pagedir>
            return current_task->cpuState;
  1044f6:	a1 38 94 10 00       	mov    0x109438,%eax
  1044fb:	8b 40 04             	mov    0x4(%eax),%eax
  1044fe:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104501:	e9 59 00 00 00       	jmp    10455f <schedule+0xbf>
        }

        struct task* next = current_task->next;
  104506:	a1 38 94 10 00       	mov    0x109438,%eax
  10450b:	8b 40 08             	mov    0x8(%eax),%eax
  10450e:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (next == 0)
  104511:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104518:	0f 85 08 00 00 00    	jne    104526 <schedule+0x86>
            next = first_task;
  10451e:	a1 34 94 10 00       	mov    0x109434,%eax
  104523:	89 45 f4             	mov    %eax,-0xc(%ebp)

        save_cpu_state(cpu);
  104526:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104529:	89 04 24             	mov    %eax,(%esp)
  10452c:	e8 2f ff ff ff       	call   104460 <save_cpu_state>

        current_task = next;
  104531:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104534:	a3 38 94 10 00       	mov    %eax,0x109438
        vmm_activate_pagedir(current_task->phys_pdir);
  104539:	a1 38 94 10 00       	mov    0x109438,%eax
  10453e:	8b 40 14             	mov    0x14(%eax),%eax
  104541:	89 04 24             	mov    %eax,(%esp)
  104544:	e8 c7 25 00 00       	call   106b10 <vmm_activate_pagedir>
        return current_task->cpuState;
  104549:	a1 38 94 10 00       	mov    0x109438,%eax
  10454e:	8b 40 04             	mov    0x4(%eax),%eax
  104551:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104554:	e9 06 00 00 00       	jmp    10455f <schedule+0xbf>
    }
    return cpu;
  104559:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10455c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10455f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104562:	83 c4 18             	add    $0x18,%esp
  104565:	5d                   	pop    %ebp
  104566:	c3                   	ret    
  104567:	66 90                	xchg   %ax,%ax
  104569:	66 90                	xchg   %ax,%ax
  10456b:	66 90                	xchg   %ax,%ax
  10456d:	66 90                	xchg   %ax,%ax
  10456f:	90                   	nop

00104570 <malloc>:
    }

    append_to_list(&first_free, tf);
}

void* malloc(size_t size) {
  104570:	55                   	push   %ebp
  104571:	89 e5                	mov    %esp,%ebp
  104573:	83 ec 38             	sub    $0x38,%esp
  104576:	8b 45 08             	mov    0x8(%ebp),%eax
  104579:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(size == 0) return 0;
  10457c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104583:	0f 85 0c 00 00 00    	jne    104595 <malloc+0x25>
  104589:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104590:	e9 95 01 00 00       	jmp    10472a <malloc+0x1ba>

    struct memory_node* last = 0;
  104595:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
  10459c:	a1 44 94 10 00       	mov    0x109444,%eax
  1045a1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  1045a4:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1045ab:	0f 84 27 00 00 00    	je     1045d8 <malloc+0x68>
        if (cur->size >= size) {
  1045b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1045b4:	8b 00                	mov    (%eax),%eax
  1045b6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1045b9:	0f 82 05 00 00 00    	jb     1045c4 <malloc+0x54>
            break;
  1045bf:	e9 14 00 00 00       	jmp    1045d8 <malloc+0x68>
        }
        last = cur;
  1045c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1045c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  1045ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1045cd:	8b 40 08             	mov    0x8(%eax),%eax
  1045d0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  1045d3:	e9 cc ff ff ff       	jmp    1045a4 <malloc+0x34>

    if (cur == 0) {
  1045d8:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1045df:	0f 85 bc 00 00 00    	jne    1046a1 <malloc+0x131>
        uint32_t pgs = size / PAGESIZE;
  1045e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1045e8:	c1 e8 0c             	shr    $0xc,%eax
  1045eb:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
  1045ee:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1045f1:	25 ff 0f 00 00       	and    $0xfff,%eax
  1045f6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1045fb:	0f 84 0b 00 00 00    	je     10460c <malloc+0x9c>
            pgs++;
  104601:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104604:	05 01 00 00 00       	add    $0x1,%eax
  104609:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
  10460c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10460f:	89 04 24             	mov    %eax,(%esp)
  104612:	e8 a9 23 00 00       	call   1069c0 <vmm_alloc_cont>
  104617:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
  10461a:	e8 81 04 00 00       	call   104aa0 <pop_unused_node>
  10461f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
  104622:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104625:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104628:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
  10462b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10462e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104631:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
  104633:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104636:	c1 e0 0c             	shl    $0xc,%eax
  104639:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10463c:	0f 86 3c 00 00 00    	jbe    10467e <malloc+0x10e>
            struct memory_node* free = pop_unused_node();
  104642:	e8 59 04 00 00       	call   104aa0 <pop_unused_node>
  104647:	8d 0d 44 94 10 00    	lea    0x109444,%ecx
  10464d:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
  104650:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104653:	8b 40 04             	mov    0x4(%eax),%eax
  104656:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  104659:	03 02                	add    (%edx),%eax
  10465b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10465e:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
  104661:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104664:	c1 e0 0c             	shl    $0xc,%eax
  104667:	2b 45 f8             	sub    -0x8(%ebp),%eax
  10466a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10466d:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  10466f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  104672:	89 0c 24             	mov    %ecx,(%esp)
  104675:	89 44 24 04          	mov    %eax,0x4(%esp)
  104679:	e8 c2 00 00 00       	call   104740 <append_to_list>
  10467e:	8d 05 40 94 10 00    	lea    0x109440,%eax
        }

        append_to_list(&first_used, fill);
  104684:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104687:	89 04 24             	mov    %eax,(%esp)
  10468a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10468e:	e8 ad 00 00 00       	call   104740 <append_to_list>

        return (void*) fill->address;
  104693:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104696:	8b 40 04             	mov    0x4(%eax),%eax
  104699:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10469c:	e9 89 00 00 00       	jmp    10472a <malloc+0x1ba>
  1046a1:	8d 05 44 94 10 00    	lea    0x109444,%eax
    } else {
        uint32_t freesize = cur->size - size;
  1046a7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1046aa:	8b 09                	mov    (%ecx),%ecx
  1046ac:	2b 4d f8             	sub    -0x8(%ebp),%ecx
  1046af:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
  1046b2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1046b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1046b8:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
  1046ba:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1046bd:	89 04 24             	mov    %eax,(%esp)
  1046c0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1046c4:	e8 a7 00 00 00       	call   104770 <remove_from_list>
  1046c9:	8d 05 40 94 10 00    	lea    0x109440,%eax
        append_to_list(&first_used, cur);
  1046cf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1046d2:	89 04 24             	mov    %eax,(%esp)
  1046d5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1046d9:	e8 62 00 00 00       	call   104740 <append_to_list>

        if (freesize > 0) {
  1046de:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  1046e5:	0f 86 36 00 00 00    	jbe    104721 <malloc+0x1b1>
            struct memory_node* free = pop_unused_node();
  1046eb:	e8 b0 03 00 00       	call   104aa0 <pop_unused_node>
  1046f0:	8d 0d 44 94 10 00    	lea    0x109444,%ecx
  1046f6:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
  1046f9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1046fc:	8b 40 04             	mov    0x4(%eax),%eax
  1046ff:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104702:	03 02                	add    (%edx),%eax
  104704:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104707:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
  10470a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10470d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104710:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  104712:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104715:	89 0c 24             	mov    %ecx,(%esp)
  104718:	89 44 24 04          	mov    %eax,0x4(%esp)
  10471c:	e8 1f 00 00 00       	call   104740 <append_to_list>
        }

        return (void*) cur->address;
  104721:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104724:	8b 40 04             	mov    0x4(%eax),%eax
  104727:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  10472a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10472d:	83 c4 38             	add    $0x38,%esp
  104730:	5d                   	pop    %ebp
  104731:	c3                   	ret    
  104732:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104739:	1f 84 00 00 00 00 00 

00104740 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
  104740:	55                   	push   %ebp
  104741:	89 e5                	mov    %esp,%ebp
  104743:	83 ec 08             	sub    $0x8,%esp
  104746:	8b 45 0c             	mov    0xc(%ebp),%eax
  104749:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10474c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10474f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
  104752:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104755:	8b 00                	mov    (%eax),%eax
  104757:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10475a:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
  10475d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104760:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104763:	89 01                	mov    %eax,(%ecx)
}
  104765:	83 c4 08             	add    $0x8,%esp
  104768:	5d                   	pop    %ebp
  104769:	c3                   	ret    
  10476a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104770 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
  104770:	55                   	push   %ebp
  104771:	89 e5                	mov    %esp,%ebp
  104773:	83 ec 10             	sub    $0x10,%esp
  104776:	8b 45 0c             	mov    0xc(%ebp),%eax
  104779:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10477c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10477f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
  104782:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
  104789:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10478c:	8b 00                	mov    (%eax),%eax
  10478e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  104791:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104798:	0f 84 4e 00 00 00    	je     1047ec <remove_from_list+0x7c>
        if (cur == element) {
  10479e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047a1:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1047a4:	0f 85 2e 00 00 00    	jne    1047d8 <remove_from_list+0x68>
            if (last == 0) {
  1047aa:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1047b1:	0f 85 10 00 00 00    	jne    1047c7 <remove_from_list+0x57>
                *root = cur->next;
  1047b7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047ba:	8b 40 08             	mov    0x8(%eax),%eax
  1047bd:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1047c0:	89 01                	mov    %eax,(%ecx)
                return;
  1047c2:	e9 25 00 00 00       	jmp    1047ec <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
  1047c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047ca:	8b 40 08             	mov    0x8(%eax),%eax
  1047cd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1047d0:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
  1047d3:	e9 14 00 00 00       	jmp    1047ec <remove_from_list+0x7c>
            }
        }
        last = cur;
  1047d8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047db:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  1047de:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1047e1:	8b 40 08             	mov    0x8(%eax),%eax
  1047e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  1047e7:	e9 a5 ff ff ff       	jmp    104791 <remove_from_list+0x21>
}
  1047ec:	83 c4 10             	add    $0x10,%esp
  1047ef:	5d                   	pop    %ebp
  1047f0:	c3                   	ret    
  1047f1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1047f8:	0f 1f 84 00 00 00 00 
  1047ff:	00 

00104800 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
  104800:	55                   	push   %ebp
  104801:	89 e5                	mov    %esp,%ebp
  104803:	83 ec 28             	sub    $0x28,%esp
  104806:	8b 45 0c             	mov    0xc(%ebp),%eax
  104809:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10480c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10480f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
  104812:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104815:	0f af 45 f8          	imul   -0x8(%ebp),%eax
  104819:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
  10481c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10481f:	89 04 24             	mov    %eax,(%esp)
  104822:	e8 49 fd ff ff       	call   104570 <malloc>
  104827:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
  10482a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104831:	0f 84 22 00 00 00    	je     104859 <calloc+0x59>
  104837:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
  10483c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10483f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104842:	89 0c 24             	mov    %ecx,(%esp)
  104845:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  10484c:	00 
  10484d:	89 54 24 08          	mov    %edx,0x8(%esp)
  104851:	89 45 ec             	mov    %eax,-0x14(%ebp)
  104854:	e8 87 03 00 00       	call   104be0 <memset>
    }

    return p;
  104859:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10485c:	83 c4 28             	add    $0x28,%esp
  10485f:	5d                   	pop    %ebp
  104860:	c3                   	ret    
  104861:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104868:	0f 1f 84 00 00 00 00 
  10486f:	00 

00104870 <realloc>:
}

void* realloc(void* ptr, size_t size) {
  104870:	55                   	push   %ebp
  104871:	89 e5                	mov    %esp,%ebp
  104873:	83 ec 28             	sub    $0x28,%esp
  104876:	8b 45 0c             	mov    0xc(%ebp),%eax
  104879:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10487c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10487f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
  104882:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
  104889:	a1 40 94 10 00       	mov    0x109440,%eax
  10488e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
  104891:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104898:	0f 84 8e 00 00 00    	je     10492c <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
  10489e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1048a1:	8b 40 04             	mov    0x4(%eax),%eax
  1048a4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1048a7:	39 c8                	cmp    %ecx,%eax
  1048a9:	0f 85 69 00 00 00    	jne    104918 <realloc+0xa8>
            if (size == 0) {
  1048af:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1048b6:	0f 85 17 00 00 00    	jne    1048d3 <realloc+0x63>
                free(ptr);
  1048bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1048bf:	89 04 24             	mov    %eax,(%esp)
  1048c2:	e8 79 00 00 00       	call   104940 <free>
                return 0;
  1048c7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1048ce:	e9 60 00 00 00       	jmp    104933 <realloc+0xc3>
            } else {
                void* new = malloc(size);
  1048d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1048d6:	89 04 24             	mov    %eax,(%esp)
  1048d9:	e8 92 fc ff ff       	call   104570 <malloc>
  1048de:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
  1048e1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1048e4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1048e7:	8b 49 04             	mov    0x4(%ecx),%ecx
  1048ea:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1048ed:	8b 12                	mov    (%edx),%edx
  1048ef:	89 04 24             	mov    %eax,(%esp)
  1048f2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1048f6:	89 54 24 08          	mov    %edx,0x8(%esp)
  1048fa:	e8 41 03 00 00       	call   104c40 <memcpy>
                free((void*) cur->address);
  1048ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104902:	8b 40 04             	mov    0x4(%eax),%eax
  104905:	89 04 24             	mov    %eax,(%esp)
  104908:	e8 33 00 00 00       	call   104940 <free>

                return new;
  10490d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104910:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104913:	e9 1b 00 00 00       	jmp    104933 <realloc+0xc3>
            }
        }
        last = cur;
  104918:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10491b:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
  10491e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104921:	8b 40 08             	mov    0x8(%eax),%eax
  104924:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
  104927:	e9 65 ff ff ff       	jmp    104891 <realloc+0x21>
    return 0;
  10492c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104933:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104936:	83 c4 28             	add    $0x28,%esp
  104939:	5d                   	pop    %ebp
  10493a:	c3                   	ret    
  10493b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104940 <free>:

void free(void* ptr) {
  104940:	55                   	push   %ebp
  104941:	89 e5                	mov    %esp,%ebp
  104943:	83 ec 18             	sub    $0x18,%esp
  104946:	8b 45 08             	mov    0x8(%ebp),%eax
  104949:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
  10494c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
  104953:	a1 40 94 10 00       	mov    0x109440,%eax
  104958:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
  10495b:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104962:	0f 84 35 00 00 00    	je     10499d <free+0x5d>
        if (cur->address == (uint32_t) ptr) {
  104968:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10496b:	8b 40 04             	mov    0x4(%eax),%eax
  10496e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104971:	39 c8                	cmp    %ecx,%eax
  104973:	0f 85 10 00 00 00    	jne    104989 <free+0x49>
            merge_into_frees(cur);
  104979:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10497c:	89 04 24             	mov    %eax,(%esp)
  10497f:	e8 2c 00 00 00       	call   1049b0 <merge_into_frees>
            break;
  104984:	e9 14 00 00 00       	jmp    10499d <free+0x5d>
        }
        last = cur;
  104989:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10498c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
  10498f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104992:	8b 40 08             	mov    0x8(%eax),%eax
  104995:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  104998:	e9 be ff ff ff       	jmp    10495b <free+0x1b>
}
  10499d:	83 c4 18             	add    $0x18,%esp
  1049a0:	5d                   	pop    %ebp
  1049a1:	c3                   	ret    
  1049a2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1049a9:	1f 84 00 00 00 00 00 

001049b0 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
  1049b0:	55                   	push   %ebp
  1049b1:	89 e5                	mov    %esp,%ebp
  1049b3:	56                   	push   %esi
  1049b4:	83 ec 14             	sub    $0x14,%esp
  1049b7:	8b 45 08             	mov    0x8(%ebp),%eax
  1049ba:	8d 0d 40 94 10 00    	lea    0x109440,%ecx
  1049c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
  1049c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1049c6:	89 0c 24             	mov    %ecx,(%esp)
  1049c9:	89 44 24 04          	mov    %eax,0x4(%esp)
  1049cd:	e8 9e fd ff ff       	call   104770 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
  1049d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
  1049d9:	a1 44 94 10 00       	mov    0x109444,%eax
  1049de:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  1049e1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1049e8:	0f 84 92 00 00 00    	je     104a80 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
  1049ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1049f1:	8b 40 04             	mov    0x4(%eax),%eax
  1049f4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1049f7:	03 01                	add    (%ecx),%eax
  1049f9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1049fc:	3b 41 04             	cmp    0x4(%ecx),%eax
  1049ff:	0f 85 26 00 00 00    	jne    104a2b <merge_into_frees+0x7b>
  104a05:	8d 05 44 94 10 00    	lea    0x109444,%eax
            tf->address = cur->address;
  104a0b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104a0e:	8b 49 04             	mov    0x4(%ecx),%ecx
  104a11:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104a14:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
  104a17:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104a1a:	89 04 24             	mov    %eax,(%esp)
  104a1d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104a21:	e8 4a fd ff ff       	call   104770 <remove_from_list>
            goto editedList;
  104a26:	e9 a7 ff ff ff       	jmp    1049d2 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
  104a2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104a2e:	8b 40 04             	mov    0x4(%eax),%eax
  104a31:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104a34:	8b 49 04             	mov    0x4(%ecx),%ecx
  104a37:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104a3a:	03 0a                	add    (%edx),%ecx
  104a3c:	39 c8                	cmp    %ecx,%eax
  104a3e:	0f 85 28 00 00 00    	jne    104a6c <merge_into_frees+0xbc>
  104a44:	8d 05 44 94 10 00    	lea    0x109444,%eax
            tf->size += cur->size;
  104a4a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104a4d:	8b 09                	mov    (%ecx),%ecx
  104a4f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  104a52:	8b 32                	mov    (%edx),%esi
  104a54:	01 ce                	add    %ecx,%esi
  104a56:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
  104a58:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104a5b:	89 04 24             	mov    %eax,(%esp)
  104a5e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104a62:	e8 09 fd ff ff       	call   104770 <remove_from_list>
            goto editedList;
  104a67:	e9 66 ff ff ff       	jmp    1049d2 <merge_into_frees+0x22>
        }

        last = cur;
  104a6c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104a6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  104a72:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104a75:	8b 40 08             	mov    0x8(%eax),%eax
  104a78:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  104a7b:	e9 61 ff ff ff       	jmp    1049e1 <merge_into_frees+0x31>
  104a80:	8d 05 44 94 10 00    	lea    0x109444,%eax

    append_to_list(&first_free, tf);
  104a86:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104a89:	89 04 24             	mov    %eax,(%esp)
  104a8c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104a90:	e8 ab fc ff ff       	call   104740 <append_to_list>
}
  104a95:	83 c4 14             	add    $0x14,%esp
  104a98:	5e                   	pop    %esi
  104a99:	5d                   	pop    %ebp
  104a9a:	c3                   	ret    
  104a9b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104aa0 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
  104aa0:	55                   	push   %ebp
  104aa1:	89 e5                	mov    %esp,%ebp
  104aa3:	83 ec 08             	sub    $0x8,%esp
  104aa6:	8d 05 3c 94 10 00    	lea    0x10943c,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
  104aac:	89 04 24             	mov    %eax,(%esp)
  104aaf:	e8 3c 00 00 00       	call   104af0 <pop_from_list>
  104ab4:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
  104ab7:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
  104abe:	0f 85 1b 00 00 00    	jne    104adf <pop_unused_node+0x3f>
        allocate_unused_nodes();
  104ac4:	e8 77 00 00 00       	call   104b40 <allocate_unused_nodes>
  104ac9:	8d 05 3c 94 10 00    	lea    0x10943c,%eax
        ret = pop_from_list(&first_unused);
  104acf:	89 04 24             	mov    %eax,(%esp)
  104ad2:	e8 19 00 00 00       	call   104af0 <pop_from_list>
  104ad7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  104ada:	e9 d8 ff ff ff       	jmp    104ab7 <pop_unused_node+0x17>

    return ret;
  104adf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104ae2:	83 c4 08             	add    $0x8,%esp
  104ae5:	5d                   	pop    %ebp
  104ae6:	c3                   	ret    
  104ae7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  104aee:	00 00 

00104af0 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
  104af0:	55                   	push   %ebp
  104af1:	89 e5                	mov    %esp,%ebp
  104af3:	83 ec 18             	sub    $0x18,%esp
  104af6:	8b 45 08             	mov    0x8(%ebp),%eax
  104af9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
  104afc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104aff:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
  104b05:	0f 85 0c 00 00 00    	jne    104b17 <pop_from_list+0x27>
        return 0;
  104b0b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104b12:	e9 20 00 00 00       	jmp    104b37 <pop_from_list+0x47>
    struct memory_node* pop = *root;
  104b17:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b1a:	8b 00                	mov    (%eax),%eax
  104b1c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
  104b1f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b22:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104b25:	89 04 24             	mov    %eax,(%esp)
  104b28:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104b2c:	e8 3f fc ff ff       	call   104770 <remove_from_list>
    return pop;
  104b31:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104b34:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104b37:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104b3a:	83 c4 18             	add    $0x18,%esp
  104b3d:	5d                   	pop    %ebp
  104b3e:	c3                   	ret    
  104b3f:	90                   	nop

00104b40 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
  104b40:	55                   	push   %ebp
  104b41:	89 e5                	mov    %esp,%ebp
  104b43:	83 ec 28             	sub    $0x28,%esp
  104b46:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
  104b4b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  104b52:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104b55:	e8 66 1e 00 00       	call   1069c0 <vmm_alloc_cont>
  104b5a:	b9 00 00 00 00       	mov    $0x0,%ecx
  104b5f:	ba 00 10 00 00       	mov    $0x1000,%edx
  104b64:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
  104b67:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104b6a:	89 04 24             	mov    %eax,(%esp)
  104b6d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  104b74:	00 
  104b75:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  104b7c:	00 
  104b7d:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104b80:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104b83:	e8 58 00 00 00       	call   104be0 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  104b88:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  104b8f:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
  104b96:	0f 83 30 00 00 00    	jae    104bcc <allocate_unused_nodes+0x8c>
  104b9c:	8d 05 3c 94 10 00    	lea    0x10943c,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
  104ba2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104ba5:	8b 55 fc             	mov    -0x4(%ebp),%edx
  104ba8:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
  104bae:	01 ca                	add    %ecx,%edx
  104bb0:	89 04 24             	mov    %eax,(%esp)
  104bb3:	89 54 24 04          	mov    %edx,0x4(%esp)
  104bb7:	e8 84 fb ff ff       	call   104740 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  104bbc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104bbf:	05 01 00 00 00       	add    $0x1,%eax
  104bc4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  104bc7:	e9 c3 ff ff ff       	jmp    104b8f <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
  104bcc:	83 c4 28             	add    $0x28,%esp
  104bcf:	5d                   	pop    %ebp
  104bd0:	c3                   	ret    
  104bd1:	66 90                	xchg   %ax,%ax
  104bd3:	66 90                	xchg   %ax,%ax
  104bd5:	66 90                	xchg   %ax,%ax
  104bd7:	66 90                	xchg   %ax,%ax
  104bd9:	66 90                	xchg   %ax,%ax
  104bdb:	66 90                	xchg   %ax,%ax
  104bdd:	66 90                	xchg   %ax,%ax
  104bdf:	90                   	nop

00104be0 <memset>:
#include "vmm.h"
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
  104be0:	55                   	push   %ebp
  104be1:	89 e5                	mov    %esp,%ebp
  104be3:	83 ec 10             	sub    $0x10,%esp
  104be6:	8b 45 10             	mov    0x10(%ebp),%eax
  104be9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104bec:	8b 55 08             	mov    0x8(%ebp),%edx
  104bef:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104bf2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104bf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* p = buf;
  104bf8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104bfb:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (n--) {
  104bfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c01:	89 c1                	mov    %eax,%ecx
  104c03:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  104c09:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104c0c:	3d 00 00 00 00       	cmp    $0x0,%eax
  104c11:	0f 84 1a 00 00 00    	je     104c31 <memset+0x51>
        *p++ = c;
  104c17:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c1a:	88 c1                	mov    %al,%cl
  104c1c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104c1f:	89 c2                	mov    %eax,%edx
  104c21:	81 c2 01 00 00 00    	add    $0x1,%edx
  104c27:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104c2a:	88 08                	mov    %cl,(%eax)
    }
  104c2c:	e9 cd ff ff ff       	jmp    104bfe <memset+0x1e>

    return buf;
  104c31:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c34:	83 c4 10             	add    $0x10,%esp
  104c37:	5d                   	pop    %ebp
  104c38:	c3                   	ret    
  104c39:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00104c40 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
  104c40:	55                   	push   %ebp
  104c41:	89 e5                	mov    %esp,%ebp
  104c43:	83 ec 14             	sub    $0x14,%esp
  104c46:	8b 45 10             	mov    0x10(%ebp),%eax
  104c49:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104c4c:	8b 55 08             	mov    0x8(%ebp),%edx
  104c4f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104c52:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104c55:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* d = dest;
  104c58:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104c5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const unsigned char* s = src;
  104c5e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c61:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (n--) {
  104c64:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c67:	89 c1                	mov    %eax,%ecx
  104c69:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  104c6f:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104c72:	3d 00 00 00 00       	cmp    $0x0,%eax
  104c77:	0f 84 25 00 00 00    	je     104ca2 <memcpy+0x62>
        *(d++) = *(s++);
  104c7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104c80:	89 c1                	mov    %eax,%ecx
  104c82:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104c88:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104c8b:	8a 10                	mov    (%eax),%dl
  104c8d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104c90:	89 c1                	mov    %eax,%ecx
  104c92:	81 c1 01 00 00 00    	add    $0x1,%ecx
  104c98:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  104c9b:	88 10                	mov    %dl,(%eax)
    }
  104c9d:	e9 c2 ff ff ff       	jmp    104c64 <memcpy+0x24>

    return dest;
  104ca2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104ca5:	83 c4 14             	add    $0x14,%esp
  104ca8:	5d                   	pop    %ebp
  104ca9:	c3                   	ret    
  104caa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104cb0 <memcmp>:
}

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  104cb0:	55                   	push   %ebp
  104cb1:	89 e5                	mov    %esp,%ebp
  104cb3:	83 ec 1c             	sub    $0x1c,%esp
  104cb6:	8b 45 10             	mov    0x10(%ebp),%eax
  104cb9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104cbc:	8b 55 08             	mov    0x8(%ebp),%edx
  104cbf:	89 55 f8             	mov    %edx,-0x8(%ebp)
  104cc2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  104cc5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
  104cc8:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104ccf:	0f 85 0c 00 00 00    	jne    104ce1 <memcmp+0x31>
        return -1;
  104cd5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  104cdc:	e9 a7 00 00 00       	jmp    104d88 <memcmp+0xd8>
    if (ptr2 == 0)
  104ce1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104ce8:	0f 85 0c 00 00 00    	jne    104cfa <memcmp+0x4a>
        return 1;
  104cee:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  104cf5:	e9 8e 00 00 00       	jmp    104d88 <memcmp+0xd8>
    if (num == 0)
  104cfa:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104d01:	0f 85 0c 00 00 00    	jne    104d13 <memcmp+0x63>
        return 0;
  104d07:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104d0e:	e9 75 00 00 00       	jmp    104d88 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
  104d13:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d16:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
  104d19:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d1c:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
  104d1f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104d26:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104d29:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  104d2c:	0f 83 4f 00 00 00    	jae    104d81 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
  104d32:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104d35:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104d38:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  104d3c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104d3f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104d42:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  104d46:	39 c8                	cmp    %ecx,%eax
  104d48:	0f 84 1e 00 00 00    	je     104d6c <memcmp+0xbc>
            return pa[i] - pb[i];
  104d4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104d51:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104d54:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  104d58:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  104d5b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104d5e:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  104d62:	29 c8                	sub    %ecx,%eax
  104d64:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104d67:	e9 1c 00 00 00       	jmp    104d88 <memcmp+0xd8>
        }
    }
  104d6c:	e9 00 00 00 00       	jmp    104d71 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
  104d71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104d74:	05 01 00 00 00       	add    $0x1,%eax
  104d79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  104d7c:	e9 a5 ff ff ff       	jmp    104d26 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
  104d81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104d88:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104d8b:	83 c4 1c             	add    $0x1c,%esp
  104d8e:	5d                   	pop    %ebp
  104d8f:	c3                   	ret    

00104d90 <strcmp>:

int strcmp(const char* str1, const char* str2) {
  104d90:	55                   	push   %ebp
  104d91:	89 e5                	mov    %esp,%ebp
  104d93:	56                   	push   %esi
  104d94:	83 ec 24             	sub    $0x24,%esp
  104d97:	8b 45 0c             	mov    0xc(%ebp),%eax
  104d9a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104d9d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104da0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
  104da3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104da6:	89 e1                	mov    %esp,%ecx
  104da8:	89 01                	mov    %eax,(%ecx)
  104daa:	e8 61 00 00 00       	call   104e10 <strlen>
  104daf:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
  104db2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104db5:	89 e1                	mov    %esp,%ecx
  104db7:	89 01                	mov    %eax,(%ecx)
  104db9:	e8 52 00 00 00       	call   104e10 <strlen>
  104dbe:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
  104dc1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104dc4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104dc7:	0f 8d 0b 00 00 00    	jge    104dd8 <strcmp+0x48>
  104dcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104dd0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104dd3:	e9 06 00 00 00       	jmp    104dde <strcmp+0x4e>
  104dd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104ddb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  104dde:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104de1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, l1 * sizeof(char));
  104de4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104de7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104dea:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104ded:	c1 e2 00             	shl    $0x0,%edx
  104df0:	89 e6                	mov    %esp,%esi
  104df2:	89 56 08             	mov    %edx,0x8(%esi)
  104df5:	89 4e 04             	mov    %ecx,0x4(%esi)
  104df8:	89 06                	mov    %eax,(%esi)
  104dfa:	e8 b1 fe ff ff       	call   104cb0 <memcmp>
  104dff:	83 c4 24             	add    $0x24,%esp
  104e02:	5e                   	pop    %esi
  104e03:	5d                   	pop    %ebp
  104e04:	c3                   	ret    
  104e05:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  104e0c:	00 00 00 00 

00104e10 <strlen>:
}

unsigned int strlen(const char* str) {
  104e10:	55                   	push   %ebp
  104e11:	89 e5                	mov    %esp,%ebp
  104e13:	83 ec 0c             	sub    $0xc,%esp
  104e16:	8b 45 08             	mov    0x8(%ebp),%eax
  104e19:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
  104e1c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104e23:	0f 85 0c 00 00 00    	jne    104e35 <strlen+0x25>
        return 0;
  104e29:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104e30:	e9 37 00 00 00       	jmp    104e6c <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
  104e35:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  104e3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e3f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104e42:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  104e46:	3d 00 00 00 00       	cmp    $0x0,%eax
  104e4b:	0f 84 15 00 00 00    	je     104e66 <strlen+0x56>
  104e51:	e9 00 00 00 00       	jmp    104e56 <strlen+0x46>
  104e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e59:	05 01 00 00 00       	add    $0x1,%eax
  104e5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104e61:	e9 d6 ff ff ff       	jmp    104e3c <strlen+0x2c>
        ;
    return i;
  104e66:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104e69:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104e6c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104e6f:	83 c4 0c             	add    $0xc,%esp
  104e72:	5d                   	pop    %ebp
  104e73:	c3                   	ret    
  104e74:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104e7b:	00 00 00 00 00 

00104e80 <strcpy>:

char* strcpy(char* dest, const char* src) {
  104e80:	55                   	push   %ebp
  104e81:	89 e5                	mov    %esp,%ebp
  104e83:	56                   	push   %esi
  104e84:	83 ec 24             	sub    $0x24,%esp
  104e87:	8b 45 0c             	mov    0xc(%ebp),%eax
  104e8a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104e8d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104e90:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
  104e93:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104e96:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104e99:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104e9c:	89 e6                	mov    %esp,%esi
  104e9e:	89 16                	mov    %edx,(%esi)
  104ea0:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104ea3:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104ea6:	e8 65 ff ff ff       	call   104e10 <strlen>
  104eab:	c1 e0 00             	shl    $0x0,%eax
  104eae:	05 01 00 00 00       	add    $0x1,%eax
  104eb3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104eb6:	89 0c 24             	mov    %ecx,(%esp)
  104eb9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  104ebc:	89 54 24 04          	mov    %edx,0x4(%esp)
  104ec0:	89 44 24 08          	mov    %eax,0x8(%esp)
  104ec4:	e8 77 fd ff ff       	call   104c40 <memcpy>
    return dest;
  104ec9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104ecc:	83 c4 24             	add    $0x24,%esp
  104ecf:	5e                   	pop    %esi
  104ed0:	5d                   	pop    %ebp
  104ed1:	c3                   	ret    
  104ed2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104ed9:	1f 84 00 00 00 00 00 

00104ee0 <strclone>:
}

char* strclone(char* str) {
  104ee0:	55                   	push   %ebp
  104ee1:	89 e5                	mov    %esp,%ebp
  104ee3:	83 ec 18             	sub    $0x18,%esp
  104ee6:	8b 45 08             	mov    0x8(%ebp),%eax
  104ee9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
  104eec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104eef:	89 e1                	mov    %esp,%ecx
  104ef1:	89 01                	mov    %eax,(%ecx)
  104ef3:	e8 18 ff ff ff       	call   104e10 <strlen>
  104ef8:	c1 e0 00             	shl    $0x0,%eax
  104efb:	05 01 00 00 00       	add    $0x1,%eax
  104f00:	89 04 24             	mov    %eax,(%esp)
  104f03:	e8 68 f6 ff ff       	call   104570 <malloc>
  104f08:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
  104f0b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f0e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104f11:	89 e2                	mov    %esp,%edx
  104f13:	89 4a 04             	mov    %ecx,0x4(%edx)
  104f16:	89 02                	mov    %eax,(%edx)
  104f18:	e8 63 ff ff ff       	call   104e80 <strcpy>

    return ret;
  104f1d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104f20:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104f23:	89 c8                	mov    %ecx,%eax
  104f25:	83 c4 18             	add    $0x18,%esp
  104f28:	5d                   	pop    %ebp
  104f29:	c3                   	ret    
  104f2a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104f30 <strtok>:
}

char* sp = NULL; /* the start position of the string */

char* strtok(char* str, const char* delimiters) {
  104f30:	55                   	push   %ebp
  104f31:	89 e5                	mov    %esp,%ebp
  104f33:	83 ec 18             	sub    $0x18,%esp
  104f36:	8b 45 0c             	mov    0xc(%ebp),%eax
  104f39:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104f3c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104f3f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) {
  104f42:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104f49:	0f 84 22 00 00 00    	je     104f71 <strtok+0x41>
        return strtoknc(strclone(str), delimiters);
  104f4f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104f52:	89 04 24             	mov    %eax,(%esp)
  104f55:	e8 86 ff ff ff       	call   104ee0 <strclone>
  104f5a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104f5d:	89 04 24             	mov    %eax,(%esp)
  104f60:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104f64:	e8 37 00 00 00       	call   104fa0 <strtoknc>
  104f69:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104f6c:	e9 1e 00 00 00       	jmp    104f8f <strtok+0x5f>
  104f71:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
  104f76:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104f79:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104f80:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104f84:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104f87:	e8 14 00 00 00       	call   104fa0 <strtoknc>
  104f8c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104f8f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104f92:	83 c4 18             	add    $0x18,%esp
  104f95:	5d                   	pop    %ebp
  104f96:	c3                   	ret    
  104f97:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  104f9e:	00 00 

00104fa0 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
  104fa0:	55                   	push   %ebp
  104fa1:	89 e5                	mov    %esp,%ebp
  104fa3:	83 ec 28             	sub    $0x28,%esp
  104fa6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104fa9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104fac:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104faf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
  104fb2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
  104fb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104fbc:	89 e1                	mov    %esp,%ecx
  104fbe:	89 01                	mov    %eax,(%ecx)
  104fc0:	e8 4b fe ff ff       	call   104e10 <strlen>
  104fc5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
  104fc8:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  104fcf:	0f 85 0c 00 00 00    	jne    104fe1 <strtoknc+0x41>
        return 0;
  104fd5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104fdc:	e9 80 01 00 00       	jmp    105161 <strtoknc+0x1c1>

    /* if the original string has nothing left */
    if (!str && !sp)
  104fe1:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104fe8:	0f 85 1c 00 00 00    	jne    10500a <strtoknc+0x6a>
  104fee:	81 3d 48 94 10 00 00 	cmpl   $0x0,0x109448
  104ff5:	00 00 00 
  104ff8:	0f 85 0c 00 00 00    	jne    10500a <strtoknc+0x6a>
        return 0;
  104ffe:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105005:	e9 57 01 00 00       	jmp    105161 <strtoknc+0x1c1>

    /* initialize the sp during the first call */
    if (str && !sp)
  10500a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105011:	0f 84 18 00 00 00    	je     10502f <strtoknc+0x8f>
  105017:	81 3d 48 94 10 00 00 	cmpl   $0x0,0x109448
  10501e:	00 00 00 
  105021:	0f 85 08 00 00 00    	jne    10502f <strtoknc+0x8f>
        sp = str;
  105027:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10502a:	a3 48 94 10 00       	mov    %eax,0x109448

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
  10502f:	a1 48 94 10 00       	mov    0x109448,%eax
  105034:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
  105037:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10503e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105041:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  105044:	0f 8d 3d 00 00 00    	jge    105087 <strtoknc+0xe7>
            if (*p_start == delimiters[i]) {
  10504a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10504d:	0f be 00             	movsbl (%eax),%eax
  105050:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105053:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105056:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  10505a:	39 c8                	cmp    %ecx,%eax
  10505c:	0f 85 10 00 00 00    	jne    105072 <strtoknc+0xd2>
                p_start++;
  105062:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105065:	05 01 00 00 00       	add    $0x1,%eax
  10506a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
  10506d:	e9 15 00 00 00       	jmp    105087 <strtoknc+0xe7>
            }
        }
  105072:	e9 00 00 00 00       	jmp    105077 <strtoknc+0xd7>
        sp = str;

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
  105077:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10507a:	05 01 00 00 00       	add    $0x1,%eax
  10507f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105082:	e9 b7 ff ff ff       	jmp    10503e <strtoknc+0x9e>
                p_start++;
                break;
            }
        }

        if (i == len) {
  105087:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10508a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10508d:	0f 85 0d 00 00 00    	jne    1050a0 <strtoknc+0x100>
            sp = p_start;
  105093:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105096:	a3 48 94 10 00       	mov    %eax,0x109448
            break;
  10509b:	e9 05 00 00 00       	jmp    1050a5 <strtoknc+0x105>
        }
    }
  1050a0:	e9 92 ff ff ff       	jmp    105037 <strtoknc+0x97>

    /* return NULL if nothing left */
    if (*sp == '\0') {
  1050a5:	a1 48 94 10 00       	mov    0x109448,%eax
  1050aa:	0f be 00             	movsbl (%eax),%eax
  1050ad:	3d 00 00 00 00       	cmp    $0x0,%eax
  1050b2:	0f 85 17 00 00 00    	jne    1050cf <strtoknc+0x12f>
        sp = NULL;
  1050b8:	c7 05 48 94 10 00 00 	movl   $0x0,0x109448
  1050bf:	00 00 00 
        return sp;
  1050c2:	a1 48 94 10 00       	mov    0x109448,%eax
  1050c7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1050ca:	e9 92 00 00 00       	jmp    105161 <strtoknc+0x1c1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
  1050cf:	e9 00 00 00 00       	jmp    1050d4 <strtoknc+0x134>
  1050d4:	a1 48 94 10 00       	mov    0x109448,%eax
  1050d9:	0f be 00             	movsbl (%eax),%eax
  1050dc:	3d 00 00 00 00       	cmp    $0x0,%eax
  1050e1:	0f 84 74 00 00 00    	je     10515b <strtoknc+0x1bb>
        for (i = 0; i < len; i++) {
  1050e7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1050ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1050f1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1050f4:	0f 8d 3c 00 00 00    	jge    105136 <strtoknc+0x196>
            if (*sp == delimiters[i]) {
  1050fa:	a1 48 94 10 00       	mov    0x109448,%eax
  1050ff:	0f be 00             	movsbl (%eax),%eax
  105102:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105105:	8b 55 f4             	mov    -0xc(%ebp),%edx
  105108:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  10510c:	39 c8                	cmp    %ecx,%eax
  10510e:	0f 85 0d 00 00 00    	jne    105121 <strtoknc+0x181>
                *sp = '\0';
  105114:	a1 48 94 10 00       	mov    0x109448,%eax
  105119:	c6 00 00             	movb   $0x0,(%eax)
                break;
  10511c:	e9 15 00 00 00       	jmp    105136 <strtoknc+0x196>
            }
        }
  105121:	e9 00 00 00 00       	jmp    105126 <strtoknc+0x186>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
  105126:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105129:	05 01 00 00 00       	add    $0x1,%eax
  10512e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105131:	e9 b8 ff ff ff       	jmp    1050ee <strtoknc+0x14e>
                *sp = '\0';
                break;
            }
        }

        sp++;
  105136:	a1 48 94 10 00       	mov    0x109448,%eax
  10513b:	05 01 00 00 00       	add    $0x1,%eax
  105140:	a3 48 94 10 00       	mov    %eax,0x109448
        if (i < len)
  105145:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105148:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10514b:	0f 8d 05 00 00 00    	jge    105156 <strtoknc+0x1b6>
            break;
  105151:	e9 05 00 00 00       	jmp    10515b <strtoknc+0x1bb>
    }
  105156:	e9 79 ff ff ff       	jmp    1050d4 <strtoknc+0x134>

    return p_start;
  10515b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10515e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  105161:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105164:	83 c4 28             	add    $0x28,%esp
  105167:	5d                   	pop    %ebp
  105168:	c3                   	ret    
  105169:	66 90                	xchg   %ax,%ax
  10516b:	66 90                	xchg   %ax,%ax
  10516d:	66 90                	xchg   %ax,%ax
  10516f:	90                   	nop

00105170 <vfs_create_dir>:
    }

    return child;
}

uint32_t vfs_create_dir(char* path) {
  105170:	55                   	push   %ebp
  105171:	89 e5                	mov    %esp,%ebp
  105173:	83 ec 08             	sub    $0x8,%esp
  105176:	8b 45 08             	mov    0x8(%ebp),%eax
  105179:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return vfs_create_path(path);
  10517c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10517f:	89 04 24             	mov    %eax,(%esp)
  105182:	e8 09 00 00 00       	call   105190 <vfs_create_path>
  105187:	83 c4 08             	add    $0x8,%esp
  10518a:	5d                   	pop    %ebp
  10518b:	c3                   	ret    
  10518c:	0f 1f 40 00          	nopl   0x0(%eax)

00105190 <vfs_create_path>:
    }

    return 1;
}

static int vfs_create_path(char* path) {
  105190:	55                   	push   %ebp
  105191:	89 e5                	mov    %esp,%ebp
  105193:	83 ec 38             	sub    $0x38,%esp
  105196:	8b 45 08             	mov    0x8(%ebp),%eax
  105199:	8d 0d 2d 86 10 00    	lea    0x10862d,%ecx
  10519f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  1051a2:	a1 4c 94 10 00       	mov    0x10944c,%eax
  1051a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  1051aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    int created = 0;
  1051b1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    sub = strtok(path, "/");
  1051b8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1051bb:	89 04 24             	mov    %eax,(%esp)
  1051be:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1051c2:	e8 69 fd ff ff       	call   104f30 <strtok>
  1051c7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  1051ca:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1051cd:	0f be 00             	movsbl (%eax),%eax
  1051d0:	3d 00 00 00 00       	cmp    $0x0,%eax
  1051d5:	0f 85 21 00 00 00    	jne    1051fc <vfs_create_path+0x6c>
  1051db:	b8 00 00 00 00       	mov    $0x0,%eax
  1051e0:	8d 0d 2d 86 10 00    	lea    0x10862d,%ecx
  1051e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1051ed:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1051f1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1051f4:	e8 37 fd ff ff       	call   104f30 <strtok>
  1051f9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  1051fc:	e9 00 00 00 00       	jmp    105201 <vfs_create_path+0x71>
  105201:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105208:	0f 84 e8 00 00 00    	je     1052f6 <vfs_create_path+0x166>
    {
        child = vfs_find_node(parent, sub);
  10520e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105211:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105214:	89 04 24             	mov    %eax,(%esp)
  105217:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10521b:	e8 90 0c 00 00       	call   105eb0 <vfs_find_node>
  105220:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(child == 0) {
  105223:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10522a:	0f 85 9a 00 00 00    	jne    1052ca <vfs_create_path+0x13a>
  105230:	b8 10 01 00 00       	mov    $0x110,%eax
            child = malloc(sizeof(struct res_node));
  105235:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  10523c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10523f:	e8 2c f3 ff ff       	call   104570 <malloc>
  105244:	89 45 f0             	mov    %eax,-0x10(%ebp)

            strcpy(child->name, sub);
  105247:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10524a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10524d:	89 e2                	mov    %esp,%edx
  10524f:	89 4a 04             	mov    %ecx,0x4(%edx)
  105252:	89 02                	mov    %eax,(%edx)
  105254:	e8 27 fc ff ff       	call   104e80 <strcpy>
            child->res_type = RES_SUBDIR;
  105259:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10525c:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  105263:	00 00 00 
            child->res_ptr = 0;
  105266:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105269:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  105270:	00 00 00 

            created++;
  105273:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105276:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10527c:	89 4d ec             	mov    %ecx,-0x14(%ebp)

            if(vfs_insert_node(parent, child)) {
  10527f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105282:	8b 55 f0             	mov    -0x10(%ebp),%edx
  105285:	89 0c 24             	mov    %ecx,(%esp)
  105288:	89 54 24 04          	mov    %edx,0x4(%esp)
  10528c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10528f:	e8 ac 0c 00 00       	call   105f40 <vfs_insert_node>
  105294:	3d 00 00 00 00       	cmp    $0x0,%eax
  105299:	0f 84 26 00 00 00    	je     1052c5 <vfs_create_path+0x135>
  10529f:	b8 38 00 00 00       	mov    $0x38,%eax
                show_cod(malloc(sizeof(struct cpu_state)), "Tried to insert VFS node in non RES_SUBDIR parent");
  1052a4:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  1052ab:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1052ae:	e8 bd f2 ff ff       	call   104570 <malloc>
  1052b3:	8d 0d 2f 86 10 00    	lea    0x10862f,%ecx
  1052b9:	89 04 24             	mov    %eax,(%esp)
  1052bc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1052c0:	e8 fb ad ff ff       	call   1000c0 <show_cod>
            }
        }
  1052c5:	e9 00 00 00 00       	jmp    1052ca <vfs_create_path+0x13a>
  1052ca:	b8 00 00 00 00       	mov    $0x0,%eax
  1052cf:	8d 0d 2d 86 10 00    	lea    0x10862d,%ecx

        parent = child;
  1052d5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1052d8:	89 55 f4             	mov    %edx,-0xc(%ebp)

        sub = strtok(0, "/");
  1052db:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1052e2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1052e6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1052e9:	e8 42 fc ff ff       	call   104f30 <strtok>
  1052ee:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  1052f1:	e9 0b ff ff ff       	jmp    105201 <vfs_create_path+0x71>

    return created;
  1052f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1052f9:	83 c4 38             	add    $0x38,%esp
  1052fc:	5d                   	pop    %ebp
  1052fd:	c3                   	ret    
  1052fe:	66 90                	xchg   %ax,%ax

00105300 <vfs_create_kfile>:

uint32_t vfs_create_dir(char* path) {
    return vfs_create_path(path);
}

uint32_t vfs_create_kfile(char* path, struct kfs_driver* driver, uint32_t* params) {
  105300:	55                   	push   %ebp
  105301:	89 e5                	mov    %esp,%ebp
  105303:	83 ec 28             	sub    $0x28,%esp
  105306:	8b 45 10             	mov    0x10(%ebp),%eax
  105309:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10530c:	8b 55 08             	mov    0x8(%ebp),%edx
  10530f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  105312:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105315:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* pathc = malloc(strlen(path) + 1);
  105318:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10531b:	89 e1                	mov    %esp,%ecx
  10531d:	89 01                	mov    %eax,(%ecx)
  10531f:	e8 ec fa ff ff       	call   104e10 <strlen>
  105324:	05 01 00 00 00       	add    $0x1,%eax
  105329:	89 04 24             	mov    %eax,(%esp)
  10532c:	e8 3f f2 ff ff       	call   104570 <malloc>
  105331:	89 45 f0             	mov    %eax,-0x10(%ebp)
    strcpy(pathc, path);
  105334:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105337:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10533a:	89 e2                	mov    %esp,%edx
  10533c:	89 4a 04             	mov    %ecx,0x4(%edx)
  10533f:	89 02                	mov    %eax,(%edx)
  105341:	e8 3a fb ff ff       	call   104e80 <strcpy>

    uint32_t ret = vfs_create_path(pathc);
  105346:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105349:	89 0c 24             	mov    %ecx,(%esp)
  10534c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10534f:	e8 3c fe ff ff       	call   105190 <vfs_create_path>
  105354:	89 45 ec             	mov    %eax,-0x14(%ebp)

    static struct res_node* node;
    node = vfs_get_node(path);
  105357:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10535a:	89 04 24             	mov    %eax,(%esp)
  10535d:	e8 4e 00 00 00       	call   1053b0 <vfs_get_node>
  105362:	a3 58 94 10 00       	mov    %eax,0x109458

    node->res_type = RES_KERNDRV;
  105367:	a1 58 94 10 00       	mov    0x109458,%eax
  10536c:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  105373:	00 00 00 
    node->res_ptr = driver->create(params);
  105376:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105379:	8b 40 14             	mov    0x14(%eax),%eax
  10537c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10537f:	89 0c 24             	mov    %ecx,(%esp)
  105382:	ff d0                	call   *%eax
  105384:	8b 0d 58 94 10 00    	mov    0x109458,%ecx
  10538a:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)
    ((struct res_kfile*) node->res_ptr)->driver = driver;
  105390:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105393:	8b 0d 58 94 10 00    	mov    0x109458,%ecx
  105399:	8b 89 04 01 00 00    	mov    0x104(%ecx),%ecx
  10539f:	89 41 04             	mov    %eax,0x4(%ecx)

    return ret;
  1053a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1053a5:	83 c4 28             	add    $0x28,%esp
  1053a8:	5d                   	pop    %ebp
  1053a9:	c3                   	ret    
  1053aa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001053b0 <vfs_get_node>:
    }

    return created;
}

static struct res_node* vfs_get_node(char* path) {
  1053b0:	55                   	push   %ebp
  1053b1:	89 e5                	mov    %esp,%ebp
  1053b3:	83 ec 28             	sub    $0x28,%esp
  1053b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1053b9:	8d 0d 2d 86 10 00    	lea    0x10862d,%ecx
  1053bf:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  1053c2:	a1 4c 94 10 00       	mov    0x10944c,%eax
  1053c7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  1053ca:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    sub = strtok(path, "/");
  1053d1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1053d4:	89 04 24             	mov    %eax,(%esp)
  1053d7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1053db:	e8 50 fb ff ff       	call   104f30 <strtok>
  1053e0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  1053e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1053e6:	0f be 00             	movsbl (%eax),%eax
  1053e9:	3d 00 00 00 00       	cmp    $0x0,%eax
  1053ee:	0f 85 21 00 00 00    	jne    105415 <vfs_get_node+0x65>
  1053f4:	b8 00 00 00 00       	mov    $0x0,%eax
  1053f9:	8d 0d 2d 86 10 00    	lea    0x10862d,%ecx
  1053ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105406:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10540a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10540d:	e8 1e fb ff ff       	call   104f30 <strtok>
  105412:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  105415:	e9 00 00 00 00       	jmp    10541a <vfs_get_node+0x6a>
  10541a:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105421:	0f 84 41 00 00 00    	je     105468 <vfs_get_node+0xb8>
    {
        child = vfs_find_node(parent, sub);
  105427:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10542a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10542d:	89 04 24             	mov    %eax,(%esp)
  105430:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105434:	e8 77 0a 00 00       	call   105eb0 <vfs_find_node>
  105439:	b9 00 00 00 00       	mov    $0x0,%ecx
  10543e:	8d 15 2d 86 10 00    	lea    0x10862d,%edx
  105444:	89 45 f0             	mov    %eax,-0x10(%ebp)
        parent = child;
  105447:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10544a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        sub = strtok(0, "/");
  10544d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105454:	89 54 24 04          	mov    %edx,0x4(%esp)
  105458:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10545b:	e8 d0 fa ff ff       	call   104f30 <strtok>
  105460:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  105463:	e9 b2 ff ff ff       	jmp    10541a <vfs_get_node+0x6a>

    return child;
  105468:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10546b:	83 c4 28             	add    $0x28,%esp
  10546e:	5d                   	pop    %ebp
  10546f:	c3                   	ret    

00105470 <vfs_open>:
    ((struct res_kfile*) node->res_ptr)->driver = driver;

    return ret;
}

struct res_handle* vfs_open(char* path, uint32_t filemode) {
  105470:	55                   	push   %ebp
  105471:	89 e5                	mov    %esp,%ebp
  105473:	83 ec 28             	sub    $0x28,%esp
  105476:	8b 45 0c             	mov    0xc(%ebp),%eax
  105479:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10547c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10547f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    static struct res_node* node;

    node = vfs_get_node(path);
  105482:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105485:	89 04 24             	mov    %eax,(%esp)
  105488:	e8 23 ff ff ff       	call   1053b0 <vfs_get_node>
  10548d:	a3 5c 94 10 00       	mov    %eax,0x10945c

    if(node->res_type == RES_KERNDRV) {
  105492:	a1 5c 94 10 00       	mov    0x10945c,%eax
  105497:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  10549e:	00 00 00 
  1054a1:	0f 85 34 00 00 00    	jne    1054db <vfs_open+0x6b>
        struct res_kfile* kf = (struct res_kfile*)node->res_ptr;
  1054a7:	a1 5c 94 10 00       	mov    0x10945c,%eax
  1054ac:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  1054b2:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct res_handle* handle = kf->driver->open(kf, filemode);
  1054b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1054b8:	8b 40 04             	mov    0x4(%eax),%eax
  1054bb:	8b 40 08             	mov    0x8(%eax),%eax
  1054be:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1054c1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1054c4:	89 0c 24             	mov    %ecx,(%esp)
  1054c7:	89 54 24 04          	mov    %edx,0x4(%esp)
  1054cb:	ff d0                	call   *%eax
  1054cd:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return handle;
  1054d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1054d3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1054d6:	e9 07 00 00 00       	jmp    1054e2 <vfs_open+0x72>
    }

    return 0;
  1054db:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1054e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1054e5:	83 c4 28             	add    $0x28,%esp
  1054e8:	5d                   	pop    %ebp
  1054e9:	c3                   	ret    
  1054ea:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001054f0 <vfs_close>:

uint32_t vfs_close(struct res_handle* handle) {
  1054f0:	55                   	push   %ebp
  1054f1:	89 e5                	mov    %esp,%ebp
  1054f3:	83 ec 18             	sub    $0x18,%esp
  1054f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1054f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle->res_type == RES_KERNDRV) {
  1054fc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1054ff:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105505:	0f 85 22 00 00 00    	jne    10552d <vfs_close+0x3d>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  10550b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10550e:	8b 40 04             	mov    0x4(%eax),%eax
  105511:	89 45 f4             	mov    %eax,-0xc(%ebp)

       return kf->driver->close(handle);
  105514:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105517:	8b 40 04             	mov    0x4(%eax),%eax
  10551a:	8b 40 0c             	mov    0xc(%eax),%eax
  10551d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105520:	89 0c 24             	mov    %ecx,(%esp)
  105523:	ff d0                	call   *%eax
  105525:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105528:	e9 07 00 00 00       	jmp    105534 <vfs_close+0x44>
    }

    return 0;
  10552d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105534:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105537:	83 c4 18             	add    $0x18,%esp
  10553a:	5d                   	pop    %ebp
  10553b:	c3                   	ret    
  10553c:	0f 1f 40 00          	nopl   0x0(%eax)

00105540 <vfs_read>:

uint32_t vfs_read(struct res_handle* handle, void* dest, uint32_t size, uint32_t count) {
  105540:	55                   	push   %ebp
  105541:	89 e5                	mov    %esp,%ebp
  105543:	56                   	push   %esi
  105544:	83 ec 34             	sub    $0x34,%esp
  105547:	8b 45 14             	mov    0x14(%ebp),%eax
  10554a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10554d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105550:	8b 75 08             	mov    0x8(%ebp),%esi
  105553:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105556:	89 55 f0             	mov    %edx,-0x10(%ebp)
  105559:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10555c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10555f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105566:	0f 85 0c 00 00 00    	jne    105578 <vfs_read+0x38>
  10556c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  105573:	e9 b6 00 00 00       	jmp    10562e <vfs_read+0xee>

    if(!(handle->filemode & FM_READ)) return RW_NOFM_READ;
  105578:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10557b:	8b 40 0c             	mov    0xc(%eax),%eax
  10557e:	25 01 00 00 00       	and    $0x1,%eax
  105583:	3d 00 00 00 00       	cmp    $0x0,%eax
  105588:	0f 85 0c 00 00 00    	jne    10559a <vfs_read+0x5a>
  10558e:	c7 45 f8 04 00 00 00 	movl   $0x4,-0x8(%ebp)
  105595:	e9 94 00 00 00       	jmp    10562e <vfs_read+0xee>

    if(handle->res_type == RES_KERNDRV) {
  10559a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10559d:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  1055a3:	0f 85 7e 00 00 00    	jne    105627 <vfs_read+0xe7>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  1055a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1055ac:	8b 40 04             	mov    0x4(%eax),%eax
  1055af:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rread(handle, dest, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  1055b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1055b5:	8b 40 04             	mov    0x4(%eax),%eax
  1055b8:	8b 00                	mov    (%eax),%eax
  1055ba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1055bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1055c0:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1055c3:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  1055c7:	89 0c 24             	mov    %ecx,(%esp)
  1055ca:	89 54 24 04          	mov    %edx,0x4(%esp)
  1055ce:	89 74 24 08          	mov    %esi,0x8(%esp)
  1055d2:	ff d0                	call   *%eax
  1055d4:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  1055d7:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1055de:	0f 85 1e 00 00 00    	jne    105602 <vfs_read+0xc2>
           handle->position += size * count;
  1055e4:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1055e7:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1055eb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1055ee:	8b 51 08             	mov    0x8(%ecx),%edx
  1055f1:	01 c2                	add    %eax,%edx
  1055f3:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1055f6:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1055fd:	e9 2c 00 00 00       	jmp    10562e <vfs_read+0xee>
       }

       if(res == RW_BLOCK) {
  105602:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  105609:	0f 85 0c 00 00 00    	jne    10561b <vfs_read+0xdb>
           return RW_BLOCK;
  10560f:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  105616:	e9 13 00 00 00       	jmp    10562e <vfs_read+0xee>
       }

       return RW_ERR_DRIVER;
  10561b:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  105622:	e9 07 00 00 00       	jmp    10562e <vfs_read+0xee>
    }

    return RW_ERR_VFS;
  105627:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  10562e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105631:	83 c4 34             	add    $0x34,%esp
  105634:	5e                   	pop    %esi
  105635:	5d                   	pop    %ebp
  105636:	c3                   	ret    
  105637:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10563e:	00 00 

00105640 <vfs_write>:

uint32_t vfs_write(struct res_handle* handle, void* src,  uint32_t size, uint32_t count) {
  105640:	55                   	push   %ebp
  105641:	89 e5                	mov    %esp,%ebp
  105643:	56                   	push   %esi
  105644:	83 ec 34             	sub    $0x34,%esp
  105647:	8b 45 14             	mov    0x14(%ebp),%eax
  10564a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10564d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105650:	8b 75 08             	mov    0x8(%ebp),%esi
  105653:	89 75 f4             	mov    %esi,-0xc(%ebp)
  105656:	89 55 f0             	mov    %edx,-0x10(%ebp)
  105659:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10565c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10565f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  105666:	0f 85 0c 00 00 00    	jne    105678 <vfs_write+0x38>
  10566c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  105673:	e9 b7 00 00 00       	jmp    10572f <vfs_write+0xef>

    if(!(handle->filemode & FM_WRITE)) return RW_NOFM_WRITE;
  105678:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10567b:	8b 40 0c             	mov    0xc(%eax),%eax
  10567e:	25 02 00 00 00       	and    $0x2,%eax
  105683:	3d 00 00 00 00       	cmp    $0x0,%eax
  105688:	0f 85 0c 00 00 00    	jne    10569a <vfs_write+0x5a>
  10568e:	c7 45 f8 05 00 00 00 	movl   $0x5,-0x8(%ebp)
  105695:	e9 95 00 00 00       	jmp    10572f <vfs_write+0xef>

    if(handle->res_type == RES_KERNDRV) {
  10569a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10569d:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  1056a3:	0f 85 7f 00 00 00    	jne    105728 <vfs_write+0xe8>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  1056a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1056ac:	8b 40 04             	mov    0x4(%eax),%eax
  1056af:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rwrite(handle, src, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  1056b2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1056b5:	8b 40 04             	mov    0x4(%eax),%eax
  1056b8:	8b 40 04             	mov    0x4(%eax),%eax
  1056bb:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1056be:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1056c1:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1056c4:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  1056c8:	89 0c 24             	mov    %ecx,(%esp)
  1056cb:	89 54 24 04          	mov    %edx,0x4(%esp)
  1056cf:	89 74 24 08          	mov    %esi,0x8(%esp)
  1056d3:	ff d0                	call   *%eax
  1056d5:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  1056d8:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1056df:	0f 85 1e 00 00 00    	jne    105703 <vfs_write+0xc3>
           handle->position += size * count;
  1056e5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1056e8:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1056ec:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1056ef:	8b 51 08             	mov    0x8(%ecx),%edx
  1056f2:	01 c2                	add    %eax,%edx
  1056f4:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1056f7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1056fe:	e9 2c 00 00 00       	jmp    10572f <vfs_write+0xef>
       }

       if(res == RW_BLOCK) {
  105703:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  10570a:	0f 85 0c 00 00 00    	jne    10571c <vfs_write+0xdc>
           return RW_BLOCK;
  105710:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  105717:	e9 13 00 00 00       	jmp    10572f <vfs_write+0xef>
       }

       return RW_ERR_DRIVER;
  10571c:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  105723:	e9 07 00 00 00       	jmp    10572f <vfs_write+0xef>
    }

    return RW_ERR_VFS;
  105728:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  10572f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105732:	83 c4 34             	add    $0x34,%esp
  105735:	5e                   	pop    %esi
  105736:	5d                   	pop    %ebp
  105737:	c3                   	ret    
  105738:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10573f:	00 

00105740 <vfs_available>:

uint32_t vfs_available(struct res_handle* handle) {
  105740:	55                   	push   %ebp
  105741:	89 e5                	mov    %esp,%ebp
  105743:	83 ec 18             	sub    $0x18,%esp
  105746:	8b 45 08             	mov    0x8(%ebp),%eax
  105749:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle == 0) return 0;
  10574c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  105753:	0f 85 0c 00 00 00    	jne    105765 <vfs_available+0x25>
  105759:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105760:	e9 38 00 00 00       	jmp    10579d <vfs_available+0x5d>

    if(handle->res_type == RES_KERNDRV) {
  105765:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105768:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  10576e:	0f 85 22 00 00 00    	jne    105796 <vfs_available+0x56>
        struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  105774:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105777:	8b 40 04             	mov    0x4(%eax),%eax
  10577a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        return kf->driver->available(handle);
  10577d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105780:	8b 40 04             	mov    0x4(%eax),%eax
  105783:	8b 40 10             	mov    0x10(%eax),%eax
  105786:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105789:	89 0c 24             	mov    %ecx,(%esp)
  10578c:	ff d0                	call   *%eax
  10578e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105791:	e9 07 00 00 00       	jmp    10579d <vfs_available+0x5d>
    }

    return 0;
  105796:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  10579d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1057a0:	83 c4 18             	add    $0x18,%esp
  1057a3:	5d                   	pop    %ebp
  1057a4:	c3                   	ret    
  1057a5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1057ac:	00 00 00 00 

001057b0 <vfs_exists>:

uint32_t vfs_exists(char* path) {
  1057b0:	55                   	push   %ebp
  1057b1:	89 e5                	mov    %esp,%ebp
  1057b3:	83 ec 18             	sub    $0x18,%esp
  1057b6:	8b 45 08             	mov    0x8(%ebp),%eax
  1057b9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(vfs_get_node(path) != 0) return 1;
  1057bc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1057bf:	89 04 24             	mov    %eax,(%esp)
  1057c2:	e8 e9 fb ff ff       	call   1053b0 <vfs_get_node>
  1057c7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1057cc:	0f 84 0c 00 00 00    	je     1057de <vfs_exists+0x2e>
  1057d2:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1057d9:	e9 07 00 00 00       	jmp    1057e5 <vfs_exists+0x35>
    return 0;
  1057de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1057e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1057e8:	83 c4 18             	add    $0x18,%esp
  1057eb:	5d                   	pop    %ebp
  1057ec:	c3                   	ret    
  1057ed:	0f 1f 00             	nopl   (%eax)

001057f0 <vfs_seek>:

void vfs_seek(struct res_handle* handle, uint32_t offset, uint32_t origin) {
  1057f0:	55                   	push   %ebp
  1057f1:	89 e5                	mov    %esp,%ebp
  1057f3:	83 ec 0c             	sub    $0xc,%esp
  1057f6:	8b 45 10             	mov    0x10(%ebp),%eax
  1057f9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1057fc:	8b 55 08             	mov    0x8(%ebp),%edx
  1057ff:	89 55 fc             	mov    %edx,-0x4(%ebp)
  105802:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105805:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(origin == SEEK_SET) {
  105808:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  10580f:	0f 85 09 00 00 00    	jne    10581e <vfs_seek+0x2e>
        handle->position = offset;
  105815:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105818:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10581b:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if(origin == SEEK_CUR) {
  10581e:	81 7d f4 01 00 00 00 	cmpl   $0x1,-0xc(%ebp)
  105825:	0f 85 0e 00 00 00    	jne    105839 <vfs_seek+0x49>
        handle->position += offset;
  10582b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10582e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105831:	8b 51 08             	mov    0x8(%ecx),%edx
  105834:	01 c2                	add    %eax,%edx
  105836:	89 51 08             	mov    %edx,0x8(%ecx)
    }
}
  105839:	83 c4 0c             	add    $0xc,%esp
  10583c:	5d                   	pop    %ebp
  10583d:	c3                   	ret    
  10583e:	66 90                	xchg   %ax,%ax

00105840 <vfs_exec>:

void vfs_exec(char* ip, char* args[], struct task* task) {
  105840:	55                   	push   %ebp
  105841:	89 e5                	mov    %esp,%ebp
  105843:	56                   	push   %esi
  105844:	81 ec c4 00 00 00    	sub    $0xc4,%esp
  10584a:	8b 45 10             	mov    0x10(%ebp),%eax
  10584d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  105850:	8b 55 08             	mov    0x8(%ebp),%edx
  105853:	89 55 f8             	mov    %edx,-0x8(%ebp)
  105856:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  105859:	89 45 f0             	mov    %eax,-0x10(%ebp)
    char* path = strclone(ip);
  10585c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10585f:	89 04 24             	mov    %eax,(%esp)
  105862:	e8 79 f6 ff ff       	call   104ee0 <strclone>
  105867:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if(vfs_exists(path)) {
  10586a:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10586d:	89 04 24             	mov    %eax,(%esp)
  105870:	e8 3b ff ff ff       	call   1057b0 <vfs_exists>
  105875:	3d 00 00 00 00       	cmp    $0x0,%eax
  10587a:	0f 84 b7 04 00 00    	je     105d37 <vfs_exec+0x4f7>
        uint32_t elf_mod_pdir;

        if(task == 0) {
  105880:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105887:	0f 85 35 00 00 00    	jne    1058c2 <vfs_exec+0x82>
            elf_mod_pdir = vmm_create_pagedir();
  10588d:	e8 9e 0c 00 00       	call   106530 <vmm_create_pagedir>
  105892:	b9 01 00 00 00       	mov    $0x1,%ecx
  105897:	89 45 e8             	mov    %eax,-0x18(%ebp)
            task = init_task(elf_mod_pdir, (void*)1);
  10589a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10589d:	89 04 24             	mov    %eax,(%esp)
  1058a0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1058a4:	e8 f7 e9 ff ff       	call   1042a0 <init_task>
  1058a9:	8d 0d 3f 85 10 00    	lea    0x10853f,%ecx
  1058af:	89 45 f0             	mov    %eax,-0x10(%ebp)
            kprintf("[exec] Initialized new task...\n");
  1058b2:	89 0c 24             	mov    %ecx,(%esp)
  1058b5:	e8 f6 a9 ff ff       	call   1002b0 <kprintf>
        }
  1058ba:	89 45 a0             	mov    %eax,-0x60(%ebp)
  1058bd:	e9 1a 00 00 00       	jmp    1058dc <vfs_exec+0x9c>
  1058c2:	8d 05 5f 85 10 00    	lea    0x10855f,%eax
        else
        {
            elf_mod_pdir = task->phys_pdir;
  1058c8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1058cb:	8b 49 14             	mov    0x14(%ecx),%ecx
  1058ce:	89 4d e8             	mov    %ecx,-0x18(%ebp)
            kprintf("[exec] Replacing old task...\n");
  1058d1:	89 04 24             	mov    %eax,(%esp)
  1058d4:	e8 d7 a9 ff ff       	call   1002b0 <kprintf>
  1058d9:	89 45 9c             	mov    %eax,-0x64(%ebp)
        }


        //Copy args into kernel memory
        uint32_t argc = 0;
  1058dc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

        if(args != 0) {
  1058e3:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1058ea:	0f 84 2d 00 00 00    	je     10591d <vfs_exec+0xdd>
            while(args[argc] != 0) {
  1058f0:	e9 00 00 00 00       	jmp    1058f5 <vfs_exec+0xb5>
  1058f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1058f8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1058fb:	81 3c 81 00 00 00 00 	cmpl   $0x0,(%ecx,%eax,4)
  105902:	0f 84 10 00 00 00    	je     105918 <vfs_exec+0xd8>
                argc++;
  105908:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10590b:	05 01 00 00 00       	add    $0x1,%eax
  105910:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            }
  105913:	e9 dd ff ff ff       	jmp    1058f5 <vfs_exec+0xb5>
        }
  105918:	e9 00 00 00 00       	jmp    10591d <vfs_exec+0xdd>

        char** kargs = malloc((sizeof(char*)) * (argc + 1));
  10591d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105920:	05 01 00 00 00       	add    $0x1,%eax
  105925:	c1 e0 02             	shl    $0x2,%eax
  105928:	89 04 24             	mov    %eax,(%esp)
  10592b:	e8 40 ec ff ff       	call   104570 <malloc>
  105930:	89 45 e0             	mov    %eax,-0x20(%ebp)

        for(uint32_t i = 0; i < argc; i++) {
  105933:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  10593a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10593d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  105940:	0f 83 7e 00 00 00    	jae    1059c4 <vfs_exec+0x184>
            kargs[i] = malloc(strlen(args[i]) + 1);
  105946:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105949:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10594c:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10594f:	89 e1                	mov    %esp,%ecx
  105951:	89 01                	mov    %eax,(%ecx)
  105953:	e8 b8 f4 ff ff       	call   104e10 <strlen>
  105958:	05 01 00 00 00       	add    $0x1,%eax
  10595d:	89 04 24             	mov    %eax,(%esp)
  105960:	e8 0b ec ff ff       	call   104570 <malloc>
  105965:	8d 0d 7d 85 10 00    	lea    0x10857d,%ecx
  10596b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10596e:	8b 75 e0             	mov    -0x20(%ebp),%esi
  105971:	89 04 96             	mov    %eax,(%esi,%edx,4)
            kprintf("Copying arg %d = %s\n", i, args[i]);
  105974:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105977:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10597a:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10597d:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105980:	89 0c 24             	mov    %ecx,(%esp)
  105983:	89 44 24 04          	mov    %eax,0x4(%esp)
  105987:	89 54 24 08          	mov    %edx,0x8(%esp)
  10598b:	e8 20 a9 ff ff       	call   1002b0 <kprintf>
            strcpy(kargs[i], args[i]);
  105990:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  105993:	8b 55 e0             	mov    -0x20(%ebp),%edx
  105996:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105999:	8b 55 dc             	mov    -0x24(%ebp),%edx
  10599c:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10599f:	8b 14 96             	mov    (%esi,%edx,4),%edx
  1059a2:	89 e6                	mov    %esp,%esi
  1059a4:	89 56 04             	mov    %edx,0x4(%esi)
  1059a7:	89 0e                	mov    %ecx,(%esi)
  1059a9:	89 45 98             	mov    %eax,-0x68(%ebp)
  1059ac:	e8 cf f4 ff ff       	call   104e80 <strcpy>
  1059b1:	89 45 94             	mov    %eax,-0x6c(%ebp)
            }
        }

        char** kargs = malloc((sizeof(char*)) * (argc + 1));

        for(uint32_t i = 0; i < argc; i++) {
  1059b4:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1059b7:	05 01 00 00 00       	add    $0x1,%eax
  1059bc:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1059bf:	e9 76 ff ff ff       	jmp    10593a <vfs_exec+0xfa>
  1059c4:	b8 05 00 00 00       	mov    $0x5,%eax
            kargs[i] = malloc(strlen(args[i]) + 1);
            kprintf("Copying arg %d = %s\n", i, args[i]);
            strcpy(kargs[i], args[i]);
        }

        kargs[argc] = 0;
  1059c9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1059cc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  1059cf:	c7 04 8a 00 00 00 00 	movl   $0x0,(%edx,%ecx,4)

        //Execute file
        struct res_handle* handle = vfs_open(path, FM_EXEC | FM_READ);
  1059d6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1059d9:	89 0c 24             	mov    %ecx,(%esp)
  1059dc:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
  1059e3:	00 
  1059e4:	89 45 90             	mov    %eax,-0x70(%ebp)
  1059e7:	e8 84 fa ff ff       	call   105470 <vfs_open>
  1059ec:	89 45 d8             	mov    %eax,-0x28(%ebp)

        if(handle) {
  1059ef:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  1059f6:	0f 84 1b 03 00 00    	je     105d17 <vfs_exec+0x4d7>
            uint32_t size = vfs_available(handle);
  1059fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1059ff:	89 04 24             	mov    %eax,(%esp)
  105a02:	e8 39 fd ff ff       	call   105740 <vfs_available>
  105a07:	89 45 d4             	mov    %eax,-0x2c(%ebp)
            if(size == 0) {
  105a0a:	81 7d d4 00 00 00 00 	cmpl   $0x0,-0x2c(%ebp)
  105a11:	0f 85 1d 00 00 00    	jne    105a34 <vfs_exec+0x1f4>
  105a17:	8d 05 92 85 10 00    	lea    0x108592,%eax
                kprintf("[exec] %s is empty\n", path);
  105a1d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105a20:	89 04 24             	mov    %eax,(%esp)
  105a23:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105a27:	e8 84 a8 ff ff       	call   1002b0 <kprintf>
                return;
  105a2c:	89 45 8c             	mov    %eax,-0x74(%ebp)
  105a2f:	e9 03 03 00 00       	jmp    105d37 <vfs_exec+0x4f7>
            }

            void* modsrc = malloc(size);
  105a34:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  105a37:	89 04 24             	mov    %eax,(%esp)
  105a3a:	e8 31 eb ff ff       	call   104570 <malloc>
  105a3f:	b9 01 00 00 00       	mov    $0x1,%ecx
  105a44:	89 45 d0             	mov    %eax,-0x30(%ebp)

            uint32_t res = vfs_read(handle, modsrc, size, 1);
  105a47:	8b 45 d8             	mov    -0x28(%ebp),%eax
  105a4a:	8b 55 d0             	mov    -0x30(%ebp),%edx
  105a4d:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  105a50:	89 04 24             	mov    %eax,(%esp)
  105a53:	89 54 24 04          	mov    %edx,0x4(%esp)
  105a57:	89 74 24 08          	mov    %esi,0x8(%esp)
  105a5b:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105a62:	00 
  105a63:	89 4d 88             	mov    %ecx,-0x78(%ebp)
  105a66:	e8 d5 fa ff ff       	call   105540 <vfs_read>
  105a6b:	89 45 cc             	mov    %eax,-0x34(%ebp)

            if(res != RW_OK) {
  105a6e:	81 7d cc 00 00 00 00 	cmpl   $0x0,-0x34(%ebp)
  105a75:	0f 84 21 00 00 00    	je     105a9c <vfs_exec+0x25c>
  105a7b:	8d 05 a6 85 10 00    	lea    0x1085a6,%eax
                kprintf("[exec] Error while reading %s\n");
  105a81:	89 04 24             	mov    %eax,(%esp)
  105a84:	e8 27 a8 ff ff       	call   1002b0 <kprintf>
                free(modsrc);
  105a89:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  105a8c:	89 0c 24             	mov    %ecx,(%esp)
  105a8f:	89 45 84             	mov    %eax,-0x7c(%ebp)
  105a92:	e8 a9 ee ff ff       	call   104940 <free>
                return;
  105a97:	e9 9b 02 00 00       	jmp    105d37 <vfs_exec+0x4f7>
            }

            uint32_t old_pdir = vmm_get_current_pagedir();
  105a9c:	e8 2f 05 00 00       	call   105fd0 <vmm_get_current_pagedir>
  105aa1:	89 45 c8             	mov    %eax,-0x38(%ebp)

            //**********************************************************************************************************
            if(task != get_current_task())  vmm_activate_pagedir(elf_mod_pdir);
  105aa4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105aa7:	89 45 80             	mov    %eax,-0x80(%ebp)
  105aaa:	e8 11 e4 ff ff       	call   103ec0 <get_current_task>
  105aaf:	8b 4d 80             	mov    -0x80(%ebp),%ecx
  105ab2:	39 c1                	cmp    %eax,%ecx
  105ab4:	0f 84 0b 00 00 00    	je     105ac5 <vfs_exec+0x285>
  105aba:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105abd:	89 04 24             	mov    %eax,(%esp)
  105ac0:	e8 4b 10 00 00       	call   106b10 <vmm_activate_pagedir>

            struct elf_header* header = modsrc;
  105ac5:	8b 45 d0             	mov    -0x30(%ebp),%eax
  105ac8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
            struct elf_program_header* ph;

            /* Ist es ueberhaupt eine ELF-Datei? */
            if (header->magic != ELF_MAGIC) {
  105acb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  105ace:	81 38 7f 45 4c 46    	cmpl   $0x464c457f,(%eax)
  105ad4:	0f 84 2b 00 00 00    	je     105b05 <vfs_exec+0x2c5>
  105ada:	8d 05 c5 85 10 00    	lea    0x1085c5,%eax
                kprintf("[exec] Invalid ELF-Magic in %s!\n", path);
  105ae0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105ae3:	89 04 24             	mov    %eax,(%esp)
  105ae6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105aea:	e8 c1 a7 ff ff       	call   1002b0 <kprintf>
                free(modsrc);
  105aef:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  105af2:	89 0c 24             	mov    %ecx,(%esp)
  105af5:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
  105afb:	e8 40 ee ff ff       	call   104940 <free>
                return;
  105b00:	e9 32 02 00 00       	jmp    105d37 <vfs_exec+0x4f7>
            }

            void* elf_mod_entry = (void*) (header->entry);
  105b05:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  105b08:	8b 40 18             	mov    0x18(%eax),%eax
  105b0b:	89 45 bc             	mov    %eax,-0x44(%ebp)

            ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);
  105b0e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  105b11:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  105b14:	03 41 1c             	add    0x1c(%ecx),%eax
  105b17:	89 45 c0             	mov    %eax,-0x40(%ebp)

            for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  105b1a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  105b21:	8b 45 b8             	mov    -0x48(%ebp),%eax
  105b24:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  105b27:	0f b7 49 2c          	movzwl 0x2c(%ecx),%ecx
  105b2b:	39 c8                	cmp    %ecx,%eax
  105b2d:	0f 83 bb 00 00 00    	jae    105bee <vfs_exec+0x3ae>
                void* dest = (void*) ph->virt_addr;
  105b33:	8b 45 c0             	mov    -0x40(%ebp),%eax
  105b36:	8b 40 08             	mov    0x8(%eax),%eax
  105b39:	89 45 b4             	mov    %eax,-0x4c(%ebp)
                void* src = ((char*) header) + ph->offset;
  105b3c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  105b3f:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  105b42:	03 41 04             	add    0x4(%ecx),%eax
  105b45:	89 45 b0             	mov    %eax,-0x50(%ebp)

                /* Nur Program Header vom Typ LOAD laden */
                if (ph->type != 1) {
  105b48:	8b 45 c0             	mov    -0x40(%ebp),%eax
  105b4b:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  105b51:	0f 84 05 00 00 00    	je     105b5c <vfs_exec+0x31c>
                    continue;
  105b57:	e9 77 00 00 00       	jmp    105bd3 <vfs_exec+0x393>
                }

                for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  105b5c:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
  105b63:	8b 45 ac             	mov    -0x54(%ebp),%eax
  105b66:	8b 4d c0             	mov    -0x40(%ebp),%ecx
  105b69:	3b 41 14             	cmp    0x14(%ecx),%eax
  105b6c:	0f 83 45 00 00 00    	jae    105bb7 <vfs_exec+0x377>
                    vmm_free(dest + offset);
  105b72:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  105b75:	03 45 ac             	add    -0x54(%ebp),%eax
  105b78:	89 04 24             	mov    %eax,(%esp)
  105b7b:	e8 20 0b 00 00       	call   1066a0 <vmm_free>
  105b80:	b8 00 00 00 00       	mov    $0x0,%eax
                    vmm_alloc_addr(dest + offset, 0);
  105b85:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
  105b88:	03 4d ac             	add    -0x54(%ebp),%ecx
  105b8b:	89 0c 24             	mov    %ecx,(%esp)
  105b8e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  105b95:	00 
  105b96:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
  105b9c:	e8 6f 0e 00 00       	call   106a10 <vmm_alloc_addr>
  105ba1:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
                /* Nur Program Header vom Typ LOAD laden */
                if (ph->type != 1) {
                    continue;
                }

                for (uint32_t offset = 0; offset < ph->mem_size; offset += 0x1000) {
  105ba7:	8b 45 ac             	mov    -0x54(%ebp),%eax
  105baa:	05 00 10 00 00       	add    $0x1000,%eax
  105baf:	89 45 ac             	mov    %eax,-0x54(%ebp)
  105bb2:	e9 ac ff ff ff       	jmp    105b63 <vfs_exec+0x323>
                    vmm_free(dest + offset);
                    vmm_alloc_addr(dest + offset, 0);
                }

                memcpy(dest, src, ph->file_size);
  105bb7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  105bba:	8b 4d b0             	mov    -0x50(%ebp),%ecx
  105bbd:	8b 55 c0             	mov    -0x40(%ebp),%edx
  105bc0:	8b 52 10             	mov    0x10(%edx),%edx
  105bc3:	89 04 24             	mov    %eax,(%esp)
  105bc6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105bca:	89 54 24 08          	mov    %edx,0x8(%esp)
  105bce:	e8 6d f0 ff ff       	call   104c40 <memcpy>

            void* elf_mod_entry = (void*) (header->entry);

            ph = (struct elf_program_header*) (((char*) header) + header->ph_offset);

            for (uint32_t n = 0; n < header->ph_entry_count; n++, ph++) {
  105bd3:	8b 45 b8             	mov    -0x48(%ebp),%eax
  105bd6:	05 01 00 00 00       	add    $0x1,%eax
  105bdb:	89 45 b8             	mov    %eax,-0x48(%ebp)
  105bde:	8b 45 c0             	mov    -0x40(%ebp),%eax
  105be1:	05 20 00 00 00       	add    $0x20,%eax
  105be6:	89 45 c0             	mov    %eax,-0x40(%ebp)
  105be9:	e9 33 ff ff ff       	jmp    105b21 <vfs_exec+0x2e1>
  105bee:	b8 01 00 00 00       	mov    $0x1,%eax
                    vmm_alloc_addr(dest + offset, 0);
                }

                memcpy(dest, src, ph->file_size);
            }
            task->cpuState->eip = (uint32_t) elf_mod_entry;
  105bf3:	8b 4d bc             	mov    -0x44(%ebp),%ecx
  105bf6:	8b 55 f0             	mov    -0x10(%ebp),%edx
  105bf9:	8b 52 04             	mov    0x4(%edx),%edx
  105bfc:	89 4a 24             	mov    %ecx,0x24(%edx)

            //Copy args into new task
            char** usargs = vmm_alloc_ucont(1);
  105bff:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  105c06:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
  105c0c:	e8 1f 0c 00 00       	call   106830 <vmm_alloc_ucont>
  105c11:	89 45 a8             	mov    %eax,-0x58(%ebp)

            for(uint32_t i = 0; i < argc; i++) {
  105c14:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
  105c1b:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  105c1e:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
  105c21:	0f 83 88 00 00 00    	jae    105caf <vfs_exec+0x46f>
  105c27:	b8 01 00 00 00       	mov    $0x1,%eax
                usargs[i] = vmm_alloc_ucont(1); //FIXME will fail on strings > 4095 chars or more than 1023 arguments
  105c2c:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  105c33:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)
  105c39:	e8 f2 0b 00 00       	call   106830 <vmm_alloc_ucont>
  105c3e:	8d 0d 7d 85 10 00    	lea    0x10857d,%ecx
  105c44:	8b 55 a4             	mov    -0x5c(%ebp),%edx
  105c47:	8b 75 a8             	mov    -0x58(%ebp),%esi
  105c4a:	89 04 96             	mov    %eax,(%esi,%edx,4)
                strcpy(usargs[i], kargs[i]);
  105c4d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  105c50:	8b 55 a8             	mov    -0x58(%ebp),%edx
  105c53:	8b 04 82             	mov    (%edx,%eax,4),%eax
  105c56:	8b 55 a4             	mov    -0x5c(%ebp),%edx
  105c59:	8b 75 e0             	mov    -0x20(%ebp),%esi
  105c5c:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105c5f:	89 e6                	mov    %esp,%esi
  105c61:	89 56 04             	mov    %edx,0x4(%esi)
  105c64:	89 06                	mov    %eax,(%esi)
  105c66:	89 8d 68 ff ff ff    	mov    %ecx,-0x98(%ebp)
  105c6c:	e8 0f f2 ff ff       	call   104e80 <strcpy>
                kprintf("Copying arg %d = %s\n", i, kargs[i]);
  105c71:	8b 4d a4             	mov    -0x5c(%ebp),%ecx
  105c74:	8b 55 a4             	mov    -0x5c(%ebp),%edx
  105c77:	8b 75 e0             	mov    -0x20(%ebp),%esi
  105c7a:	8b 14 96             	mov    (%esi,%edx,4),%edx
  105c7d:	8b b5 68 ff ff ff    	mov    -0x98(%ebp),%esi
  105c83:	89 34 24             	mov    %esi,(%esp)
  105c86:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105c8a:	89 54 24 08          	mov    %edx,0x8(%esp)
  105c8e:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
  105c94:	e8 17 a6 ff ff       	call   1002b0 <kprintf>
  105c99:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
            task->cpuState->eip = (uint32_t) elf_mod_entry;

            //Copy args into new task
            char** usargs = vmm_alloc_ucont(1);

            for(uint32_t i = 0; i < argc; i++) {
  105c9f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
  105ca2:	05 01 00 00 00       	add    $0x1,%eax
  105ca7:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  105caa:	e9 6c ff ff ff       	jmp    105c1b <vfs_exec+0x3db>
                usargs[i] = vmm_alloc_ucont(1); //FIXME will fail on strings > 4095 chars or more than 1023 arguments
                strcpy(usargs[i], kargs[i]);
                kprintf("Copying arg %d = %s\n", i, kargs[i]);
            }

            usargs[argc] = 0;
  105caf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105cb2:	8b 4d a8             	mov    -0x58(%ebp),%ecx
  105cb5:	c7 04 81 00 00 00 00 	movl   $0x0,(%ecx,%eax,4)

            task->args = usargs;
  105cbc:	8b 45 a8             	mov    -0x58(%ebp),%eax
  105cbf:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105cc2:	89 41 18             	mov    %eax,0x18(%ecx)

            if(task != get_current_task()) vmm_activate_pagedir(old_pdir);
  105cc5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105cc8:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  105cce:	e8 ed e1 ff ff       	call   103ec0 <get_current_task>
  105cd3:	8b 8d 5c ff ff ff    	mov    -0xa4(%ebp),%ecx
  105cd9:	39 c1                	cmp    %eax,%ecx
  105cdb:	0f 84 0b 00 00 00    	je     105cec <vfs_exec+0x4ac>
  105ce1:	8b 45 c8             	mov    -0x38(%ebp),%eax
  105ce4:	89 04 24             	mov    %eax,(%esp)
  105ce7:	e8 24 0e 00 00       	call   106b10 <vmm_activate_pagedir>
  105cec:	8d 05 e6 85 10 00    	lea    0x1085e6,%eax

            kprintf("[exec] Executed %s\n", path);
  105cf2:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105cf5:	89 04 24             	mov    %eax,(%esp)
  105cf8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105cfc:	e8 af a5 ff ff       	call   1002b0 <kprintf>
            free(modsrc);
  105d01:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  105d04:	89 0c 24             	mov    %ecx,(%esp)
  105d07:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
  105d0d:	e8 2e ec ff ff       	call   104940 <free>
        }
  105d12:	e9 1b 00 00 00       	jmp    105d32 <vfs_exec+0x4f2>
  105d17:	8d 05 fa 85 10 00    	lea    0x1085fa,%eax
        else
        {
            kprintf("[exec] %s doesn't exist\n", path);
  105d1d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105d20:	89 04 24             	mov    %eax,(%esp)
  105d23:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105d27:	e8 84 a5 ff ff       	call   1002b0 <kprintf>
  105d2c:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
        }
    }
  105d32:	e9 00 00 00 00       	jmp    105d37 <vfs_exec+0x4f7>
}
  105d37:	81 c4 c4 00 00 00    	add    $0xc4,%esp
  105d3d:	5e                   	pop    %esi
  105d3e:	5d                   	pop    %ebp
  105d3f:	c3                   	ret    

00105d40 <vfs_init_root>:

void vfs_init_root() {
  105d40:	55                   	push   %ebp
  105d41:	89 e5                	mov    %esp,%ebp
    if(root == 0) {
  105d43:	83 ec 18             	sub    $0x18,%esp
  105d46:	81 3d 4c 94 10 00 00 	cmpl   $0x0,0x10944c
  105d4d:	00 00 00 
  105d50:	0f 85 6f 00 00 00    	jne    105dc5 <vfs_init_root+0x85>
  105d56:	b8 10 01 00 00       	mov    $0x110,%eax
        root = malloc(sizeof(struct res_node));
  105d5b:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  105d62:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105d65:	e8 06 e8 ff ff       	call   104570 <malloc>
  105d6a:	a3 4c 94 10 00       	mov    %eax,0x10944c
        root->next = 0;
  105d6f:	a1 4c 94 10 00       	mov    0x10944c,%eax
  105d74:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  105d7b:	00 00 00 
        root->parent = 0;
  105d7e:	a1 4c 94 10 00       	mov    0x10944c,%eax
  105d83:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  105d8a:	00 00 00 
        strcpy(root->name, "$");
  105d8d:	a1 4c 94 10 00       	mov    0x10944c,%eax
  105d92:	89 e1                	mov    %esp,%ecx
  105d94:	89 01                	mov    %eax,(%ecx)
  105d96:	c7 41 04 13 86 10 00 	movl   $0x108613,0x4(%ecx)
  105d9d:	e8 de f0 ff ff       	call   104e80 <strcpy>
        root->res_ptr = 0;
  105da2:	8b 0d 4c 94 10 00    	mov    0x10944c,%ecx
  105da8:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  105daf:	00 00 00 
        root->res_type = RES_SUBDIR;
  105db2:	8b 0d 4c 94 10 00    	mov    0x10944c,%ecx
  105db8:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  105dbf:	00 00 00 
  105dc2:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  105dc5:	83 c4 18             	add    $0x18,%esp
  105dc8:	5d                   	pop    %ebp
  105dc9:	c3                   	ret    
  105dca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105dd0 <vfs_debug_ls>:

void vfs_debug_ls(char* path) {
  105dd0:	55                   	push   %ebp
  105dd1:	89 e5                	mov    %esp,%ebp
  105dd3:	56                   	push   %esi
  105dd4:	83 ec 24             	sub    $0x24,%esp
  105dd7:	8b 45 08             	mov    0x8(%ebp),%eax
  105dda:	89 45 f8             	mov    %eax,-0x8(%ebp)
    static struct res_node* node;
    node = vfs_get_node(path);
  105ddd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105de0:	89 04 24             	mov    %eax,(%esp)
  105de3:	e8 c8 f5 ff ff       	call   1053b0 <vfs_get_node>
  105de8:	a3 60 94 10 00       	mov    %eax,0x109460
    node = node->res_ptr;
  105ded:	a1 60 94 10 00       	mov    0x109460,%eax
  105df2:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105df8:	a3 60 94 10 00       	mov    %eax,0x109460

    while(node != 0) {
  105dfd:	81 3d 60 94 10 00 00 	cmpl   $0x0,0x109460
  105e04:	00 00 00 
  105e07:	0f 84 90 00 00 00    	je     105e9d <vfs_debug_ls+0xcd>
  105e0d:	8d 05 15 86 10 00    	lea    0x108615,%eax
        char* type = "N/A";
  105e13:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(node->res_type == RES_SUBDIR) {
  105e16:	a1 60 94 10 00       	mov    0x109460,%eax
  105e1b:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  105e22:	00 00 00 
  105e25:	0f 85 09 00 00 00    	jne    105e34 <vfs_debug_ls+0x64>
  105e2b:	8d 05 19 86 10 00    	lea    0x108619,%eax
            type = "DIR";
  105e31:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        if(node->res_type == RES_KERNDRV) {
  105e34:	a1 60 94 10 00       	mov    0x109460,%eax
  105e39:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  105e40:	00 00 00 
  105e43:	0f 85 14 00 00 00    	jne    105e5d <vfs_debug_ls+0x8d>
            type = ((struct res_kfile*)node->res_ptr)->driver->drvname;
  105e49:	a1 60 94 10 00       	mov    0x109460,%eax
  105e4e:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105e54:	8b 40 04             	mov    0x4(%eax),%eax
  105e57:	8b 40 18             	mov    0x18(%eax),%eax
  105e5a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  105e5d:	8d 05 1d 86 10 00    	lea    0x10861d,%eax
        }

        kprintf("LS %s: %s [%s]\n", path, node->name, type);
  105e63:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105e66:	8b 15 60 94 10 00    	mov    0x109460,%edx
  105e6c:	8b 75 f4             	mov    -0xc(%ebp),%esi
  105e6f:	89 04 24             	mov    %eax,(%esp)
  105e72:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105e76:	89 54 24 08          	mov    %edx,0x8(%esp)
  105e7a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  105e7e:	e8 2d a4 ff ff       	call   1002b0 <kprintf>

        node = node->next;
  105e83:	8b 0d 60 94 10 00    	mov    0x109460,%ecx
  105e89:	8b 89 08 01 00 00    	mov    0x108(%ecx),%ecx
  105e8f:	89 0d 60 94 10 00    	mov    %ecx,0x109460
    }
  105e95:	89 45 f0             	mov    %eax,-0x10(%ebp)
  105e98:	e9 60 ff ff ff       	jmp    105dfd <vfs_debug_ls+0x2d>
}
  105e9d:	83 c4 24             	add    $0x24,%esp
  105ea0:	5e                   	pop    %esi
  105ea1:	5d                   	pop    %ebp
  105ea2:	c3                   	ret    
  105ea3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  105eaa:	84 00 00 00 00 00 

00105eb0 <vfs_find_node>:

struct res_node* root = 0;
struct res_node* current = 0;
struct res_node* temp = 0;

static struct res_node* vfs_find_node(struct res_node* parent, char* name) {
  105eb0:	55                   	push   %ebp
  105eb1:	89 e5                	mov    %esp,%ebp
  105eb3:	83 ec 18             	sub    $0x18,%esp
  105eb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  105eb9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105ebc:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105ebf:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_type == RES_SUBDIR) {
  105ec2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ec5:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  105ecc:	00 00 00 
  105ecf:	0f 85 57 00 00 00    	jne    105f2c <vfs_find_node+0x7c>
        struct res_node* ptr = parent->res_ptr;
  105ed5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105ed8:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105ede:	89 45 f0             	mov    %eax,-0x10(%ebp)

        while(ptr != 0) {
  105ee1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  105ee8:	0f 84 39 00 00 00    	je     105f27 <vfs_find_node+0x77>
            if(strcmp(name, ptr->name) == 0) {
  105eee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105ef1:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105ef4:	89 e2                	mov    %esp,%edx
  105ef6:	89 4a 04             	mov    %ecx,0x4(%edx)
  105ef9:	89 02                	mov    %eax,(%edx)
  105efb:	e8 90 ee ff ff       	call   104d90 <strcmp>
  105f00:	3d 00 00 00 00       	cmp    $0x0,%eax
  105f05:	0f 85 0b 00 00 00    	jne    105f16 <vfs_find_node+0x66>
                return ptr;
  105f0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105f0e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  105f11:	e9 1d 00 00 00       	jmp    105f33 <vfs_find_node+0x83>
            }

            ptr = ptr->next;
  105f16:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105f19:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  105f1f:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
  105f22:	e9 ba ff ff ff       	jmp    105ee1 <vfs_find_node+0x31>
    }
  105f27:	e9 00 00 00 00       	jmp    105f2c <vfs_find_node+0x7c>

    return 0;
  105f2c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  105f33:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105f36:	83 c4 18             	add    $0x18,%esp
  105f39:	5d                   	pop    %ebp
  105f3a:	c3                   	ret    
  105f3b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105f40 <vfs_insert_node>:

static int vfs_insert_node(struct res_node* parent, struct res_node* child) {
  105f40:	55                   	push   %ebp
  105f41:	89 e5                	mov    %esp,%ebp
  105f43:	83 ec 0c             	sub    $0xc,%esp
  105f46:	8b 45 0c             	mov    0xc(%ebp),%eax
  105f49:	8b 4d 08             	mov    0x8(%ebp),%ecx
  105f4c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  105f4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_ptr == 0) {
  105f52:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f55:	81 b8 04 01 00 00 00 	cmpl   $0x0,0x104(%eax)
  105f5c:	00 00 00 
  105f5f:	0f 85 0d 00 00 00    	jne    105f72 <vfs_insert_node+0x32>
        parent->res_type = RES_SUBDIR;
  105f65:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f68:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  105f6f:	00 00 00 
    }

    if(parent->res_type == RES_SUBDIR) {
  105f72:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f75:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  105f7c:	00 00 00 
  105f7f:	0f 85 36 00 00 00    	jne    105fbb <vfs_insert_node+0x7b>
        child->next = parent->res_ptr;
  105f85:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f88:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  105f8e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105f91:	89 81 08 01 00 00    	mov    %eax,0x108(%ecx)
        child->parent = parent;
  105f97:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105f9a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  105f9d:	89 81 0c 01 00 00    	mov    %eax,0x10c(%ecx)
        parent->res_ptr = child;
  105fa3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105fa6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  105fa9:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)

        return 0;
  105faf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  105fb6:	e9 07 00 00 00       	jmp    105fc2 <vfs_insert_node+0x82>
    }

    return 1;
  105fbb:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
}
  105fc2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  105fc5:	83 c4 0c             	add    $0xc,%esp
  105fc8:	5d                   	pop    %ebp
  105fc9:	c3                   	ret    
  105fca:	66 90                	xchg   %ax,%ax
  105fcc:	66 90                	xchg   %ax,%ax
  105fce:	66 90                	xchg   %ax,%ax

00105fd0 <vmm_get_current_pagedir>:
	}

	vmm_unmap(pagedir_ptr);
}

uint32_t vmm_get_current_pagedir(void) {
  105fd0:	55                   	push   %ebp
  105fd1:	89 e5                	mov    %esp,%ebp
	return active_pagedir;
  105fd3:	a1 64 94 10 00       	mov    0x109464,%eax
  105fd8:	5d                   	pop    %ebp
  105fd9:	c3                   	ret    
  105fda:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00105fe0 <vmm_fork_current>:
}

uint32_t vmm_fork_current(void) {
  105fe0:	55                   	push   %ebp
  105fe1:	89 e5                	mov    %esp,%ebp
  105fe3:	56                   	push   %esi
  105fe4:	83 ec 34             	sub    $0x34,%esp
  105fe7:	8d 45 f8             	lea    -0x8(%ebp),%eax
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  105fea:	89 04 24             	mov    %eax,(%esp)
  105fed:	e8 ce 00 00 00       	call   1060c0 <vmm_create_vpdraw>
  105ff2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  105ff5:	c7 45 f0 00 10 40 20 	movl   $0x20401000,-0x10(%ebp)
  105ffc:	81 7d f0 00 f0 ff ff 	cmpl   $0xfffff000,-0x10(%ebp)
  106003:	0f 83 98 00 00 00    	jae    1060a1 <vmm_fork_current+0xc1>
		if (active_pagetables[i >> 12] & PT_PRESENT) {
  106009:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10600c:	c1 e8 0c             	shr    $0xc,%eax
  10600f:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  106015:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106018:	25 01 00 00 00       	and    $0x1,%eax
  10601d:	3d 00 00 00 00       	cmp    $0x0,%eax
  106022:	0f 84 64 00 00 00    	je     10608c <vmm_fork_current+0xac>
  106028:	8d 45 f4             	lea    -0xc(%ebp),%eax
			void* newp = vmm_alloc_user(&paddr);
  10602b:	89 04 24             	mov    %eax,(%esp)
  10602e:	e8 4d 03 00 00       	call   106380 <vmm_alloc_user>
  106033:	b9 00 00 00 00       	mov    $0x0,%ecx
  106038:	ba 00 10 00 00       	mov    $0x1000,%edx
  10603d:	89 45 e8             	mov    %eax,-0x18(%ebp)

			memcpy(newp, (void*) i, 0x1000);
  106040:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106043:	8b 75 f0             	mov    -0x10(%ebp),%esi
  106046:	89 04 24             	mov    %eax,(%esp)
  106049:	89 74 24 04          	mov    %esi,0x4(%esp)
  10604d:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  106054:	00 
  106055:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  106058:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10605b:	e8 e0 eb ff ff       	call   104c40 <memcpy>
			map_address_context(pdptr, i, paddr, 0);
  106060:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106063:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106066:	8b 55 f4             	mov    -0xc(%ebp),%edx
  106069:	89 04 24             	mov    %eax,(%esp)
  10606c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106070:	89 54 24 08          	mov    %edx,0x8(%esp)
  106074:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10607b:	00 
  10607c:	e8 4f 03 00 00       	call   1063d0 <map_address_context>

			vmm_unmap(newp);
  106081:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106084:	89 04 24             	mov    %eax,(%esp)
  106087:	e8 d4 03 00 00       	call   106460 <vmm_unmap>
		}

	}
  10608c:	e9 00 00 00 00       	jmp    106091 <vmm_fork_current+0xb1>

uint32_t vmm_fork_current(void) {
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  106091:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106094:	05 00 10 00 00       	add    $0x1000,%eax
  106099:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10609c:	e9 5b ff ff ff       	jmp    105ffc <vmm_fork_current+0x1c>
			vmm_unmap(newp);
		}

	}

	vmm_free_pdptr(pdptr);
  1060a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1060a4:	89 04 24             	mov    %eax,(%esp)
  1060a7:	e8 24 04 00 00       	call   1064d0 <vmm_free_pdptr>

	return phys_pagedir;
  1060ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1060af:	83 c4 34             	add    $0x34,%esp
  1060b2:	5e                   	pop    %esi
  1060b3:	5d                   	pop    %ebp
  1060b4:	c3                   	ret    
  1060b5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1060bc:	00 00 00 00 

001060c0 <vmm_create_vpdraw>:
uint32_t* active_pagetables = (uint32_t*) (ACTIVE_PAGETBL_VADDR);
struct vmm_context* active_context = (void*) (ACTIVE_CONTEXT_VADDR);

uint32_t active_pagedir = 0;

static uint32_t* vmm_create_vpdraw(uint32_t* pagedir) {
  1060c0:	55                   	push   %ebp
  1060c1:	89 e5                	mov    %esp,%ebp
  1060c3:	53                   	push   %ebx
  1060c4:	57                   	push   %edi
  1060c5:	56                   	push   %esi
  1060c6:	83 ec 4c             	sub    $0x4c,%esp
  1060c9:	8b 45 08             	mov    0x8(%ebp),%eax
  1060cc:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  1060cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t phys_context = 0;
  1060d2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct vmm_context* context = vmm_alloc(&phys_context);
  1060d9:	89 0c 24             	mov    %ecx,(%esp)
  1060dc:	e8 6f 05 00 00       	call   106650 <vmm_alloc>
  1060e1:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  1060e4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32_t phys_pagedir = 0;
  1060e7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	context->pagedir = vmm_alloc(&phys_pagedir);
  1060ee:	89 0c 24             	mov    %ecx,(%esp)
  1060f1:	e8 5a 05 00 00       	call   106650 <vmm_alloc>
  1060f6:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1060f9:	89 01                	mov    %eax,(%ecx)
	if (pagedir != 0)
  1060fb:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  106102:	0f 84 08 00 00 00    	je     106110 <vmm_create_vpdraw+0x50>
		*pagedir = phys_pagedir;
  106108:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10610b:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10610e:	89 01                	mov    %eax,(%ecx)
  106110:	b8 00 00 00 00       	mov    $0x0,%eax

	uint32_t* pagedir_ptr = vmm_alloc(0);
  106115:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  10611c:	89 45 c8             	mov    %eax,-0x38(%ebp)
  10611f:	e8 2c 05 00 00       	call   106650 <vmm_alloc>
  106124:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  106127:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  10612e:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  106135:	0f 83 25 01 00 00    	jae    106260 <vmm_create_vpdraw+0x1a0>
  10613b:	8d 45 dc             	lea    -0x24(%ebp),%eax
		pagedir_ptr[i] = (uint32_t) vmm_alloc(&paddr);
  10613e:	89 04 24             	mov    %eax,(%esp)
  106141:	e8 0a 05 00 00       	call   106650 <vmm_alloc>
  106146:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  106149:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10614c:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i < PMEM_TABLES) {
  10614f:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  106156:	0f 83 4d 00 00 00    	jae    1061a9 <vmm_create_vpdraw+0xe9>
			vmm_free((void*) (pagedir_ptr[i]));
  10615c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10615f:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  106162:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106165:	89 04 24             	mov    %eax,(%esp)
  106168:	e8 33 05 00 00       	call   1066a0 <vmm_free>
  10616d:	b8 00 00 00 00       	mov    $0x0,%eax
			map_address_active(pagedir_ptr[i], kernel_pagetables[i], 0); //Can reuse pagedir_ptr[i] cause of vmm_free
  106172:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  106175:	8b 55 e0             	mov    -0x20(%ebp),%edx
  106178:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  10617b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  10617e:	8b 14 95 98 98 18 00 	mov    0x189898(,%edx,4),%edx
  106185:	89 0c 24             	mov    %ecx,(%esp)
  106188:	89 54 24 04          	mov    %edx,0x4(%esp)
  10618c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106193:	00 
  106194:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  106197:	e8 84 05 00 00       	call   106720 <map_address_active>
			paddr = kernel_pagetables[i];
  10619c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10619f:	8b 04 85 98 98 18 00 	mov    0x189898(,%eax,4),%eax
  1061a6:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;
  1061a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1061ac:	0d 01 00 00 00       	or     $0x1,%eax
  1061b1:	0d 02 00 00 00       	or     $0x2,%eax
  1061b6:	0d 04 00 00 00       	or     $0x4,%eax
  1061bb:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1061be:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1061c1:	8b 12                	mov    (%edx),%edx
  1061c3:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
  1061c6:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  1061cd:	0f 82 78 00 00 00    	jb     10624b <vmm_create_vpdraw+0x18b>
			for (i2 = 0; i2 < 1024; i2++) {
  1061d3:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  1061da:	81 7d d4 00 04 00 00 	cmpl   $0x400,-0x2c(%ebp)
  1061e1:	0f 83 5f 00 00 00    	jae    106246 <vmm_create_vpdraw+0x186>
  1061e7:	b8 04 00 00 00       	mov    $0x4,%eax
  1061ec:	b9 00 00 00 00       	mov    $0x0,%ecx
  1061f1:	ba 00 02 00 00       	mov    $0x200,%edx
				uint32_t vaddr = (i << 22) + (i2 << 12);
  1061f6:	8b 75 d8             	mov    -0x28(%ebp),%esi
  1061f9:	c1 e6 16             	shl    $0x16,%esi
  1061fc:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  1061ff:	c1 e7 0c             	shl    $0xc,%edi
  106202:	01 fe                	add    %edi,%esi
  106204:	89 75 d0             	mov    %esi,-0x30(%ebp)

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
  106207:	81 7d d0 00 00 00 01 	cmpl   $0x1000000,-0x30(%ebp)
  10620e:	0f 97 c3             	seta   %bl
  106211:	84 db                	test   %bl,%bl
  106213:	0f 44 d1             	cmove  %ecx,%edx
  106216:	81 7d d0 00 10 40 20 	cmpl   $0x20401000,-0x30(%ebp)
  10621d:	0f 97 c3             	seta   %bl
  106220:	84 db                	test   %bl,%bl
  106222:	0f 44 c1             	cmove  %ecx,%eax
  106225:	09 c2                	or     %eax,%edx
  106227:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  10622a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10622d:	8b 75 e0             	mov    -0x20(%ebp),%esi
  106230:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  106233:	89 14 81             	mov    %edx,(%ecx,%eax,4)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
			for (i2 = 0; i2 < 1024; i2++) {
  106236:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  106239:	05 01 00 00 00       	add    $0x1,%eax
  10623e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  106241:	e9 94 ff ff ff       	jmp    1061da <vmm_create_vpdraw+0x11a>

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
						(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
  106246:	e9 00 00 00 00       	jmp    10624b <vmm_create_vpdraw+0x18b>
	}
  10624b:	e9 00 00 00 00       	jmp    106250 <vmm_create_vpdraw+0x190>
		*pagedir = phys_pagedir;

	uint32_t* pagedir_ptr = vmm_alloc(0);
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  106250:	8b 45 d8             	mov    -0x28(%ebp),%eax
  106253:	05 01 00 00 00       	add    $0x1,%eax
  106258:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10625b:	e9 ce fe ff ff       	jmp    10612e <vmm_create_vpdraw+0x6e>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  106260:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  106267:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  10626e:	0f 83 58 00 00 00    	jae    1062cc <vmm_create_vpdraw+0x20c>
  106274:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
  106279:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10627c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10627f:	8b 12                	mov    (%edx),%edx
  106281:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106284:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  10628a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		map_address_context(pagedir_ptr,
  10628d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  106290:	8b 15 e4 72 10 00    	mov    0x1072e4,%edx
  106296:	8b 75 d8             	mov    -0x28(%ebp),%esi
  106299:	c1 e6 0c             	shl    $0xc,%esi
  10629c:	01 f2                	add    %esi,%edx
  10629e:	8b 75 dc             	mov    -0x24(%ebp),%esi
  1062a1:	89 0c 24             	mov    %ecx,(%esp)
  1062a4:	89 54 24 04          	mov    %edx,0x4(%esp)
  1062a8:	89 74 24 08          	mov    %esi,0x8(%esp)
  1062ac:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1062b3:	00 
  1062b4:	89 45 c0             	mov    %eax,-0x40(%ebp)
  1062b7:	e8 14 01 00 00       	call   1063d0 <map_address_context>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  1062bc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1062bf:	05 01 00 00 00       	add    $0x1,%eax
  1062c4:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1062c7:	e9 9b ff ff ff       	jmp    106267 <vmm_create_vpdraw+0x1a7>
  1062cc:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(pagedir_ptr,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
  1062d1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1062d4:	8b 15 e8 72 10 00    	mov    0x1072e8,%edx
  1062da:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1062dd:	89 0c 24             	mov    %ecx,(%esp)
  1062e0:	89 54 24 04          	mov    %edx,0x4(%esp)
  1062e4:	89 74 24 08          	mov    %esi,0x8(%esp)
  1062e8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1062ef:	00 
  1062f0:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1062f3:	e8 d8 00 00 00       	call   1063d0 <map_address_context>
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  1062f8:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
  1062ff:	8d 05 00 a0 18 00    	lea    0x18a000,%eax
  106305:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  106308:	0f 83 39 00 00 00    	jae    106347 <vmm_create_vpdraw+0x287>
  10630e:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(pagedir_ptr, i, i, 0);
  106313:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  106316:	8b 55 d8             	mov    -0x28(%ebp),%edx
  106319:	8b 75 d8             	mov    -0x28(%ebp),%esi
  10631c:	89 0c 24             	mov    %ecx,(%esp)
  10631f:	89 54 24 04          	mov    %edx,0x4(%esp)
  106323:	89 74 24 08          	mov    %esi,0x8(%esp)
  106327:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10632e:	00 
  10632f:	89 45 b8             	mov    %eax,-0x48(%ebp)
  106332:	e8 99 00 00 00       	call   1063d0 <map_address_context>
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  106337:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10633a:	05 00 10 00 00       	add    $0x1000,%eax
  10633f:	89 45 d8             	mov    %eax,-0x28(%ebp)
  106342:	e9 b8 ff ff ff       	jmp    1062ff <vmm_create_vpdraw+0x23f>
		map_address_context(pagedir_ptr, i, i, 0);
	}

	uint32_t* pd_ptr = context->pagedir;
  106347:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10634a:	8b 00                	mov    (%eax),%eax
  10634c:	89 45 cc             	mov    %eax,-0x34(%ebp)
	context->pagedir = (uint32_t*) phys_pagedir;
  10634f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106352:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  106355:	89 01                	mov    %eax,(%ecx)

	vmm_unmap(pd_ptr);
  106357:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10635a:	89 04 24             	mov    %eax,(%esp)
  10635d:	e8 fe 00 00 00       	call   106460 <vmm_unmap>
	vmm_unmap(context);
  106362:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106365:	89 04 24             	mov    %eax,(%esp)
  106368:	e8 f3 00 00 00       	call   106460 <vmm_unmap>

	return pagedir_ptr;
  10636d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  106370:	83 c4 4c             	add    $0x4c,%esp
  106373:	5e                   	pop    %esi
  106374:	5f                   	pop    %edi
  106375:	5b                   	pop    %ebx
  106376:	5d                   	pop    %ebp
  106377:	c3                   	ret    
  106378:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10637f:	00 

00106380 <vmm_alloc_user>:

void* vmm_alloc_ucont(uint32_t cont) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
}

void* vmm_alloc_user(uint32_t* retpaddr) {
  106380:	55                   	push   %ebp
  106381:	89 e5                	mov    %esp,%ebp
  106383:	56                   	push   %esi
  106384:	83 ec 24             	sub    $0x24,%esp
  106387:	8b 45 08             	mov    0x8(%ebp),%eax
  10638a:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  10638f:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  106394:	be 01 00 00 00       	mov    $0x1,%esi
  106399:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
  10639c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10639f:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  1063a6:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  1063ad:	ff 
  1063ae:	89 44 24 08          	mov    %eax,0x8(%esp)
  1063b2:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1063b9:	00 
  1063ba:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1063bd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1063c0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1063c3:	e8 b8 04 00 00       	call   106880 <vmm_alloc_in_range>
  1063c8:	83 c4 24             	add    $0x24,%esp
  1063cb:	5e                   	pop    %esi
  1063cc:	5d                   	pop    %ebp
  1063cd:	c3                   	ret    
  1063ce:	66 90                	xchg   %ax,%ax

001063d0 <map_address_context>:
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}

void map_address_context(uint32_t* pagedir, uint32_t vaddr, uint32_t paddr,
		uint32_t flags) {
  1063d0:	55                   	push   %ebp
  1063d1:	89 e5                	mov    %esp,%ebp
  1063d3:	56                   	push   %esi
  1063d4:	83 ec 18             	sub    $0x18,%esp
  1063d7:	8b 45 14             	mov    0x14(%ebp),%eax
  1063da:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1063dd:	8b 55 0c             	mov    0xc(%ebp),%edx
  1063e0:	8b 75 08             	mov    0x8(%ebp),%esi
  1063e3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  1063e6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  1063e9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1063ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32_t pd_entry = vaddr >> 22;
  1063ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1063f2:	c1 e8 16             	shr    $0x16,%eax
  1063f5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pt_entry = (vaddr >> 12) % 1024;
  1063f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1063fb:	c1 e8 0c             	shr    $0xc,%eax
  1063fe:	25 ff 03 00 00       	and    $0x3ff,%eax
  106403:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry] = (paddr
  106406:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106409:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10640e:	0d 01 00 00 00       	or     $0x1,%eax
  106413:	0d 02 00 00 00       	or     $0x2,%eax
  106418:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10641b:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  106421:	09 c8                	or     %ecx,%eax
  106423:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  106426:	8b 55 e8             	mov    -0x18(%ebp),%edx
  106429:	8b 75 f8             	mov    -0x8(%ebp),%esi
  10642c:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10642f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  106435:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106438:	81 e1 04 02 00 00    	and    $0x204,%ecx
  10643e:	09 c8                	or     %ecx,%eax
  106440:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  106443:	8b 55 e8             	mov    -0x18(%ebp),%edx
  106446:	8b 75 f8             	mov    -0x8(%ebp),%esi
  106449:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10644c:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  106452:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}
  106455:	83 c4 18             	add    $0x18,%esp
  106458:	5e                   	pop    %esi
  106459:	5d                   	pop    %ebp
  10645a:	c3                   	ret    
  10645b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00106460 <vmm_unmap>:
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

void vmm_unmap(void* p_vaddr) { //USE ONLY IF YOU KNOW WHAT YOU DO. POTENTIAL MEMORY LEAK!
  106460:	55                   	push   %ebp
  106461:	89 e5                	mov    %esp,%ebp
  106463:	83 ec 08             	sub    $0x8,%esp
  106466:	8b 45 08             	mov    0x8(%ebp),%eax
  106469:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  10646c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10646f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  106472:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106475:	c1 e8 0c             	shr    $0xc,%eax
  106478:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  10647e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106481:	25 01 02 00 00       	and    $0x201,%eax
  106486:	3d 01 02 00 00       	cmp    $0x201,%eax
  10648b:	0f 85 2e 00 00 00    	jne    1064bf <vmm_unmap+0x5f>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  106491:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106494:	c1 e8 0c             	shr    $0xc,%eax
  106497:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  10649d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1064a0:	25 04 00 00 00       	and    $0x4,%eax
  1064a5:	0d 00 02 00 00       	or     $0x200,%eax
  1064aa:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1064ad:	c1 e9 0c             	shr    $0xc,%ecx
  1064b0:	8b 15 e4 72 10 00    	mov    0x1072e4,%edx
  1064b6:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  1064b9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1064bc:	0f 01 38             	invlpg (%eax)
	}
}
  1064bf:	83 c4 08             	add    $0x8,%esp
  1064c2:	5d                   	pop    %ebp
  1064c3:	c3                   	ret    
  1064c4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1064cb:	00 00 00 00 00 

001064d0 <vmm_free_pdptr>:
	vmm_unmap(context);

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
  1064d0:	55                   	push   %ebp
  1064d1:	89 e5                	mov    %esp,%ebp
  1064d3:	83 ec 18             	sub    $0x18,%esp
  1064d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1064d9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (uint32_t i = 0; i < 1024; i++) {
  1064dc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1064e3:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
  1064ea:	0f 83 21 00 00 00    	jae    106511 <vmm_free_pdptr+0x41>
		vmm_unmap((void*) pagedir_ptr[i]);
  1064f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1064f3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1064f6:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1064f9:	89 04 24             	mov    %eax,(%esp)
  1064fc:	e8 5f ff ff ff       	call   106460 <vmm_unmap>

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
	for (uint32_t i = 0; i < 1024; i++) {
  106501:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106504:	05 01 00 00 00       	add    $0x1,%eax
  106509:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10650c:	e9 d2 ff ff ff       	jmp    1064e3 <vmm_free_pdptr+0x13>
		vmm_unmap((void*) pagedir_ptr[i]);
	}

	vmm_unmap(pagedir_ptr);
  106511:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106514:	89 04 24             	mov    %eax,(%esp)
  106517:	e8 44 ff ff ff       	call   106460 <vmm_unmap>
}
  10651c:	83 c4 18             	add    $0x18,%esp
  10651f:	5d                   	pop    %ebp
  106520:	c3                   	ret    
  106521:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  106528:	0f 1f 84 00 00 00 00 
  10652f:	00 

00106530 <vmm_create_pagedir>:
	vmm_free_pdptr(pdptr);

	return phys_pagedir;
}

uint32_t vmm_create_pagedir() {
  106530:	55                   	push   %ebp
  106531:	89 e5                	mov    %esp,%ebp
  106533:	83 ec 18             	sub    $0x18,%esp
  106536:	8d 45 fc             	lea    -0x4(%ebp),%eax
	uint32_t phys_pagedir;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  106539:	89 04 24             	mov    %eax,(%esp)
  10653c:	e8 7f fb ff ff       	call   1060c0 <vmm_create_vpdraw>
  106541:	89 45 f8             	mov    %eax,-0x8(%ebp)
	vmm_free_pdptr(pdptr);
  106544:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106547:	89 04 24             	mov    %eax,(%esp)
  10654a:	e8 81 ff ff ff       	call   1064d0 <vmm_free_pdptr>

	return phys_pagedir;
  10654f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106552:	83 c4 18             	add    $0x18,%esp
  106555:	5d                   	pop    %ebp
  106556:	c3                   	ret    
  106557:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10655e:	00 00 

00106560 <vmm_resolve>:
}

uint32_t vmm_resolve(void* vaddr) {
  106560:	55                   	push   %ebp
  106561:	89 e5                	mov    %esp,%ebp
  106563:	50                   	push   %eax
  106564:	8b 45 08             	mov    0x8(%ebp),%eax
  106567:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return active_pagetables[(uint32_t) vaddr >> 12] & 0xFFFFF000;
  10656a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10656d:	c1 e8 0c             	shr    $0xc,%eax
  106570:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  106576:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106579:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10657e:	83 c4 04             	add    $0x4,%esp
  106581:	5d                   	pop    %ebp
  106582:	c3                   	ret    
  106583:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10658a:	84 00 00 00 00 00 

00106590 <vmm_resolve_ppd>:
}

uint32_t vmm_resolve_ppd(uint32_t pdir, void* vaddr) {
  106590:	55                   	push   %ebp
  106591:	89 e5                	mov    %esp,%ebp
  106593:	83 ec 38             	sub    $0x38,%esp
  106596:	8b 45 0c             	mov    0xc(%ebp),%eax
  106599:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10659c:	ba 00 00 00 00       	mov    $0x0,%edx
  1065a1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1065a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32_t pd_entry = (uint32_t) vaddr >> 22;
  1065a7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1065aa:	c1 e8 16             	shr    $0x16,%eax
  1065ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t pt_entry = ((uint32_t) vaddr >> 12) % 1024;
  1065b0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1065b3:	c1 e8 0c             	shr    $0xc,%eax
  1065b6:	25 ff 03 00 00       	and    $0x3ff,%eax
  1065bb:	89 45 f0             	mov    %eax,-0x10(%ebp)

	uint32_t* vpd = vmm_alloc(0);
  1065be:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1065c5:	89 55 e0             	mov    %edx,-0x20(%ebp)
  1065c8:	e8 83 00 00 00       	call   106650 <vmm_alloc>
  1065cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	vmm_free(vpd);
  1065d0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1065d3:	89 04 24             	mov    %eax,(%esp)
  1065d6:	e8 c5 00 00 00       	call   1066a0 <vmm_free>
  1065db:	b8 00 00 00 00       	mov    $0x0,%eax

	map_address_active((uint32_t) vpd, pdir, 0);
  1065e0:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1065e3:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1065e6:	89 0c 24             	mov    %ecx,(%esp)
  1065e9:	89 54 24 04          	mov    %edx,0x4(%esp)
  1065ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1065f4:	00 
  1065f5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1065f8:	e8 23 01 00 00       	call   106720 <map_address_active>
  1065fd:	b8 00 00 00 00       	mov    $0x0,%eax
	uint32_t table = vpd[pd_entry] & 0xFFFFF000;
  106602:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106605:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106608:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  10660b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  106611:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	map_address_active((uint32_t) vpd, table, 0);
  106614:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106617:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10661a:	89 0c 24             	mov    %ecx,(%esp)
  10661d:	89 54 24 04          	mov    %edx,0x4(%esp)
  106621:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106628:	00 
  106629:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10662c:	e8 ef 00 00 00       	call   106720 <map_address_active>
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;
  106631:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106634:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106637:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10663a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10663f:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	return addr & 0xFFFFF000;
  106642:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  106645:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10664a:	83 c4 38             	add    $0x38,%esp
  10664d:	5d                   	pop    %ebp
  10664e:	c3                   	ret    
  10664f:	90                   	nop

00106650 <vmm_alloc>:

void* vmm_alloc_cont(uint32_t cont) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
}

void* vmm_alloc(uint32_t* retpaddr) {
  106650:	55                   	push   %ebp
  106651:	89 e5                	mov    %esp,%ebp
  106653:	56                   	push   %esi
  106654:	83 ec 24             	sub    $0x24,%esp
  106657:	8b 45 08             	mov    0x8(%ebp),%eax
  10665a:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  10665f:	ba 00 00 00 20       	mov    $0x20000000,%edx
  106664:	be 01 00 00 00       	mov    $0x1,%esi
  106669:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
  10666c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10666f:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
  106676:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  10667d:	20 
  10667e:	89 44 24 08          	mov    %eax,0x8(%esp)
  106682:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  106689:	00 
  10668a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10668d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106690:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106693:	e8 e8 01 00 00       	call   106880 <vmm_alloc_in_range>
  106698:	83 c4 24             	add    $0x24,%esp
  10669b:	5e                   	pop    %esi
  10669c:	5d                   	pop    %ebp
  10669d:	c3                   	ret    
  10669e:	66 90                	xchg   %ax,%ax

001066a0 <vmm_free>:
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
}

void vmm_free(void* p_vaddr) {
  1066a0:	55                   	push   %ebp
  1066a1:	89 e5                	mov    %esp,%ebp
  1066a3:	83 ec 18             	sub    $0x18,%esp
  1066a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1066a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  1066ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1066af:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  1066b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1066b5:	c1 e8 0c             	shr    $0xc,%eax
  1066b8:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  1066be:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1066c1:	25 01 02 00 00       	and    $0x201,%eax
  1066c6:	3d 01 02 00 00       	cmp    $0x201,%eax
  1066cb:	0f 85 4a 00 00 00    	jne    10671b <vmm_free+0x7b>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		pmm_free((void*) (active_pagetables[vaddr >> 12] & 0xFFFFF000));
  1066d1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1066d4:	c1 e8 0c             	shr    $0xc,%eax
  1066d7:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  1066dd:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1066e0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1066e5:	89 04 24             	mov    %eax,(%esp)
  1066e8:	e8 53 c5 ff ff       	call   102c40 <pmm_free>

		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  1066ed:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1066f0:	c1 e8 0c             	shr    $0xc,%eax
  1066f3:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  1066f9:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1066fc:	25 04 00 00 00       	and    $0x4,%eax
  106701:	0d 00 02 00 00       	or     $0x200,%eax
  106706:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  106709:	c1 e9 0c             	shr    $0xc,%ecx
  10670c:	8b 15 e4 72 10 00    	mov    0x1072e4,%edx
  106712:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  106715:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106718:	0f 01 38             	invlpg (%eax)
	}
}
  10671b:	83 c4 18             	add    $0x18,%esp
  10671e:	5d                   	pop    %ebp
  10671f:	c3                   	ret    

00106720 <map_address_active>:
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}

void map_address_active(uint32_t vaddr, uint32_t paddr, uint32_t flags) {
  106720:	55                   	push   %ebp
  106721:	89 e5                	mov    %esp,%ebp
  106723:	83 ec 0c             	sub    $0xc,%esp
  106726:	8b 45 10             	mov    0x10(%ebp),%eax
  106729:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10672c:	8b 55 08             	mov    0x8(%ebp),%edx
  10672f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  106732:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  106735:	89 45 f4             	mov    %eax,-0xc(%ebp)
	active_pagetables[vaddr >> 12] = (paddr & 0xFFFFF000) | PT_PRESENT
  106738:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10673b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  106740:	0d 01 00 00 00       	or     $0x1,%eax
  106745:	0d 02 00 00 00       	or     $0x2,%eax
  10674a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10674d:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  106753:	09 c8                	or     %ecx,%eax
  106755:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  106758:	c1 e9 0c             	shr    $0xc,%ecx
  10675b:	8b 15 e4 72 10 00    	mov    0x1072e4,%edx
  106761:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106764:	81 e1 04 02 00 00    	and    $0x204,%ecx
  10676a:	09 c8                	or     %ecx,%eax
  10676c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10676f:	c1 e9 0c             	shr    $0xc,%ecx
  106772:	8b 15 e4 72 10 00    	mov    0x1072e4,%edx
  106778:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  10677b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10677e:	0f 01 38             	invlpg (%eax)
}
  106781:	83 c4 0c             	add    $0xc,%esp
  106784:	5d                   	pop    %ebp
  106785:	c3                   	ret    
  106786:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10678d:	00 00 00 

00106790 <vmm_map_range>:
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;

	return addr & 0xFFFFF000;
}

void vmm_map_range(void* vaddr, void* paddr, uint32_t length, uint32_t flags) {
  106790:	55                   	push   %ebp
  106791:	89 e5                	mov    %esp,%ebp
  106793:	56                   	push   %esi
  106794:	83 ec 24             	sub    $0x24,%esp
  106797:	8b 45 14             	mov    0x14(%ebp),%eax
  10679a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10679d:	8b 55 0c             	mov    0xc(%ebp),%edx
  1067a0:	8b 75 08             	mov    0x8(%ebp),%esi
  1067a3:	89 75 f8             	mov    %esi,-0x8(%ebp)
  1067a6:	89 55 f4             	mov    %edx,-0xc(%ebp)
  1067a9:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1067ac:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((uint32_t) vaddr & 0xFFF)
  1067af:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1067b2:	25 ff 0f 00 00       	and    $0xfff,%eax
  1067b7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1067bc:	0f 84 05 00 00 00    	je     1067c7 <vmm_map_range+0x37>
		return;
  1067c2:	e9 5a 00 00 00       	jmp    106821 <vmm_map_range+0x91>
	if ((uint32_t) paddr & 0xFFF)
  1067c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1067ca:	25 ff 0f 00 00       	and    $0xfff,%eax
  1067cf:	3d 00 00 00 00       	cmp    $0x0,%eax
  1067d4:	0f 84 05 00 00 00    	je     1067df <vmm_map_range+0x4f>
		return;
  1067da:	e9 42 00 00 00       	jmp    106821 <vmm_map_range+0x91>

	for (uint32_t i = 0; i < length; i += 0x1000) {
  1067df:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  1067e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1067e9:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  1067ec:	0f 83 2f 00 00 00    	jae    106821 <vmm_map_range+0x91>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
  1067f2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1067f5:	03 45 e8             	add    -0x18(%ebp),%eax
  1067f8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1067fb:	03 4d e8             	add    -0x18(%ebp),%ecx
  1067fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106801:	89 04 24             	mov    %eax,(%esp)
  106804:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106808:	89 54 24 08          	mov    %edx,0x8(%esp)
  10680c:	e8 0f ff ff ff       	call   106720 <map_address_active>
	if ((uint32_t) vaddr & 0xFFF)
		return;
	if ((uint32_t) paddr & 0xFFF)
		return;

	for (uint32_t i = 0; i < length; i += 0x1000) {
  106811:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106814:	05 00 10 00 00       	add    $0x1000,%eax
  106819:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10681c:	e9 c5 ff ff ff       	jmp    1067e6 <vmm_map_range+0x56>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}
  106821:	83 c4 24             	add    $0x24,%esp
  106824:	5e                   	pop    %esi
  106825:	5d                   	pop    %ebp
  106826:	c3                   	ret    
  106827:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10682e:	00 00 

00106830 <vmm_alloc_ucont>:
	}

	return vaddr;
}

void* vmm_alloc_ucont(uint32_t cont) {
  106830:	55                   	push   %ebp
  106831:	89 e5                	mov    %esp,%ebp
  106833:	56                   	push   %esi
  106834:	83 ec 24             	sub    $0x24,%esp
  106837:	8b 45 08             	mov    0x8(%ebp),%eax
  10683a:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  10683f:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  106844:	be 00 00 00 00       	mov    $0x0,%esi
  106849:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
  10684c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10684f:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  106856:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  10685d:	ff 
  10685e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106865:	00 
  106866:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10686a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10686d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106870:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106873:	e8 08 00 00 00       	call   106880 <vmm_alloc_in_range>
  106878:	83 c4 24             	add    $0x24,%esp
  10687b:	5e                   	pop    %esi
  10687c:	5d                   	pop    %ebp
  10687d:	c3                   	ret    
  10687e:	66 90                	xchg   %ax,%ax

00106880 <vmm_alloc_in_range>:
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

static void* vmm_alloc_in_range(uint32_t low, uint32_t high, uint32_t* retpaddr,
		uint32_t cont) {
  106880:	55                   	push   %ebp
  106881:	89 e5                	mov    %esp,%ebp
  106883:	56                   	push   %esi
  106884:	83 ec 34             	sub    $0x34,%esp
  106887:	8b 45 14             	mov    0x14(%ebp),%eax
  10688a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10688d:	8b 55 0c             	mov    0xc(%ebp),%edx
  106890:	8b 75 08             	mov    0x8(%ebp),%esi
  106893:	89 75 f8             	mov    %esi,-0x8(%ebp)
  106896:	89 55 f4             	mov    %edx,-0xc(%ebp)
  106899:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10689c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	void* vaddr = 0;
  10689f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32_t i = 0;
  1068a6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32_t c = 0;
  1068ad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  1068b4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1068b7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1068bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1068bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1068c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  1068c5:	0f 83 6f 00 00 00    	jae    10693a <vmm_alloc_in_range+0xba>
		if ((active_pagetables[i >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  1068cb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1068ce:	c1 e8 0c             	shr    $0xc,%eax
  1068d1:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  1068d7:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1068da:	25 01 02 00 00       	and    $0x201,%eax
  1068df:	3d 00 02 00 00       	cmp    $0x200,%eax
  1068e4:	0f 85 34 00 00 00    	jne    10691e <vmm_alloc_in_range+0x9e>
				== PT_ALLOCATABLE) {
			if (c == 0)
  1068ea:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1068f1:	0f 85 06 00 00 00    	jne    1068fd <vmm_alloc_in_range+0x7d>
				vaddr = (void*) i;
  1068f7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1068fa:	89 45 e8             	mov    %eax,-0x18(%ebp)
			c++;
  1068fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  106900:	05 01 00 00 00       	add    $0x1,%eax
  106905:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (c >= cont)
  106908:	8b 45 e0             	mov    -0x20(%ebp),%eax
  10690b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10690e:	0f 82 05 00 00 00    	jb     106919 <vmm_alloc_in_range+0x99>
				break;
  106914:	e9 21 00 00 00       	jmp    10693a <vmm_alloc_in_range+0xba>
		} else {
  106919:	e9 07 00 00 00       	jmp    106925 <vmm_alloc_in_range+0xa5>
			c = 0;
  10691e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
	}
  106925:	e9 00 00 00 00       	jmp    10692a <vmm_alloc_in_range+0xaa>
		uint32_t cont) {
	void* vaddr = 0;
	uint32_t i = 0;
	uint32_t c = 0;

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  10692a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10692d:	05 00 10 00 00       	add    $0x1000,%eax
  106932:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106935:	e9 85 ff ff ff       	jmp    1068bf <vmm_alloc_in_range+0x3f>
		} else {
			c = 0;
		}
	}

	uint32_t off = 0;
  10693a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	while (c--) {
  106941:	8b 45 e0             	mov    -0x20(%ebp),%eax
  106944:	89 c1                	mov    %eax,%ecx
  106946:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  10694c:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  10694f:	3d 00 00 00 00       	cmp    $0x0,%eax
  106954:	0f 84 59 00 00 00    	je     1069b3 <vmm_alloc_in_range+0x133>
		vmm_alloc_addr(vaddr + off * 0x1000, off == 0 ? retpaddr : 0);
  10695a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10695d:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  106960:	c1 e1 0c             	shl    $0xc,%ecx
  106963:	01 c8                	add    %ecx,%eax
  106965:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  10696c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10696f:	0f 85 0b 00 00 00    	jne    106980 <vmm_alloc_in_range+0x100>
  106975:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106978:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10697b:	e9 0d 00 00 00       	jmp    10698d <vmm_alloc_in_range+0x10d>
  106980:	b8 00 00 00 00       	mov    $0x0,%eax
  106985:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  106988:	e9 00 00 00 00       	jmp    10698d <vmm_alloc_in_range+0x10d>
  10698d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  106990:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  106993:	89 0c 24             	mov    %ecx,(%esp)
  106996:	89 44 24 04          	mov    %eax,0x4(%esp)
  10699a:	e8 71 00 00 00       	call   106a10 <vmm_alloc_addr>
		off++;
  10699f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  1069a2:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1069a8:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	}
  1069ab:	89 45 d0             	mov    %eax,-0x30(%ebp)
  1069ae:	e9 8e ff ff ff       	jmp    106941 <vmm_alloc_in_range+0xc1>

	return vaddr;
  1069b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1069b6:	83 c4 34             	add    $0x34,%esp
  1069b9:	5e                   	pop    %esi
  1069ba:	5d                   	pop    %ebp
  1069bb:	c3                   	ret    
  1069bc:	0f 1f 40 00          	nopl   0x0(%eax)

001069c0 <vmm_alloc_cont>:

void* vmm_alloc_user(uint32_t* retpaddr) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
}

void* vmm_alloc_cont(uint32_t cont) {
  1069c0:	55                   	push   %ebp
  1069c1:	89 e5                	mov    %esp,%ebp
  1069c3:	56                   	push   %esi
  1069c4:	83 ec 24             	sub    $0x24,%esp
  1069c7:	8b 45 08             	mov    0x8(%ebp),%eax
  1069ca:	b9 00 00 00 01       	mov    $0x1000000,%ecx
  1069cf:	ba 00 00 00 20       	mov    $0x20000000,%edx
  1069d4:	be 00 00 00 00       	mov    $0x0,%esi
  1069d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
  1069dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1069df:	c7 04 24 00 00 00 01 	movl   $0x1000000,(%esp)
  1069e6:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  1069ed:	20 
  1069ee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1069f5:	00 
  1069f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1069fa:	89 75 f4             	mov    %esi,-0xc(%ebp)
  1069fd:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  106a00:	89 55 ec             	mov    %edx,-0x14(%ebp)
  106a03:	e8 78 fe ff ff       	call   106880 <vmm_alloc_in_range>
  106a08:	83 c4 24             	add    $0x24,%esp
  106a0b:	5e                   	pop    %esi
  106a0c:	5d                   	pop    %ebp
  106a0d:	c3                   	ret    
  106a0e:	66 90                	xchg   %ax,%ax

00106a10 <vmm_alloc_addr>:

void* vmm_alloc(uint32_t* retpaddr) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
}

void* vmm_alloc_addr(void* reqvaddr, uint32_t* retpaddr) {
  106a10:	55                   	push   %ebp
  106a11:	89 e5                	mov    %esp,%ebp
  106a13:	56                   	push   %esi
  106a14:	83 ec 34             	sub    $0x34,%esp
  106a17:	8b 45 0c             	mov    0xc(%ebp),%eax
  106a1a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  106a1d:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  106a20:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (reqvaddr == 0) {
  106a23:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  106a2a:	0f 85 34 00 00 00    	jne    106a64 <vmm_alloc_addr+0x54>
  106a30:	8d 05 61 86 10 00    	lea    0x108661,%eax
  106a36:	b9 00 00 00 00       	mov    $0x0,%ecx
		kprintf(
  106a3b:	8b 55 f4             	mov    -0xc(%ebp),%edx
  106a3e:	89 04 24             	mov    %eax,(%esp)
  106a41:	89 54 24 04          	mov    %edx,0x4(%esp)
  106a45:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  106a4c:	00 
  106a4d:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  106a50:	e8 5b 98 ff ff       	call   1002b0 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, 0);
		return 0;
  106a55:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  106a5c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  106a5f:	e9 9b 00 00 00       	jmp    106aff <vmm_alloc_addr+0xef>
	}

	if ((active_pagetables[(uint32_t) reqvaddr >> 12]
  106a64:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106a67:	c1 e8 0c             	shr    $0xc,%eax
  106a6a:	8b 0d e4 72 10 00    	mov    0x1072e4,%ecx
  106a70:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106a73:	25 01 02 00 00       	and    $0x201,%eax
  106a78:	3d 00 02 00 00       	cmp    $0x200,%eax
  106a7d:	0f 84 37 00 00 00    	je     106aba <vmm_alloc_addr+0xaa>
  106a83:	8d 05 61 86 10 00    	lea    0x108661,%eax
			& (PT_ALLOCATABLE | PT_PRESENT)) != PT_ALLOCATABLE) {
		kprintf(
  106a89:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  106a8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  106a8f:	c1 ea 0c             	shr    $0xc,%edx
  106a92:	8b 35 e4 72 10 00    	mov    0x1072e4,%esi
  106a98:	8b 14 96             	mov    (%esi,%edx,4),%edx
  106a9b:	89 04 24             	mov    %eax,(%esp)
  106a9e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106aa2:	89 54 24 08          	mov    %edx,0x8(%esp)
  106aa6:	e8 05 98 ff ff       	call   1002b0 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, active_pagetables[(uint32_t) reqvaddr >> 12]);
		return 0;
  106aab:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  106ab2:	89 45 e0             	mov    %eax,-0x20(%ebp)
  106ab5:	e9 45 00 00 00       	jmp    106aff <vmm_alloc_addr+0xef>
  106aba:	b8 04 02 00 00       	mov    $0x204,%eax
	}

	uint32_t paddr = (uint32_t) pmm_alloc();
  106abf:	89 45 dc             	mov    %eax,-0x24(%ebp)
  106ac2:	e8 59 bf ff ff       	call   102a20 <pmm_alloc>
  106ac7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	map_address_active((uint32_t) reqvaddr, paddr, PT_PUBLIC | PT_ALLOCATABLE);
  106aca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106acd:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106ad0:	89 04 24             	mov    %eax,(%esp)
  106ad3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  106ad7:	c7 44 24 08 04 02 00 	movl   $0x204,0x8(%esp)
  106ade:	00 
  106adf:	e8 3c fc ff ff       	call   106720 <map_address_active>

	if (retpaddr != 0)
  106ae4:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  106aeb:	0f 84 08 00 00 00    	je     106af9 <vmm_alloc_addr+0xe9>
		*retpaddr = paddr;
  106af1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106af4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106af7:	89 01                	mov    %eax,(%ecx)

	return reqvaddr;
  106af9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  106afc:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  106aff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  106b02:	83 c4 34             	add    $0x34,%esp
  106b05:	5e                   	pop    %esi
  106b06:	5d                   	pop    %ebp
  106b07:	c3                   	ret    
  106b08:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  106b0f:	00 

00106b10 <vmm_activate_pagedir>:

void vmm_activate_pagedir(uint32_t pdpaddr) {
  106b10:	55                   	push   %ebp
  106b11:	89 e5                	mov    %esp,%ebp
  106b13:	50                   	push   %eax
  106b14:	8b 45 08             	mov    0x8(%ebp),%eax
  106b17:	89 45 fc             	mov    %eax,-0x4(%ebp)
	active_pagedir = pdpaddr;
  106b1a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106b1d:	a3 64 94 10 00       	mov    %eax,0x109464
	asm volatile("mov %0, %%cr3" : : "r" (pdpaddr));
  106b22:	8b 45 fc             	mov    -0x4(%ebp),%eax
  106b25:	0f 22 d8             	mov    %eax,%cr3
}
  106b28:	83 c4 04             	add    $0x4,%esp
  106b2b:	5d                   	pop    %ebp
  106b2c:	c3                   	ret    
  106b2d:	0f 1f 00             	nopl   (%eax)

00106b30 <vmm_init>:

uint32_t vmm_init(void) {
  106b30:	55                   	push   %ebp
  106b31:	89 e5                	mov    %esp,%ebp
	//CREATE CONTEXT ************************************************************

	struct vmm_context* context = pmm_alloc();
  106b33:	53                   	push   %ebx
  106b34:	57                   	push   %edi
  106b35:	56                   	push   %esi
  106b36:	83 ec 3c             	sub    $0x3c,%esp
  106b39:	e8 e2 be ff ff       	call   102a20 <pmm_alloc>
  106b3e:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t i, i2;

	context->pagedir = pmm_alloc();
  106b41:	e8 da be ff ff       	call   102a20 <pmm_alloc>
  106b46:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106b49:	89 01                	mov    %eax,(%ecx)

	for (i = 0; i < 1024; i++) {
  106b4b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106b52:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  106b59:	0f 83 d6 00 00 00    	jae    106c35 <vmm_init+0x105>
		context->pagedir[i] = ((uint32_t) pmm_alloc());
  106b5f:	e8 bc be ff ff       	call   102a20 <pmm_alloc>
  106b64:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106b67:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106b6a:	8b 12                	mov    (%edx),%edx
  106b6c:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		if (i < PMEM_TABLES) {
  106b6f:	81 7d ec 80 00 00 00 	cmpl   $0x80,-0x14(%ebp)
  106b76:	0f 83 15 00 00 00    	jae    106b91 <vmm_init+0x61>
			kernel_pagetables[i] = context->pagedir[i];
  106b7c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106b7f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106b82:	8b 09                	mov    (%ecx),%ecx
  106b84:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  106b87:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106b8a:	89 04 8d 98 98 18 00 	mov    %eax,0x189898(,%ecx,4)
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;
  106b91:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106b94:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106b97:	8b 09                	mov    (%ecx),%ecx
  106b99:	8b 14 81             	mov    (%ecx,%eax,4),%edx
  106b9c:	81 ca 07 00 00 00    	or     $0x7,%edx
  106ba2:	89 14 81             	mov    %edx,(%ecx,%eax,4)

		for (i2 = 0; i2 < 1024; i2++) {
  106ba5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  106bac:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
  106bb3:	0f 83 67 00 00 00    	jae    106c20 <vmm_init+0xf0>
  106bb9:	b8 04 00 00 00       	mov    $0x4,%eax
  106bbe:	b9 00 00 00 00       	mov    $0x0,%ecx
  106bc3:	ba 00 02 00 00       	mov    $0x200,%edx
			uint32_t vaddr = (i << 22) + (i2 << 12);
  106bc8:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106bcb:	c1 e6 16             	shl    $0x16,%esi
  106bce:	8b 7d e8             	mov    -0x18(%ebp),%edi
  106bd1:	c1 e7 0c             	shl    $0xc,%edi
  106bd4:	01 fe                	add    %edi,%esi
  106bd6:	89 75 e4             	mov    %esi,-0x1c(%ebp)

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
  106bd9:	81 7d e4 00 00 00 01 	cmpl   $0x1000000,-0x1c(%ebp)
  106be0:	0f 97 c3             	seta   %bl
  106be3:	84 db                	test   %bl,%bl
  106be5:	0f 44 d1             	cmove  %ecx,%edx
  106be8:	81 7d e4 00 10 40 20 	cmpl   $0x20401000,-0x1c(%ebp)
  106bef:	0f 97 c3             	seta   %bl
  106bf2:	84 db                	test   %bl,%bl
  106bf4:	0f 44 c1             	cmove  %ecx,%eax
  106bf7:	09 c2                	or     %eax,%edx
  106bf9:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106bfc:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106bff:	8b 75 f0             	mov    -0x10(%ebp),%esi
  106c02:	8b 36                	mov    (%esi),%esi
  106c04:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  106c07:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  106c0d:	89 14 81             	mov    %edx,(%ecx,%eax,4)
			kernel_pagetables[i] = context->pagedir[i];
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;

		for (i2 = 0; i2 < 1024; i2++) {
  106c10:	8b 45 e8             	mov    -0x18(%ebp),%eax
  106c13:	05 01 00 00 00       	add    $0x1,%eax
  106c18:	89 45 e8             	mov    %eax,-0x18(%ebp)
  106c1b:	e9 8c ff ff ff       	jmp    106bac <vmm_init+0x7c>

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}
  106c20:	e9 00 00 00 00       	jmp    106c25 <vmm_init+0xf5>
	struct vmm_context* context = pmm_alloc();
	uint32_t i, i2;

	context->pagedir = pmm_alloc();

	for (i = 0; i < 1024; i++) {
  106c25:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106c28:	05 01 00 00 00       	add    $0x1,%eax
  106c2d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106c30:	e9 1d ff ff ff       	jmp    106b52 <vmm_init+0x22>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  106c35:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  106c3c:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  106c43:	0f 83 5a 00 00 00    	jae    106ca3 <vmm_init+0x173>
  106c49:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
  106c4e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  106c51:	8b 55 f0             	mov    -0x10(%ebp),%edx
  106c54:	8b 12                	mov    (%edx),%edx
  106c56:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  106c59:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  106c5f:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		map_address_context(context->pagedir,
  106c62:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106c65:	8b 09                	mov    (%ecx),%ecx
  106c67:	8b 15 e4 72 10 00    	mov    0x1072e4,%edx
  106c6d:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106c70:	c1 e6 0c             	shl    $0xc,%esi
  106c73:	01 f2                	add    %esi,%edx
  106c75:	8b 75 e0             	mov    -0x20(%ebp),%esi
  106c78:	89 0c 24             	mov    %ecx,(%esp)
  106c7b:	89 54 24 04          	mov    %edx,0x4(%esp)
  106c7f:	89 74 24 08          	mov    %esi,0x8(%esp)
  106c83:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106c8a:	00 
  106c8b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  106c8e:	e8 3d f7 ff ff       	call   1063d0 <map_address_context>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  106c93:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106c96:	05 01 00 00 00       	add    $0x1,%eax
  106c9b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106c9e:	e9 99 ff ff ff       	jmp    106c3c <vmm_init+0x10c>
  106ca3:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(context->pagedir,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
  106ca8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106cab:	8b 09                	mov    (%ecx),%ecx
  106cad:	8b 15 e8 72 10 00    	mov    0x1072e8,%edx
  106cb3:	8b 75 f0             	mov    -0x10(%ebp),%esi
  106cb6:	89 0c 24             	mov    %ecx,(%esp)
  106cb9:	89 54 24 04          	mov    %edx,0x4(%esp)
  106cbd:	89 74 24 08          	mov    %esi,0x8(%esp)
  106cc1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106cc8:	00 
  106cc9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  106ccc:	e8 ff f6 ff ff       	call   1063d0 <map_address_context>
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  106cd1:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
  106cd8:	8d 05 00 a0 18 00    	lea    0x18a000,%eax
  106cde:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  106ce1:	0f 83 3b 00 00 00    	jae    106d22 <vmm_init+0x1f2>
  106ce7:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(context->pagedir, i, i, 0);
  106cec:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  106cef:	8b 09                	mov    (%ecx),%ecx
  106cf1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  106cf4:	8b 75 ec             	mov    -0x14(%ebp),%esi
  106cf7:	89 0c 24             	mov    %ecx,(%esp)
  106cfa:	89 54 24 04          	mov    %edx,0x4(%esp)
  106cfe:	89 74 24 08          	mov    %esi,0x8(%esp)
  106d02:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  106d09:	00 
  106d0a:	89 45 d0             	mov    %eax,-0x30(%ebp)
  106d0d:	e8 be f6 ff ff       	call   1063d0 <map_address_context>
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  106d12:	8b 45 ec             	mov    -0x14(%ebp),%eax
  106d15:	05 00 10 00 00       	add    $0x1000,%eax
  106d1a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  106d1d:	e9 b6 ff ff ff       	jmp    106cd8 <vmm_init+0x1a8>
		map_address_context(context->pagedir, i, i, 0);
	}

	//END CREATE CONTEXT ********************************************************

	vmm_activate_pagedir((uint32_t) context->pagedir);
  106d22:	8b 45 f0             	mov    -0x10(%ebp),%eax
  106d25:	8b 00                	mov    (%eax),%eax
  106d27:	89 04 24             	mov    %eax,(%esp)
  106d2a:	e8 e1 fd ff ff       	call   106b10 <vmm_activate_pagedir>

	uint32_t cr0;

	asm volatile("mov %%cr0, %0" : "=r" (cr0));
  106d2f:	0f 20 c0             	mov    %cr0,%eax
  106d32:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= (1 << 31);
  106d35:	8b 45 dc             	mov    -0x24(%ebp),%eax
  106d38:	0d 00 00 00 80       	or     $0x80000000,%eax
  106d3d:	89 45 dc             	mov    %eax,-0x24(%ebp)
	asm volatile("mov %0, %%cr0" : : "r" (cr0));
  106d40:	8b 45 dc             	mov    -0x24(%ebp),%eax
  106d43:	0f 22 c0             	mov    %eax,%cr0

	return (uint32_t) active_context->pagedir;
  106d46:	a1 e8 72 10 00       	mov    0x1072e8,%eax
  106d4b:	8b 00                	mov    (%eax),%eax
  106d4d:	83 c4 3c             	add    $0x3c,%esp
  106d50:	5e                   	pop    %esi
  106d51:	5f                   	pop    %edi
  106d52:	5b                   	pop    %ebx
  106d53:	5d                   	pop    %ebp
  106d54:	c3                   	ret    
  106d55:	66 90                	xchg   %ax,%ax
  106d57:	90                   	nop

00106d58 <_start>:
  106d58:	bc 68 94 11 00       	mov    $0x119468,%esp
  106d5d:	53                   	push   %ebx
  106d5e:	e8 ad 92 ff ff       	call   100010 <init>

00106d63 <_stop>:
  106d63:	fa                   	cli    
  106d64:	f4                   	hlt    
  106d65:	eb fc                	jmp    106d63 <_stop>


kernel/kernel:     file format elf32-i386


Disassembly of section .text:

00100000 <kernel_start>:
  100000:	02 b0 ad 1b 00 00    	add    0x1bad(%eax),%dh
  100006:	00 00                	add    %al,(%eax)
  100008:	fe 4f 52             	decb   0x52(%edi)
  10000b:	e4 66                	in     $0x66,%al
  10000d:	90                   	nop
  10000e:	66 90                	xchg   %ax,%ax

00100010 <init>:
#include "pmm.h"
#include "vfs.h"

#define _VERSION "alphaKernelDev 1.01"

void init(struct multiboot_info* mb_info) {
  100010:	55                   	push   %ebp
  100011:	89 e5                	mov    %esp,%ebp
  100013:	83 ec 28             	sub    $0x28,%esp
  100016:	8b 45 08             	mov    0x8(%ebp),%eax
  100019:	89 45 fc             	mov    %eax,-0x4(%ebp)
	clrscr();
  10001c:	e8 af 04 00 00       	call   1004d0 <clrscr>
	pmm_init(mb_info);
  100021:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100024:	89 04 24             	mov    %eax,(%esp)
  100027:	e8 34 23 00 00       	call   102360 <pmm_init>
  10002c:	8d 05 5c 70 10 00    	lea    0x10705c,%eax
  100032:	8d 0d 7f 70 10 00    	lea    0x10707f,%ecx

	kprintf("Welcome to mikrOS (version '%s')!\n", _VERSION);
  100038:	89 04 24             	mov    %eax,(%esp)
  10003b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10003f:	e8 0c 05 00 00       	call   100550 <kprintf>
  100044:	8d 0d 93 70 10 00    	lea    0x107093,%ecx
	kprintf("(C) Copyright 2012-2014 Fabian Sachara.  All Rights Reserved.\n");
  10004a:	89 0c 24             	mov    %ecx,(%esp)
  10004d:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100050:	e8 fb 04 00 00       	call   100550 <kprintf>
  100055:	8d 0d d2 70 10 00    	lea    0x1070d2,%ecx

	kprintf("Initializing GDT...\n");
  10005b:	89 0c 24             	mov    %ecx,(%esp)
  10005e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100061:	e8 ea 04 00 00       	call   100550 <kprintf>

	init_gdt();
  100066:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100069:	e8 a2 0a 00 00       	call   100b10 <init_gdt>
  10006e:	8d 05 e7 70 10 00    	lea    0x1070e7,%eax

	kprintf("Initializing IDT...\n");
  100074:	89 04 24             	mov    %eax,(%esp)
  100077:	e8 d4 04 00 00       	call   100550 <kprintf>
  10007c:	8d 0d fc 70 10 00    	lea    0x1070fc,%ecx

	init_idt();
  100082:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100085:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  100088:	e8 a3 0c 00 00       	call   100d30 <init_idt>

	kprintf("Initializing in-kernel-Drivers...\n");
  10008d:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100090:	89 04 24             	mov    %eax,(%esp)
  100093:	e8 b8 04 00 00       	call   100550 <kprintf>

	init_drivers();
  100098:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10009b:	e8 30 00 00 00       	call   1000d0 <init_drivers>
  1000a0:	8d 05 1f 71 10 00    	lea    0x10711f,%eax

	kprintf("Initializing Kernel...\n");
  1000a6:	89 04 24             	mov    %eax,(%esp)
  1000a9:	e8 a2 04 00 00       	call   100550 <kprintf>

	pmm_print_stats();
  1000ae:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1000b1:	e8 ba 20 00 00       	call   102170 <pmm_print_stats>

	kernel_main(mb_info);
  1000b6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000b9:	89 04 24             	mov    %eax,(%esp)
  1000bc:	e8 5f 1e 00 00       	call   101f20 <kernel_main>

	return;
  1000c1:	83 c4 28             	add    $0x28,%esp
  1000c4:	5d                   	pop    %ebp
  1000c5:	c3                   	ret    
  1000c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1000cd:	00 00 00 

001000d0 <init_drivers>:
#ifndef DRVINIT_H
#define DRVINIT_H

#include "keyboard.h"

static inline void init_drivers() {
  1000d0:	55                   	push   %ebp
  1000d1:	89 e5                	mov    %esp,%ebp
    init_keyboard_drv();
  1000d3:	83 ec 08             	sub    $0x8,%esp
  1000d6:	e8 05 02 00 00       	call   1002e0 <init_keyboard_drv>
}
  1000db:	83 c4 08             	add    $0x8,%esp
  1000de:	5d                   	pop    %ebp
  1000df:	c3                   	ret    

001000e0 <translate_scancode>:

static uint8_t buffer[4096];
static int bfindex = 0;

uint8_t translate_scancode(int set, uint16_t scancode)
{
  1000e0:	55                   	push   %ebp
  1000e1:	89 e5                	mov    %esp,%ebp
  1000e3:	83 ec 28             	sub    $0x28,%esp
  1000e6:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
  1000ea:	66 89 c1             	mov    %ax,%cx
  1000ed:	8b 45 08             	mov    0x8(%ebp),%eax
  1000f0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1000f3:	66 89 4d fa          	mov    %cx,-0x6(%ebp)
  uint8_t keycode = 0;
  1000f7:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)

  switch (set) {
  1000fb:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1000fe:	89 c2                	mov    %eax,%edx
  100100:	83 ea 02             	sub    $0x2,%edx
  100103:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100106:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100109:	0f 84 4f 00 00 00    	je     10015e <translate_scancode+0x7e>
  10010f:	e9 00 00 00 00       	jmp    100114 <translate_scancode+0x34>
  100114:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100117:	83 e8 01             	sub    $0x1,%eax
  10011a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10011d:	0f 84 28 00 00 00    	je     10014b <translate_scancode+0x6b>
  100123:	e9 00 00 00 00       	jmp    100128 <translate_scancode+0x48>
  100128:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10012b:	85 c0                	test   %eax,%eax
  10012d:	0f 85 54 00 00 00    	jne    100187 <translate_scancode+0xa7>
  100133:	e9 00 00 00 00       	jmp    100138 <translate_scancode+0x58>
    case 0:
      keycode = sc_to_kc[0][scancode];
  100138:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10013c:	8a 0c 05 00 60 10 00 	mov    0x106000(,%eax,1),%cl
  100143:	88 4d f9             	mov    %cl,-0x7(%ebp)
      break;
  100146:	e9 3c 00 00 00       	jmp    100187 <translate_scancode+0xa7>
    case 1:
      keycode = sc_to_kc[1][scancode];
  10014b:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  10014f:	8a 0c 05 80 60 10 00 	mov    0x106080(,%eax,1),%cl
  100156:	88 4d f9             	mov    %cl,-0x7(%ebp)
      break;
  100159:	e9 29 00 00 00       	jmp    100187 <translate_scancode+0xa7>
    case 2:
      switch (scancode) {
  10015e:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
  100162:	2d 1d 45 00 00       	sub    $0x451d,%eax
  100167:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10016a:	0f 85 0e 00 00 00    	jne    10017e <translate_scancode+0x9e>
  100170:	e9 00 00 00 00       	jmp    100175 <translate_scancode+0x95>
        case 0x451D:
          keycode = 119;
  100175:	c6 45 f9 77          	movb   $0x77,-0x7(%ebp)
          break;
  100179:	e9 04 00 00 00       	jmp    100182 <translate_scancode+0xa2>

        default:
          keycode = 0x0;	
  10017e:	c6 45 f9 00          	movb   $0x0,-0x7(%ebp)
      };
      break;
  100182:	e9 00 00 00 00       	jmp    100187 <translate_scancode+0xa7>
  }

  if (keycode == 0) {
  100187:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  10018b:	3d 00 00 00 00       	cmp    $0x0,%eax
  100190:	0f 85 20 00 00 00    	jne    1001b6 <translate_scancode+0xd6>
  100196:	8d 05 37 71 10 00    	lea    0x107137,%eax
      kprintf("kbc: Unbekannter Scancode: 0x%x (%d)\n", scancode, set);
  10019c:	0f b7 4d fa          	movzwl -0x6(%ebp),%ecx
  1001a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
  1001a3:	89 04 24             	mov    %eax,(%esp)
  1001a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1001aa:	89 54 24 08          	mov    %edx,0x8(%esp)
  1001ae:	e8 9d 03 00 00       	call   100550 <kprintf>
  1001b3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }

  return keycode;
  1001b6:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
  1001ba:	83 c4 28             	add    $0x28,%esp
  1001bd:	5d                   	pop    %ebp
  1001be:	c3                   	ret    
  1001bf:	90                   	nop

001001c0 <keyboard_handler>:
}

void keyboard_handler() {    
  1001c0:	55                   	push   %ebp
  1001c1:	89 e5                	mov    %esp,%ebp
  return;
  1001c3:	5d                   	pop    %ebp
  1001c4:	c3                   	ret    
  1001c5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1001cc:	00 00 00 00 

001001d0 <getc>:
		//buffer[bfindex] = keycode;
		//bfindex++;	
	}
}

char getc() {
  1001d0:	55                   	push   %ebp
  1001d1:	89 e5                	mov    %esp,%ebp
	char ret = buffer[0];
  1001d3:	83 ec 08             	sub    $0x8,%esp
  1001d6:	a0 0a 80 10 00       	mov    0x10800a,%al
  1001db:	88 45 ff             	mov    %al,-0x1(%ebp)
	
	int i;
	for(i = 0; i < bfindex; i++) {
  1001de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1001e5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001e8:	3b 05 0c 90 10 00    	cmp    0x10900c,%eax
  1001ee:	0f 8d 24 00 00 00    	jge    100218 <getc+0x48>
		buffer[i] = buffer[i+1];	
  1001f4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1001f7:	8a 0c 05 0b 80 10 00 	mov    0x10800b(,%eax,1),%cl
  1001fe:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100201:	88 0c 05 0a 80 10 00 	mov    %cl,0x10800a(,%eax,1)

char getc() {
	char ret = buffer[0];
	
	int i;
	for(i = 0; i < bfindex; i++) {
  100208:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10020b:	05 01 00 00 00       	add    $0x1,%eax
  100210:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100213:	e9 cd ff ff ff       	jmp    1001e5 <getc+0x15>
		buffer[i] = buffer[i+1];	
	}
	bfindex--;
  100218:	a1 0c 90 10 00       	mov    0x10900c,%eax
  10021d:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100222:	a3 0c 90 10 00       	mov    %eax,0x10900c

	return ret;
  100227:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  10022b:	83 c4 08             	add    $0x8,%esp
  10022e:	5d                   	pop    %ebp
  10022f:	c3                   	ret    

00100230 <send_command>:
}

void send_command(uint8_t command) {
  100230:	55                   	push   %ebp
  100231:	89 e5                	mov    %esp,%ebp
  100233:	83 ec 18             	sub    $0x18,%esp
  100236:	8a 45 08             	mov    0x8(%ebp),%al
  100239:	88 45 ff             	mov    %al,-0x1(%ebp)
  10023c:	b8 64 00 00 00       	mov    $0x64,%eax
	while((inb(0x64) & 0x2)) { }
  100241:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100248:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10024b:	e8 40 00 00 00       	call   100290 <inb>
  100250:	0f b6 c8             	movzbl %al,%ecx
  100253:	81 e1 02 00 00 00    	and    $0x2,%ecx
  100259:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  10025f:	0f 84 05 00 00 00    	je     10026a <send_command+0x3a>
  100265:	e9 d2 ff ff ff       	jmp    10023c <send_command+0xc>
  10026a:	b8 60 00 00 00       	mov    $0x60,%eax
	outb(0x60, command);
  10026f:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100276:	0f b6 4d ff          	movzbl -0x1(%ebp),%ecx
  10027a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10027e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100281:	e8 2a 00 00 00       	call   1002b0 <outb>
}
  100286:	83 c4 18             	add    $0x18,%esp
  100289:	5d                   	pop    %ebp
  10028a:	c3                   	ret    
  10028b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00100290 <inb>:
    uint16_t result;
    asm volatile ("inw %1, %0" : "=a" (result) : "Nd" (_port));
    return result;
}

static inline uint8_t inb(uint16_t _port) {
  100290:	55                   	push   %ebp
  100291:	89 e5                	mov    %esp,%ebp
  100293:	50                   	push   %eax
  100294:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  100298:	66 89 c1             	mov    %ax,%cx
  10029b:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
    uint8_t result;
    asm volatile ("inb %1, %0" : "=a" (result) : "Nd" (_port));
  10029f:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1002a3:	ec                   	in     (%dx),%al
  1002a4:	88 45 fd             	mov    %al,-0x3(%ebp)
    return result;
  1002a7:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
  1002ab:	83 c4 04             	add    $0x4,%esp
  1002ae:	5d                   	pop    %ebp
  1002af:	c3                   	ret    

001002b0 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  1002b0:	55                   	push   %ebp
  1002b1:	89 e5                	mov    %esp,%ebp
  1002b3:	50                   	push   %eax
  1002b4:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  1002b8:	66 89 c1             	mov    %ax,%cx
  1002bb:	8a 55 0c             	mov    0xc(%ebp),%dl
  1002be:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  1002c2:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  1002c5:	8a 45 fd             	mov    -0x3(%ebp),%al
  1002c8:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  1002cc:	ee                   	out    %al,(%dx)
}
  1002cd:	83 c4 04             	add    $0x4,%esp
  1002d0:	5d                   	pop    %ebp
  1002d1:	c3                   	ret    
  1002d2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1002d9:	1f 84 00 00 00 00 00 

001002e0 <init_keyboard_drv>:

void init_keyboard_drv() {
  1002e0:	55                   	push   %ebp
  1002e1:	89 e5                	mov    %esp,%ebp
  1002e3:	83 ec 28             	sub    $0x28,%esp
  1002e6:	b8 21 00 00 00       	mov    $0x21,%eax
  1002eb:	8d 0d c0 01 10 00    	lea    0x1001c0,%ecx
	register_intr_handler(0x21, &keyboard_handler);
  1002f1:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  1002f8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1002fc:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1002ff:	e8 5c 16 00 00       	call   101960 <register_intr_handler>
  100304:	b8 64 00 00 00       	mov    $0x64,%eax

	while(inb(0x64) & 0x1) {
  100309:	c7 04 24 64 00 00 00 	movl   $0x64,(%esp)
  100310:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100313:	e8 78 ff ff ff       	call   100290 <inb>
  100318:	0f b6 c8             	movzbl %al,%ecx
  10031b:	81 e1 01 00 00 00    	and    $0x1,%ecx
  100321:	81 f9 00 00 00 00    	cmp    $0x0,%ecx
  100327:	0f 84 1c 00 00 00    	je     100349 <init_keyboard_drv+0x69>
  10032d:	b8 60 00 00 00       	mov    $0x60,%eax
		inb(0x60);
  100332:	c7 04 24 60 00 00 00 	movl   $0x60,(%esp)
  100339:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10033c:	e8 4f ff ff ff       	call   100290 <inb>
	}
  100341:	88 45 f3             	mov    %al,-0xd(%ebp)
  100344:	e9 bb ff ff ff       	jmp    100304 <init_keyboard_drv+0x24>
  100349:	b8 f4 00 00 00       	mov    $0xf4,%eax

	send_command(0xF4);
  10034e:	c7 04 24 f4 00 00 00 	movl   $0xf4,(%esp)
  100355:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100358:	e8 d3 fe ff ff       	call   100230 <send_command>

	init_done = 1;
  10035d:	c7 05 10 90 10 00 01 	movl   $0x1,0x109010
  100364:	00 00 00 
}
  100367:	83 c4 28             	add    $0x28,%esp
  10036a:	5d                   	pop    %ebp
  10036b:	c3                   	ret    
  10036c:	66 90                	xchg   %ax,%ax
  10036e:	66 90                	xchg   %ax,%ax

00100370 <show_cod>:
#include "catofdeath.h"

void show_cod(struct cpu_state* cpu, char* fstr) {
  100370:	55                   	push   %ebp
  100371:	89 e5                	mov    %esp,%ebp
  100373:	56                   	push   %esi
  100374:	83 ec 24             	sub    $0x24,%esp
  100377:	8b 45 0c             	mov    0xc(%ebp),%eax
  10037a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10037d:	ba 04 00 00 00       	mov    $0x4,%edx
  100382:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100385:	89 45 f4             	mov    %eax,-0xc(%ebp)
    kprintf ("          '''  \\   `-._.'`---^_))) \n");
    kprintf ("                `-._ )))       ``` \n");
    kprintf ("                     ```            \n");
#endif

    setclr(0x04);
  100388:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10038f:	89 55 f0             	mov    %edx,-0x10(%ebp)
  100392:	e8 99 01 00 00       	call   100530 <setclr>
    kprintf(fstr);
  100397:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10039a:	89 04 24             	mov    %eax,(%esp)
  10039d:	e8 ae 01 00 00       	call   100550 <kprintf>
  1003a2:	8d 0d 5d 71 10 00    	lea    0x10715d,%ecx
    kprintf("\n\nException I:%d E:%x, Kernel halt!\n", cpu->intr, cpu->error);
  1003a8:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1003ab:	8b 52 1c             	mov    0x1c(%edx),%edx
  1003ae:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1003b1:	8b 76 20             	mov    0x20(%esi),%esi
  1003b4:	89 0c 24             	mov    %ecx,(%esp)
  1003b7:	89 54 24 04          	mov    %edx,0x4(%esp)
  1003bb:	89 74 24 08          	mov    %esi,0x8(%esp)
  1003bf:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1003c2:	e8 89 01 00 00       	call   100550 <kprintf>
    show_dump(cpu);
  1003c7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1003ca:	89 0c 24             	mov    %ecx,(%esp)
  1003cd:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1003d0:	e8 0b 00 00 00       	call   1003e0 <show_dump>

    while (1) {
        asm volatile("cli; hlt");
  1003d5:	fa                   	cli    
  1003d6:	f4                   	hlt    
    }
  1003d7:	e9 f9 ff ff ff       	jmp    1003d5 <show_cod+0x65>
  1003dc:	0f 1f 40 00          	nopl   0x0(%eax)

001003e0 <show_dump>:
}

void show_dump(struct cpu_state* cpu) {
  1003e0:	55                   	push   %ebp
  1003e1:	89 e5                	mov    %esp,%ebp
  1003e3:	53                   	push   %ebx
  1003e4:	57                   	push   %edi
  1003e5:	56                   	push   %esi
  1003e6:	83 ec 2c             	sub    $0x2c,%esp
  1003e9:	8b 45 08             	mov    0x8(%ebp),%eax
  1003ec:	8d 0d 82 71 10 00    	lea    0x107182,%ecx
  1003f2:	89 45 f0             	mov    %eax,-0x10(%ebp)
    kprintf("EAX: %x EBX: %x ECX: %x EDX: %x\n", cpu->eax, cpu->ebx, cpu->ecx,
  1003f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1003f8:	8b 00                	mov    (%eax),%eax
  1003fa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1003fd:	8b 52 04             	mov    0x4(%edx),%edx
  100400:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100403:	8b 76 08             	mov    0x8(%esi),%esi
  100406:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100409:	8b 7f 0c             	mov    0xc(%edi),%edi
  10040c:	89 0c 24             	mov    %ecx,(%esp)
  10040f:	89 44 24 04          	mov    %eax,0x4(%esp)
  100413:	89 54 24 08          	mov    %edx,0x8(%esp)
  100417:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10041b:	89 7c 24 10          	mov    %edi,0x10(%esp)
  10041f:	e8 2c 01 00 00       	call   100550 <kprintf>
  100424:	8d 0d a3 71 10 00    	lea    0x1071a3,%ecx
            cpu->edx);
    kprintf("ESI: %x EDI: %x EBP: %x EIP: %x\n", cpu->esi, cpu->edi, cpu->ebp,
  10042a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10042d:	8b 52 10             	mov    0x10(%edx),%edx
  100430:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100433:	8b 76 14             	mov    0x14(%esi),%esi
  100436:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100439:	8b 7f 18             	mov    0x18(%edi),%edi
  10043c:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  10043f:	8b 5b 24             	mov    0x24(%ebx),%ebx
  100442:	89 0c 24             	mov    %ecx,(%esp)
  100445:	89 54 24 04          	mov    %edx,0x4(%esp)
  100449:	89 74 24 08          	mov    %esi,0x8(%esp)
  10044d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  100451:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  100455:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100458:	e8 f3 00 00 00       	call   100550 <kprintf>
  10045d:	8d 0d c4 71 10 00    	lea    0x1071c4,%ecx
            cpu->eip);
    kprintf("CS: %x EFLAGS: %x ESP: %x SS: %x\n", cpu->cs, cpu->eflags,
  100463:	8b 55 f0             	mov    -0x10(%ebp),%edx
  100466:	8b 52 28             	mov    0x28(%edx),%edx
  100469:	8b 75 f0             	mov    -0x10(%ebp),%esi
  10046c:	8b 76 2c             	mov    0x2c(%esi),%esi
  10046f:	8b 7d f0             	mov    -0x10(%ebp),%edi
  100472:	8b 7f 30             	mov    0x30(%edi),%edi
  100475:	8b 5d f0             	mov    -0x10(%ebp),%ebx
  100478:	8b 5b 34             	mov    0x34(%ebx),%ebx
  10047b:	89 0c 24             	mov    %ecx,(%esp)
  10047e:	89 54 24 04          	mov    %edx,0x4(%esp)
  100482:	89 74 24 08          	mov    %esi,0x8(%esp)
  100486:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  10048a:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  10048e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100491:	e8 ba 00 00 00       	call   100550 <kprintf>
  100496:	8d 0d e6 71 10 00    	lea    0x1071e6,%ecx
            cpu->esp, cpu->ss);

    uint32_t cr2 = 0;
  10049c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    asm volatile("mov %%cr2, %0" : "=r" (cr2));
  1004a3:	0f 20 d2             	mov    %cr2,%edx
  1004a6:	89 55 ec             	mov    %edx,-0x14(%ebp)

    kprintf("CR2: %x \n", cr2);
  1004a9:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1004ac:	89 0c 24             	mov    %ecx,(%esp)
  1004af:	89 54 24 04          	mov    %edx,0x4(%esp)
  1004b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1004b6:	e8 95 00 00 00       	call   100550 <kprintf>
}
  1004bb:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1004be:	83 c4 2c             	add    $0x2c,%esp
  1004c1:	5e                   	pop    %esi
  1004c2:	5f                   	pop    %edi
  1004c3:	5b                   	pop    %ebx
  1004c4:	5d                   	pop    %ebp
  1004c5:	c3                   	ret    
  1004c6:	66 90                	xchg   %ax,%ax
  1004c8:	66 90                	xchg   %ax,%ax
  1004ca:	66 90                	xchg   %ax,%ax
  1004cc:	66 90                	xchg   %ax,%ax
  1004ce:	66 90                	xchg   %ax,%ax

001004d0 <clrscr>:
        x /= base;
    } while (x);
    kputs(p);
}

void clrscr(void) {
  1004d0:	55                   	push   %ebp
  1004d1:	89 e5                	mov    %esp,%ebp
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  1004d3:	50                   	push   %eax
  1004d4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1004db:	81 7d fc a0 0f 00 00 	cmpl   $0xfa0,-0x4(%ebp)
  1004e2:	0f 8d 1d 00 00 00    	jge    100505 <clrscr+0x35>
        video[i] = 0;
  1004e8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004eb:	8b 0d 00 61 10 00    	mov    0x106100,%ecx
  1004f1:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
    kputs(p);
}

void clrscr(void) {
    int i;
    for (i = 0; i < 2 * 25 * 80; i++) {
  1004f5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1004f8:	05 01 00 00 00       	add    $0x1,%eax
  1004fd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  100500:	e9 d6 ff ff ff       	jmp    1004db <clrscr+0xb>
        video[i] = 0;
    }

    color = 0x07;
  100505:	c6 05 04 61 10 00 07 	movb   $0x7,0x106104

    x = y = 0;
  10050c:	c7 05 14 90 10 00 00 	movl   $0x0,0x109014
  100513:	00 00 00 
  100516:	c7 05 18 90 10 00 00 	movl   $0x0,0x109018
  10051d:	00 00 00 
}
  100520:	83 c4 04             	add    $0x4,%esp
  100523:	5d                   	pop    %ebp
  100524:	c3                   	ret    
  100525:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  10052c:	00 00 00 00 

00100530 <setclr>:

void setclr(char clr) {
  100530:	55                   	push   %ebp
  100531:	89 e5                	mov    %esp,%ebp
  100533:	50                   	push   %eax
  100534:	8a 45 08             	mov    0x8(%ebp),%al
  100537:	88 45 ff             	mov    %al,-0x1(%ebp)
    color = clr;
  10053a:	8a 45 ff             	mov    -0x1(%ebp),%al
  10053d:	a2 04 61 10 00       	mov    %al,0x106104
}
  100542:	83 c4 04             	add    $0x4,%esp
  100545:	5d                   	pop    %ebp
  100546:	c3                   	ret    
  100547:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10054e:	00 00 

00100550 <kprintf>:

int kprintf(const char* fmt, ...) {
  100550:	55                   	push   %ebp
  100551:	89 e5                	mov    %esp,%ebp
  100553:	83 ec 58             	sub    $0x58,%esp
  100556:	8b 45 08             	mov    0x8(%ebp),%eax
  100559:	8d 4d f8             	lea    -0x8(%ebp),%ecx
  10055c:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10055f:	8d 45 0c             	lea    0xc(%ebp),%eax
    va_list ap;
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
  100562:	89 01                	mov    %eax,(%ecx)
    kprintf_res = 0;
  100564:	c7 05 1c 90 10 00 00 	movl   $0x0,0x10901c
  10056b:	00 00 00 
    while (*fmt) {
  10056e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100571:	80 38 00             	cmpb   $0x0,(%eax)
  100574:	0f 84 dd 01 00 00    	je     100757 <kprintf+0x207>
        if (*fmt == '%') {
  10057a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10057d:	0f be 00             	movsbl (%eax),%eax
  100580:	3d 25 00 00 00       	cmp    $0x25,%eax
  100585:	0f 85 ae 01 00 00    	jne    100739 <kprintf+0x1e9>
            fmt++;
  10058b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10058e:	89 c1                	mov    %eax,%ecx
  100590:	41                   	inc    %ecx
  100591:	89 4d fc             	mov    %ecx,-0x4(%ebp)
            switch (*fmt) {
  100594:	0f be 40 01          	movsbl 0x1(%eax),%eax
  100598:	89 c1                	mov    %eax,%ecx
  10059a:	83 e9 24             	sub    $0x24,%ecx
  10059d:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1005a0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  1005a3:	0f 8f 15 00 00 00    	jg     1005be <kprintf+0x6e>
  1005a9:	e9 00 00 00 00       	jmp    1005ae <kprintf+0x5e>
  1005ae:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005b1:	85 c0                	test   %eax,%eax
  1005b3:	0f 84 54 01 00 00    	je     10070d <kprintf+0x1bd>
  1005b9:	e9 54 01 00 00       	jmp    100712 <kprintf+0x1c2>
  1005be:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005c1:	83 e8 62             	sub    $0x62,%eax
  1005c4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  1005c7:	0f 8f 19 00 00 00    	jg     1005e6 <kprintf+0x96>
  1005cd:	e9 00 00 00 00       	jmp    1005d2 <kprintf+0x82>
  1005d2:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005d5:	83 e8 25             	sub    $0x25,%eax
  1005d8:	89 45 dc             	mov    %eax,-0x24(%ebp)
  1005db:	0f 84 13 01 00 00    	je     1006f4 <kprintf+0x1a4>
  1005e1:	e9 2c 01 00 00       	jmp    100712 <kprintf+0x1c2>
  1005e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005e9:	83 e8 6f             	sub    $0x6f,%eax
  1005ec:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1005ef:	0f 8f 2d 00 00 00    	jg     100622 <kprintf+0xd2>
  1005f5:	e9 00 00 00 00       	jmp    1005fa <kprintf+0xaa>
  1005fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1005fd:	83 e8 63             	sub    $0x63,%eax
  100600:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100603:	0f 84 c5 00 00 00    	je     1006ce <kprintf+0x17e>
  100609:	e9 00 00 00 00       	jmp    10060e <kprintf+0xbe>
  10060e:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100611:	83 e8 64             	sub    $0x64,%eax
  100614:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100617:	0f 84 4b 00 00 00    	je     100668 <kprintf+0x118>
  10061d:	e9 f0 00 00 00       	jmp    100712 <kprintf+0x1c2>
  100622:	8b 45 e8             	mov    -0x18(%ebp),%eax
  100625:	83 c0 90             	add    $0xffffff90,%eax
  100628:	89 c1                	mov    %eax,%ecx
  10062a:	83 e9 08             	sub    $0x8,%ecx
  10062d:	89 45 cc             	mov    %eax,-0x34(%ebp)
  100630:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  100633:	0f 87 d9 00 00 00    	ja     100712 <kprintf+0x1c2>
  100639:	8b 45 cc             	mov    -0x34(%ebp),%eax
  10063c:	8b 0c 85 00 70 10 00 	mov    0x107000(,%eax,4),%ecx
  100643:	ff e1                	jmp    *%ecx
            case 's':
                s = va_arg(ap, char*);
  100645:	8b 45 f8             	mov    -0x8(%ebp),%eax
  100648:	89 c1                	mov    %eax,%ecx
  10064a:	81 c1 04 00 00 00    	add    $0x4,%ecx
  100650:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  100653:	8b 00                	mov    (%eax),%eax
  100655:	89 45 f4             	mov    %eax,-0xc(%ebp)
                kputs(s);
  100658:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10065b:	89 04 24             	mov    %eax,(%esp)
  10065e:	e8 0d 01 00 00       	call   100770 <kputs>
                break;
  100663:	e9 cc 00 00 00       	jmp    100734 <kprintf+0x1e4>
  100668:	b8 0a 00 00 00       	mov    $0xa,%eax
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
  10066d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100670:	89 ca                	mov    %ecx,%edx
  100672:	81 c2 04 00 00 00    	add    $0x4,%edx
  100678:	89 55 f8             	mov    %edx,-0x8(%ebp)
  10067b:	8b 09                	mov    (%ecx),%ecx
  10067d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 10);
  100680:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  100683:	89 0c 24             	mov    %ecx,(%esp)
  100686:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  10068d:	00 
  10068e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  100691:	e8 1a 01 00 00       	call   1007b0 <kputn>
                break;
  100696:	e9 99 00 00 00       	jmp    100734 <kprintf+0x1e4>
  10069b:	b8 10 00 00 00       	mov    $0x10,%eax
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
  1006a0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1006a3:	89 ca                	mov    %ecx,%edx
  1006a5:	81 c2 04 00 00 00    	add    $0x4,%edx
  1006ab:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1006ae:	8b 09                	mov    (%ecx),%ecx
  1006b0:	89 4d f0             	mov    %ecx,-0x10(%ebp)
                kputn(n, 16);
  1006b3:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1006b6:	89 0c 24             	mov    %ecx,(%esp)
  1006b9:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
  1006c0:	00 
  1006c1:	89 45 c0             	mov    %eax,-0x40(%ebp)
  1006c4:	e8 e7 00 00 00       	call   1007b0 <kputn>
                break;
  1006c9:	e9 66 00 00 00       	jmp    100734 <kprintf+0x1e4>
            case 'c':
                c = va_arg(ap, int);
  1006ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1006d1:	89 c1                	mov    %eax,%ecx
  1006d3:	81 c1 04 00 00 00    	add    $0x4,%ecx
  1006d9:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1006dc:	8b 00                	mov    (%eax),%eax
  1006de:	88 c2                	mov    %al,%dl
  1006e0:	88 55 ef             	mov    %dl,-0x11(%ebp)
                kputc(c);
  1006e3:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
  1006e7:	89 04 24             	mov    %eax,(%esp)
  1006ea:	e8 61 01 00 00       	call   100850 <kputc>
                break;
  1006ef:	e9 40 00 00 00       	jmp    100734 <kprintf+0x1e4>
  1006f4:	b8 25 00 00 00       	mov    $0x25,%eax
            case '%':
                kputc('%');
  1006f9:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  100700:	89 45 bc             	mov    %eax,-0x44(%ebp)
  100703:	e8 48 01 00 00       	call   100850 <kputc>
                break;
  100708:	e9 27 00 00 00       	jmp    100734 <kprintf+0x1e4>
            case '\0':
                goto out;
  10070d:	e9 4a 00 00 00       	jmp    10075c <kprintf+0x20c>
  100712:	b8 25 00 00 00       	mov    $0x25,%eax
            default:
                kputc('%');
  100717:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  10071e:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100721:	e8 2a 01 00 00       	call   100850 <kputc>
                kputc(*fmt);
  100726:	8b 45 fc             	mov    -0x4(%ebp),%eax
  100729:	0f be 00             	movsbl (%eax),%eax
  10072c:	89 04 24             	mov    %eax,(%esp)
  10072f:	e8 1c 01 00 00       	call   100850 <kputc>
                break;
            }
        } else {
  100734:	e9 0e 00 00 00       	jmp    100747 <kprintf+0x1f7>
            kputc(*fmt);
  100739:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10073c:	0f be 00             	movsbl (%eax),%eax
  10073f:	89 04 24             	mov    %eax,(%esp)
  100742:	e8 09 01 00 00       	call   100850 <kputc>
        }

        fmt++;
  100747:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10074a:	05 01 00 00 00       	add    $0x1,%eax
  10074f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  100752:	e9 17 fe ff ff       	jmp    10056e <kprintf+0x1e>
  100757:	e9 00 00 00 00       	jmp    10075c <kprintf+0x20c>

    out:
    va_end(ap);

    return kprintf_res;
  10075c:	a1 1c 90 10 00       	mov    0x10901c,%eax
  100761:	83 c4 58             	add    $0x58,%esp
  100764:	5d                   	pop    %ebp
  100765:	c3                   	ret    
  100766:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10076d:	00 00 00 

00100770 <kputs>:

    x++;
    kprintf_res++;
}

static void kputs(const char* s) {
  100770:	55                   	push   %ebp
  100771:	89 e5                	mov    %esp,%ebp
  100773:	83 ec 08             	sub    $0x8,%esp
  100776:	8b 45 08             	mov    0x8(%ebp),%eax
  100779:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while (*s) {
  10077c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10077f:	80 38 00             	cmpb   $0x0,(%eax)
  100782:	0f 84 1e 00 00 00    	je     1007a6 <kputs+0x36>
        kputc(*s++);
  100788:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10078b:	89 c1                	mov    %eax,%ecx
  10078d:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100793:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  100796:	0f be 00             	movsbl (%eax),%eax
  100799:	89 04 24             	mov    %eax,(%esp)
  10079c:	e8 af 00 00 00       	call   100850 <kputc>
    }
  1007a1:	e9 d6 ff ff ff       	jmp    10077c <kputs+0xc>
}
  1007a6:	83 c4 08             	add    $0x8,%esp
  1007a9:	5d                   	pop    %ebp
  1007aa:	c3                   	ret    
  1007ab:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

001007b0 <kputn>:

static void kputn(unsigned long x, int base) {
  1007b0:	55                   	push   %ebp
  1007b1:	89 e5                	mov    %esp,%ebp
  1007b3:	56                   	push   %esi
  1007b4:	83 ec 64             	sub    $0x64,%esp
  1007b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1007ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1007bd:	8d 15 f0 71 10 00    	lea    0x1071f0,%edx
  1007c3:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1007c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
  1007c9:	89 55 ac             	mov    %edx,-0x54(%ebp)
    char* p;

    if (base > 36) {
  1007cc:	81 7d f4 24 00 00 00 	cmpl   $0x24,-0xc(%ebp)
  1007d3:	0f 8e 05 00 00 00    	jle    1007de <kputn+0x2e>
        return;
  1007d9:	e9 5d 00 00 00       	jmp    10083b <kputn+0x8b>
  1007de:	8d 45 b3             	lea    -0x4d(%ebp),%eax
    }

    p = buf + 64;
  1007e1:	05 40 00 00 00       	add    $0x40,%eax
  1007e6:	89 45 a8             	mov    %eax,-0x58(%ebp)
    *p = '\0';
  1007e9:	8b 45 a8             	mov    -0x58(%ebp),%eax
  1007ec:	c6 00 00             	movb   $0x0,(%eax)
    do {
        *--p = digits[x % base];
  1007ef:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1007f2:	31 d2                	xor    %edx,%edx
  1007f4:	f7 75 f4             	divl   -0xc(%ebp)
  1007f7:	8b 45 ac             	mov    -0x54(%ebp),%eax
  1007fa:	8a 0c 10             	mov    (%eax,%edx,1),%cl
  1007fd:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100800:	89 c2                	mov    %eax,%edx
  100802:	81 c2 ff ff ff ff    	add    $0xffffffff,%edx
  100808:	89 55 a8             	mov    %edx,-0x58(%ebp)
  10080b:	88 48 ff             	mov    %cl,-0x1(%eax)
        x /= base;
  10080e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100811:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100814:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  100817:	89 d0                	mov    %edx,%eax
  100819:	31 d2                	xor    %edx,%edx
  10081b:	8b 75 a4             	mov    -0x5c(%ebp),%esi
  10081e:	f7 f6                	div    %esi
  100820:	89 45 f8             	mov    %eax,-0x8(%ebp)
    } while (x);
  100823:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10082a:	0f 85 bf ff ff ff    	jne    1007ef <kputn+0x3f>
    kputs(p);
  100830:	8b 45 a8             	mov    -0x58(%ebp),%eax
  100833:	89 04 24             	mov    %eax,(%esp)
  100836:	e8 35 ff ff ff       	call   100770 <kputs>
}
  10083b:	83 c4 64             	add    $0x64,%esp
  10083e:	5e                   	pop    %esi
  10083f:	5d                   	pop    %ebp
  100840:	c3                   	ret    
  100841:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  100848:	0f 1f 84 00 00 00 00 
  10084f:	00 

00100850 <kputc>:
static int kprintf_res = 0;
static char color = 0x07;

static char* video = (char*) 0xb8000;

static void kputc(char c) {
  100850:	55                   	push   %ebp
  100851:	89 e5                	mov    %esp,%ebp
  100853:	83 ec 08             	sub    $0x8,%esp
  100856:	8a 45 08             	mov    0x8(%ebp),%al
  100859:	88 45 ff             	mov    %al,-0x1(%ebp)
    if ((c == '\n') || (x > 79)) {
  10085c:	0f be 4d ff          	movsbl -0x1(%ebp),%ecx
  100860:	81 f9 0a 00 00 00    	cmp    $0xa,%ecx
  100866:	0f 84 10 00 00 00    	je     10087c <kputc+0x2c>
  10086c:	81 3d 18 90 10 00 4f 	cmpl   $0x4f,0x109018
  100873:	00 00 00 
  100876:	0f 8e 19 00 00 00    	jle    100895 <kputc+0x45>
        x = 0;
  10087c:	c7 05 18 90 10 00 00 	movl   $0x0,0x109018
  100883:	00 00 00 
        y++;
  100886:	a1 14 90 10 00       	mov    0x109014,%eax
  10088b:	05 01 00 00 00       	add    $0x1,%eax
  100890:	a3 14 90 10 00       	mov    %eax,0x109014
    }

    if (c == '\n') {
  100895:	0f be 45 ff          	movsbl -0x1(%ebp),%eax
  100899:	3d 0a 00 00 00       	cmp    $0xa,%eax
  10089e:	0f 85 05 00 00 00    	jne    1008a9 <kputc+0x59>
        return;
  1008a4:	e9 f3 00 00 00       	jmp    10099c <kputc+0x14c>
    }

    if (y > 24) {
  1008a9:	81 3d 14 90 10 00 18 	cmpl   $0x18,0x109014
  1008b0:	00 00 00 
  1008b3:	0f 8e 7e 00 00 00    	jle    100937 <kputc+0xe7>
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  1008b9:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1008c0:	81 7d f8 00 0f 00 00 	cmpl   $0xf00,-0x8(%ebp)
  1008c7:	0f 8d 2c 00 00 00    	jge    1008f9 <kputc+0xa9>
            video[i] = video[i + 160];
  1008cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1008d0:	8b 0d 00 61 10 00    	mov    0x106100,%ecx
  1008d6:	8a 94 01 a0 00 00 00 	mov    0xa0(%ecx,%eax,1),%dl
  1008dd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1008e0:	8b 0d 00 61 10 00    	mov    0x106100,%ecx
  1008e6:	88 14 01             	mov    %dl,(%ecx,%eax,1)
        return;
    }

    if (y > 24) {
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
  1008e9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1008ec:	05 01 00 00 00       	add    $0x1,%eax
  1008f1:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1008f4:	e9 c7 ff ff ff       	jmp    1008c0 <kputc+0x70>
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  1008f9:	e9 00 00 00 00       	jmp    1008fe <kputc+0xae>
  1008fe:	81 7d f8 a0 0f 00 00 	cmpl   $0xfa0,-0x8(%ebp)
  100905:	0f 8d 1d 00 00 00    	jge    100928 <kputc+0xd8>
            video[i] = 0;
  10090b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10090e:	8b 0d 00 61 10 00    	mov    0x106100,%ecx
  100914:	c6 04 01 00          	movb   $0x0,(%ecx,%eax,1)
        int i;
        for (i = 0; i < 2 * 24 * 80; i++) {
            video[i] = video[i + 160];
        }

        for (; i < 2 * 25 * 80; i++) {
  100918:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10091b:	05 01 00 00 00       	add    $0x1,%eax
  100920:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100923:	e9 d6 ff ff ff       	jmp    1008fe <kputc+0xae>
            video[i] = 0;
        }
        y--;
  100928:	a1 14 90 10 00       	mov    0x109014,%eax
  10092d:	05 ff ff ff ff       	add    $0xffffffff,%eax
  100932:	a3 14 90 10 00       	mov    %eax,0x109014
    }

    video[2 * (y * 80 + x)] = c;
  100937:	8a 45 ff             	mov    -0x1(%ebp),%al
  10093a:	69 0d 14 90 10 00 50 	imul   $0x50,0x109014,%ecx
  100941:	00 00 00 
  100944:	03 0d 18 90 10 00    	add    0x109018,%ecx
  10094a:	c1 e1 01             	shl    $0x1,%ecx
  10094d:	8b 15 00 61 10 00    	mov    0x106100,%edx
  100953:	88 04 0a             	mov    %al,(%edx,%ecx,1)
    video[2 * (y * 80 + x) + 1] = color;
  100956:	a0 04 61 10 00       	mov    0x106104,%al
  10095b:	69 0d 14 90 10 00 50 	imul   $0x50,0x109014,%ecx
  100962:	00 00 00 
  100965:	03 0d 18 90 10 00    	add    0x109018,%ecx
  10096b:	c1 e1 01             	shl    $0x1,%ecx
  10096e:	8b 15 00 61 10 00    	mov    0x106100,%edx
  100974:	88 44 0a 01          	mov    %al,0x1(%edx,%ecx,1)

    x++;
  100978:	8b 0d 18 90 10 00    	mov    0x109018,%ecx
  10097e:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100984:	89 0d 18 90 10 00    	mov    %ecx,0x109018
    kprintf_res++;
  10098a:	8b 0d 1c 90 10 00    	mov    0x10901c,%ecx
  100990:	81 c1 01 00 00 00    	add    $0x1,%ecx
  100996:	89 0d 1c 90 10 00    	mov    %ecx,0x10901c
}
  10099c:	83 c4 08             	add    $0x8,%esp
  10099f:	5d                   	pop    %ebp
  1009a0:	c3                   	ret    
  1009a1:	66 90                	xchg   %ax,%ax
  1009a3:	66 90                	xchg   %ax,%ax
  1009a5:	66 90                	xchg   %ax,%ax
  1009a7:	66 90                	xchg   %ax,%ax
  1009a9:	66 90                	xchg   %ax,%ax
  1009ab:	66 90                	xchg   %ax,%ax
  1009ad:	66 90                	xchg   %ax,%ax
  1009af:	90                   	nop

001009b0 <load_gdt>:

#define GDT_ENTRIES 6

uint64_t gdt[GDT_ENTRIES];

void load_gdt() {
  1009b0:	55                   	push   %ebp
  1009b1:	89 e5                	mov    %esp,%ebp
	struct {
  1009b3:	83 ec 08             	sub    $0x8,%esp
  1009b6:	a1 24 70 10 00       	mov    0x107024,%eax
  1009bb:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1009be:	66 8b 0d 28 70 10 00 	mov    0x107028,%cx
  1009c5:	66 89 4d fc          	mov    %cx,-0x4(%ebp)
		uint16_t limit;
		void* pointer;
	}__attribute__((packed)) gdtp = { .limit = GDT_ENTRIES * 8 - 1, .pointer =
			gdt, };

	asm volatile("lgdt %0" : : "m" (gdtp));
  1009c9:	0f 01 55 f8          	lgdtl  -0x8(%ebp)

	asm ("mov $0x10, %ax");
  1009cd:	66 b8 10 00          	mov    $0x10,%ax
	asm ("mov %ax, %ds");
  1009d1:	66 8e d8             	mov    %ax,%ds
	asm ("mov %ax, %es");
  1009d4:	66 8e c0             	mov    %ax,%es
	asm ("mov %ax, %fs");
  1009d7:	66 8e e0             	mov    %ax,%fs
	asm ("mov %ax, %gs");
  1009da:	66 8e e8             	mov    %ax,%gs
	asm ("mov %ax, %ss");
  1009dd:	66 8e d0             	mov    %ax,%ss
	//asm ("ljmp $0x8, $.1");
	//asm (".1:");
}
  1009e0:	83 c4 08             	add    $0x8,%esp
  1009e3:	5d                   	pop    %ebp
  1009e4:	c3                   	ret    
  1009e5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1009ec:	00 00 00 00 

001009f0 <set_gdt_entry>:

void set_gdt_entry(int i, unsigned int base, unsigned int limit, int flags) {
  1009f0:	55                   	push   %ebp
  1009f1:	89 e5                	mov    %esp,%ebp
  1009f3:	56                   	push   %esi
  1009f4:	83 ec 10             	sub    $0x10,%esp
  1009f7:	8b 45 14             	mov    0x14(%ebp),%eax
  1009fa:	8b 4d 10             	mov    0x10(%ebp),%ecx
  1009fd:	8b 55 0c             	mov    0xc(%ebp),%edx
  100a00:	8b 75 08             	mov    0x8(%ebp),%esi
  100a03:	89 75 f8             	mov    %esi,-0x8(%ebp)
  100a06:	89 55 f4             	mov    %edx,-0xc(%ebp)
  100a09:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100a0c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gdt[i] = limit & 0xffffLL;
  100a0f:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
  100a13:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100a16:	89 04 cd 60 94 12 00 	mov    %eax,0x129460(,%ecx,8)
  100a1d:	c7 04 cd 64 94 12 00 	movl   $0x0,0x129464(,%ecx,8)
  100a24:	00 00 00 00 
	gdt[i] |= (base & 0xffffffLL) << 16;
  100a28:	8b 45 f4             	mov    -0xc(%ebp),%eax
  100a2b:	25 ff ff ff 00       	and    $0xffffff,%eax
  100a30:	89 c1                	mov    %eax,%ecx
  100a32:	c1 e1 10             	shl    $0x10,%ecx
  100a35:	c1 e8 10             	shr    $0x10,%eax
  100a38:	8b 55 f8             	mov    -0x8(%ebp),%edx
  100a3b:	8b 34 d5 64 94 12 00 	mov    0x129464(,%edx,8),%esi
  100a42:	09 f0                	or     %esi,%eax
  100a44:	8b 34 d5 60 94 12 00 	mov    0x129460(,%edx,8),%esi
  100a4b:	09 ce                	or     %ecx,%esi
  100a4d:	89 04 d5 64 94 12 00 	mov    %eax,0x129464(,%edx,8)
  100a54:	89 34 d5 60 94 12 00 	mov    %esi,0x129460(,%edx,8)
	gdt[i] |= (flags & 0xffLL) << 40;
  100a5b:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
  100a5f:	c1 e0 08             	shl    $0x8,%eax
  100a62:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100a65:	8b 14 cd 60 94 12 00 	mov    0x129460(,%ecx,8),%edx
  100a6c:	8b 34 cd 64 94 12 00 	mov    0x129464(,%ecx,8),%esi
  100a73:	09 c6                	or     %eax,%esi
  100a75:	89 14 cd 60 94 12 00 	mov    %edx,0x129460(,%ecx,8)
  100a7c:	89 34 cd 64 94 12 00 	mov    %esi,0x129464(,%ecx,8)
	gdt[i] |= ((limit >> 16) & 0xfLL) << 48;
  100a83:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
  100a87:	83 e0 0f             	and    $0xf,%eax
  100a8a:	c1 e0 10             	shl    $0x10,%eax
  100a8d:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100a90:	8b 14 cd 60 94 12 00 	mov    0x129460(,%ecx,8),%edx
  100a97:	8b 34 cd 64 94 12 00 	mov    0x129464(,%ecx,8),%esi
  100a9e:	09 c6                	or     %eax,%esi
  100aa0:	89 14 cd 60 94 12 00 	mov    %edx,0x129460(,%ecx,8)
  100aa7:	89 34 cd 64 94 12 00 	mov    %esi,0x129464(,%ecx,8)
	gdt[i] |= ((flags >> 8) & 0xffLL) << 52;
  100aae:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100ab1:	c1 e0 0c             	shl    $0xc,%eax
  100ab4:	25 00 00 f0 0f       	and    $0xff00000,%eax
  100ab9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100abc:	8b 14 cd 60 94 12 00 	mov    0x129460(,%ecx,8),%edx
  100ac3:	8b 34 cd 64 94 12 00 	mov    0x129464(,%ecx,8),%esi
  100aca:	09 c6                	or     %eax,%esi
  100acc:	89 14 cd 60 94 12 00 	mov    %edx,0x129460(,%ecx,8)
  100ad3:	89 34 cd 64 94 12 00 	mov    %esi,0x129464(,%ecx,8)
	gdt[i] |= ((base >> 24) & 0xffLL) << 56;
  100ada:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  100ade:	c1 e0 18             	shl    $0x18,%eax
  100ae1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  100ae4:	8b 14 cd 60 94 12 00 	mov    0x129460(,%ecx,8),%edx
  100aeb:	8b 34 cd 64 94 12 00 	mov    0x129464(,%ecx,8),%esi
  100af2:	09 c6                	or     %eax,%esi
  100af4:	89 14 cd 60 94 12 00 	mov    %edx,0x129460(,%ecx,8)
  100afb:	89 34 cd 64 94 12 00 	mov    %esi,0x129464(,%ecx,8)
}
  100b02:	83 c4 10             	add    $0x10,%esp
  100b05:	5e                   	pop    %esi
  100b06:	5d                   	pop    %ebp
  100b07:	c3                   	ret    
  100b08:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  100b0f:	00 

00100b10 <init_gdt>:

void init_gdt(void) {
  100b10:	55                   	push   %ebp
  100b11:	89 e5                	mov    %esp,%ebp
  100b13:	56                   	push   %esi
  100b14:	83 ec 54             	sub    $0x54,%esp
  100b17:	b8 00 00 00 00       	mov    $0x0,%eax
	set_gdt_entry(0, 0, 0, 0);
  100b1c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100b23:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100b2a:	00 
  100b2b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  100b32:	00 
  100b33:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  100b3a:	00 
  100b3b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  100b3e:	e8 ad fe ff ff       	call   1009f0 <set_gdt_entry>
  100b43:	b8 01 00 00 00       	mov    $0x1,%eax
  100b48:	b9 00 00 00 00       	mov    $0x0,%ecx
  100b4d:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100b52:	be 9a 0c 00 00       	mov    $0xc9a,%esi
	set_gdt_entry(1, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100b57:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100b5e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100b65:	00 
  100b66:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100b6d:	00 
  100b6e:	c7 44 24 0c 9a 0c 00 	movl   $0xc9a,0xc(%esp)
  100b75:	00 
  100b76:	89 45 f4             	mov    %eax,-0xc(%ebp)
  100b79:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  100b7c:	89 55 ec             	mov    %edx,-0x14(%ebp)
  100b7f:	89 75 e8             	mov    %esi,-0x18(%ebp)
  100b82:	e8 69 fe ff ff       	call   1009f0 <set_gdt_entry>
  100b87:	b8 02 00 00 00       	mov    $0x2,%eax
  100b8c:	b9 00 00 00 00       	mov    $0x0,%ecx
  100b91:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100b96:	be 92 0c 00 00       	mov    $0xc92,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(2, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100b9b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100ba2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ba9:	00 
  100baa:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100bb1:	00 
  100bb2:	c7 44 24 0c 92 0c 00 	movl   $0xc92,0xc(%esp)
  100bb9:	00 
  100bba:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  100bbd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  100bc0:	89 55 dc             	mov    %edx,-0x24(%ebp)
  100bc3:	89 75 d8             	mov    %esi,-0x28(%ebp)
  100bc6:	e8 25 fe ff ff       	call   1009f0 <set_gdt_entry>
  100bcb:	b8 03 00 00 00       	mov    $0x3,%eax
  100bd0:	b9 00 00 00 00       	mov    $0x0,%ecx
  100bd5:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100bda:	be fa 0c 00 00       	mov    $0xcfa,%esi
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT);
	set_gdt_entry(3, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100bdf:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  100be6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100bed:	00 
  100bee:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100bf5:	00 
  100bf6:	c7 44 24 0c fa 0c 00 	movl   $0xcfa,0xc(%esp)
  100bfd:	00 
  100bfe:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  100c01:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  100c04:	89 55 cc             	mov    %edx,-0x34(%ebp)
  100c07:	89 75 c8             	mov    %esi,-0x38(%ebp)
  100c0a:	e8 e1 fd ff ff       	call   1009f0 <set_gdt_entry>
  100c0f:	b8 04 00 00 00       	mov    $0x4,%eax
  100c14:	b9 00 00 00 00       	mov    $0x0,%ecx
  100c19:	ba ff ff 0f 00       	mov    $0xfffff,%edx
  100c1e:	be f2 0c 00 00       	mov    $0xcf2,%esi
	GDT_FLAG_CODESEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);
	set_gdt_entry(4, 0, 0xfffff, GDT_FLAG_SEGMENT | GDT_FLAG_32_BIT |
  100c23:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  100c2a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100c31:	00 
  100c32:	c7 44 24 08 ff ff 0f 	movl   $0xfffff,0x8(%esp)
  100c39:	00 
  100c3a:	c7 44 24 0c f2 0c 00 	movl   $0xcf2,0xc(%esp)
  100c41:	00 
  100c42:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  100c45:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  100c48:	89 55 bc             	mov    %edx,-0x44(%ebp)
  100c4b:	89 75 b8             	mov    %esi,-0x48(%ebp)
  100c4e:	e8 9d fd ff ff       	call   1009f0 <set_gdt_entry>
	GDT_FLAG_DATASEG | GDT_FLAG_4K_GRAN | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	load_gdt();
  100c53:	e8 58 fd ff ff       	call   1009b0 <load_gdt>
}
  100c58:	83 c4 54             	add    $0x54,%esp
  100c5b:	5e                   	pop    %esi
  100c5c:	5d                   	pop    %ebp
  100c5d:	c3                   	ret    
  100c5e:	66 90                	xchg   %ax,%ax

00100c60 <idt_set_entry>:
extern void intr_stub_46(void);
extern void intr_stub_47(void);

extern void intr_stub_48(void);

void idt_set_entry(int i, void (*fn)(), uint16_t selector, uint8_t flags) {
  100c60:	55                   	push   %ebp
  100c61:	89 e5                	mov    %esp,%ebp
  100c63:	53                   	push   %ebx
  100c64:	57                   	push   %edi
  100c65:	56                   	push   %esi
  100c66:	83 ec 10             	sub    $0x10,%esp
  100c69:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  100c6d:	66 89 c1             	mov    %ax,%cx
  100c70:	8a 55 14             	mov    0x14(%ebp),%dl
  100c73:	8b 45 0c             	mov    0xc(%ebp),%eax
  100c76:	8b 75 08             	mov    0x8(%ebp),%esi
  100c79:	89 75 f0             	mov    %esi,-0x10(%ebp)
  100c7c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100c7f:	66 89 4d ea          	mov    %cx,-0x16(%ebp)
  100c83:	88 55 e9             	mov    %dl,-0x17(%ebp)
	unsigned long int handler = (unsigned long int) fn;
  100c86:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100c89:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	idt[i] = handler & 0xffffLL;
  100c8c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  100c90:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100c93:	89 04 f5 20 90 10 00 	mov    %eax,0x109020(,%esi,8)
  100c9a:	c7 04 f5 24 90 10 00 	movl   $0x0,0x109024(,%esi,8)
  100ca1:	00 00 00 00 
	idt[i] |= (selector & 0xffffLL) << 16;
  100ca5:	0f b7 45 ea          	movzwl -0x16(%ebp),%eax
  100ca9:	c1 e0 10             	shl    $0x10,%eax
  100cac:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100caf:	8b 3c f5 24 90 10 00 	mov    0x109024(,%esi,8),%edi
  100cb6:	8b 1c f5 20 90 10 00 	mov    0x109020(,%esi,8),%ebx
  100cbd:	09 c3                	or     %eax,%ebx
  100cbf:	89 3c f5 24 90 10 00 	mov    %edi,0x109024(,%esi,8)
  100cc6:	89 1c f5 20 90 10 00 	mov    %ebx,0x109020(,%esi,8)
	idt[i] |= (flags & 0xffLL) << 40;
  100ccd:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
  100cd1:	c1 e0 08             	shl    $0x8,%eax
  100cd4:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100cd7:	8b 3c f5 20 90 10 00 	mov    0x109020(,%esi,8),%edi
  100cde:	8b 1c f5 24 90 10 00 	mov    0x109024(,%esi,8),%ebx
  100ce5:	09 c3                	or     %eax,%ebx
  100ce7:	89 3c f5 20 90 10 00 	mov    %edi,0x109020(,%esi,8)
  100cee:	89 1c f5 24 90 10 00 	mov    %ebx,0x109024(,%esi,8)
	idt[i] |= ((handler >> 16) & 0xffffLL) << 48;
  100cf5:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  100cf9:	c1 e0 10             	shl    $0x10,%eax
  100cfc:	8b 75 f0             	mov    -0x10(%ebp),%esi
  100cff:	8b 3c f5 20 90 10 00 	mov    0x109020(,%esi,8),%edi
  100d06:	8b 1c f5 24 90 10 00 	mov    0x109024(,%esi,8),%ebx
  100d0d:	09 c3                	or     %eax,%ebx
  100d0f:	89 3c f5 20 90 10 00 	mov    %edi,0x109020(,%esi,8)
  100d16:	89 1c f5 24 90 10 00 	mov    %ebx,0x109024(,%esi,8)
}
  100d1d:	83 c4 10             	add    $0x10,%esp
  100d20:	5e                   	pop    %esi
  100d21:	5f                   	pop    %edi
  100d22:	5b                   	pop    %ebx
  100d23:	5d                   	pop    %ebp
  100d24:	c3                   	ret    
  100d25:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  100d2c:	00 00 00 00 

00100d30 <init_idt>:

void init_idt() {
  100d30:	55                   	push   %ebp
  100d31:	89 e5                	mov    %esp,%ebp
	struct {
  100d33:	56                   	push   %esi
  100d34:	81 ec 34 02 00 00    	sub    $0x234,%esp
  100d3a:	a1 2a 70 10 00       	mov    0x10702a,%eax
  100d3f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  100d42:	66 8b 0d 2e 70 10 00 	mov    0x10702e,%cx
  100d49:	66 89 4d f4          	mov    %cx,-0xc(%ebp)
		unsigned short int limit;
		void* pointer;
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;
  100d4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

	for (i = 0; i < IDT_ENTRIES; i++) {
  100d54:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  100d5b:	81 7d ec 40 00 00 00 	cmpl   $0x40,-0x14(%ebp)
  100d62:	0f 8d 1e 00 00 00    	jge    100d86 <init_idt+0x56>
		handler_set[i] = 0;
  100d68:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100d6b:	c7 04 85 20 92 10 00 	movl   $0x0,0x109220(,%eax,4)
  100d72:	00 00 00 00 
	}__attribute__((packed)) idtp = { .limit = IDT_ENTRIES * 8 - 1, .pointer =
			idt, };

	int i = 0;

	for (i = 0; i < IDT_ENTRIES; i++) {
  100d76:	8b 45 ec             	mov    -0x14(%ebp),%eax
  100d79:	05 01 00 00 00       	add    $0x1,%eax
  100d7e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  100d81:	e9 d5 ff ff ff       	jmp    100d5b <init_idt+0x2b>
  100d86:	b8 20 00 00 00       	mov    $0x20,%eax
  100d8b:	b9 11 00 00 00       	mov    $0x11,%ecx
		handler_set[i] = 0;
	}

	outb(0x20, 0x11); // Initialisierungsbefehl fuer den PIC
  100d90:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  100d97:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  100d9e:	00 
  100d9f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  100da2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  100da5:	e8 86 0b 00 00       	call   101930 <outb>
  100daa:	b8 21 00 00 00       	mov    $0x21,%eax
  100daf:	b9 20 00 00 00       	mov    $0x20,%ecx
	outb(0x21, 0x20); // Interruptnummer fuer IRQ 0
  100db4:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100dbb:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  100dc2:	00 
  100dc3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  100dc6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  100dc9:	e8 62 0b 00 00       	call   101930 <outb>
  100dce:	b8 21 00 00 00       	mov    $0x21,%eax
  100dd3:	b9 04 00 00 00       	mov    $0x4,%ecx
	outb(0x21, 0x04); // An IRQ 2 haengt der Slave
  100dd8:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100ddf:	c7 44 24 04 04 00 00 	movl   $0x4,0x4(%esp)
  100de6:	00 
  100de7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  100dea:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  100ded:	e8 3e 0b 00 00       	call   101930 <outb>
  100df2:	b8 21 00 00 00       	mov    $0x21,%eax
  100df7:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0x21, 0x01); // ICW 4
  100dfc:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  100e03:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100e0a:	00 
  100e0b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  100e0e:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  100e11:	e8 1a 0b 00 00       	call   101930 <outb>
  100e16:	b8 a0 00 00 00       	mov    $0xa0,%eax
  100e1b:	b9 11 00 00 00       	mov    $0x11,%ecx

	outb(0xa0, 0x11); // Initialisierungsbefehl fuer den PIC
  100e20:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  100e27:	c7 44 24 04 11 00 00 	movl   $0x11,0x4(%esp)
  100e2e:	00 
  100e2f:	89 45 c8             	mov    %eax,-0x38(%ebp)
  100e32:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  100e35:	e8 f6 0a 00 00       	call   101930 <outb>
  100e3a:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100e3f:	b9 28 00 00 00       	mov    $0x28,%ecx
	outb(0xa1, 0x28); // Interruptnummer fuer IRQ 8
  100e44:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100e4b:	c7 44 24 04 28 00 00 	movl   $0x28,0x4(%esp)
  100e52:	00 
  100e53:	89 45 c0             	mov    %eax,-0x40(%ebp)
  100e56:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  100e59:	e8 d2 0a 00 00       	call   101930 <outb>
  100e5e:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100e63:	b9 02 00 00 00       	mov    $0x2,%ecx
	outb(0xa1, 0x02); // An IRQ 2 haengt der Slave
  100e68:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100e6f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  100e76:	00 
  100e77:	89 45 b8             	mov    %eax,-0x48(%ebp)
  100e7a:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
  100e7d:	e8 ae 0a 00 00       	call   101930 <outb>
  100e82:	b8 a1 00 00 00       	mov    $0xa1,%eax
  100e87:	b9 01 00 00 00       	mov    $0x1,%ecx
	outb(0xa1, 0x01); // ICW 4
  100e8c:	c7 04 24 a1 00 00 00 	movl   $0xa1,(%esp)
  100e93:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  100e9a:	00 
  100e9b:	89 45 b0             	mov    %eax,-0x50(%ebp)
  100e9e:	89 4d ac             	mov    %ecx,-0x54(%ebp)
  100ea1:	e8 8a 0a 00 00       	call   101930 <outb>
  100ea6:	b8 20 00 00 00       	mov    $0x20,%eax
  100eab:	b9 00 00 00 00       	mov    $0x0,%ecx

	outb(0x20, 0x0);
  100eb0:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  100eb7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ebe:	00 
  100ebf:	89 45 a8             	mov    %eax,-0x58(%ebp)
  100ec2:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
  100ec5:	e8 66 0a 00 00       	call   101930 <outb>
  100eca:	b8 a0 00 00 00       	mov    $0xa0,%eax
  100ecf:	b9 00 00 00 00       	mov    $0x0,%ecx
	outb(0xa0, 0x0);
  100ed4:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  100edb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  100ee2:	00 
  100ee3:	89 45 a0             	mov    %eax,-0x60(%ebp)
  100ee6:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
  100ee9:	e8 42 0a 00 00       	call   101930 <outb>
  100eee:	b8 00 00 00 00       	mov    $0x0,%eax
  100ef3:	8d 0d 04 1b 10 00    	lea    0x101b04,%ecx
  100ef9:	ba 08 00 00 00       	mov    $0x8,%edx
  100efe:	be 8e 00 00 00       	mov    $0x8e,%esi

	idt_set_entry(0, intr_stub_0, 0x8,
  100f03:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  100f0a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f0e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100f15:	00 
  100f16:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100f1d:	00 
  100f1e:	89 45 98             	mov    %eax,-0x68(%ebp)
  100f21:	89 75 94             	mov    %esi,-0x6c(%ebp)
  100f24:	89 55 90             	mov    %edx,-0x70(%ebp)
  100f27:	e8 34 fd ff ff       	call   100c60 <idt_set_entry>
  100f2c:	b8 01 00 00 00       	mov    $0x1,%eax
  100f31:	8d 0d 0d 1b 10 00    	lea    0x101b0d,%ecx
  100f37:	ba 08 00 00 00       	mov    $0x8,%edx
  100f3c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(1, intr_stub_1, 0x8,
  100f41:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  100f48:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f4c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100f53:	00 
  100f54:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100f5b:	00 
  100f5c:	89 45 8c             	mov    %eax,-0x74(%ebp)
  100f5f:	89 75 88             	mov    %esi,-0x78(%ebp)
  100f62:	89 55 84             	mov    %edx,-0x7c(%ebp)
  100f65:	e8 f6 fc ff ff       	call   100c60 <idt_set_entry>
  100f6a:	b8 02 00 00 00       	mov    $0x2,%eax
  100f6f:	8d 0d 16 1b 10 00    	lea    0x101b16,%ecx
  100f75:	ba 08 00 00 00       	mov    $0x8,%edx
  100f7a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(2, intr_stub_2, 0x8,
  100f7f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  100f86:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100f8a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100f91:	00 
  100f92:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100f99:	00 
  100f9a:	89 45 80             	mov    %eax,-0x80(%ebp)
  100f9d:	89 b5 7c ff ff ff    	mov    %esi,-0x84(%ebp)
  100fa3:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
  100fa9:	e8 b2 fc ff ff       	call   100c60 <idt_set_entry>
  100fae:	b8 03 00 00 00       	mov    $0x3,%eax
  100fb3:	8d 0d 1f 1b 10 00    	lea    0x101b1f,%ecx
  100fb9:	ba 08 00 00 00       	mov    $0x8,%edx
  100fbe:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(3, intr_stub_3, 0x8,
  100fc3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  100fca:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  100fce:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  100fd5:	00 
  100fd6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  100fdd:	00 
  100fde:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
  100fe4:	89 b5 70 ff ff ff    	mov    %esi,-0x90(%ebp)
  100fea:	89 95 6c ff ff ff    	mov    %edx,-0x94(%ebp)
  100ff0:	e8 6b fc ff ff       	call   100c60 <idt_set_entry>
  100ff5:	b8 04 00 00 00       	mov    $0x4,%eax
  100ffa:	8d 0d 28 1b 10 00    	lea    0x101b28,%ecx
  101000:	ba 08 00 00 00       	mov    $0x8,%edx
  101005:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(4, intr_stub_4, 0x8,
  10100a:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  101011:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101015:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10101c:	00 
  10101d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101024:	00 
  101025:	89 85 68 ff ff ff    	mov    %eax,-0x98(%ebp)
  10102b:	89 b5 64 ff ff ff    	mov    %esi,-0x9c(%ebp)
  101031:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%ebp)
  101037:	e8 24 fc ff ff       	call   100c60 <idt_set_entry>
  10103c:	b8 05 00 00 00       	mov    $0x5,%eax
  101041:	8d 0d 31 1b 10 00    	lea    0x101b31,%ecx
  101047:	ba 08 00 00 00       	mov    $0x8,%edx
  10104c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(5, intr_stub_5, 0x8,
  101051:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  101058:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10105c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101063:	00 
  101064:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10106b:	00 
  10106c:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
  101072:	89 b5 58 ff ff ff    	mov    %esi,-0xa8(%ebp)
  101078:	89 95 54 ff ff ff    	mov    %edx,-0xac(%ebp)
  10107e:	e8 dd fb ff ff       	call   100c60 <idt_set_entry>
  101083:	b8 06 00 00 00       	mov    $0x6,%eax
  101088:	8d 0d 3a 1b 10 00    	lea    0x101b3a,%ecx
  10108e:	ba 08 00 00 00       	mov    $0x8,%edx
  101093:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(6, intr_stub_6, 0x8,
  101098:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  10109f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1010a3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1010aa:	00 
  1010ab:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1010b2:	00 
  1010b3:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%ebp)
  1010b9:	89 b5 4c ff ff ff    	mov    %esi,-0xb4(%ebp)
  1010bf:	89 95 48 ff ff ff    	mov    %edx,-0xb8(%ebp)
  1010c5:	e8 96 fb ff ff       	call   100c60 <idt_set_entry>
  1010ca:	b8 07 00 00 00       	mov    $0x7,%eax
  1010cf:	8d 0d 43 1b 10 00    	lea    0x101b43,%ecx
  1010d5:	ba 08 00 00 00       	mov    $0x8,%edx
  1010da:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(7, intr_stub_7, 0x8,
  1010df:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  1010e6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1010ea:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1010f1:	00 
  1010f2:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1010f9:	00 
  1010fa:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%ebp)
  101100:	89 b5 40 ff ff ff    	mov    %esi,-0xc0(%ebp)
  101106:	89 95 3c ff ff ff    	mov    %edx,-0xc4(%ebp)
  10110c:	e8 4f fb ff ff       	call   100c60 <idt_set_entry>
  101111:	b8 08 00 00 00       	mov    $0x8,%eax
  101116:	8d 0d 4c 1b 10 00    	lea    0x101b4c,%ecx
  10111c:	ba 8e 00 00 00       	mov    $0x8e,%edx
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(8, intr_stub_8, 0x8,
  101121:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  101128:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10112c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101133:	00 
  101134:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10113b:	00 
  10113c:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%ebp)
  101142:	89 95 34 ff ff ff    	mov    %edx,-0xcc(%ebp)
  101148:	e8 13 fb ff ff       	call   100c60 <idt_set_entry>
  10114d:	b8 09 00 00 00       	mov    $0x9,%eax
  101152:	8d 0d 53 1b 10 00    	lea    0x101b53,%ecx
  101158:	ba 08 00 00 00       	mov    $0x8,%edx
  10115d:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(9, intr_stub_9, 0x8,
  101162:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  101169:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10116d:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101174:	00 
  101175:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10117c:	00 
  10117d:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%ebp)
  101183:	89 b5 2c ff ff ff    	mov    %esi,-0xd4(%ebp)
  101189:	89 95 28 ff ff ff    	mov    %edx,-0xd8(%ebp)
  10118f:	e8 cc fa ff ff       	call   100c60 <idt_set_entry>
  101194:	b8 0a 00 00 00       	mov    $0xa,%eax
  101199:	8d 0d 5c 1b 10 00    	lea    0x101b5c,%ecx
  10119f:	ba 08 00 00 00       	mov    $0x8,%edx
  1011a4:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(10, intr_stub_10, 0x8,
  1011a9:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  1011b0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1011b4:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1011bb:	00 
  1011bc:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1011c3:	00 
  1011c4:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%ebp)
  1011ca:	89 b5 20 ff ff ff    	mov    %esi,-0xe0(%ebp)
  1011d0:	89 95 1c ff ff ff    	mov    %edx,-0xe4(%ebp)
  1011d6:	e8 85 fa ff ff       	call   100c60 <idt_set_entry>
  1011db:	b8 0b 00 00 00       	mov    $0xb,%eax
  1011e0:	8d 0d 63 1b 10 00    	lea    0x101b63,%ecx
  1011e6:	ba 08 00 00 00       	mov    $0x8,%edx
  1011eb:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(11, intr_stub_11, 0x8,
  1011f0:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  1011f7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1011fb:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101202:	00 
  101203:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10120a:	00 
  10120b:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%ebp)
  101211:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%ebp)
  101217:	89 95 10 ff ff ff    	mov    %edx,-0xf0(%ebp)
  10121d:	e8 3e fa ff ff       	call   100c60 <idt_set_entry>
  101222:	b8 0c 00 00 00       	mov    $0xc,%eax
  101227:	8d 0d 6a 1b 10 00    	lea    0x101b6a,%ecx
  10122d:	ba 08 00 00 00       	mov    $0x8,%edx
  101232:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(12, intr_stub_12, 0x8,
  101237:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  10123e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101242:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101249:	00 
  10124a:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101251:	00 
  101252:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%ebp)
  101258:	89 b5 08 ff ff ff    	mov    %esi,-0xf8(%ebp)
  10125e:	89 95 04 ff ff ff    	mov    %edx,-0xfc(%ebp)
  101264:	e8 f7 f9 ff ff       	call   100c60 <idt_set_entry>
  101269:	b8 0d 00 00 00       	mov    $0xd,%eax
  10126e:	8d 0d 71 1b 10 00    	lea    0x101b71,%ecx
  101274:	ba 08 00 00 00       	mov    $0x8,%edx
  101279:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(13, intr_stub_13, 0x8,
  10127e:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  101285:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101289:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101290:	00 
  101291:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101298:	00 
  101299:	89 85 00 ff ff ff    	mov    %eax,-0x100(%ebp)
  10129f:	89 b5 fc fe ff ff    	mov    %esi,-0x104(%ebp)
  1012a5:	89 95 f8 fe ff ff    	mov    %edx,-0x108(%ebp)
  1012ab:	e8 b0 f9 ff ff       	call   100c60 <idt_set_entry>
  1012b0:	b8 0e 00 00 00       	mov    $0xe,%eax
  1012b5:	8d 0d 78 1b 10 00    	lea    0x101b78,%ecx
  1012bb:	ba 08 00 00 00       	mov    $0x8,%edx
  1012c0:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(14, intr_stub_14, 0x8,
  1012c5:	c7 04 24 0e 00 00 00 	movl   $0xe,(%esp)
  1012cc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1012d0:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1012d7:	00 
  1012d8:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1012df:	00 
  1012e0:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
  1012e6:	89 b5 f0 fe ff ff    	mov    %esi,-0x110(%ebp)
  1012ec:	89 95 ec fe ff ff    	mov    %edx,-0x114(%ebp)
  1012f2:	e8 69 f9 ff ff       	call   100c60 <idt_set_entry>
  1012f7:	b8 0f 00 00 00       	mov    $0xf,%eax
  1012fc:	8d 0d 7c 1b 10 00    	lea    0x101b7c,%ecx
  101302:	ba 08 00 00 00       	mov    $0x8,%edx
  101307:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(15, intr_stub_15, 0x8,
  10130c:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
  101313:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101317:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10131e:	00 
  10131f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101326:	00 
  101327:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%ebp)
  10132d:	89 b5 e4 fe ff ff    	mov    %esi,-0x11c(%ebp)
  101333:	89 95 e0 fe ff ff    	mov    %edx,-0x120(%ebp)
  101339:	e8 22 f9 ff ff       	call   100c60 <idt_set_entry>
  10133e:	b8 10 00 00 00       	mov    $0x10,%eax
  101343:	8d 0d 82 1b 10 00    	lea    0x101b82,%ecx
  101349:	ba 08 00 00 00       	mov    $0x8,%edx
  10134e:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(16, intr_stub_16, 0x8,
  101353:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10135a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10135e:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101365:	00 
  101366:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10136d:	00 
  10136e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%ebp)
  101374:	89 b5 d8 fe ff ff    	mov    %esi,-0x128(%ebp)
  10137a:	89 95 d4 fe ff ff    	mov    %edx,-0x12c(%ebp)
  101380:	e8 db f8 ff ff       	call   100c60 <idt_set_entry>
  101385:	b8 11 00 00 00       	mov    $0x11,%eax
  10138a:	8d 0d 88 1b 10 00    	lea    0x101b88,%ecx
  101390:	ba 08 00 00 00       	mov    $0x8,%edx
  101395:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(17, intr_stub_17, 0x8,
  10139a:	c7 04 24 11 00 00 00 	movl   $0x11,(%esp)
  1013a1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1013a5:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1013ac:	00 
  1013ad:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1013b4:	00 
  1013b5:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%ebp)
  1013bb:	89 b5 cc fe ff ff    	mov    %esi,-0x134(%ebp)
  1013c1:	89 95 c8 fe ff ff    	mov    %edx,-0x138(%ebp)
  1013c7:	e8 94 f8 ff ff       	call   100c60 <idt_set_entry>
  1013cc:	b8 12 00 00 00       	mov    $0x12,%eax
  1013d1:	8d 0d 8c 1b 10 00    	lea    0x101b8c,%ecx
  1013d7:	ba 08 00 00 00       	mov    $0x8,%edx
  1013dc:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(18, intr_stub_18, 0x8,
  1013e1:	c7 04 24 12 00 00 00 	movl   $0x12,(%esp)
  1013e8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1013ec:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1013f3:	00 
  1013f4:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1013fb:	00 
  1013fc:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%ebp)
  101402:	89 b5 c0 fe ff ff    	mov    %esi,-0x140(%ebp)
  101408:	89 95 bc fe ff ff    	mov    %edx,-0x144(%ebp)
  10140e:	e8 4d f8 ff ff       	call   100c60 <idt_set_entry>
  101413:	b8 20 00 00 00       	mov    $0x20,%eax
  101418:	8d 0d 92 1b 10 00    	lea    0x101b92,%ecx
  10141e:	ba 08 00 00 00       	mov    $0x8,%edx
  101423:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(32, intr_stub_32, 0x8,
  101428:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  10142f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101433:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10143a:	00 
  10143b:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101442:	00 
  101443:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%ebp)
  101449:	89 b5 b4 fe ff ff    	mov    %esi,-0x14c(%ebp)
  10144f:	89 95 b0 fe ff ff    	mov    %edx,-0x150(%ebp)
  101455:	e8 06 f8 ff ff       	call   100c60 <idt_set_entry>
  10145a:	b8 21 00 00 00       	mov    $0x21,%eax
  10145f:	8d 0d 98 1b 10 00    	lea    0x101b98,%ecx
  101465:	ba 08 00 00 00       	mov    $0x8,%edx
  10146a:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(33, intr_stub_33, 0x8,
  10146f:	c7 04 24 21 00 00 00 	movl   $0x21,(%esp)
  101476:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10147a:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101481:	00 
  101482:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101489:	00 
  10148a:	89 85 ac fe ff ff    	mov    %eax,-0x154(%ebp)
  101490:	89 b5 a8 fe ff ff    	mov    %esi,-0x158(%ebp)
  101496:	89 95 a4 fe ff ff    	mov    %edx,-0x15c(%ebp)
  10149c:	e8 bf f7 ff ff       	call   100c60 <idt_set_entry>
  1014a1:	b8 22 00 00 00       	mov    $0x22,%eax
  1014a6:	8d 0d 9e 1b 10 00    	lea    0x101b9e,%ecx
  1014ac:	ba 08 00 00 00       	mov    $0x8,%edx
  1014b1:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(34, intr_stub_34, 0x8,
  1014b6:	c7 04 24 22 00 00 00 	movl   $0x22,(%esp)
  1014bd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1014c1:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1014c8:	00 
  1014c9:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1014d0:	00 
  1014d1:	89 85 a0 fe ff ff    	mov    %eax,-0x160(%ebp)
  1014d7:	89 b5 9c fe ff ff    	mov    %esi,-0x164(%ebp)
  1014dd:	89 95 98 fe ff ff    	mov    %edx,-0x168(%ebp)
  1014e3:	e8 78 f7 ff ff       	call   100c60 <idt_set_entry>
  1014e8:	b8 23 00 00 00       	mov    $0x23,%eax
  1014ed:	8d 0d a4 1b 10 00    	lea    0x101ba4,%ecx
  1014f3:	ba 08 00 00 00       	mov    $0x8,%edx
  1014f8:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(35, intr_stub_35, 0x8,
  1014fd:	c7 04 24 23 00 00 00 	movl   $0x23,(%esp)
  101504:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101508:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10150f:	00 
  101510:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101517:	00 
  101518:	89 85 94 fe ff ff    	mov    %eax,-0x16c(%ebp)
  10151e:	89 b5 90 fe ff ff    	mov    %esi,-0x170(%ebp)
  101524:	89 95 8c fe ff ff    	mov    %edx,-0x174(%ebp)
  10152a:	e8 31 f7 ff ff       	call   100c60 <idt_set_entry>
  10152f:	b8 24 00 00 00       	mov    $0x24,%eax
  101534:	8d 0d aa 1b 10 00    	lea    0x101baa,%ecx
  10153a:	ba 08 00 00 00       	mov    $0x8,%edx
  10153f:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(36, intr_stub_36, 0x8,
  101544:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
  10154b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10154f:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101556:	00 
  101557:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10155e:	00 
  10155f:	89 85 88 fe ff ff    	mov    %eax,-0x178(%ebp)
  101565:	89 b5 84 fe ff ff    	mov    %esi,-0x17c(%ebp)
  10156b:	89 95 80 fe ff ff    	mov    %edx,-0x180(%ebp)
  101571:	e8 ea f6 ff ff       	call   100c60 <idt_set_entry>
  101576:	b8 25 00 00 00       	mov    $0x25,%eax
  10157b:	8d 0d b0 1b 10 00    	lea    0x101bb0,%ecx
  101581:	ba 08 00 00 00       	mov    $0x8,%edx
  101586:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(37, intr_stub_37, 0x8,
  10158b:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  101592:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101596:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10159d:	00 
  10159e:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015a5:	00 
  1015a6:	89 85 7c fe ff ff    	mov    %eax,-0x184(%ebp)
  1015ac:	89 b5 78 fe ff ff    	mov    %esi,-0x188(%ebp)
  1015b2:	89 95 74 fe ff ff    	mov    %edx,-0x18c(%ebp)
  1015b8:	e8 a3 f6 ff ff       	call   100c60 <idt_set_entry>
  1015bd:	b8 26 00 00 00       	mov    $0x26,%eax
  1015c2:	8d 0d b6 1b 10 00    	lea    0x101bb6,%ecx
  1015c8:	ba 08 00 00 00       	mov    $0x8,%edx
  1015cd:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(38, intr_stub_38, 0x8,
  1015d2:	c7 04 24 26 00 00 00 	movl   $0x26,(%esp)
  1015d9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1015dd:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1015e4:	00 
  1015e5:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1015ec:	00 
  1015ed:	89 85 70 fe ff ff    	mov    %eax,-0x190(%ebp)
  1015f3:	89 b5 6c fe ff ff    	mov    %esi,-0x194(%ebp)
  1015f9:	89 95 68 fe ff ff    	mov    %edx,-0x198(%ebp)
  1015ff:	e8 5c f6 ff ff       	call   100c60 <idt_set_entry>
  101604:	b8 27 00 00 00       	mov    $0x27,%eax
  101609:	8d 0d bc 1b 10 00    	lea    0x101bbc,%ecx
  10160f:	ba 08 00 00 00       	mov    $0x8,%edx
  101614:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(39, intr_stub_39, 0x8,
  101619:	c7 04 24 27 00 00 00 	movl   $0x27,(%esp)
  101620:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101624:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10162b:	00 
  10162c:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101633:	00 
  101634:	89 85 64 fe ff ff    	mov    %eax,-0x19c(%ebp)
  10163a:	89 b5 60 fe ff ff    	mov    %esi,-0x1a0(%ebp)
  101640:	89 95 5c fe ff ff    	mov    %edx,-0x1a4(%ebp)
  101646:	e8 15 f6 ff ff       	call   100c60 <idt_set_entry>
  10164b:	b8 28 00 00 00       	mov    $0x28,%eax
  101650:	8d 0d c2 1b 10 00    	lea    0x101bc2,%ecx
  101656:	ba 08 00 00 00       	mov    $0x8,%edx
  10165b:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(40, intr_stub_40, 0x8,
  101660:	c7 04 24 28 00 00 00 	movl   $0x28,(%esp)
  101667:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10166b:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101672:	00 
  101673:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10167a:	00 
  10167b:	89 85 58 fe ff ff    	mov    %eax,-0x1a8(%ebp)
  101681:	89 b5 54 fe ff ff    	mov    %esi,-0x1ac(%ebp)
  101687:	89 95 50 fe ff ff    	mov    %edx,-0x1b0(%ebp)
  10168d:	e8 ce f5 ff ff       	call   100c60 <idt_set_entry>
  101692:	b8 29 00 00 00       	mov    $0x29,%eax
  101697:	8d 0d c8 1b 10 00    	lea    0x101bc8,%ecx
  10169d:	ba 08 00 00 00       	mov    $0x8,%edx
  1016a2:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(41, intr_stub_41, 0x8,
  1016a7:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
  1016ae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016b2:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1016b9:	00 
  1016ba:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1016c1:	00 
  1016c2:	89 85 4c fe ff ff    	mov    %eax,-0x1b4(%ebp)
  1016c8:	89 b5 48 fe ff ff    	mov    %esi,-0x1b8(%ebp)
  1016ce:	89 95 44 fe ff ff    	mov    %edx,-0x1bc(%ebp)
  1016d4:	e8 87 f5 ff ff       	call   100c60 <idt_set_entry>
  1016d9:	b8 2a 00 00 00       	mov    $0x2a,%eax
  1016de:	8d 0d ce 1b 10 00    	lea    0x101bce,%ecx
  1016e4:	ba 08 00 00 00       	mov    $0x8,%edx
  1016e9:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(42, intr_stub_42, 0x8,
  1016ee:	c7 04 24 2a 00 00 00 	movl   $0x2a,(%esp)
  1016f5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1016f9:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101700:	00 
  101701:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101708:	00 
  101709:	89 85 40 fe ff ff    	mov    %eax,-0x1c0(%ebp)
  10170f:	89 b5 3c fe ff ff    	mov    %esi,-0x1c4(%ebp)
  101715:	89 95 38 fe ff ff    	mov    %edx,-0x1c8(%ebp)
  10171b:	e8 40 f5 ff ff       	call   100c60 <idt_set_entry>
  101720:	b8 2b 00 00 00       	mov    $0x2b,%eax
  101725:	8d 0d d4 1b 10 00    	lea    0x101bd4,%ecx
  10172b:	ba 08 00 00 00       	mov    $0x8,%edx
  101730:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(43, intr_stub_43, 0x8,
  101735:	c7 04 24 2b 00 00 00 	movl   $0x2b,(%esp)
  10173c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101740:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101747:	00 
  101748:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10174f:	00 
  101750:	89 85 34 fe ff ff    	mov    %eax,-0x1cc(%ebp)
  101756:	89 b5 30 fe ff ff    	mov    %esi,-0x1d0(%ebp)
  10175c:	89 95 2c fe ff ff    	mov    %edx,-0x1d4(%ebp)
  101762:	e8 f9 f4 ff ff       	call   100c60 <idt_set_entry>
  101767:	b8 2c 00 00 00       	mov    $0x2c,%eax
  10176c:	8d 0d da 1b 10 00    	lea    0x101bda,%ecx
  101772:	ba 08 00 00 00       	mov    $0x8,%edx
  101777:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(44, intr_stub_44, 0x8,
  10177c:	c7 04 24 2c 00 00 00 	movl   $0x2c,(%esp)
  101783:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101787:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10178e:	00 
  10178f:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101796:	00 
  101797:	89 85 28 fe ff ff    	mov    %eax,-0x1d8(%ebp)
  10179d:	89 b5 24 fe ff ff    	mov    %esi,-0x1dc(%ebp)
  1017a3:	89 95 20 fe ff ff    	mov    %edx,-0x1e0(%ebp)
  1017a9:	e8 b2 f4 ff ff       	call   100c60 <idt_set_entry>
  1017ae:	b8 2d 00 00 00       	mov    $0x2d,%eax
  1017b3:	8d 0d e0 1b 10 00    	lea    0x101be0,%ecx
  1017b9:	ba 08 00 00 00       	mov    $0x8,%edx
  1017be:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(45, intr_stub_45, 0x8,
  1017c3:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  1017ca:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1017ce:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1017d5:	00 
  1017d6:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  1017dd:	00 
  1017de:	89 85 1c fe ff ff    	mov    %eax,-0x1e4(%ebp)
  1017e4:	89 b5 18 fe ff ff    	mov    %esi,-0x1e8(%ebp)
  1017ea:	89 95 14 fe ff ff    	mov    %edx,-0x1ec(%ebp)
  1017f0:	e8 6b f4 ff ff       	call   100c60 <idt_set_entry>
  1017f5:	b8 2e 00 00 00       	mov    $0x2e,%eax
  1017fa:	8d 0d e6 1b 10 00    	lea    0x101be6,%ecx
  101800:	ba 08 00 00 00       	mov    $0x8,%edx
  101805:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(46, intr_stub_46, 0x8,
  10180a:	c7 04 24 2e 00 00 00 	movl   $0x2e,(%esp)
  101811:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101815:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  10181c:	00 
  10181d:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  101824:	00 
  101825:	89 85 10 fe ff ff    	mov    %eax,-0x1f0(%ebp)
  10182b:	89 b5 0c fe ff ff    	mov    %esi,-0x1f4(%ebp)
  101831:	89 95 08 fe ff ff    	mov    %edx,-0x1f8(%ebp)
  101837:	e8 24 f4 ff ff       	call   100c60 <idt_set_entry>
  10183c:	b8 2f 00 00 00       	mov    $0x2f,%eax
  101841:	8d 0d ec 1b 10 00    	lea    0x101bec,%ecx
  101847:	ba 08 00 00 00       	mov    $0x8,%edx
  10184c:	be 8e 00 00 00       	mov    $0x8e,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);
	idt_set_entry(47, intr_stub_47, 0x8,
  101851:	c7 04 24 2f 00 00 00 	movl   $0x2f,(%esp)
  101858:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10185c:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  101863:	00 
  101864:	c7 44 24 0c 8e 00 00 	movl   $0x8e,0xc(%esp)
  10186b:	00 
  10186c:	89 85 04 fe ff ff    	mov    %eax,-0x1fc(%ebp)
  101872:	89 b5 00 fe ff ff    	mov    %esi,-0x200(%ebp)
  101878:	89 95 fc fd ff ff    	mov    %edx,-0x204(%ebp)
  10187e:	e8 dd f3 ff ff       	call   100c60 <idt_set_entry>
  101883:	b8 30 00 00 00       	mov    $0x30,%eax
  101888:	8d 0d f2 1b 10 00    	lea    0x101bf2,%ecx
  10188e:	ba 08 00 00 00       	mov    $0x8,%edx
  101893:	be ee 00 00 00       	mov    $0xee,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING0 | IDT_FLAG_PRESENT);

	idt_set_entry(48, intr_stub_48, 0x8,
  101898:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  10189f:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018a3:	c7 44 24 08 08 00 00 	movl   $0x8,0x8(%esp)
  1018aa:	00 
  1018ab:	c7 44 24 0c ee 00 00 	movl   $0xee,0xc(%esp)
  1018b2:	00 
  1018b3:	89 85 f8 fd ff ff    	mov    %eax,-0x208(%ebp)
  1018b9:	89 b5 f4 fd ff ff    	mov    %esi,-0x20c(%ebp)
  1018bf:	89 95 f0 fd ff ff    	mov    %edx,-0x210(%ebp)
  1018c5:	e8 96 f3 ff ff       	call   100c60 <idt_set_entry>
  1018ca:	b8 05 00 00 00       	mov    $0x5,%eax
  1018cf:	8d 0d 08 61 10 00    	lea    0x106108,%ecx
  1018d5:	ba 80 00 00 00       	mov    $0x80,%edx
  1018da:	be e9 00 00 00       	mov    $0xe9,%esi
			IDT_FLAG_INTERRUPT_GATE | IDT_FLAG_RING3 | IDT_FLAG_PRESENT);

	set_gdt_entry(5, (uint32_t) tss, sizeof(tss),
  1018df:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  1018e6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1018ea:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  1018f1:	00 
  1018f2:	c7 44 24 0c e9 00 00 	movl   $0xe9,0xc(%esp)
  1018f9:	00 
  1018fa:	89 85 ec fd ff ff    	mov    %eax,-0x214(%ebp)
  101900:	89 b5 e8 fd ff ff    	mov    %esi,-0x218(%ebp)
  101906:	89 95 e4 fd ff ff    	mov    %edx,-0x21c(%ebp)
  10190c:	e8 df f0 ff ff       	call   1009f0 <set_gdt_entry>
  101911:	b8 28 00 00 00       	mov    $0x28,%eax
			GDT_FLAG_TSS | GDT_FLAG_PRESENT | GDT_FLAG_RING3);

	asm volatile("ltr %%ax" : : "a" (5 << 3));
  101916:	0f 00 d8             	ltr    %ax

	asm volatile("lidt %0" : : "m" (idtp));
  101919:	0f 01 5d f0          	lidtl  -0x10(%ebp)
	asm volatile("sti");
  10191d:	fb                   	sti    
}
  10191e:	81 c4 34 02 00 00    	add    $0x234,%esp
  101924:	5e                   	pop    %esi
  101925:	5d                   	pop    %ebp
  101926:	c3                   	ret    
  101927:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10192e:	00 00 

00101930 <outb>:

static inline void outw(uint16_t _port, uint16_t _data) {
    asm volatile ("outw %0, %1" : : "a" (_data), "Nd" (_port));
}

static inline void outb(uint16_t _port, uint8_t _data) {
  101930:	55                   	push   %ebp
  101931:	89 e5                	mov    %esp,%ebp
  101933:	50                   	push   %eax
  101934:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  101938:	66 89 c1             	mov    %ax,%cx
  10193b:	8a 55 0c             	mov    0xc(%ebp),%dl
  10193e:	66 89 4d fe          	mov    %cx,-0x2(%ebp)
  101942:	88 55 fd             	mov    %dl,-0x3(%ebp)
    asm volatile ("outb %0, %1" : : "a" (_data), "Nd" (_port));
  101945:	8a 45 fd             	mov    -0x3(%ebp),%al
  101948:	66 8b 55 fe          	mov    -0x2(%ebp),%dx
  10194c:	ee                   	out    %al,(%dx)
}
  10194d:	83 c4 04             	add    $0x4,%esp
  101950:	5d                   	pop    %ebp
  101951:	c3                   	ret    
  101952:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101959:	1f 84 00 00 00 00 00 

00101960 <register_intr_handler>:

void register_intr_handler(int i, void (*fn)()) {
  101960:	55                   	push   %ebp
  101961:	89 e5                	mov    %esp,%ebp
  101963:	83 ec 08             	sub    $0x8,%esp
  101966:	8b 45 0c             	mov    0xc(%ebp),%eax
  101969:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10196c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  10196f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	handlers[i] = fn;
  101972:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101975:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  101978:	89 04 8d 20 93 10 00 	mov    %eax,0x109320(,%ecx,4)
	handler_set[i] = 1;
  10197f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101982:	c7 04 85 20 92 10 00 	movl   $0x1,0x109220(,%eax,4)
  101989:	01 00 00 00 
}
  10198d:	83 c4 08             	add    $0x8,%esp
  101990:	5d                   	pop    %ebp
  101991:	c3                   	ret    
  101992:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101999:	1f 84 00 00 00 00 00 

001019a0 <handle_interrupt>:

struct cpu_state* handle_interrupt(struct cpu_state* cpu) {
  1019a0:	55                   	push   %ebp
  1019a1:	89 e5                	mov    %esp,%ebp
  1019a3:	83 ec 28             	sub    $0x28,%esp
  1019a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1019a9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	struct cpu_state* new_cpu = cpu;
  1019ac:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1019af:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if (cpu->intr <= 0x1f) {
  1019b2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1019b5:	81 78 1c 1f 00 00 00 	cmpl   $0x1f,0x1c(%eax)
  1019bc:	0f 87 3d 00 00 00    	ja     1019ff <handle_interrupt+0x5f>
		if (!isSchedulingEnabled()) {
  1019c2:	e8 29 18 00 00       	call   1031f0 <isSchedulingEnabled>
  1019c7:	3d 00 00 00 00       	cmp    $0x0,%eax
  1019cc:	0f 85 1a 00 00 00    	jne    1019ec <handle_interrupt+0x4c>
  1019d2:	8d 05 15 72 10 00    	lea    0x107215,%eax
			show_cod(cpu, "Kernel PANIC!");
  1019d8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1019db:	89 0c 24             	mov    %ecx,(%esp)
  1019de:	89 44 24 04          	mov    %eax,0x4(%esp)
  1019e2:	e8 89 e9 ff ff       	call   100370 <show_cod>
		} else {
  1019e7:	e9 0e 00 00 00       	jmp    1019fa <handle_interrupt+0x5a>
			schedule_exception(cpu);
  1019ec:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1019ef:	89 04 24             	mov    %eax,(%esp)
  1019f2:	e8 59 19 00 00       	call   103350 <schedule_exception>
  1019f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
		}
	} else if (cpu->intr >= 0x20 && cpu->intr <= 0x2f) {
  1019fa:	e9 fc 00 00 00       	jmp    101afb <handle_interrupt+0x15b>
  1019ff:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a02:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101a09:	0f 82 a7 00 00 00    	jb     101ab6 <handle_interrupt+0x116>
  101a0f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a12:	81 78 1c 2f 00 00 00 	cmpl   $0x2f,0x1c(%eax)
  101a19:	0f 87 97 00 00 00    	ja     101ab6 <handle_interrupt+0x116>
		if (cpu->intr >= 0x28) {
  101a1f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a22:	81 78 1c 28 00 00 00 	cmpl   $0x28,0x1c(%eax)
  101a29:	0f 82 24 00 00 00    	jb     101a53 <handle_interrupt+0xb3>
  101a2f:	b8 a0 00 00 00       	mov    $0xa0,%eax
  101a34:	b9 20 00 00 00       	mov    $0x20,%ecx
			outb(0xa0, 0x20);
  101a39:	c7 04 24 a0 00 00 00 	movl   $0xa0,(%esp)
  101a40:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101a47:	00 
  101a48:	89 45 f0             	mov    %eax,-0x10(%ebp)
  101a4b:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  101a4e:	e8 dd fe ff ff       	call   101930 <outb>
		}
		if (cpu->intr == 0x20) {
  101a53:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a56:	81 78 1c 20 00 00 00 	cmpl   $0x20,0x1c(%eax)
  101a5d:	0f 85 0e 00 00 00    	jne    101a71 <handle_interrupt+0xd1>
			new_cpu = schedule(cpu);
  101a63:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a66:	89 04 24             	mov    %eax,(%esp)
  101a69:	e8 12 1d 00 00       	call   103780 <schedule>
  101a6e:	89 45 f8             	mov    %eax,-0x8(%ebp)
  101a71:	b8 20 00 00 00       	mov    $0x20,%eax
		}
		outb(0x20, 0x20);
  101a76:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  101a7d:	c7 44 24 04 20 00 00 	movl   $0x20,0x4(%esp)
  101a84:	00 
  101a85:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101a88:	e8 a3 fe ff ff       	call   101930 <outb>
		if (handler_set[cpu->intr]) {
  101a8d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101a90:	8b 40 1c             	mov    0x1c(%eax),%eax
  101a93:	81 3c 85 20 92 10 00 	cmpl   $0x0,0x109220(,%eax,4)
  101a9a:	00 00 00 00 
  101a9e:	0f 84 0d 00 00 00    	je     101ab1 <handle_interrupt+0x111>
			handlers[cpu->intr]();
  101aa4:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101aa7:	8b 40 1c             	mov    0x1c(%eax),%eax
  101aaa:	ff 14 85 20 93 10 00 	call   *0x109320(,%eax,4)
		}
	} else if (cpu->intr == 0x30) {
  101ab1:	e9 40 00 00 00       	jmp    101af6 <handle_interrupt+0x156>
  101ab6:	8b 45 fc             	mov    -0x4(%ebp),%eax
  101ab9:	81 78 1c 30 00 00 00 	cmpl   $0x30,0x1c(%eax)
  101ac0:	0f 85 13 00 00 00    	jne    101ad9 <handle_interrupt+0x139>
		new_cpu = syscall(new_cpu);
  101ac6:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ac9:	89 04 24             	mov    %eax,(%esp)
  101acc:	e8 5f 01 00 00       	call   101c30 <syscall>
  101ad1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	} else {
  101ad4:	e9 18 00 00 00       	jmp    101af1 <handle_interrupt+0x151>
  101ad9:	8d 05 23 72 10 00    	lea    0x107223,%eax
		kprintf("Unbekannter Interrupt\n");
  101adf:	89 04 24             	mov    %eax,(%esp)
  101ae2:	e8 69 ea ff ff       	call   100550 <kprintf>
  101ae7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		while (1) {
			// Prozessor anhalten
			asm volatile("cli; hlt");
  101aea:	fa                   	cli    
  101aeb:	f4                   	hlt    
		}
  101aec:	e9 f9 ff ff ff       	jmp    101aea <handle_interrupt+0x14a>
  101af1:	e9 00 00 00 00       	jmp    101af6 <handle_interrupt+0x156>
  101af6:	e9 00 00 00 00       	jmp    101afb <handle_interrupt+0x15b>
	}

	return new_cpu;
  101afb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101afe:	83 c4 28             	add    $0x28,%esp
  101b01:	5d                   	pop    %ebp
  101b02:	c3                   	ret    
  101b03:	90                   	nop

00101b04 <intr_stub_0>:
  101b04:	6a 00                	push   $0x0
  101b06:	6a 00                	push   $0x0
  101b08:	e9 eb 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b0d <intr_stub_1>:
  101b0d:	6a 00                	push   $0x0
  101b0f:	6a 01                	push   $0x1
  101b11:	e9 e2 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b16 <intr_stub_2>:
  101b16:	6a 00                	push   $0x0
  101b18:	6a 02                	push   $0x2
  101b1a:	e9 d9 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b1f <intr_stub_3>:
  101b1f:	6a 00                	push   $0x0
  101b21:	6a 03                	push   $0x3
  101b23:	e9 d0 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b28 <intr_stub_4>:
  101b28:	6a 00                	push   $0x0
  101b2a:	6a 04                	push   $0x4
  101b2c:	e9 c7 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b31 <intr_stub_5>:
  101b31:	6a 00                	push   $0x0
  101b33:	6a 05                	push   $0x5
  101b35:	e9 be 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b3a <intr_stub_6>:
  101b3a:	6a 00                	push   $0x0
  101b3c:	6a 06                	push   $0x6
  101b3e:	e9 b5 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b43 <intr_stub_7>:
  101b43:	6a 00                	push   $0x0
  101b45:	6a 07                	push   $0x7
  101b47:	e9 ac 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b4c <intr_stub_8>:
  101b4c:	6a 08                	push   $0x8
  101b4e:	e9 a5 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b53 <intr_stub_9>:
  101b53:	6a 00                	push   $0x0
  101b55:	6a 09                	push   $0x9
  101b57:	e9 9c 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b5c <intr_stub_10>:
  101b5c:	6a 0a                	push   $0xa
  101b5e:	e9 95 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b63 <intr_stub_11>:
  101b63:	6a 0b                	push   $0xb
  101b65:	e9 8e 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b6a <intr_stub_12>:
  101b6a:	6a 0c                	push   $0xc
  101b6c:	e9 87 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b71 <intr_stub_13>:
  101b71:	6a 0d                	push   $0xd
  101b73:	e9 80 00 00 00       	jmp    101bf8 <intr_common_handler>

00101b78 <intr_stub_14>:
  101b78:	6a 0e                	push   $0xe
  101b7a:	eb 7c                	jmp    101bf8 <intr_common_handler>

00101b7c <intr_stub_15>:
  101b7c:	6a 00                	push   $0x0
  101b7e:	6a 0f                	push   $0xf
  101b80:	eb 76                	jmp    101bf8 <intr_common_handler>

00101b82 <intr_stub_16>:
  101b82:	6a 00                	push   $0x0
  101b84:	6a 10                	push   $0x10
  101b86:	eb 70                	jmp    101bf8 <intr_common_handler>

00101b88 <intr_stub_17>:
  101b88:	6a 11                	push   $0x11
  101b8a:	eb 6c                	jmp    101bf8 <intr_common_handler>

00101b8c <intr_stub_18>:
  101b8c:	6a 00                	push   $0x0
  101b8e:	6a 12                	push   $0x12
  101b90:	eb 66                	jmp    101bf8 <intr_common_handler>

00101b92 <intr_stub_32>:
  101b92:	6a 00                	push   $0x0
  101b94:	6a 20                	push   $0x20
  101b96:	eb 60                	jmp    101bf8 <intr_common_handler>

00101b98 <intr_stub_33>:
  101b98:	6a 00                	push   $0x0
  101b9a:	6a 21                	push   $0x21
  101b9c:	eb 5a                	jmp    101bf8 <intr_common_handler>

00101b9e <intr_stub_34>:
  101b9e:	6a 00                	push   $0x0
  101ba0:	6a 22                	push   $0x22
  101ba2:	eb 54                	jmp    101bf8 <intr_common_handler>

00101ba4 <intr_stub_35>:
  101ba4:	6a 00                	push   $0x0
  101ba6:	6a 23                	push   $0x23
  101ba8:	eb 4e                	jmp    101bf8 <intr_common_handler>

00101baa <intr_stub_36>:
  101baa:	6a 00                	push   $0x0
  101bac:	6a 24                	push   $0x24
  101bae:	eb 48                	jmp    101bf8 <intr_common_handler>

00101bb0 <intr_stub_37>:
  101bb0:	6a 00                	push   $0x0
  101bb2:	6a 25                	push   $0x25
  101bb4:	eb 42                	jmp    101bf8 <intr_common_handler>

00101bb6 <intr_stub_38>:
  101bb6:	6a 00                	push   $0x0
  101bb8:	6a 26                	push   $0x26
  101bba:	eb 3c                	jmp    101bf8 <intr_common_handler>

00101bbc <intr_stub_39>:
  101bbc:	6a 00                	push   $0x0
  101bbe:	6a 27                	push   $0x27
  101bc0:	eb 36                	jmp    101bf8 <intr_common_handler>

00101bc2 <intr_stub_40>:
  101bc2:	6a 00                	push   $0x0
  101bc4:	6a 28                	push   $0x28
  101bc6:	eb 30                	jmp    101bf8 <intr_common_handler>

00101bc8 <intr_stub_41>:
  101bc8:	6a 00                	push   $0x0
  101bca:	6a 29                	push   $0x29
  101bcc:	eb 2a                	jmp    101bf8 <intr_common_handler>

00101bce <intr_stub_42>:
  101bce:	6a 00                	push   $0x0
  101bd0:	6a 2a                	push   $0x2a
  101bd2:	eb 24                	jmp    101bf8 <intr_common_handler>

00101bd4 <intr_stub_43>:
  101bd4:	6a 00                	push   $0x0
  101bd6:	6a 2b                	push   $0x2b
  101bd8:	eb 1e                	jmp    101bf8 <intr_common_handler>

00101bda <intr_stub_44>:
  101bda:	6a 00                	push   $0x0
  101bdc:	6a 2c                	push   $0x2c
  101bde:	eb 18                	jmp    101bf8 <intr_common_handler>

00101be0 <intr_stub_45>:
  101be0:	6a 00                	push   $0x0
  101be2:	6a 2d                	push   $0x2d
  101be4:	eb 12                	jmp    101bf8 <intr_common_handler>

00101be6 <intr_stub_46>:
  101be6:	6a 00                	push   $0x0
  101be8:	6a 2e                	push   $0x2e
  101bea:	eb 0c                	jmp    101bf8 <intr_common_handler>

00101bec <intr_stub_47>:
  101bec:	6a 00                	push   $0x0
  101bee:	6a 2f                	push   $0x2f
  101bf0:	eb 06                	jmp    101bf8 <intr_common_handler>

00101bf2 <intr_stub_48>:
  101bf2:	6a 00                	push   $0x0
  101bf4:	6a 30                	push   $0x30
  101bf6:	eb 00                	jmp    101bf8 <intr_common_handler>

00101bf8 <intr_common_handler>:
  101bf8:	55                   	push   %ebp
  101bf9:	57                   	push   %edi
  101bfa:	56                   	push   %esi
  101bfb:	52                   	push   %edx
  101bfc:	51                   	push   %ecx
  101bfd:	53                   	push   %ebx
  101bfe:	50                   	push   %eax
  101bff:	54                   	push   %esp
  101c00:	66 b8 10 00          	mov    $0x10,%ax
  101c04:	66 8e d8             	mov    %ax,%ds
  101c07:	66 8e c0             	mov    %ax,%es
  101c0a:	e8 91 fd ff ff       	call   1019a0 <handle_interrupt>
  101c0f:	89 c4                	mov    %eax,%esp
  101c11:	66 b8 23 00          	mov    $0x23,%ax
  101c15:	66 8e d8             	mov    %ax,%ds
  101c18:	66 8e c0             	mov    %ax,%es
  101c1b:	58                   	pop    %eax
  101c1c:	5b                   	pop    %ebx
  101c1d:	59                   	pop    %ecx
  101c1e:	5a                   	pop    %edx
  101c1f:	5e                   	pop    %esi
  101c20:	5f                   	pop    %edi
  101c21:	5d                   	pop    %ebp
  101c22:	83 c4 08             	add    $0x8,%esp
  101c25:	cf                   	iret   
  101c26:	66 90                	xchg   %ax,%ax
  101c28:	66 90                	xchg   %ax,%ax
  101c2a:	66 90                	xchg   %ax,%ax
  101c2c:	66 90                	xchg   %ax,%ax
  101c2e:	66 90                	xchg   %ax,%ax

00101c30 <syscall>:
#include "vfs.h"
#include "ramfs/fifo.h"
#include "ramfs/block.h"
#include "ramfs/tar.h"

struct cpu_state* syscall(struct cpu_state* cpu) {
  101c30:	55                   	push   %ebp
  101c31:	89 e5                	mov    %esp,%ebp
  101c33:	56                   	push   %esi
  101c34:	83 ec 64             	sub    $0x64,%esp
  101c37:	8b 45 08             	mov    0x8(%ebp),%eax
  101c3a:	89 45 f8             	mov    %eax,-0x8(%ebp)
	switch (cpu->eax) {
  101c3d:	8b 00                	mov    (%eax),%eax
  101c3f:	89 c1                	mov    %eax,%ecx
  101c41:	81 e9 c8 00 00 00    	sub    $0xc8,%ecx
  101c47:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  101c4a:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  101c4d:	0f 8f 26 00 00 00    	jg     101c79 <syscall+0x49>
  101c53:	e9 00 00 00 00       	jmp    101c58 <syscall+0x28>
  101c58:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101c5b:	48                   	dec    %eax
  101c5c:	89 c1                	mov    %eax,%ecx
  101c5e:	83 e9 05             	sub    $0x5,%ecx
  101c61:	89 45 cc             	mov    %eax,-0x34(%ebp)
  101c64:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  101c67:	0f 87 81 02 00 00    	ja     101eee <syscall+0x2be>
  101c6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
  101c70:	8b 0c 85 44 70 10 00 	mov    0x107044(,%eax,4),%ecx
  101c77:	ff e1                	jmp    *%ecx
  101c79:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  101c7c:	05 37 ff ff ff       	add    $0xffffff37,%eax
  101c81:	89 c1                	mov    %eax,%ecx
  101c83:	83 e9 04             	sub    $0x4,%ecx
  101c86:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  101c89:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  101c8c:	0f 87 5c 02 00 00    	ja     101eee <syscall+0x2be>
  101c92:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  101c95:	8b 0c 85 30 70 10 00 	mov    0x107030(,%eax,4),%ecx
  101c9c:	ff e1                	jmp    *%ecx
	case 1: /* exit */
		cpu = terminate_current(cpu);
  101c9e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ca1:	89 04 24             	mov    %eax,(%esp)
  101ca4:	e8 d7 17 00 00       	call   103480 <terminate_current>
  101ca9:	89 45 f8             	mov    %eax,-0x8(%ebp)
		break;
  101cac:	e9 57 02 00 00       	jmp    101f08 <syscall+0x2d8>

	case 2: /* fork */
	{
		save_cpu_state(cpu);
  101cb1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101cb4:	89 04 24             	mov    %eax,(%esp)
  101cb7:	e8 84 1a 00 00       	call   103740 <save_cpu_state>

		uint32_t forkpdir = vmm_fork_current();
  101cbc:	e8 bf 30 00 00       	call   104d80 <vmm_fork_current>
  101cc1:	b9 00 00 00 00       	mov    $0x0,%ecx
  101cc6:	89 45 f4             	mov    %eax,-0xc(%ebp)

		struct task* ntask = init_task(forkpdir, 0);
  101cc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101ccc:	89 04 24             	mov    %eax,(%esp)
  101ccf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  101cd6:	00 
  101cd7:	89 4d bc             	mov    %ecx,-0x44(%ebp)
  101cda:	e8 b1 18 00 00       	call   103590 <init_task>
  101cdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
		fork_task_state(ntask);
  101ce2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101ce5:	89 04 24             	mov    %eax,(%esp)
  101ce8:	e8 43 18 00 00       	call   103530 <fork_task_state>

		cpu->eax = ntask->PID;
  101ced:	8b 45 f0             	mov    -0x10(%ebp),%eax
  101cf0:	8b 00                	mov    (%eax),%eax
  101cf2:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101cf5:	89 01                	mov    %eax,(%ecx)
	}
		break;
  101cf7:	e9 0c 02 00 00       	jmp    101f08 <syscall+0x2d8>

	case 3: /* fopen */
	{
	    char* name = (char*) cpu->ebx;
  101cfc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101cff:	8b 40 04             	mov    0x4(%eax),%eax
  101d02:	89 45 ec             	mov    %eax,-0x14(%ebp)
	    uint32_t fmode = (uint32_t) cpu->ecx;
  101d05:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d08:	8b 40 08             	mov    0x8(%eax),%eax
  101d0b:	89 45 e8             	mov    %eax,-0x18(%ebp)

	    struct res_handle* handle = vfs_open(name, fmode);
  101d0e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  101d11:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  101d14:	89 04 24             	mov    %eax,(%esp)
  101d17:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101d1b:	e8 30 2a 00 00       	call   104750 <vfs_open>
  101d20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    if(handle) {
  101d23:	81 7d e4 00 00 00 00 	cmpl   $0x0,-0x1c(%ebp)
  101d2a:	0f 84 1b 00 00 00    	je     101d4b <syscall+0x11b>
	        register_handle(handle);
  101d30:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  101d33:	89 04 24             	mov    %eax,(%esp)
  101d36:	e8 d5 14 00 00       	call   103210 <register_handle>
	        cpu->eax = (uint32_t) handle;
  101d3b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  101d3e:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101d41:	89 0a                	mov    %ecx,(%edx)
	    }
  101d43:	89 45 b8             	mov    %eax,-0x48(%ebp)
  101d46:	e9 09 00 00 00       	jmp    101d54 <syscall+0x124>
	    else
	    {
	        cpu->eax = 0;
  101d4b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d4e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	    }
	}
	    break;
  101d54:	e9 af 01 00 00       	jmp    101f08 <syscall+0x2d8>

	case 4: /* fclose */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  101d59:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d5c:	8b 40 04             	mov    0x4(%eax),%eax
  101d5f:	89 45 e0             	mov    %eax,-0x20(%ebp)
	    if(!unregister_handle(handle)) {
  101d62:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101d65:	89 04 24             	mov    %eax,(%esp)
  101d68:	e8 03 15 00 00       	call   103270 <unregister_handle>
  101d6d:	3d 00 00 00 00       	cmp    $0x0,%eax
  101d72:	0f 85 1c 00 00 00    	jne    101d94 <syscall+0x164>
	        vfs_close(handle);
  101d78:	8b 45 e0             	mov    -0x20(%ebp),%eax
  101d7b:	89 04 24             	mov    %eax,(%esp)
  101d7e:	e8 4d 2a 00 00       	call   1047d0 <vfs_close>

	        cpu->eax = 0;
  101d83:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101d86:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	    }
  101d8c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  101d8f:	e9 09 00 00 00       	jmp    101d9d <syscall+0x16d>
	    else
	    {
	        cpu->eax = (uint32_t) -1;
  101d94:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101d97:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
	    }
	}
	    break;
  101d9d:	e9 66 01 00 00       	jmp    101f08 <syscall+0x2d8>

	case 5: /* fwrite */
	{
	    struct res_handle* handle = (void*) cpu->ebx;
  101da2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101da5:	8b 40 04             	mov    0x4(%eax),%eax
  101da8:	89 45 dc             	mov    %eax,-0x24(%ebp)
	    if(handle != 0) {
  101dab:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  101db2:	0f 84 39 00 00 00    	je     101df1 <syscall+0x1c1>
  101db8:	b8 01 00 00 00       	mov    $0x1,%eax
	        cpu->eax = vfs_write(handle, (char*) cpu->ecx, cpu->edx, 1);
  101dbd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  101dc0:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101dc3:	8b 52 08             	mov    0x8(%edx),%edx
  101dc6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  101dc9:	8b 76 0c             	mov    0xc(%esi),%esi
  101dcc:	89 0c 24             	mov    %ecx,(%esp)
  101dcf:	89 54 24 04          	mov    %edx,0x4(%esp)
  101dd3:	89 74 24 08          	mov    %esi,0x8(%esp)
  101dd7:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  101dde:	00 
  101ddf:	89 45 b0             	mov    %eax,-0x50(%ebp)
  101de2:	e8 19 2b 00 00       	call   104900 <vfs_write>
  101de7:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101dea:	89 01                	mov    %eax,(%ecx)
	    }
  101dec:	e9 09 00 00 00       	jmp    101dfa <syscall+0x1ca>
	    else
	    {
            cpu->eax = RW_ERR_VFS;
  101df1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101df4:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
	    }
	}
	    break;
  101dfa:	e9 09 01 00 00       	jmp    101f08 <syscall+0x2d8>

	case 6: /* fread */
	{
        struct res_handle* handle = (void*) cpu->ebx;
  101dff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e02:	8b 40 04             	mov    0x4(%eax),%eax
  101e05:	89 45 d8             	mov    %eax,-0x28(%ebp)
        if(handle != 0) {
  101e08:	81 7d d8 00 00 00 00 	cmpl   $0x0,-0x28(%ebp)
  101e0f:	0f 84 39 00 00 00    	je     101e4e <syscall+0x21e>
  101e15:	b8 01 00 00 00       	mov    $0x1,%eax
            cpu->eax = vfs_read(handle, (char*) cpu->ecx, cpu->edx, 1);
  101e1a:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  101e1d:	8b 55 f8             	mov    -0x8(%ebp),%edx
  101e20:	8b 52 08             	mov    0x8(%edx),%edx
  101e23:	8b 75 f8             	mov    -0x8(%ebp),%esi
  101e26:	8b 76 0c             	mov    0xc(%esi),%esi
  101e29:	89 0c 24             	mov    %ecx,(%esp)
  101e2c:	89 54 24 04          	mov    %edx,0x4(%esp)
  101e30:	89 74 24 08          	mov    %esi,0x8(%esp)
  101e34:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  101e3b:	00 
  101e3c:	89 45 ac             	mov    %eax,-0x54(%ebp)
  101e3f:	e8 dc 29 00 00       	call   104820 <vfs_read>
  101e44:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e47:	89 01                	mov    %eax,(%ecx)
        }
  101e49:	e9 09 00 00 00       	jmp    101e57 <syscall+0x227>
        else
        {
            cpu->eax = RW_ERR_VFS;
  101e4e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101e51:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
        }
	}
	    break;
  101e57:	e9 ac 00 00 00       	jmp    101f08 <syscall+0x2d8>
  101e5c:	8d 05 3a 72 10 00    	lea    0x10723a,%eax

	case 201: /* kputc */
		cpu->eax = kprintf("%c", cpu->ebx);
  101e62:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e65:	8b 49 04             	mov    0x4(%ecx),%ecx
  101e68:	89 04 24             	mov    %eax,(%esp)
  101e6b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101e6f:	e8 dc e6 ff ff       	call   100550 <kprintf>
  101e74:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e77:	89 01                	mov    %eax,(%ecx)
		break;
  101e79:	e9 8a 00 00 00       	jmp    101f08 <syscall+0x2d8>
  101e7e:	8d 05 3d 72 10 00    	lea    0x10723d,%eax
	case 202: /* kputs */
		cpu->eax = kprintf("%s", cpu->ebx);
  101e84:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e87:	8b 49 04             	mov    0x4(%ecx),%ecx
  101e8a:	89 04 24             	mov    %eax,(%esp)
  101e8d:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101e91:	e8 ba e6 ff ff       	call   100550 <kprintf>
  101e96:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101e99:	89 01                	mov    %eax,(%ecx)
		break;
  101e9b:	e9 68 00 00 00       	jmp    101f08 <syscall+0x2d8>
	case 203: /* vmm_alloc_ucont */
		cpu->eax = (uint32_t) vmm_alloc_ucont(cpu->ebx);
  101ea0:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ea3:	8b 40 04             	mov    0x4(%eax),%eax
  101ea6:	89 04 24             	mov    %eax,(%esp)
  101ea9:	e8 22 37 00 00       	call   1055d0 <vmm_alloc_ucont>
  101eae:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101eb1:	89 01                	mov    %eax,(%ecx)
		break;
  101eb3:	e9 50 00 00 00       	jmp    101f08 <syscall+0x2d8>
	case 204: /* vmm_free */
		cpu->eax = 0;
  101eb8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ebb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		if (cpu->ebx >= PROGRAM_BOTTOM) { //Only in PROGRAM AREA ;)
  101ec1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ec4:	81 78 04 00 10 40 20 	cmpl   $0x20401000,0x4(%eax)
  101ecb:	0f 82 0e 00 00 00    	jb     101edf <syscall+0x2af>
			vmm_free((void*) cpu->ebx);
  101ed1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101ed4:	8b 40 04             	mov    0x4(%eax),%eax
  101ed7:	89 04 24             	mov    %eax,(%esp)
  101eda:	e8 61 35 00 00       	call   105440 <vmm_free>
		}
		break;
  101edf:	e9 24 00 00 00       	jmp    101f08 <syscall+0x2d8>
	case 205: /* pmm_print_stats */
		pmm_print_stats();
  101ee4:	e8 87 02 00 00       	call   102170 <pmm_print_stats>
		break;
  101ee9:	e9 1a 00 00 00       	jmp    101f08 <syscall+0x2d8>
  101eee:	8d 05 40 72 10 00    	lea    0x107240,%eax
	default:
		kprintf("Invalid Syscall %d...", cpu->eax);
  101ef4:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  101ef7:	8b 09                	mov    (%ecx),%ecx
  101ef9:	89 04 24             	mov    %eax,(%esp)
  101efc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101f00:	e8 4b e6 ff ff       	call   100550 <kprintf>
  101f05:	89 45 a8             	mov    %eax,-0x58(%ebp)
		break;
	}

	return cpu;
  101f08:	8b 45 f8             	mov    -0x8(%ebp),%eax
  101f0b:	83 c4 64             	add    $0x64,%esp
  101f0e:	5e                   	pop    %esi
  101f0f:	5d                   	pop    %ebp
  101f10:	c3                   	ret    
  101f11:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  101f18:	0f 1f 84 00 00 00 00 
  101f1f:	00 

00101f20 <kernel_main>:
}

void kernel_main(struct multiboot_info* mb_info) {
  101f20:	55                   	push   %ebp
  101f21:	89 e5                	mov    %esp,%ebp
  101f23:	57                   	push   %edi
  101f24:	56                   	push   %esi
  101f25:	83 ec 40             	sub    $0x40,%esp
  101f28:	8b 45 08             	mov    0x8(%ebp),%eax
  101f2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t kernel_init_pdir = vmm_init();
  101f2e:	e8 9d 39 00 00       	call   1058d0 <vmm_init>
  101f33:	8d 0d 56 72 10 00    	lea    0x107256,%ecx
  101f39:	89 45 f0             	mov    %eax,-0x10(%ebp)

    kprintf("Initializing vfs...\n");
  101f3c:	89 0c 24             	mov    %ecx,(%esp)
  101f3f:	e8 0c e6 ff ff       	call   100550 <kprintf>

    vfs_init_root();
  101f44:	89 45 ec             	mov    %eax,-0x14(%ebp)
  101f47:	e8 94 2b 00 00       	call   104ae0 <vfs_init_root>
  101f4c:	b8 00 00 00 00       	mov    $0x0,%eax
    ramfs_fifo_init();
  101f51:	89 45 e8             	mov    %eax,-0x18(%ebp)
  101f54:	e8 a7 0a 00 00       	call   102a00 <ramfs_fifo_init>
    ramfs_block_init();
  101f59:	e8 f2 05 00 00       	call   102550 <ramfs_block_init>

    map_address_active((uint32_t) mb_info,
  101f5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101f61:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  101f64:	89 04 24             	mov    %eax,(%esp)
  101f67:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  101f6b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101f72:	00 
  101f73:	e8 48 35 00 00       	call   1054c0 <map_address_active>
  101f78:	b8 00 00 00 00       	mov    $0x0,%eax
                       (uint32_t) mb_info, 0);
    map_address_active((uint32_t) mb_info->mi_mods_addr,
  101f7d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  101f80:	8b 49 18             	mov    0x18(%ecx),%ecx
  101f83:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101f86:	8b 52 18             	mov    0x18(%edx),%edx
  101f89:	89 0c 24             	mov    %ecx,(%esp)
  101f8c:	89 54 24 04          	mov    %edx,0x4(%esp)
  101f90:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  101f97:	00 
  101f98:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  101f9b:	e8 20 35 00 00       	call   1054c0 <map_address_active>
                       (uint32_t) mb_info->mi_mods_addr, 0);

    if (mb_info->mi_flags & MULTIBOOT_INFO_HAS_MODS) {
  101fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  101fa3:	8b 00                	mov    (%eax),%eax
  101fa5:	25 08 00 00 00       	and    $0x8,%eax
  101faa:	3d 00 00 00 00       	cmp    $0x0,%eax
  101faf:	0f 84 80 00 00 00    	je     102035 <kernel_main+0x115>
  101fb5:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_map_range(mb_info->mi_mods_addr[0].start,
  101fba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  101fbd:	8b 49 18             	mov    0x18(%ecx),%ecx
  101fc0:	8b 09                	mov    (%ecx),%ecx
  101fc2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  101fc5:	8b 52 18             	mov    0x18(%edx),%edx
  101fc8:	8b 12                	mov    (%edx),%edx
  101fca:	8b 75 f4             	mov    -0xc(%ebp),%esi
  101fcd:	8b 76 18             	mov    0x18(%esi),%esi
  101fd0:	8b 76 04             	mov    0x4(%esi),%esi
  101fd3:	8b 7d f4             	mov    -0xc(%ebp),%edi
  101fd6:	8b 7f 18             	mov    0x18(%edi),%edi
  101fd9:	8b 3f                	mov    (%edi),%edi
  101fdb:	29 fe                	sub    %edi,%esi
  101fdd:	89 0c 24             	mov    %ecx,(%esp)
  101fe0:	89 54 24 04          	mov    %edx,0x4(%esp)
  101fe4:	89 74 24 08          	mov    %esi,0x8(%esp)
  101fe8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  101fef:	00 
  101ff0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  101ff3:	e8 38 35 00 00       	call   105530 <vmm_map_range>
  101ff8:	8d 05 6b 72 10 00    	lea    0x10726b,%eax
                      mb_info->mi_mods_addr[0].start,
                      mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start,
                      0);

        kprintf("Assuming mbmod[0] is a tarball (%d bytes) and unpacking it...", mb_info->mi_mods_addr[0].end - mb_info->mi_mods_addr[0].start);
  101ffe:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102001:	8b 49 18             	mov    0x18(%ecx),%ecx
  102004:	8b 49 04             	mov    0x4(%ecx),%ecx
  102007:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10200a:	8b 52 18             	mov    0x18(%edx),%edx
  10200d:	8b 12                	mov    (%edx),%edx
  10200f:	29 d1                	sub    %edx,%ecx
  102011:	89 04 24             	mov    %eax,(%esp)
  102014:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102018:	e8 33 e5 ff ff       	call   100550 <kprintf>

        tar_load_ramfs(mb_info->mi_mods_addr[0].start);
  10201d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102020:	8b 49 18             	mov    0x18(%ecx),%ecx
  102023:	8b 09                	mov    (%ecx),%ecx
  102025:	89 0c 24             	mov    %ecx,(%esp)
  102028:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10202b:	e8 70 0f 00 00       	call   102fa0 <tar_load_ramfs>
    } else {
  102030:	e9 11 00 00 00       	jmp    102046 <kernel_main+0x126>
  102035:	8d 05 a9 72 10 00    	lea    0x1072a9,%eax
        kprintf("[PANIC] No multiboot module (initrfs) available.\n");
  10203b:	89 04 24             	mov    %eax,(%esp)
  10203e:	e8 0d e5 ff ff       	call   100550 <kprintf>
  102043:	89 45 d8             	mov    %eax,-0x28(%ebp)
  102046:	8d 05 db 72 10 00    	lea    0x1072db,%eax
    }

    if(vfs_exists("/ibin/init")) {
  10204c:	89 04 24             	mov    %eax,(%esp)
  10204f:	e8 fc 29 00 00       	call   104a50 <vfs_exists>
  102054:	3d 00 00 00 00       	cmp    $0x0,%eax
  102059:	0f 84 11 00 00 00    	je     102070 <kernel_main+0x150>
  10205f:	8d 05 e6 72 10 00    	lea    0x1072e6,%eax
        kprintf("[init] /ibin/init found. Executing...");
  102065:	89 04 24             	mov    %eax,(%esp)
  102068:	e8 e3 e4 ff ff       	call   100550 <kprintf>
  10206d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    }


	while(1);
  102070:	e9 00 00 00 00       	jmp    102075 <kernel_main+0x155>
  102075:	e9 fb ff ff ff       	jmp    102075 <kernel_main+0x155>
  10207a:	66 90                	xchg   %ax,%ax
  10207c:	66 90                	xchg   %ax,%ax
  10207e:	66 90                	xchg   %ax,%ax

00102080 <pmm_alloc>:
#define BITMAP_SIZE 32768

uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
  102080:	55                   	push   %ebp
  102081:	89 e5                	mov    %esp,%ebp
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102083:	56                   	push   %esi
  102084:	83 ec 10             	sub    $0x10,%esp
  102087:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10208e:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102095:	0f 8d b7 00 00 00    	jge    102152 <pmm_alloc+0xd2>
		if (allocatable[i]) {
  10209b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10209e:	81 3c 85 90 94 12 00 	cmpl   $0x0,0x129490(,%eax,4)
  1020a5:	00 00 00 00 
  1020a9:	0f 84 8e 00 00 00    	je     10213d <pmm_alloc+0xbd>
			int s;
			for (s = 0; s < 32; s++) {
  1020af:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1020b6:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  1020bd:	0f 8d 75 00 00 00    	jge    102138 <pmm_alloc+0xb8>
  1020c3:	b8 01 00 00 00       	mov    $0x1,%eax
				if (allocatable[i] & (1 << s)) {
  1020c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1020cb:	8b 0c 8d 90 94 12 00 	mov    0x129490(,%ecx,4),%ecx
  1020d2:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1020d5:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  1020d8:	89 d1                	mov    %edx,%ecx
  1020da:	d3 e0                	shl    %cl,%eax
  1020dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1020df:	21 c2                	and    %eax,%edx
  1020e1:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  1020e7:	0f 84 36 00 00 00    	je     102123 <pmm_alloc+0xa3>
  1020ed:	b8 01 00 00 00       	mov    $0x1,%eax
					allocatable[i] &= ~(1 << s);
  1020f2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1020f5:	d3 e0                	shl    %cl,%eax
  1020f7:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  1020fc:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1020ff:	8b 34 95 90 94 12 00 	mov    0x129490(,%edx,4),%esi
  102106:	21 c6                	and    %eax,%esi
  102108:	89 34 95 90 94 12 00 	mov    %esi,0x129490(,%edx,4)
					return (uint8_t*) ((i * 32 + s) * 4096);
  10210f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102112:	c1 e0 05             	shl    $0x5,%eax
  102115:	03 45 f0             	add    -0x10(%ebp),%eax
  102118:	c1 e0 0c             	shl    $0xc,%eax
  10211b:	89 45 f8             	mov    %eax,-0x8(%ebp)
  10211e:	e9 36 00 00 00       	jmp    102159 <pmm_alloc+0xd9>
				}
			}
  102123:	e9 00 00 00 00       	jmp    102128 <pmm_alloc+0xa8>
void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
		if (allocatable[i]) {
			int s;
			for (s = 0; s < 32; s++) {
  102128:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10212b:	05 01 00 00 00       	add    $0x1,%eax
  102130:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102133:	e9 7e ff ff ff       	jmp    1020b6 <pmm_alloc+0x36>
				if (allocatable[i] & (1 << s)) {
					allocatable[i] &= ~(1 << s);
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
  102138:	e9 00 00 00 00       	jmp    10213d <pmm_alloc+0xbd>
	}
  10213d:	e9 00 00 00 00       	jmp    102142 <pmm_alloc+0xc2>
uint32_t allocatable[BITMAP_SIZE];
uint32_t upper_limit = 0;

void* pmm_alloc() {
	int i;
	for (i = 0; i < BITMAP_SIZE; i++) {
  102142:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102145:	05 01 00 00 00       	add    $0x1,%eax
  10214a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  10214d:	e9 3c ff ff ff       	jmp    10208e <pmm_alloc+0xe>
					return (uint8_t*) ((i * 32 + s) * 4096);
				}
			}
		}
	}
	return NULL ;
  102152:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
}
  102159:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10215c:	83 c4 10             	add    $0x10,%esp
  10215f:	5e                   	pop    %esi
  102160:	5d                   	pop    %ebp
  102161:	c3                   	ret    
  102162:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102169:	1f 84 00 00 00 00 00 

00102170 <pmm_print_stats>:

void pmm_print_stats() {
  102170:	55                   	push   %ebp
  102171:	89 e5                	mov    %esp,%ebp
  102173:	56                   	push   %esi
  102174:	83 ec 34             	sub    $0x34,%esp
  102177:	b8 00 00 10 00       	mov    $0x100000,%eax
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
  10217c:	c7 04 24 00 00 10 00 	movl   $0x100000,(%esp)
  102183:	89 45 f8             	mov    %eax,-0x8(%ebp)
  102186:	e8 65 00 00 00       	call   1021f0 <pmm_get_free_space>
  10218b:	b9 00 04 00 00       	mov    $0x400,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  102190:	8b 15 20 94 10 00    	mov    0x109420,%edx
  102196:	c1 ea 14             	shr    $0x14,%edx
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
  102199:	c7 04 24 00 04 00 00 	movl   $0x400,(%esp)
  1021a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1021a3:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1021a6:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1021a9:	e8 42 00 00 00       	call   1021f0 <pmm_get_free_space>
  1021ae:	8d 0d 0c 73 10 00    	lea    0x10730c,%ecx
	}
	return NULL ;
}

void pmm_print_stats() {
	kprintf("Running mikrOS with %dMB/%dMB (%dkB/%dkB) available memory!\n",
  1021b4:	8b 15 20 94 10 00    	mov    0x109420,%edx
  1021ba:	c1 ea 0a             	shr    $0xa,%edx
  1021bd:	89 0c 24             	mov    %ecx,(%esp)
  1021c0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1021c3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1021c7:	8b 75 ec             	mov    -0x14(%ebp),%esi
  1021ca:	89 74 24 08          	mov    %esi,0x8(%esp)
  1021ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  1021d2:	89 54 24 10          	mov    %edx,0x10(%esp)
  1021d6:	e8 75 e3 ff ff       	call   100550 <kprintf>
			pmm_get_free_space(1024 * 1024), upper_limit / (1024 * 1024),
			pmm_get_free_space(1024), upper_limit / 1024);
}
  1021db:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1021de:	83 c4 34             	add    $0x34,%esp
  1021e1:	5e                   	pop    %esi
  1021e2:	5d                   	pop    %ebp
  1021e3:	c3                   	ret    
  1021e4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1021eb:	00 00 00 00 00 

001021f0 <pmm_get_free_space>:

uint32_t pmm_get_free_space(uint32_t div) {
  1021f0:	55                   	push   %ebp
  1021f1:	89 e5                	mov    %esp,%ebp
  1021f3:	83 ec 14             	sub    $0x14,%esp
  1021f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1021f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t free = 0;
  1021fc:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  102203:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10220a:	81 7d f4 00 80 00 00 	cmpl   $0x8000,-0xc(%ebp)
  102211:	0f 83 73 00 00 00    	jae    10228a <pmm_get_free_space+0x9a>
		for (uint32_t s = 0; s < 32; s++) {
  102217:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10221e:	81 7d f0 20 00 00 00 	cmpl   $0x20,-0x10(%ebp)
  102225:	0f 83 4a 00 00 00    	jae    102275 <pmm_get_free_space+0x85>
  10222b:	b8 01 00 00 00       	mov    $0x1,%eax
			if (allocatable[i] & (1 << s))
  102230:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102233:	8b 0c 8d 90 94 12 00 	mov    0x129490(,%ecx,4),%ecx
  10223a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10223d:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102240:	89 d1                	mov    %edx,%ecx
  102242:	d3 e0                	shl    %cl,%eax
  102244:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102247:	21 c2                	and    %eax,%edx
  102249:	81 fa 00 00 00 00    	cmp    $0x0,%edx
  10224f:	0f 84 0b 00 00 00    	je     102260 <pmm_get_free_space+0x70>
				free += 0x1000;
  102255:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102258:	05 00 10 00 00       	add    $0x1000,%eax
  10225d:	89 45 f8             	mov    %eax,-0x8(%ebp)
		}
  102260:	e9 00 00 00 00       	jmp    102265 <pmm_get_free_space+0x75>

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
		for (uint32_t s = 0; s < 32; s++) {
  102265:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102268:	05 01 00 00 00       	add    $0x1,%eax
  10226d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102270:	e9 a9 ff ff ff       	jmp    10221e <pmm_get_free_space+0x2e>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}
  102275:	e9 00 00 00 00       	jmp    10227a <pmm_get_free_space+0x8a>
}

uint32_t pmm_get_free_space(uint32_t div) {
	uint32_t free = 0;

	for (uint32_t i = 0; i < BITMAP_SIZE; i++) {
  10227a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10227d:	05 01 00 00 00       	add    $0x1,%eax
  102282:	89 45 f4             	mov    %eax,-0xc(%ebp)
  102285:	e9 80 ff ff ff       	jmp    10220a <pmm_get_free_space+0x1a>
			if (allocatable[i] & (1 << s))
				free += 0x1000;
		}
	}

	return free / div;
  10228a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10228d:	31 d2                	xor    %edx,%edx
  10228f:	f7 75 fc             	divl   -0x4(%ebp)
  102292:	83 c4 14             	add    $0x14,%esp
  102295:	5d                   	pop    %ebp
  102296:	c3                   	ret    
  102297:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10229e:	00 00 

001022a0 <pmm_free>:
}

void pmm_free(void* addr) {
  1022a0:	55                   	push   %ebp
  1022a1:	89 e5                	mov    %esp,%ebp
  1022a3:	56                   	push   %esi
  1022a4:	83 ec 14             	sub    $0x14,%esp
  1022a7:	8b 45 08             	mov    0x8(%ebp),%eax
  1022aa:	b9 01 00 00 00       	mov    $0x1,%ecx
  1022af:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  1022b2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1022b5:	c1 e8 0c             	shr    $0xc,%eax
  1022b8:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  1022bb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022be:	25 1f 00 00 00       	and    $0x1f,%eax
  1022c3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  1022c6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1022c9:	c1 e8 05             	shr    $0x5,%eax
  1022cc:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] |= (1 << s);
  1022cf:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1022d2:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1022d5:	89 c1                	mov    %eax,%ecx
  1022d7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1022da:	d3 e0                	shl    %cl,%eax
  1022dc:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1022df:	8b 34 95 90 94 12 00 	mov    0x129490(,%edx,4),%esi
  1022e6:	09 c6                	or     %eax,%esi
  1022e8:	89 34 95 90 94 12 00 	mov    %esi,0x129490(,%edx,4)
}
  1022ef:	83 c4 14             	add    $0x14,%esp
  1022f2:	5e                   	pop    %esi
  1022f3:	5d                   	pop    %ebp
  1022f4:	c3                   	ret    
  1022f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1022fc:	00 00 00 00 

00102300 <pmm_mark_used>:

void pmm_mark_used(void* addr) {
  102300:	55                   	push   %ebp
  102301:	89 e5                	mov    %esp,%ebp
  102303:	56                   	push   %esi
  102304:	83 ec 14             	sub    $0x14,%esp
  102307:	8b 45 08             	mov    0x8(%ebp),%eax
  10230a:	b9 01 00 00 00       	mov    $0x1,%ecx
  10230f:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uintptr_t ptr = ((uintptr_t) addr) / 4096;
  102312:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102315:	c1 e8 0c             	shr    $0xc,%eax
  102318:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uintptr_t s = ptr % 32;
  10231b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10231e:	25 1f 00 00 00       	and    $0x1f,%eax
  102323:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uintptr_t i = ptr / 32;
  102326:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102329:	c1 e8 05             	shr    $0x5,%eax
  10232c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	allocatable[i] &= ~(1 << s);
  10232f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102332:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  102335:	89 c1                	mov    %eax,%ecx
  102337:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10233a:	d3 e0                	shl    %cl,%eax
  10233c:	35 ff ff ff ff       	xor    $0xffffffff,%eax
  102341:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102344:	8b 34 95 90 94 12 00 	mov    0x129490(,%edx,4),%esi
  10234b:	21 c6                	and    %eax,%esi
  10234d:	89 34 95 90 94 12 00 	mov    %esi,0x129490(,%edx,4)
}
  102354:	83 c4 14             	add    $0x14,%esp
  102357:	5e                   	pop    %esi
  102358:	5d                   	pop    %ebp
  102359:	c3                   	ret    
  10235a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00102360 <pmm_init>:

void pmm_init(struct multiboot_info* mb_info) {
  102360:	55                   	push   %ebp
  102361:	89 e5                	mov    %esp,%ebp
  102363:	53                   	push   %ebx
  102364:	57                   	push   %edi
  102365:	56                   	push   %esi
  102366:	83 ec 5c             	sub    $0x5c,%esp
  102369:	8b 45 08             	mov    0x8(%ebp),%eax
  10236c:	8d 0d 49 73 10 00    	lea    0x107349,%ecx
  102372:	8d 15 90 94 12 00    	lea    0x129490,%edx
  102378:	89 d6                	mov    %edx,%esi
  10237a:	81 c6 00 00 02 00    	add    $0x20000,%esi
  102380:	89 d7                	mov    %edx,%edi
  102382:	bb 00 00 00 00       	mov    $0x0,%ebx
  102387:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10238a:	b8 00 00 02 00       	mov    $0x20000,%eax
  10238f:	89 45 cc             	mov    %eax,-0x34(%ebp)
  102392:	8b 45 d0             	mov    -0x30(%ebp),%eax
  102395:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct multiboot_mmap* mmap = mb_info->mi_mmap_addr;
  102398:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10239b:	8b 40 30             	mov    0x30(%eax),%eax
  10239e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct multiboot_mmap* mmap_end = (void*) ((uintptr_t) mb_info->mi_mmap_addr
  1023a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1023a4:	8b 40 30             	mov    0x30(%eax),%eax
  1023a7:	89 45 c8             	mov    %eax,-0x38(%ebp)
  1023aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1023ad:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  1023b0:	8b 45 c8             	mov    -0x38(%ebp),%eax
  1023b3:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  1023b6:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  1023b9:	03 41 2c             	add    0x2c(%ecx),%eax
  1023bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
			+ mb_info->mi_mmap_length);

	memset(allocatable, 0, sizeof(allocatable));
  1023bf:	89 3c 24             	mov    %edi,(%esp)
  1023c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  1023c9:	00 
  1023ca:	c7 44 24 08 00 00 02 	movl   $0x20000,0x8(%esp)
  1023d1:	00 
  1023d2:	89 5d bc             	mov    %ebx,-0x44(%ebp)
  1023d5:	89 55 b8             	mov    %edx,-0x48(%ebp)
  1023d8:	89 75 b4             	mov    %esi,-0x4c(%ebp)
  1023db:	e8 e0 1a 00 00       	call   103ec0 <memset>

	kprintf("Mem-Bitmap: %x to %x\n", allocatable, &(allocatable[BITMAP_SIZE]));
  1023e0:	8b 45 c0             	mov    -0x40(%ebp),%eax
  1023e3:	89 04 24             	mov    %eax,(%esp)
  1023e6:	8b 4d b8             	mov    -0x48(%ebp),%ecx
  1023e9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1023ed:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  1023f0:	89 54 24 08          	mov    %edx,0x8(%esp)
  1023f4:	e8 57 e1 ff ff       	call   100550 <kprintf>
  1023f9:	89 45 b0             	mov    %eax,-0x50(%ebp)

	while (mmap < mmap_end) {
  1023fc:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1023ff:	3b 45 e8             	cmp    -0x18(%ebp),%eax
  102402:	0f 83 77 00 00 00    	jae    10247f <pmm_init+0x11f>
		if (mmap->mm_type == 1) {
  102408:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10240b:	81 78 14 01 00 00 00 	cmpl   $0x1,0x14(%eax)
  102412:	0f 85 57 00 00 00    	jne    10246f <pmm_init+0x10f>
			uintptr_t addr = mmap->mm_base_addr;
  102418:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10241b:	8b 40 04             	mov    0x4(%eax),%eax
  10241e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uintptr_t end_addr = addr + mmap->mm_length;
  102421:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102424:	8b 49 0c             	mov    0xc(%ecx),%ecx
  102427:	01 c8                	add    %ecx,%eax
  102429:	89 45 e0             	mov    %eax,-0x20(%ebp)

			while (addr < end_addr) {
  10242c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10242f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  102432:	0f 83 32 00 00 00    	jae    10246a <pmm_init+0x10a>
				pmm_free((void*) addr);
  102438:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10243b:	89 04 24             	mov    %eax,(%esp)
  10243e:	e8 5d fe ff ff       	call   1022a0 <pmm_free>
				if (addr > upper_limit)
  102443:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102446:	3b 05 20 94 10 00    	cmp    0x109420,%eax
  10244c:	0f 86 08 00 00 00    	jbe    10245a <pmm_init+0xfa>
					upper_limit = addr;
  102452:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  102455:	a3 20 94 10 00       	mov    %eax,0x109420
				addr += 0x1000;
  10245a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10245d:	05 00 10 00 00       	add    $0x1000,%eax
  102462:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			}
  102465:	e9 c2 ff ff ff       	jmp    10242c <pmm_init+0xcc>
		}
  10246a:	e9 00 00 00 00       	jmp    10246f <pmm_init+0x10f>
		mmap++;
  10246f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102472:	05 18 00 00 00       	add    $0x18,%eax
  102477:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}
  10247a:	e9 7d ff ff ff       	jmp    1023fc <pmm_init+0x9c>
  10247f:	8d 05 00 00 10 00    	lea    0x100000,%eax

	extern const void kernel_start;
	extern const void kernel_end;

	uintptr_t addr = (uintptr_t) &kernel_start;
  102485:	89 45 dc             	mov    %eax,-0x24(%ebp)
  102488:	8d 05 00 a0 18 00    	lea    0x18a000,%eax
	while (addr < (uintptr_t) &kernel_end) {
  10248e:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  102491:	0f 83 1b 00 00 00    	jae    1024b2 <pmm_init+0x152>
		pmm_mark_used((void*) addr);
  102497:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10249a:	89 04 24             	mov    %eax,(%esp)
  10249d:	e8 5e fe ff ff       	call   102300 <pmm_mark_used>
		addr += 0x1000;
  1024a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1024a5:	05 00 10 00 00       	add    $0x1000,%eax
  1024aa:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
  1024ad:	e9 d6 ff ff ff       	jmp    102488 <pmm_init+0x128>

	struct multiboot_module* modules = mb_info->mi_mods_addr;
  1024b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1024b5:	8b 40 18             	mov    0x18(%eax),%eax
  1024b8:	89 45 d8             	mov    %eax,-0x28(%ebp)

	pmm_mark_used(mb_info);
  1024bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1024be:	89 04 24             	mov    %eax,(%esp)
  1024c1:	e8 3a fe ff ff       	call   102300 <pmm_mark_used>
	pmm_mark_used(modules);
  1024c6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1024c9:	89 04 24             	mov    %eax,(%esp)
  1024cc:	e8 2f fe ff ff       	call   102300 <pmm_mark_used>

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  1024d1:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  1024d8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1024db:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1024de:	3b 41 14             	cmp    0x14(%ecx),%eax
  1024e1:	0f 83 59 00 00 00    	jae    102540 <pmm_init+0x1e0>
		addr = (uintptr_t) modules[i].start;
  1024e7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  1024ea:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  1024ed:	c1 e0 04             	shl    $0x4,%eax
  1024f0:	01 c1                	add    %eax,%ecx
  1024f2:	8b 01                	mov    (%ecx),%eax
  1024f4:	89 45 dc             	mov    %eax,-0x24(%ebp)
		while (addr < (uintptr_t) modules[i].end) {
  1024f7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1024fa:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  1024fd:	8b 55 d8             	mov    -0x28(%ebp),%edx
  102500:	c1 e1 04             	shl    $0x4,%ecx
  102503:	01 ca                	add    %ecx,%edx
  102505:	8b 4a 04             	mov    0x4(%edx),%ecx
  102508:	39 c8                	cmp    %ecx,%eax
  10250a:	0f 83 1b 00 00 00    	jae    10252b <pmm_init+0x1cb>
			pmm_mark_used((void*) addr);
  102510:	8b 45 dc             	mov    -0x24(%ebp),%eax
  102513:	89 04 24             	mov    %eax,(%esp)
  102516:	e8 e5 fd ff ff       	call   102300 <pmm_mark_used>
			addr += 0x1000;
  10251b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  10251e:	05 00 10 00 00       	add    $0x1000,%eax
  102523:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}
  102526:	e9 cc ff ff ff       	jmp    1024f7 <pmm_init+0x197>
	}
  10252b:	e9 00 00 00 00       	jmp    102530 <pmm_init+0x1d0>

	pmm_mark_used(mb_info);
	pmm_mark_used(modules);

	uint32_t i;
	for (i = 0; i < mb_info->mi_mods_count; i++) {
  102530:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  102533:	05 01 00 00 00       	add    $0x1,%eax
  102538:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10253b:	e9 98 ff ff ff       	jmp    1024d8 <pmm_init+0x178>
		while (addr < (uintptr_t) modules[i].end) {
			pmm_mark_used((void*) addr);
			addr += 0x1000;
		}
	}
}
  102540:	83 c4 5c             	add    $0x5c,%esp
  102543:	5e                   	pop    %esi
  102544:	5f                   	pop    %edi
  102545:	5b                   	pop    %ebx
  102546:	5d                   	pop    %ebp
  102547:	c3                   	ret    
  102548:	66 90                	xchg   %ax,%ax
  10254a:	66 90                	xchg   %ax,%ax
  10254c:	66 90                	xchg   %ax,%ax
  10254e:	66 90                	xchg   %ax,%ax

00102550 <ramfs_block_init>:
#include "ramfs/block.h"

struct block_buffer* buffer[65536];

void ramfs_block_init() {
  102550:	55                   	push   %ebp
  102551:	89 e5                	mov    %esp,%ebp
  102553:	83 ec 18             	sub    $0x18,%esp
  102556:	8d 05 90 94 14 00    	lea    0x149490,%eax
  10255c:	b9 00 00 00 00       	mov    $0x0,%ecx
  102561:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102566:	89 04 24             	mov    %eax,(%esp)
  102569:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102570:	00 
  102571:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102578:	00 
  102579:	89 55 fc             	mov    %edx,-0x4(%ebp)
  10257c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10257f:	e8 3c 19 00 00       	call   103ec0 <memset>
}
  102584:	83 c4 18             	add    $0x18,%esp
  102587:	5d                   	pop    %ebp
  102588:	c3                   	ret    
  102589:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102590 <ramfs_block_read>:
    }

    return 0;
}

uint32_t ramfs_block_read(struct res_handle* handle, void* dest, uint32_t length) {
  102590:	55                   	push   %ebp
  102591:	89 e5                	mov    %esp,%ebp
  102593:	83 ec 28             	sub    $0x28,%esp
  102596:	8b 45 10             	mov    0x10(%ebp),%eax
  102599:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10259c:	8b 55 08             	mov    0x8(%ebp),%edx
  10259f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  1025a2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1025a5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1025a8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1025ab:	8b 40 04             	mov    0x4(%eax),%eax
  1025ae:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  1025b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1025b4:	8b 00                	mov    (%eax),%eax
  1025b6:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  1025bd:	00 00 00 00 
  1025c1:	0f 84 70 00 00 00    	je     102637 <ramfs_block_read+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't read that much biatch
  1025c7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1025ca:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1025cd:	8b 09                	mov    (%ecx),%ecx
  1025cf:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  1025d6:	8b 49 04             	mov    0x4(%ecx),%ecx
  1025d9:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1025dc:	2b 4a 08             	sub    0x8(%edx),%ecx
  1025df:	39 c8                	cmp    %ecx,%eax
  1025e1:	0f 86 0c 00 00 00    	jbe    1025f3 <ramfs_block_read+0x63>
  1025e7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  1025ee:	e9 4b 00 00 00       	jmp    10263e <ramfs_block_read+0xae>

        memcpy(dest, buffer[kf->id]->buffer + handle->position, length);
  1025f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1025f6:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1025f9:	8b 09                	mov    (%ecx),%ecx
  1025fb:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102602:	8b 09                	mov    (%ecx),%ecx
  102604:	8b 55 f8             	mov    -0x8(%ebp),%edx
  102607:	03 4a 08             	add    0x8(%edx),%ecx
  10260a:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10260d:	89 04 24             	mov    %eax,(%esp)
  102610:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102614:	89 54 24 08          	mov    %edx,0x8(%esp)
  102618:	e8 03 19 00 00       	call   103f20 <memcpy>
        handle->position += length;
  10261d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102620:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  102623:	8b 51 08             	mov    0x8(%ecx),%edx
  102626:	01 c2                	add    %eax,%edx
  102628:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  10262b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102632:	e9 07 00 00 00       	jmp    10263e <ramfs_block_read+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102637:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  10263e:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102641:	83 c4 28             	add    $0x28,%esp
  102644:	5d                   	pop    %ebp
  102645:	c3                   	ret    
  102646:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10264d:	00 00 00 

00102650 <ramfs_block_write>:

uint32_t ramfs_block_write(struct res_handle* handle, void* src, uint32_t length) {
  102650:	55                   	push   %ebp
  102651:	89 e5                	mov    %esp,%ebp
  102653:	83 ec 28             	sub    $0x28,%esp
  102656:	8b 45 10             	mov    0x10(%ebp),%eax
  102659:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  10265c:	8b 55 08             	mov    0x8(%ebp),%edx
  10265f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102662:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102665:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102668:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10266b:	8b 40 04             	mov    0x4(%eax),%eax
  10266e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102671:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102674:	8b 00                	mov    (%eax),%eax
  102676:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  10267d:	00 00 00 00 
  102681:	0f 84 70 00 00 00    	je     1026f7 <ramfs_block_write+0xa7>
        if(length > (buffer[kf->id]->size - handle->position)) return RW_ERR_DRIVER; //Can't write  that much biatch TODO realloc so file may grow
  102687:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10268a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10268d:	8b 09                	mov    (%ecx),%ecx
  10268f:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102696:	8b 49 04             	mov    0x4(%ecx),%ecx
  102699:	8b 55 f8             	mov    -0x8(%ebp),%edx
  10269c:	2b 4a 08             	sub    0x8(%edx),%ecx
  10269f:	39 c8                	cmp    %ecx,%eax
  1026a1:	0f 86 0c 00 00 00    	jbe    1026b3 <ramfs_block_write+0x63>
  1026a7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  1026ae:	e9 4b 00 00 00       	jmp    1026fe <ramfs_block_write+0xae>

        memcpy(buffer[kf->id]->buffer + handle->position, src, length);
  1026b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1026b6:	8b 00                	mov    (%eax),%eax
  1026b8:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  1026bf:	8b 00                	mov    (%eax),%eax
  1026c1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1026c4:	03 41 08             	add    0x8(%ecx),%eax
  1026c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1026ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1026cd:	89 04 24             	mov    %eax,(%esp)
  1026d0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1026d4:	89 54 24 08          	mov    %edx,0x8(%esp)
  1026d8:	e8 43 18 00 00       	call   103f20 <memcpy>
        handle->position += length;
  1026dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1026e0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1026e3:	8b 51 08             	mov    0x8(%ecx),%edx
  1026e6:	01 c2                	add    %eax,%edx
  1026e8:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  1026eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1026f2:	e9 07 00 00 00       	jmp    1026fe <ramfs_block_write+0xae>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  1026f7:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  1026fe:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102701:	83 c4 28             	add    $0x28,%esp
  102704:	5d                   	pop    %ebp
  102705:	c3                   	ret    
  102706:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10270d:	00 00 00 

00102710 <ramfs_block_open>:

struct res_handle* ramfs_block_open(struct res_kfile* kf, uint32_t filemode) {
  102710:	55                   	push   %ebp
  102711:	89 e5                	mov    %esp,%ebp
  102713:	83 ec 18             	sub    $0x18,%esp
  102716:	8b 45 0c             	mov    0xc(%ebp),%eax
  102719:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10271c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10271f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  102722:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102725:	8b 00                	mov    (%eax),%eax
  102727:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  10272e:	00 00 00 00 
  102732:	0f 84 9d 00 00 00    	je     1027d5 <ramfs_block_open+0xc5>
        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  102738:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10273b:	25 01 00 00 00       	and    $0x1,%eax
  102740:	3d 00 00 00 00       	cmp    $0x0,%eax
  102745:	0f 84 18 00 00 00    	je     102763 <ramfs_block_open+0x53>
  10274b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10274e:	8b 00                	mov    (%eax),%eax
  102750:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102757:	8b 48 08             	mov    0x8(%eax),%ecx
  10275a:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102760:	89 48 08             	mov    %ecx,0x8(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  102763:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102766:	25 02 00 00 00       	and    $0x2,%eax
  10276b:	3d 00 00 00 00       	cmp    $0x0,%eax
  102770:	0f 84 18 00 00 00    	je     10278e <ramfs_block_open+0x7e>
  102776:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102779:	8b 00                	mov    (%eax),%eax
  10277b:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102782:	8b 48 0c             	mov    0xc(%eax),%ecx
  102785:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10278b:	89 48 0c             	mov    %ecx,0xc(%eax)
  10278e:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  102793:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  10279a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  10279d:	e8 ae 10 00 00       	call   103850 <malloc>
  1027a2:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  1027a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1027a8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1027ab:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  1027ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1027b1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  1027b8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1027bb:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  1027c1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1027c4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1027c7:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  1027ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1027cd:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1027d0:	e9 08 00 00 00       	jmp    1027dd <ramfs_block_open+0xcd>
  1027d5:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return (void*)1;
  1027da:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  1027dd:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1027e0:	83 c4 18             	add    $0x18,%esp
  1027e3:	5d                   	pop    %ebp
  1027e4:	c3                   	ret    
  1027e5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1027ec:	00 00 00 00 

001027f0 <ramfs_block_close>:

uint32_t ramfs_block_close(struct res_handle* handle) {
  1027f0:	55                   	push   %ebp
  1027f1:	89 e5                	mov    %esp,%ebp
  1027f3:	83 ec 18             	sub    $0x18,%esp
  1027f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1027f9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1027fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1027ff:	8b 40 04             	mov    0x4(%eax),%eax
  102802:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  102805:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102808:	8b 00                	mov    (%eax),%eax
  10280a:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102811:	00 00 00 00 
  102815:	0f 84 61 00 00 00    	je     10287c <ramfs_block_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  10281b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10281e:	8b 40 0c             	mov    0xc(%eax),%eax
  102821:	25 01 00 00 00       	and    $0x1,%eax
  102826:	3d 00 00 00 00       	cmp    $0x0,%eax
  10282b:	0f 84 18 00 00 00    	je     102849 <ramfs_block_close+0x59>
  102831:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102834:	8b 00                	mov    (%eax),%eax
  102836:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  10283d:	8b 48 08             	mov    0x8(%eax),%ecx
  102840:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102846:	89 48 08             	mov    %ecx,0x8(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  102849:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10284c:	8b 40 0c             	mov    0xc(%eax),%eax
  10284f:	25 02 00 00 00       	and    $0x2,%eax
  102854:	3d 00 00 00 00       	cmp    $0x0,%eax
  102859:	0f 84 18 00 00 00    	je     102877 <ramfs_block_close+0x87>
  10285f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102862:	8b 00                	mov    (%eax),%eax
  102864:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  10286b:	8b 48 0c             	mov    0xc(%eax),%ecx
  10286e:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102874:	89 48 0c             	mov    %ecx,0xc(%eax)
    }
  102877:	e9 00 00 00 00       	jmp    10287c <ramfs_block_close+0x8c>

    free(handle);
  10287c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10287f:	89 04 24             	mov    %eax,(%esp)
  102882:	e8 99 13 00 00       	call   103c20 <free>
  102887:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  10288c:	83 c4 18             	add    $0x18,%esp
  10288f:	5d                   	pop    %ebp
  102890:	c3                   	ret    
  102891:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102898:	0f 1f 84 00 00 00 00 
  10289f:	00 

001028a0 <ramfs_block_available>:

struct kfs_driver* ramfs_block_driver_struct() {
    return &block_driver;
}

uint32_t ramfs_block_available(struct res_handle* handle) {
  1028a0:	55                   	push   %ebp
  1028a1:	89 e5                	mov    %esp,%ebp
  1028a3:	83 ec 0c             	sub    $0xc,%esp
  1028a6:	8b 45 08             	mov    0x8(%ebp),%eax
  1028a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  1028ac:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1028af:	8b 40 04             	mov    0x4(%eax),%eax
  1028b2:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  1028b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028b8:	8b 00                	mov    (%eax),%eax
  1028ba:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  1028c1:	00 00 00 00 
  1028c5:	0f 84 1d 00 00 00    	je     1028e8 <ramfs_block_available+0x48>
        return buffer[kf->id]->size - handle->position;
  1028cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1028ce:	8b 00                	mov    (%eax),%eax
  1028d0:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  1028d7:	8b 40 04             	mov    0x4(%eax),%eax
  1028da:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1028dd:	2b 41 08             	sub    0x8(%ecx),%eax
  1028e0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1028e3:	e9 07 00 00 00       	jmp    1028ef <ramfs_block_available+0x4f>
    }

    return 0;
  1028e8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1028ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1028f2:	83 c4 0c             	add    $0xc,%esp
  1028f5:	5d                   	pop    %ebp
  1028f6:	c3                   	ret    
  1028f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1028fe:	00 00 

00102900 <ramfs_block_create>:

struct res_kfile* ramfs_block_create(uint32_t* args) {
  102900:	55                   	push   %ebp
  102901:	89 e5                	mov    %esp,%ebp
  102903:	83 ec 28             	sub    $0x28,%esp
  102906:	8b 45 08             	mov    0x8(%ebp),%eax
  102909:	b9 08 00 00 00       	mov    $0x8,%ecx
  10290e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  102911:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  102918:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10291b:	e8 30 0f 00 00       	call   103850 <malloc>
  102920:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  102923:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10292a:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  102931:	0f 8d a7 00 00 00    	jge    1029de <ramfs_block_create+0xde>
        if(buffer[i] == 0) {
  102937:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10293a:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102941:	00 00 00 00 
  102945:	0f 85 7e 00 00 00    	jne    1029c9 <ramfs_block_create+0xc9>
  10294b:	b8 10 00 00 00       	mov    $0x10,%eax
            buffer[i] = malloc(sizeof(struct block_buffer));
  102950:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  102957:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10295a:	e8 f1 0e 00 00       	call   103850 <malloc>
  10295f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102962:	89 04 8d 90 94 14 00 	mov    %eax,0x149490(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  102969:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10296c:	8b 00                	mov    (%eax),%eax
  10296e:	89 04 24             	mov    %eax,(%esp)
  102971:	e8 da 0e 00 00       	call   103850 <malloc>
  102976:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102979:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102980:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  102982:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102985:	8b 00                	mov    (%eax),%eax
  102987:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10298a:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102991:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->writers = 0;
  102994:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102997:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  10299e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
            buffer[i]->readers = 0;
  1029a5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1029a8:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  1029af:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

            kfret->id = i;
  1029b6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1029b9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1029bc:	89 01                	mov    %eax,(%ecx)

            return kfret;
  1029be:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1029c1:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1029c4:	e9 1c 00 00 00       	jmp    1029e5 <ramfs_block_create+0xe5>
        }
    }
  1029c9:	e9 00 00 00 00       	jmp    1029ce <ramfs_block_create+0xce>
}

struct res_kfile* ramfs_block_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  1029ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1029d1:	05 01 00 00 00       	add    $0x1,%eax
  1029d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1029d9:	e9 4c ff ff ff       	jmp    10292a <ramfs_block_create+0x2a>

            return kfret;
        }
    }

    return 0;
  1029de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1029e5:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1029e8:	83 c4 28             	add    $0x28,%esp
  1029eb:	5d                   	pop    %ebp
  1029ec:	c3                   	ret    
  1029ed:	0f 1f 00             	nopl   (%eax)

001029f0 <ramfs_block_driver_struct>:
    .close     = ramfs_block_close,
    .available = ramfs_block_available,
    .drvname   = "RAMFILE"
};

struct kfs_driver* ramfs_block_driver_struct() {
  1029f0:	55                   	push   %ebp
  1029f1:	89 e5                	mov    %esp,%ebp
  1029f3:	8d 05 88 61 10 00    	lea    0x106188,%eax
    return &block_driver;
  1029f9:	5d                   	pop    %ebp
  1029fa:	c3                   	ret    
  1029fb:	66 90                	xchg   %ax,%ax
  1029fd:	66 90                	xchg   %ax,%ax
  1029ff:	90                   	nop

00102a00 <ramfs_fifo_init>:
#include "ramfs/fifo.h"

struct fifo_buffer* buffer[65536];

void ramfs_fifo_init() {
  102a00:	55                   	push   %ebp
  102a01:	89 e5                	mov    %esp,%ebp
  102a03:	83 ec 18             	sub    $0x18,%esp
  102a06:	8d 05 90 94 14 00    	lea    0x149490,%eax
  102a0c:	b9 00 00 00 00       	mov    $0x0,%ecx
  102a11:	ba 00 00 04 00       	mov    $0x40000,%edx
    memset(buffer, 0, sizeof(buffer));
  102a16:	89 04 24             	mov    %eax,(%esp)
  102a19:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  102a20:	00 
  102a21:	c7 44 24 08 00 00 04 	movl   $0x40000,0x8(%esp)
  102a28:	00 
  102a29:	89 55 fc             	mov    %edx,-0x4(%ebp)
  102a2c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102a2f:	e8 8c 14 00 00       	call   103ec0 <memset>
}
  102a34:	83 c4 18             	add    $0x18,%esp
  102a37:	5d                   	pop    %ebp
  102a38:	c3                   	ret    
  102a39:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00102a40 <ramfs_fifo_read>:
    }

    return 0;
}

uint32_t ramfs_fifo_read(struct res_handle* handle, void* dest, uint32_t length) {
  102a40:	55                   	push   %ebp
  102a41:	89 e5                	mov    %esp,%ebp
  102a43:	56                   	push   %esi
  102a44:	83 ec 24             	sub    $0x24,%esp
  102a47:	8b 45 10             	mov    0x10(%ebp),%eax
  102a4a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102a4d:	8b 55 08             	mov    0x8(%ebp),%edx
  102a50:	89 55 f4             	mov    %edx,-0xc(%ebp)
  102a53:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  102a56:	89 45 ec             	mov    %eax,-0x14(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102a59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102a5c:	8b 40 04             	mov    0x4(%eax),%eax
  102a5f:	89 45 e8             	mov    %eax,-0x18(%ebp)

    if(buffer[kf->id] != 0) {
  102a62:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102a65:	8b 00                	mov    (%eax),%eax
  102a67:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102a6e:	00 00 00 00 
  102a72:	0f 84 b9 00 00 00    	je     102b31 <ramfs_fifo_read+0xf1>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't read cause buffer too small
  102a78:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a7b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  102a7e:	8b 09                	mov    (%ecx),%ecx
  102a80:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102a87:	3b 41 04             	cmp    0x4(%ecx),%eax
  102a8a:	0f 86 0c 00 00 00    	jbe    102a9c <ramfs_fifo_read+0x5c>
  102a90:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  102a97:	e9 9c 00 00 00       	jmp    102b38 <ramfs_fifo_read+0xf8>
        if(length > buffer[kf->id]->pos)  return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has writers
  102a9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102a9f:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  102aa2:	8b 09                	mov    (%ecx),%ecx
  102aa4:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102aab:	3b 41 08             	cmp    0x8(%ecx),%eax
  102aae:	0f 86 0c 00 00 00    	jbe    102ac0 <ramfs_fifo_read+0x80>
  102ab4:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  102abb:	e9 78 00 00 00       	jmp    102b38 <ramfs_fifo_read+0xf8>

        memcpy(dest, buffer[kf->id]->buffer, length);
  102ac0:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102ac3:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  102ac6:	8b 09                	mov    (%ecx),%ecx
  102ac8:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102acf:	8b 09                	mov    (%ecx),%ecx
  102ad1:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102ad4:	89 04 24             	mov    %eax,(%esp)
  102ad7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102adb:	89 54 24 08          	mov    %edx,0x8(%esp)
  102adf:	e8 3c 14 00 00       	call   103f20 <memcpy>
        memcpy(buffer[kf->id]->buffer, buffer[kf->id]->buffer + length, length - buffer[kf->id]->pos);
  102ae4:	8b 45 e8             	mov    -0x18(%ebp),%eax
  102ae7:	8b 00                	mov    (%eax),%eax
  102ae9:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102af0:	8b 00                	mov    (%eax),%eax
  102af2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  102af5:	8b 09                	mov    (%ecx),%ecx
  102af7:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102afe:	8b 09                	mov    (%ecx),%ecx
  102b00:	03 4d ec             	add    -0x14(%ebp),%ecx
  102b03:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102b06:	8b 75 e8             	mov    -0x18(%ebp),%esi
  102b09:	8b 36                	mov    (%esi),%esi
  102b0b:	8b 34 b5 90 94 14 00 	mov    0x149490(,%esi,4),%esi
  102b12:	2b 56 08             	sub    0x8(%esi),%edx
  102b15:	89 04 24             	mov    %eax,(%esp)
  102b18:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102b1c:	89 54 24 08          	mov    %edx,0x8(%esp)
  102b20:	e8 fb 13 00 00       	call   103f20 <memcpy>

        return RW_OK;
  102b25:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  102b2c:	e9 07 00 00 00       	jmp    102b38 <ramfs_fifo_read+0xf8>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull read when returning 0 so we return error code 1 (length+1)
  102b31:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
}
  102b38:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102b3b:	83 c4 24             	add    $0x24,%esp
  102b3e:	5e                   	pop    %esi
  102b3f:	5d                   	pop    %ebp
  102b40:	c3                   	ret    
  102b41:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102b48:	0f 1f 84 00 00 00 00 
  102b4f:	00 

00102b50 <ramfs_fifo_write>:

uint32_t ramfs_fifo_write(struct res_handle* handle, void* src, uint32_t length) {
  102b50:	55                   	push   %ebp
  102b51:	89 e5                	mov    %esp,%ebp
  102b53:	83 ec 28             	sub    $0x28,%esp
  102b56:	8b 45 10             	mov    0x10(%ebp),%eax
  102b59:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  102b5c:	8b 55 08             	mov    0x8(%ebp),%edx
  102b5f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  102b62:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  102b65:	89 45 f0             	mov    %eax,-0x10(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102b68:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102b6b:	8b 40 04             	mov    0x4(%eax),%eax
  102b6e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if(buffer[kf->id] != 0) {
  102b71:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102b74:	8b 00                	mov    (%eax),%eax
  102b76:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102b7d:	00 00 00 00 
  102b81:	0f 84 af 00 00 00    	je     102c36 <ramfs_fifo_write+0xe6>
        if(length > buffer[kf->id]->size) return RW_ERR_DRIVER; //Error code 2 -> Can't write cause buffer too small
  102b87:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102b8a:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102b8d:	8b 09                	mov    (%ecx),%ecx
  102b8f:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102b96:	3b 41 04             	cmp    0x4(%ecx),%eax
  102b99:	0f 86 0c 00 00 00    	jbe    102bab <ramfs_fifo_write+0x5b>
  102b9f:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
  102ba6:	e9 92 00 00 00       	jmp    102c3d <ramfs_fifo_write+0xed>
        if(length > (buffer[kf->id]->size - buffer[kf->id]->pos)) return RW_BLOCK; //Block until write is possible TODO maybe check if FIFO has readers
  102bab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102bae:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102bb1:	8b 09                	mov    (%ecx),%ecx
  102bb3:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102bba:	8b 49 04             	mov    0x4(%ecx),%ecx
  102bbd:	8b 55 ec             	mov    -0x14(%ebp),%edx
  102bc0:	8b 12                	mov    (%edx),%edx
  102bc2:	8b 14 95 90 94 14 00 	mov    0x149490(,%edx,4),%edx
  102bc9:	2b 4a 08             	sub    0x8(%edx),%ecx
  102bcc:	39 c8                	cmp    %ecx,%eax
  102bce:	0f 86 0c 00 00 00    	jbe    102be0 <ramfs_fifo_write+0x90>
  102bd4:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  102bdb:	e9 5d 00 00 00       	jmp    102c3d <ramfs_fifo_write+0xed>

        memcpy(buffer[kf->id]->buffer + buffer[kf->id]->pos, src, length);
  102be0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102be3:	8b 00                	mov    (%eax),%eax
  102be5:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102bec:	8b 00                	mov    (%eax),%eax
  102bee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102bf1:	8b 09                	mov    (%ecx),%ecx
  102bf3:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102bfa:	03 41 08             	add    0x8(%ecx),%eax
  102bfd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102c00:	8b 55 f0             	mov    -0x10(%ebp),%edx
  102c03:	89 04 24             	mov    %eax,(%esp)
  102c06:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  102c0a:	89 54 24 08          	mov    %edx,0x8(%esp)
  102c0e:	e8 0d 13 00 00       	call   103f20 <memcpy>
        buffer[kf->id]->pos += length;
  102c13:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102c16:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  102c19:	8b 09                	mov    (%ecx),%ecx
  102c1b:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102c22:	8b 51 08             	mov    0x8(%ecx),%edx
  102c25:	01 c2                	add    %eax,%edx
  102c27:	89 51 08             	mov    %edx,0x8(%ecx)

        return RW_OK;
  102c2a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  102c31:	e9 07 00 00 00       	jmp    102c3d <ramfs_fifo_write+0xed>
    }

    return RW_ERR_DRIVER; //Deadlock if lib-mikrOS tries to block until successfull write when returning 0 so we return error code 1 (length+1)
  102c36:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  102c3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102c40:	83 c4 28             	add    $0x28,%esp
  102c43:	5d                   	pop    %ebp
  102c44:	c3                   	ret    
  102c45:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  102c4c:	00 00 00 00 

00102c50 <ramfs_fifo_open>:

struct res_handle* ramfs_fifo_open(struct res_kfile* kf, uint32_t filemode) {
  102c50:	55                   	push   %ebp
  102c51:	89 e5                	mov    %esp,%ebp
  102c53:	83 ec 18             	sub    $0x18,%esp
  102c56:	8b 45 0c             	mov    0xc(%ebp),%eax
  102c59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  102c5c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  102c5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(buffer[kf->id] != 0) {
  102c62:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102c65:	8b 00                	mov    (%eax),%eax
  102c67:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102c6e:	00 00 00 00 
  102c72:	0f 84 f6 00 00 00    	je     102d6e <ramfs_fifo_open+0x11e>
        if(filemode & FM_EXEC) return (void*)3;
  102c78:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c7b:	25 04 00 00 00       	and    $0x4,%eax
  102c80:	3d 00 00 00 00       	cmp    $0x0,%eax
  102c85:	0f 84 0d 00 00 00    	je     102c98 <ramfs_fifo_open+0x48>
  102c8b:	b8 03 00 00 00       	mov    $0x3,%eax
  102c90:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102c93:	e9 de 00 00 00       	jmp    102d76 <ramfs_fifo_open+0x126>
        if((filemode & FM_READ) && buffer[kf->id]->readers > 0) return (void*)2;
  102c98:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102c9b:	25 01 00 00 00       	and    $0x1,%eax
  102ca0:	3d 00 00 00 00       	cmp    $0x0,%eax
  102ca5:	0f 84 26 00 00 00    	je     102cd1 <ramfs_fifo_open+0x81>
  102cab:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102cae:	8b 00                	mov    (%eax),%eax
  102cb0:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102cb7:	81 78 0c 00 00 00 00 	cmpl   $0x0,0xc(%eax)
  102cbe:	0f 86 0d 00 00 00    	jbe    102cd1 <ramfs_fifo_open+0x81>
  102cc4:	b8 02 00 00 00       	mov    $0x2,%eax
  102cc9:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102ccc:	e9 a5 00 00 00       	jmp    102d76 <ramfs_fifo_open+0x126>

        if((filemode & FM_READ)) buffer[kf->id]->readers++;
  102cd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cd4:	25 01 00 00 00       	and    $0x1,%eax
  102cd9:	3d 00 00 00 00       	cmp    $0x0,%eax
  102cde:	0f 84 18 00 00 00    	je     102cfc <ramfs_fifo_open+0xac>
  102ce4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102ce7:	8b 00                	mov    (%eax),%eax
  102ce9:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102cf0:	8b 48 0c             	mov    0xc(%eax),%ecx
  102cf3:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102cf9:	89 48 0c             	mov    %ecx,0xc(%eax)
        if((filemode & FM_WRITE)) buffer[kf->id]->writers++;
  102cfc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102cff:	25 02 00 00 00       	and    $0x2,%eax
  102d04:	3d 00 00 00 00       	cmp    $0x0,%eax
  102d09:	0f 84 18 00 00 00    	je     102d27 <ramfs_fifo_open+0xd7>
  102d0f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d12:	8b 00                	mov    (%eax),%eax
  102d14:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102d1b:	8b 48 10             	mov    0x10(%eax),%ecx
  102d1e:	81 c1 01 00 00 00    	add    $0x1,%ecx
  102d24:	89 48 10             	mov    %ecx,0x10(%eax)
  102d27:	b8 10 00 00 00       	mov    $0x10,%eax

        struct res_handle* rethandle = malloc(sizeof(struct res_handle));
  102d2c:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  102d33:	89 45 ec             	mov    %eax,-0x14(%ebp)
  102d36:	e8 15 0b 00 00       	call   103850 <malloc>
  102d3b:	89 45 f0             	mov    %eax,-0x10(%ebp)

        rethandle->filemode = filemode;
  102d3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102d41:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d44:	89 41 0c             	mov    %eax,0xc(%ecx)
        rethandle->position = 0;
  102d47:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d4a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        rethandle->res_type = RES_KERNDRV;
  102d51:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d54:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        rethandle->res_ptr  = kf;
  102d5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d5d:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102d60:	89 41 04             	mov    %eax,0x4(%ecx)

        return rethandle;
  102d63:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102d66:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102d69:	e9 08 00 00 00       	jmp    102d76 <ramfs_fifo_open+0x126>
  102d6e:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return (void*)1;
  102d73:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  102d76:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d79:	83 c4 18             	add    $0x18,%esp
  102d7c:	5d                   	pop    %ebp
  102d7d:	c3                   	ret    
  102d7e:	66 90                	xchg   %ax,%ax

00102d80 <ramfs_fifo_close>:

uint32_t ramfs_fifo_close(struct res_handle* handle) {
  102d80:	55                   	push   %ebp
  102d81:	89 e5                	mov    %esp,%ebp
  102d83:	83 ec 18             	sub    $0x18,%esp
  102d86:	8b 45 08             	mov    0x8(%ebp),%eax
  102d89:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102d8c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102d8f:	8b 40 04             	mov    0x4(%eax),%eax
  102d92:	89 45 f8             	mov    %eax,-0x8(%ebp)

    if(buffer[kf->id] != 0) {
  102d95:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102d98:	8b 00                	mov    (%eax),%eax
  102d9a:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102da1:	00 00 00 00 
  102da5:	0f 84 61 00 00 00    	je     102e0c <ramfs_fifo_close+0x8c>
        if(handle->filemode & FM_READ)  buffer[kf->id]->readers--;
  102dab:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102dae:	8b 40 0c             	mov    0xc(%eax),%eax
  102db1:	25 01 00 00 00       	and    $0x1,%eax
  102db6:	3d 00 00 00 00       	cmp    $0x0,%eax
  102dbb:	0f 84 18 00 00 00    	je     102dd9 <ramfs_fifo_close+0x59>
  102dc1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102dc4:	8b 00                	mov    (%eax),%eax
  102dc6:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102dcd:	8b 48 0c             	mov    0xc(%eax),%ecx
  102dd0:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102dd6:	89 48 0c             	mov    %ecx,0xc(%eax)
        if(handle->filemode & FM_WRITE) buffer[kf->id]->writers--;
  102dd9:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102ddc:	8b 40 0c             	mov    0xc(%eax),%eax
  102ddf:	25 02 00 00 00       	and    $0x2,%eax
  102de4:	3d 00 00 00 00       	cmp    $0x0,%eax
  102de9:	0f 84 18 00 00 00    	je     102e07 <ramfs_fifo_close+0x87>
  102def:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102df2:	8b 00                	mov    (%eax),%eax
  102df4:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102dfb:	8b 48 10             	mov    0x10(%eax),%ecx
  102dfe:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  102e04:	89 48 10             	mov    %ecx,0x10(%eax)
    }
  102e07:	e9 00 00 00 00       	jmp    102e0c <ramfs_fifo_close+0x8c>

    free(handle);
  102e0c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e0f:	89 04 24             	mov    %eax,(%esp)
  102e12:	e8 09 0e 00 00       	call   103c20 <free>
  102e17:	b8 00 00 00 00       	mov    $0x0,%eax

    return 0;
  102e1c:	83 c4 18             	add    $0x18,%esp
  102e1f:	5d                   	pop    %ebp
  102e20:	c3                   	ret    
  102e21:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102e28:	0f 1f 84 00 00 00 00 
  102e2f:	00 

00102e30 <ramfs_fifo_available>:

struct kfs_driver* ramfs_fifo_driver_struct() {
    return &fifo_driver;
}

uint32_t ramfs_fifo_available(struct res_handle* handle) {
  102e30:	55                   	push   %ebp
  102e31:	89 e5                	mov    %esp,%ebp
  102e33:	83 ec 0c             	sub    $0xc,%esp
  102e36:	8b 45 08             	mov    0x8(%ebp),%eax
  102e39:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kf = ((struct res_kfile*)handle->res_ptr);
  102e3c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102e3f:	8b 40 04             	mov    0x4(%eax),%eax
  102e42:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(buffer[kf->id] != 0) {
  102e45:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e48:	8b 00                	mov    (%eax),%eax
  102e4a:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102e51:	00 00 00 00 
  102e55:	0f 84 17 00 00 00    	je     102e72 <ramfs_fifo_available+0x42>
        return buffer[kf->id]->pos;
  102e5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102e5e:	8b 00                	mov    (%eax),%eax
  102e60:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102e67:	8b 40 08             	mov    0x8(%eax),%eax
  102e6a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102e6d:	e9 07 00 00 00       	jmp    102e79 <ramfs_fifo_available+0x49>
    }

    return 0;
  102e72:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  102e79:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102e7c:	83 c4 0c             	add    $0xc,%esp
  102e7f:	5d                   	pop    %ebp
  102e80:	c3                   	ret    
  102e81:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  102e88:	0f 1f 84 00 00 00 00 
  102e8f:	00 

00102e90 <ramfs_fifo_create>:

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
  102e90:	55                   	push   %ebp
  102e91:	89 e5                	mov    %esp,%ebp
  102e93:	83 ec 28             	sub    $0x28,%esp
  102e96:	8b 45 08             	mov    0x8(%ebp),%eax
  102e99:	b9 08 00 00 00       	mov    $0x8,%ecx
  102e9e:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));
  102ea1:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  102ea8:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  102eab:	e8 a0 09 00 00       	call   103850 <malloc>
  102eb0:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(int i = 0; i < 65536; i++) {
  102eb3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102eba:	81 7d f0 00 00 01 00 	cmpl   $0x10000,-0x10(%ebp)
  102ec1:	0f 8d b8 00 00 00    	jge    102f7f <ramfs_fifo_create+0xef>
        if(buffer[i] == 0) {
  102ec7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102eca:	81 3c 85 90 94 14 00 	cmpl   $0x0,0x149490(,%eax,4)
  102ed1:	00 00 00 00 
  102ed5:	0f 85 8f 00 00 00    	jne    102f6a <ramfs_fifo_create+0xda>
  102edb:	b8 14 00 00 00       	mov    $0x14,%eax
            buffer[i] = malloc(sizeof(struct fifo_buffer));
  102ee0:	c7 04 24 14 00 00 00 	movl   $0x14,(%esp)
  102ee7:	89 45 e8             	mov    %eax,-0x18(%ebp)
  102eea:	e8 61 09 00 00       	call   103850 <malloc>
  102eef:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102ef2:	89 04 8d 90 94 14 00 	mov    %eax,0x149490(,%ecx,4)
            buffer[i]->buffer = malloc(args[0]);
  102ef9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102efc:	8b 00                	mov    (%eax),%eax
  102efe:	89 04 24             	mov    %eax,(%esp)
  102f01:	e8 4a 09 00 00       	call   103850 <malloc>
  102f06:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102f09:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102f10:	89 01                	mov    %eax,(%ecx)
            buffer[i]->size   = args[0];
  102f12:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102f15:	8b 00                	mov    (%eax),%eax
  102f17:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  102f1a:	8b 0c 8d 90 94 14 00 	mov    0x149490(,%ecx,4),%ecx
  102f21:	89 41 04             	mov    %eax,0x4(%ecx)

            buffer[i]->pos = 0;
  102f24:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f27:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102f2e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
            buffer[i]->writers = 0;
  102f35:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f38:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102f3f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
            buffer[i]->readers = 0;
  102f46:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f49:	8b 04 85 90 94 14 00 	mov    0x149490(,%eax,4),%eax
  102f50:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

            kfret->id = i;
  102f57:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f5a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  102f5d:	89 01                	mov    %eax,(%ecx)

            return kfret;
  102f5f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102f62:	89 45 fc             	mov    %eax,-0x4(%ebp)
  102f65:	e9 1c 00 00 00       	jmp    102f86 <ramfs_fifo_create+0xf6>
        }
    }
  102f6a:	e9 00 00 00 00       	jmp    102f6f <ramfs_fifo_create+0xdf>
}

struct res_kfile* ramfs_fifo_create(uint32_t* args) {
    struct res_kfile* kfret = malloc(sizeof(struct res_kfile));

    for(int i = 0; i < 65536; i++) {
  102f6f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  102f72:	05 01 00 00 00       	add    $0x1,%eax
  102f77:	89 45 f0             	mov    %eax,-0x10(%ebp)
  102f7a:	e9 3b ff ff ff       	jmp    102eba <ramfs_fifo_create+0x2a>

            return kfret;
        }
    }

    return 0;
  102f7f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  102f86:	8b 45 fc             	mov    -0x4(%ebp),%eax
  102f89:	83 c4 28             	add    $0x28,%esp
  102f8c:	5d                   	pop    %ebp
  102f8d:	c3                   	ret    
  102f8e:	66 90                	xchg   %ax,%ax

00102f90 <ramfs_fifo_driver_struct>:
    .close     = ramfs_fifo_close,
    .available = ramfs_fifo_available,
    .drvname   = "FIFO"
};

struct kfs_driver* ramfs_fifo_driver_struct() {
  102f90:	55                   	push   %ebp
  102f91:	89 e5                	mov    %esp,%ebp
  102f93:	8d 05 a4 61 10 00    	lea    0x1061a4,%eax
    return &fifo_driver;
  102f99:	5d                   	pop    %ebp
  102f9a:	c3                   	ret    
  102f9b:	90                   	nop
  102f9c:	66 90                	xchg   %ax,%ax
  102f9e:	66 90                	xchg   %ax,%ax

00102fa0 <tar_load_ramfs>:

    return size;

}

void tar_load_ramfs(void* tarball) {
  102fa0:	55                   	push   %ebp
  102fa1:	89 e5                	mov    %esp,%ebp
  102fa3:	56                   	push   %esi
  102fa4:	83 ec 64             	sub    $0x64,%esp
  102fa7:	8b 45 08             	mov    0x8(%ebp),%eax
  102faa:	8d 0d 6c 73 10 00    	lea    0x10736c,%ecx
  102fb0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    void* address = tarball;
  102fb3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  102fb6:	89 45 f4             	mov    %eax,-0xc(%ebp)

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);
  102fb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fbc:	89 0c 24             	mov    %ecx,(%esp)
  102fbf:	89 44 24 04          	mov    %eax,0x4(%esp)
  102fc3:	e8 88 d5 ff ff       	call   100550 <kprintf>

    for (i = 0; ; i++)
  102fc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  102fcf:	89 45 dc             	mov    %eax,-0x24(%ebp)
    {

        struct tar_header *header = (struct tar_header*)address;
  102fd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  102fd5:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if (header->name[0] == '\0')
  102fd8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102fdb:	0f be 00             	movsbl (%eax),%eax
  102fde:	3d 00 00 00 00       	cmp    $0x0,%eax
  102fe3:	0f 85 05 00 00 00    	jne    102fee <tar_load_ramfs+0x4e>
            break;
  102fe9:	e9 67 01 00 00       	jmp    103155 <tar_load_ramfs+0x1b5>

        uint32_t size = tar_parse_number(header->size);
  102fee:	8b 45 ec             	mov    -0x14(%ebp),%eax
  102ff1:	05 7c 00 00 00       	add    $0x7c,%eax
  102ff6:	89 04 24             	mov    %eax,(%esp)
  102ff9:	e8 72 01 00 00       	call   103170 <tar_parse_number>
  102ffe:	89 45 e8             	mov    %eax,-0x18(%ebp)
        address += 512;
  103001:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103004:	05 00 02 00 00       	add    $0x200,%eax
  103009:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(size != 0) {
  10300c:	81 7d e8 00 00 00 00 	cmpl   $0x0,-0x18(%ebp)
  103013:	0f 84 cb 00 00 00    	je     1030e4 <tar_load_ramfs+0x144>
  103019:	8d 05 98 73 10 00    	lea    0x107398,%eax
            kprintf("[initrfs] Extracting %s (%d bytes)\n", header->name, size);
  10301f:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103022:	8b 55 e8             	mov    -0x18(%ebp),%edx
  103025:	89 04 24             	mov    %eax,(%esp)
  103028:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10302c:	89 54 24 08          	mov    %edx,0x8(%esp)
  103030:	e8 1b d5 ff ff       	call   100550 <kprintf>
  103035:	8d 4d e8             	lea    -0x18(%ebp),%ecx

            vfs_create_kfile(header->name, ramfs_block_driver_struct(), &size);
  103038:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10303b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10303e:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  103041:	89 55 d0             	mov    %edx,-0x30(%ebp)
  103044:	e8 a7 f9 ff ff       	call   1029f0 <ramfs_block_driver_struct>
  103049:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  10304c:	89 0c 24             	mov    %ecx,(%esp)
  10304f:	89 44 24 04          	mov    %eax,0x4(%esp)
  103053:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  103056:	89 44 24 08          	mov    %eax,0x8(%esp)
  10305a:	e8 81 15 00 00       	call   1045e0 <vfs_create_kfile>
  10305f:	b9 02 00 00 00       	mov    $0x2,%ecx
            struct res_handle* h = vfs_open(header->name, FM_WRITE);
  103064:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103067:	89 14 24             	mov    %edx,(%esp)
  10306a:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  103071:	00 
  103072:	89 45 cc             	mov    %eax,-0x34(%ebp)
  103075:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  103078:	e8 d3 16 00 00       	call   104750 <vfs_open>
  10307d:	b9 01 00 00 00       	mov    $0x1,%ecx
  103082:	89 45 e4             	mov    %eax,-0x1c(%ebp)

            uint32_t err = vfs_write(h, address, size, 1);
  103085:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103088:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10308b:	8b 75 e8             	mov    -0x18(%ebp),%esi
  10308e:	89 04 24             	mov    %eax,(%esp)
  103091:	89 54 24 04          	mov    %edx,0x4(%esp)
  103095:	89 74 24 08          	mov    %esi,0x8(%esp)
  103099:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  1030a0:	00 
  1030a1:	89 4d c4             	mov    %ecx,-0x3c(%ebp)
  1030a4:	e8 57 18 00 00       	call   104900 <vfs_write>
  1030a9:	89 45 e0             	mov    %eax,-0x20(%ebp)
            if(err) {
  1030ac:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  1030b3:	0f 84 18 00 00 00    	je     1030d1 <tar_load_ramfs+0x131>
  1030b9:	8d 05 bc 73 10 00    	lea    0x1073bc,%eax
                kprintf("[initrfs] VFS ERROR: %d\n", err);
  1030bf:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1030c2:	89 04 24             	mov    %eax,(%esp)
  1030c5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1030c9:	e8 82 d4 ff ff       	call   100550 <kprintf>
  1030ce:	89 45 c0             	mov    %eax,-0x40(%ebp)
            }

            vfs_close(h);
  1030d1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1030d4:	89 04 24             	mov    %eax,(%esp)
  1030d7:	e8 f4 16 00 00       	call   1047d0 <vfs_close>
        }
  1030dc:	89 45 bc             	mov    %eax,-0x44(%ebp)
  1030df:	e9 2d 00 00 00       	jmp    103111 <tar_load_ramfs+0x171>
  1030e4:	8d 05 d5 73 10 00    	lea    0x1073d5,%eax
        else
        {
            kprintf("[initrfs] Creating dir %s (%d bytes)\n", header->name, size);
  1030ea:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1030ed:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1030f0:	89 04 24             	mov    %eax,(%esp)
  1030f3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1030f7:	89 54 24 08          	mov    %edx,0x8(%esp)
  1030fb:	e8 50 d4 ff ff       	call   100550 <kprintf>
            vfs_create_dir(header->name);
  103100:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103103:	89 0c 24             	mov    %ecx,(%esp)
  103106:	89 45 b8             	mov    %eax,-0x48(%ebp)
  103109:	e8 42 13 00 00       	call   104450 <vfs_create_dir>
  10310e:	89 45 b4             	mov    %eax,-0x4c(%ebp)
        }

        address += (size / 512) * 512;
  103111:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103114:	c1 e8 09             	shr    $0x9,%eax
  103117:	c1 e0 09             	shl    $0x9,%eax
  10311a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10311d:	01 c1                	add    %eax,%ecx
  10311f:	89 4d f4             	mov    %ecx,-0xc(%ebp)

        if (size % 512)
  103122:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103125:	25 ff 01 00 00       	and    $0x1ff,%eax
  10312a:	3d 00 00 00 00       	cmp    $0x0,%eax
  10312f:	0f 84 0b 00 00 00    	je     103140 <tar_load_ramfs+0x1a0>
            address += 512;
  103135:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103138:	05 00 02 00 00       	add    $0x200,%eax
  10313d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    }
  103140:	e9 00 00 00 00       	jmp    103145 <tar_load_ramfs+0x1a5>

    uint32_t i;

    kprintf("[initrfs] Starting unpacking tarball at %x\n", address);

    for (i = 0; ; i++)
  103145:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103148:	05 01 00 00 00       	add    $0x1,%eax
  10314d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  103150:	e9 7d fe ff ff       	jmp    102fd2 <tar_load_ramfs+0x32>
  103155:	8d 05 fb 73 10 00    	lea    0x1073fb,%eax
        if (size % 512)
            address += 512;

    }

    kprintf("[initrfs] Finished unpacking tarball\n");
  10315b:	89 04 24             	mov    %eax,(%esp)
  10315e:	e8 ed d3 ff ff       	call   100550 <kprintf>
}
  103163:	89 45 b0             	mov    %eax,-0x50(%ebp)
  103166:	83 c4 64             	add    $0x64,%esp
  103169:	5e                   	pop    %esi
  10316a:	5d                   	pop    %ebp
  10316b:	c3                   	ret    
  10316c:	0f 1f 40 00          	nopl   0x0(%eax)

00103170 <tar_parse_number>:
#include "ramfs/tar.h"
#include "ramfs/block.h"
#include "vfs.h"

static uint32_t tar_parse_number(const char *in)
{
  103170:	55                   	push   %ebp
  103171:	89 e5                	mov    %esp,%ebp
  103173:	83 ec 10             	sub    $0x10,%esp
  103176:	8b 45 08             	mov    0x8(%ebp),%eax
  103179:	89 45 fc             	mov    %eax,-0x4(%ebp)

    unsigned int size = 0;
  10317c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    unsigned int j;
    unsigned int count = 1;
  103183:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

    for (j = 11; j > 0; j--, count *= 8)
  10318a:	c7 45 f4 0b 00 00 00 	movl   $0xb,-0xc(%ebp)
  103191:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103198:	0f 86 39 00 00 00    	jbe    1031d7 <tar_parse_number+0x67>
        size += ((in[j - 1] - '0') * count);
  10319e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031a1:	2d 01 00 00 00       	sub    $0x1,%eax
  1031a6:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1031a9:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  1031ad:	2d 30 00 00 00       	sub    $0x30,%eax
  1031b2:	0f af 45 f0          	imul   -0x10(%ebp),%eax
  1031b6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1031b9:	01 c1                	add    %eax,%ecx
  1031bb:	89 4d f8             	mov    %ecx,-0x8(%ebp)

    unsigned int size = 0;
    unsigned int j;
    unsigned int count = 1;

    for (j = 11; j > 0; j--, count *= 8)
  1031be:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1031c1:	05 ff ff ff ff       	add    $0xffffffff,%eax
  1031c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  1031c9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1031cc:	c1 e0 03             	shl    $0x3,%eax
  1031cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
  1031d2:	e9 ba ff ff ff       	jmp    103191 <tar_parse_number+0x21>
        size += ((in[j - 1] - '0') * count);

    return size;
  1031d7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1031da:	83 c4 10             	add    $0x10,%esp
  1031dd:	5d                   	pop    %ebp
  1031de:	c3                   	ret    
  1031df:	90                   	nop

001031e0 <enableScheduling>:
struct task* first_task = 0;
struct task* current_task = 0;

int nextPID = 1;

void enableScheduling(void) {
  1031e0:	55                   	push   %ebp
  1031e1:	89 e5                	mov    %esp,%ebp
    schedulingEnabled = 1;
  1031e3:	c7 05 24 94 10 00 01 	movl   $0x1,0x109424
  1031ea:	00 00 00 
}
  1031ed:	5d                   	pop    %ebp
  1031ee:	c3                   	ret    
  1031ef:	90                   	nop

001031f0 <isSchedulingEnabled>:

uint32_t isSchedulingEnabled(void) {
  1031f0:	55                   	push   %ebp
  1031f1:	89 e5                	mov    %esp,%ebp
    return schedulingEnabled;
  1031f3:	a1 24 94 10 00       	mov    0x109424,%eax
  1031f8:	5d                   	pop    %ebp
  1031f9:	c3                   	ret    
  1031fa:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103200 <get_current_task>:
}

struct task* get_current_task(void) {
  103200:	55                   	push   %ebp
  103201:	89 e5                	mov    %esp,%ebp
    return current_task;
  103203:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103208:	5d                   	pop    %ebp
  103209:	c3                   	ret    
  10320a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103210 <register_handle>:
}

uint32_t register_handle(struct res_handle* h) {
  103210:	55                   	push   %ebp
  103211:	89 e5                	mov    %esp,%ebp
  103213:	83 ec 18             	sub    $0x18,%esp
  103216:	8b 45 08             	mov    0x8(%ebp),%eax
  103219:	b9 08 00 00 00       	mov    $0x8,%ecx
  10321e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct hl_node* old = current_task->handle_list;
  103221:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103226:	8b 40 18             	mov    0x18(%eax),%eax
  103229:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task->handle_list = malloc(sizeof(struct hl_node));
  10322c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  103233:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103236:	e8 15 06 00 00       	call   103850 <malloc>
  10323b:	b9 00 00 00 00       	mov    $0x0,%ecx
  103240:	8b 15 2c 94 10 00    	mov    0x10942c,%edx
  103246:	89 42 18             	mov    %eax,0x18(%edx)
    current_task->handle_list->next = old;
  103249:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10324c:	8b 15 2c 94 10 00    	mov    0x10942c,%edx
  103252:	8b 52 18             	mov    0x18(%edx),%edx
  103255:	89 42 04             	mov    %eax,0x4(%edx)
    current_task->handle_list->handle = h;
  103258:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10325b:	8b 15 2c 94 10 00    	mov    0x10942c,%edx
  103261:	8b 52 18             	mov    0x18(%edx),%edx
  103264:	89 02                	mov    %eax,(%edx)

    return 0;
  103266:	89 c8                	mov    %ecx,%eax
  103268:	83 c4 18             	add    $0x18,%esp
  10326b:	5d                   	pop    %ebp
  10326c:	c3                   	ret    
  10326d:	0f 1f 00             	nopl   (%eax)

00103270 <unregister_handle>:
}

uint32_t unregister_handle(struct res_handle* h) {
  103270:	55                   	push   %ebp
  103271:	89 e5                	mov    %esp,%ebp
  103273:	83 ec 18             	sub    $0x18,%esp
  103276:	8b 45 08             	mov    0x8(%ebp),%eax
  103279:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct hl_node* cur = current_task->handle_list;
  10327c:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103281:	8b 40 18             	mov    0x18(%eax),%eax
  103284:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if(h == 0) return 2;
  103287:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  10328e:	0f 85 0c 00 00 00    	jne    1032a0 <unregister_handle+0x30>
  103294:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
  10329b:	e9 a8 00 00 00       	jmp    103348 <unregister_handle+0xd8>
    if(cur == 0) return 1;
  1032a0:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1032a7:	0f 85 0c 00 00 00    	jne    1032b9 <unregister_handle+0x49>
  1032ad:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  1032b4:	e9 8f 00 00 00       	jmp    103348 <unregister_handle+0xd8>

    if(cur->handle == h) {
  1032b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032bc:	8b 00                	mov    (%eax),%eax
  1032be:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1032c1:	0f 85 1a 00 00 00    	jne    1032e1 <unregister_handle+0x71>
        current_task->handle_list = cur->next;
  1032c7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032ca:	8b 40 04             	mov    0x4(%eax),%eax
  1032cd:	8b 0d 2c 94 10 00    	mov    0x10942c,%ecx
  1032d3:	89 41 18             	mov    %eax,0x18(%ecx)
        free(cur);
  1032d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032d9:	89 04 24             	mov    %eax,(%esp)
  1032dc:	e8 3f 09 00 00       	call   103c20 <free>
    }

    while(cur != 0) {
  1032e1:	e9 00 00 00 00       	jmp    1032e6 <unregister_handle+0x76>
  1032e6:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1032ed:	0f 84 4e 00 00 00    	je     103341 <unregister_handle+0xd1>
        if(cur->next->handle == h) {
  1032f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1032f6:	8b 40 04             	mov    0x4(%eax),%eax
  1032f9:	8b 00                	mov    (%eax),%eax
  1032fb:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  1032fe:	0f 85 2f 00 00 00    	jne    103333 <unregister_handle+0xc3>
            void* next = cur->next;
  103304:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103307:	8b 40 04             	mov    0x4(%eax),%eax
  10330a:	89 45 f0             	mov    %eax,-0x10(%ebp)
            cur->next =  cur->next->next;
  10330d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103310:	8b 40 04             	mov    0x4(%eax),%eax
  103313:	8b 40 04             	mov    0x4(%eax),%eax
  103316:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103319:	89 41 04             	mov    %eax,0x4(%ecx)

            free(next);
  10331c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10331f:	89 04 24             	mov    %eax,(%esp)
  103322:	e8 f9 08 00 00       	call   103c20 <free>

            return 0;
  103327:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  10332e:	e9 15 00 00 00       	jmp    103348 <unregister_handle+0xd8>
        }

        cur = cur->next;
  103333:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103336:	8b 40 04             	mov    0x4(%eax),%eax
  103339:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  10333c:	e9 a5 ff ff ff       	jmp    1032e6 <unregister_handle+0x76>

    return 3;
  103341:	c7 45 fc 03 00 00 00 	movl   $0x3,-0x4(%ebp)
}
  103348:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10334b:	83 c4 18             	add    $0x18,%esp
  10334e:	5d                   	pop    %ebp
  10334f:	c3                   	ret    

00103350 <schedule_exception>:

struct cpu_state* schedule_exception(struct cpu_state* cpu) {
  103350:	55                   	push   %ebp
  103351:	89 e5                	mov    %esp,%ebp
  103353:	56                   	push   %esi
  103354:	83 ec 34             	sub    $0x34,%esp
  103357:	8b 45 08             	mov    0x8(%ebp),%eax
  10335a:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (current_task == first_task && current_task->next == 0) {
  10335d:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103362:	3b 05 28 94 10 00    	cmp    0x109428,%eax
  103368:	0f 85 71 00 00 00    	jne    1033df <schedule_exception+0x8f>
  10336e:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103373:	81 78 08 00 00 00 00 	cmpl   $0x0,0x8(%eax)
  10337a:	0f 85 5f 00 00 00    	jne    1033df <schedule_exception+0x8f>
  103380:	b8 04 00 00 00       	mov    $0x4,%eax
        //Only one process is running, which just crashed. Stop system.
        setclr(0x04);
  103385:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  10338c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  10338f:	e8 9c d1 ff ff       	call   100530 <setclr>
  103394:	8d 05 21 74 10 00    	lea    0x107421,%eax
        kprintf("\n Terminated task (PID=%d) due to exception %x:%x \n",
  10339a:	8b 0d 2c 94 10 00    	mov    0x10942c,%ecx
  1033a0:	8b 09                	mov    (%ecx),%ecx
  1033a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1033a5:	8b 52 1c             	mov    0x1c(%edx),%edx
  1033a8:	8b 75 f4             	mov    -0xc(%ebp),%esi
  1033ab:	8b 76 20             	mov    0x20(%esi),%esi
  1033ae:	89 04 24             	mov    %eax,(%esp)
  1033b1:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1033b5:	89 54 24 08          	mov    %edx,0x8(%esp)
  1033b9:	89 74 24 0c          	mov    %esi,0xc(%esp)
  1033bd:	e8 8e d1 ff ff       	call   100550 <kprintf>
  1033c2:	8d 0d 55 74 10 00    	lea    0x107455,%ecx
                current_task->PID, cpu->intr, cpu->error);
        show_cod(cpu, "Last task crashed. Terminating kernel...");
  1033c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1033cb:	89 14 24             	mov    %edx,(%esp)
  1033ce:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1033d2:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1033d5:	e8 96 cf ff ff       	call   100370 <show_cod>
    } else {
  1033da:	e9 88 00 00 00       	jmp    103467 <schedule_exception+0x117>
  1033df:	b8 04 00 00 00       	mov    $0x4,%eax
        //Potential security leaks available in following code.
        setclr(0x04);
  1033e4:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  1033eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1033ee:	e8 3d d1 ff ff       	call   100530 <setclr>
  1033f3:	8d 05 21 74 10 00    	lea    0x107421,%eax
        kprintf("\n Terminated task (PID=%d) due to exception %x:%x \n",
  1033f9:	8b 0d 2c 94 10 00    	mov    0x10942c,%ecx
  1033ff:	8b 09                	mov    (%ecx),%ecx
  103401:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103404:	8b 52 1c             	mov    0x1c(%edx),%edx
  103407:	8b 75 f4             	mov    -0xc(%ebp),%esi
  10340a:	8b 76 20             	mov    0x20(%esi),%esi
  10340d:	89 04 24             	mov    %eax,(%esp)
  103410:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103414:	89 54 24 08          	mov    %edx,0x8(%esp)
  103418:	89 74 24 0c          	mov    %esi,0xc(%esp)
  10341c:	e8 2f d1 ff ff       	call   100550 <kprintf>
  103421:	8d 0d 15 75 10 00    	lea    0x107515,%ecx
                current_task->PID, cpu->intr, cpu->error);
        kprintf("\n");
  103427:	89 0c 24             	mov    %ecx,(%esp)
  10342a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10342d:	e8 1e d1 ff ff       	call   100550 <kprintf>
        show_dump(cpu);
  103432:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103435:	89 0c 24             	mov    %ecx,(%esp)
  103438:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10343b:	e8 a0 cf ff ff       	call   1003e0 <show_dump>
  103440:	b8 07 00 00 00       	mov    $0x7,%eax
        setclr(0x07);
  103445:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  10344c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10344f:	e8 dc d0 ff ff       	call   100530 <setclr>

        return terminate_current(cpu);
  103454:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103457:	89 04 24             	mov    %eax,(%esp)
  10345a:	e8 21 00 00 00       	call   103480 <terminate_current>
  10345f:	89 45 f8             	mov    %eax,-0x8(%ebp)
  103462:	e9 06 00 00 00       	jmp    10346d <schedule_exception+0x11d>
    }
    return cpu;
  103467:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10346a:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  10346d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103470:	83 c4 34             	add    $0x34,%esp
  103473:	5e                   	pop    %esi
  103474:	5d                   	pop    %ebp
  103475:	c3                   	ret    
  103476:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10347d:	00 00 00 

00103480 <terminate_current>:

struct cpu_state* terminate_current(struct cpu_state* cpu) {
  103480:	55                   	push   %ebp
  103481:	89 e5                	mov    %esp,%ebp
  103483:	83 ec 18             	sub    $0x18,%esp
  103486:	8b 45 08             	mov    0x8(%ebp),%eax
  103489:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct task* next = current_task->next;
  10348c:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103491:	8b 40 08             	mov    0x8(%eax),%eax
  103494:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* prev = current_task->prev;
  103497:	a1 2c 94 10 00       	mov    0x10942c,%eax
  10349c:	8b 40 0c             	mov    0xc(%eax),%eax
  10349f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    //TODO: free resources here

    if (current_task == first_task) {
  1034a2:	a1 2c 94 10 00       	mov    0x10942c,%eax
  1034a7:	3b 05 28 94 10 00    	cmp    0x109428,%eax
  1034ad:	0f 85 0d 00 00 00    	jne    1034c0 <terminate_current+0x40>
        first_task = current_task->next;
  1034b3:	a1 2c 94 10 00       	mov    0x10942c,%eax
  1034b8:	8b 40 08             	mov    0x8(%eax),%eax
  1034bb:	a3 28 94 10 00       	mov    %eax,0x109428
    }

    if (next != 0) {
  1034c0:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1034c7:	0f 84 09 00 00 00    	je     1034d6 <terminate_current+0x56>
        next->prev = prev;
  1034cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1034d0:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1034d3:	89 41 0c             	mov    %eax,0xc(%ecx)
    }

    if (prev != 0) {
  1034d6:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1034dd:	0f 84 09 00 00 00    	je     1034ec <terminate_current+0x6c>
        prev->next = next;
  1034e3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1034e6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1034e9:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    //TODO: handle if all tasks are closed

    if (next == 0)
  1034ec:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1034f3:	0f 85 08 00 00 00    	jne    103501 <terminate_current+0x81>
        next = first_task;
  1034f9:	a1 28 94 10 00       	mov    0x109428,%eax
  1034fe:	89 45 f8             	mov    %eax,-0x8(%ebp)

    current_task = next;
  103501:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103504:	a3 2c 94 10 00       	mov    %eax,0x10942c
    vmm_activate_pagedir(current_task->phys_pdir);
  103509:	a1 2c 94 10 00       	mov    0x10942c,%eax
  10350e:	8b 40 14             	mov    0x14(%eax),%eax
  103511:	89 04 24             	mov    %eax,(%esp)
  103514:	e8 97 23 00 00       	call   1058b0 <vmm_activate_pagedir>
    return current_task->cpuState;
  103519:	a1 2c 94 10 00       	mov    0x10942c,%eax
  10351e:	8b 40 04             	mov    0x4(%eax),%eax
  103521:	83 c4 18             	add    $0x18,%esp
  103524:	5d                   	pop    %ebp
  103525:	c3                   	ret    
  103526:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10352d:	00 00 00 

00103530 <fork_task_state>:
}

void fork_task_state(struct task* new_task) {
  103530:	55                   	push   %ebp
  103531:	89 e5                	mov    %esp,%ebp
  103533:	83 ec 18             	sub    $0x18,%esp
  103536:	8b 45 08             	mov    0x8(%ebp),%eax
  103539:	b9 38 00 00 00       	mov    $0x38,%ecx
  10353e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    new_task->user_stack_bottom = current_task->user_stack_bottom;
  103541:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103546:	8b 40 10             	mov    0x10(%eax),%eax
  103549:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10354c:	89 42 10             	mov    %eax,0x10(%edx)

    memcpy(new_task->cpuState, current_task->cpuState,
  10354f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103552:	8b 40 04             	mov    0x4(%eax),%eax
  103555:	8b 15 2c 94 10 00    	mov    0x10942c,%edx
  10355b:	8b 52 04             	mov    0x4(%edx),%edx
  10355e:	89 04 24             	mov    %eax,(%esp)
  103561:	89 54 24 04          	mov    %edx,0x4(%esp)
  103565:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  10356c:	00 
  10356d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103570:	e8 ab 09 00 00       	call   103f20 <memcpy>
            sizeof(struct cpu_state));

    new_task->cpuState->eax = 0;
  103575:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103578:	8b 40 04             	mov    0x4(%eax),%eax
  10357b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
  103581:	83 c4 18             	add    $0x18,%esp
  103584:	5d                   	pop    %ebp
  103585:	c3                   	ret    
  103586:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10358d:	00 00 00 

00103590 <init_task>:

struct task* init_task(uint32_t task_pagedir, void* entry) {
  103590:	55                   	push   %ebp
  103591:	89 e5                	mov    %esp,%ebp
  103593:	83 ec 68             	sub    $0x68,%esp
  103596:	8b 45 0c             	mov    0xc(%ebp),%eax
  103599:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10359c:	ba 1c 00 00 00       	mov    $0x1c,%edx
  1035a1:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  1035a4:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct task* ntask = malloc(sizeof(struct task));
  1035a7:	c7 04 24 1c 00 00 00 	movl   $0x1c,(%esp)
  1035ae:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  1035b1:	e8 9a 02 00 00       	call   103850 <malloc>
  1035b6:	b9 38 00 00 00       	mov    $0x38,%ecx
  1035bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    ntask->cpuState = malloc(sizeof(struct cpu_state));
  1035be:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  1035c5:	89 4d b0             	mov    %ecx,-0x50(%ebp)
  1035c8:	e8 83 02 00 00       	call   103850 <malloc>
  1035cd:	b9 00 e0 ff ff       	mov    $0xffffe000,%ecx
  1035d2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1035d5:	89 42 04             	mov    %eax,0x4(%edx)

    ntask->phys_pdir = task_pagedir;
  1035d8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1035db:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1035de:	89 42 14             	mov    %eax,0x14(%edx)
    ntask->user_stack_bottom = (void*) 0xFFFFE000;
  1035e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1035e4:	89 48 10             	mov    %ecx,0x10(%eax)
    ntask->PID = nextPID++;
  1035e7:	a1 c0 61 10 00       	mov    0x1061c0,%eax
  1035ec:	89 c1                	mov    %eax,%ecx
  1035ee:	81 c1 01 00 00 00    	add    $0x1,%ecx
  1035f4:	89 0d c0 61 10 00    	mov    %ecx,0x1061c0
  1035fa:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1035fd:	89 01                	mov    %eax,(%ecx)

    ntask->next = (void*) 0;
  1035ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103602:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    ntask->prev = (void*) 0;
  103609:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10360c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

    if (first_task == 0) {
  103613:	81 3d 28 94 10 00 00 	cmpl   $0x0,0x109428
  10361a:	00 00 00 
  10361d:	0f 85 0d 00 00 00    	jne    103630 <init_task+0xa0>
        first_task = ntask;
  103623:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103626:	a3 28 94 10 00       	mov    %eax,0x109428
    } else {
  10362b:	e9 1f 00 00 00       	jmp    10364f <init_task+0xbf>
        ntask->next = first_task;
  103630:	a1 28 94 10 00       	mov    0x109428,%eax
  103635:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103638:	89 41 08             	mov    %eax,0x8(%ecx)
        first_task->prev = ntask;
  10363b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10363e:	8b 0d 28 94 10 00    	mov    0x109428,%ecx
  103644:	89 41 0c             	mov    %eax,0xc(%ecx)
        first_task = ntask;
  103647:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10364a:	a3 28 94 10 00       	mov    %eax,0x109428
    }

    uint32_t rest_pdir = vmm_get_current_pagedir();
  10364f:	e8 1c 17 00 00       	call   104d70 <vmm_get_current_pagedir>
  103654:	89 45 f0             	mov    %eax,-0x10(%ebp)
    vmm_activate_pagedir(task_pagedir);
  103657:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10365a:	89 04 24             	mov    %eax,(%esp)
  10365d:	e8 4e 22 00 00       	call   1058b0 <vmm_activate_pagedir>

    if (entry != 0) { //entry == 0 means that this will be forked
  103662:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103669:	0f 84 21 00 00 00    	je     103690 <init_task+0x100>
  10366f:	b8 00 00 00 00       	mov    $0x0,%eax
        vmm_alloc_addr(ntask->user_stack_bottom, 0);
  103674:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103677:	8b 49 10             	mov    0x10(%ecx),%ecx
  10367a:	89 0c 24             	mov    %ecx,(%esp)
  10367d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103684:	00 
  103685:	89 45 ac             	mov    %eax,-0x54(%ebp)
  103688:	e8 23 21 00 00       	call   1057b0 <vmm_alloc_addr>
  10368d:	89 45 a8             	mov    %eax,-0x58(%ebp)
  103690:	b8 38 00 00 00       	mov    $0x38,%eax
  103695:	8d 4d b8             	lea    -0x48(%ebp),%ecx
    }

    struct cpu_state nstate = { .eax = 0, .ebx = 0, .ecx = 0, .edx = 0,
  103698:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
  10369f:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
  1036a6:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
  1036ad:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  1036b4:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  1036bb:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  1036c2:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  1036c9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  1036d0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  1036d7:	8b 55 f8             	mov    -0x8(%ebp),%edx
  1036da:	89 55 dc             	mov    %edx,-0x24(%ebp)
  1036dd:	c7 45 e0 1b 00 00 00 	movl   $0x1b,-0x20(%ebp)
  1036e4:	c7 45 e4 00 02 00 00 	movl   $0x200,-0x1c(%ebp)
  1036eb:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1036ee:	8b 52 10             	mov    0x10(%edx),%edx
  1036f1:	81 c2 00 10 00 00    	add    $0x1000,%edx
  1036f7:	89 55 e8             	mov    %edx,-0x18(%ebp)
  1036fa:	c7 45 ec 23 00 00 00 	movl   $0x23,-0x14(%ebp)
            /* Ring-3-Segmentregister */
            .cs = 0x18 | 0x03, .ss = 0x20 | 0x03,

            .eflags = 0x200, };

    memcpy(ntask->cpuState, &nstate, sizeof(struct cpu_state));
  103701:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103704:	8b 52 04             	mov    0x4(%edx),%edx
  103707:	89 14 24             	mov    %edx,(%esp)
  10370a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10370e:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  103715:	00 
  103716:	89 45 a4             	mov    %eax,-0x5c(%ebp)
  103719:	e8 02 08 00 00       	call   103f20 <memcpy>

    vmm_activate_pagedir(rest_pdir);
  10371e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103721:	89 04 24             	mov    %eax,(%esp)
  103724:	e8 87 21 00 00       	call   1058b0 <vmm_activate_pagedir>

    return ntask;
  103729:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10372c:	83 c4 68             	add    $0x68,%esp
  10372f:	5d                   	pop    %ebp
  103730:	c3                   	ret    
  103731:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103738:	0f 1f 84 00 00 00 00 
  10373f:	00 

00103740 <save_cpu_state>:
}

void save_cpu_state(struct cpu_state* cpu) {
  103740:	55                   	push   %ebp
  103741:	89 e5                	mov    %esp,%ebp
  103743:	83 ec 18             	sub    $0x18,%esp
  103746:	8b 45 08             	mov    0x8(%ebp),%eax
  103749:	b9 38 00 00 00       	mov    $0x38,%ecx
  10374e:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memcpy(current_task->cpuState, cpu, sizeof(struct cpu_state));
  103751:	a1 2c 94 10 00       	mov    0x10942c,%eax
  103756:	8b 40 04             	mov    0x4(%eax),%eax
  103759:	8b 55 fc             	mov    -0x4(%ebp),%edx
  10375c:	89 04 24             	mov    %eax,(%esp)
  10375f:	89 54 24 04          	mov    %edx,0x4(%esp)
  103763:	c7 44 24 08 38 00 00 	movl   $0x38,0x8(%esp)
  10376a:	00 
  10376b:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10376e:	e8 ad 07 00 00       	call   103f20 <memcpy>
}
  103773:	83 c4 18             	add    $0x18,%esp
  103776:	5d                   	pop    %ebp
  103777:	c3                   	ret    
  103778:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10377f:	00 

00103780 <schedule>:

struct cpu_state* schedule(struct cpu_state* cpu) {
  103780:	55                   	push   %ebp
  103781:	89 e5                	mov    %esp,%ebp
  103783:	83 ec 18             	sub    $0x18,%esp
  103786:	8b 45 08             	mov    0x8(%ebp),%eax
  103789:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (first_task != 0 && schedulingEnabled) {
  10378c:	81 3d 28 94 10 00 00 	cmpl   $0x0,0x109428
  103793:	00 00 00 
  103796:	0f 84 9d 00 00 00    	je     103839 <schedule+0xb9>
  10379c:	81 3d 24 94 10 00 00 	cmpl   $0x0,0x109424
  1037a3:	00 00 00 
  1037a6:	0f 84 8d 00 00 00    	je     103839 <schedule+0xb9>
        if (current_task == 0) {
  1037ac:	81 3d 2c 94 10 00 00 	cmpl   $0x0,0x10942c
  1037b3:	00 00 00 
  1037b6:	0f 85 2a 00 00 00    	jne    1037e6 <schedule+0x66>
            current_task = first_task;
  1037bc:	a1 28 94 10 00       	mov    0x109428,%eax
  1037c1:	a3 2c 94 10 00       	mov    %eax,0x10942c
            vmm_activate_pagedir(current_task->phys_pdir);
  1037c6:	a1 2c 94 10 00       	mov    0x10942c,%eax
  1037cb:	8b 40 14             	mov    0x14(%eax),%eax
  1037ce:	89 04 24             	mov    %eax,(%esp)
  1037d1:	e8 da 20 00 00       	call   1058b0 <vmm_activate_pagedir>
            return current_task->cpuState;
  1037d6:	a1 2c 94 10 00       	mov    0x10942c,%eax
  1037db:	8b 40 04             	mov    0x4(%eax),%eax
  1037de:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1037e1:	e9 59 00 00 00       	jmp    10383f <schedule+0xbf>
        }

        struct task* next = current_task->next;
  1037e6:	a1 2c 94 10 00       	mov    0x10942c,%eax
  1037eb:	8b 40 08             	mov    0x8(%eax),%eax
  1037ee:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (next == 0)
  1037f1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1037f8:	0f 85 08 00 00 00    	jne    103806 <schedule+0x86>
            next = first_task;
  1037fe:	a1 28 94 10 00       	mov    0x109428,%eax
  103803:	89 45 f4             	mov    %eax,-0xc(%ebp)

        save_cpu_state(cpu);
  103806:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103809:	89 04 24             	mov    %eax,(%esp)
  10380c:	e8 2f ff ff ff       	call   103740 <save_cpu_state>

        current_task = next;
  103811:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103814:	a3 2c 94 10 00       	mov    %eax,0x10942c
        vmm_activate_pagedir(current_task->phys_pdir);
  103819:	a1 2c 94 10 00       	mov    0x10942c,%eax
  10381e:	8b 40 14             	mov    0x14(%eax),%eax
  103821:	89 04 24             	mov    %eax,(%esp)
  103824:	e8 87 20 00 00       	call   1058b0 <vmm_activate_pagedir>
        return current_task->cpuState;
  103829:	a1 2c 94 10 00       	mov    0x10942c,%eax
  10382e:	8b 40 04             	mov    0x4(%eax),%eax
  103831:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103834:	e9 06 00 00 00       	jmp    10383f <schedule+0xbf>
    }
    return cpu;
  103839:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10383c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10383f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103842:	83 c4 18             	add    $0x18,%esp
  103845:	5d                   	pop    %ebp
  103846:	c3                   	ret    
  103847:	66 90                	xchg   %ax,%ax
  103849:	66 90                	xchg   %ax,%ax
  10384b:	66 90                	xchg   %ax,%ax
  10384d:	66 90                	xchg   %ax,%ax
  10384f:	90                   	nop

00103850 <malloc>:
    }

    append_to_list(&first_free, tf);
}

void* malloc(size_t size) {
  103850:	55                   	push   %ebp
  103851:	89 e5                	mov    %esp,%ebp
  103853:	83 ec 38             	sub    $0x38,%esp
  103856:	8b 45 08             	mov    0x8(%ebp),%eax
  103859:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(size == 0) return 0;
  10385c:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103863:	0f 85 0c 00 00 00    	jne    103875 <malloc+0x25>
  103869:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103870:	e9 95 01 00 00       	jmp    103a0a <malloc+0x1ba>

    struct memory_node* last = 0;
  103875:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = first_free;
  10387c:	a1 38 94 10 00       	mov    0x109438,%eax
  103881:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  103884:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10388b:	0f 84 27 00 00 00    	je     1038b8 <malloc+0x68>
        if (cur->size >= size) {
  103891:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103894:	8b 00                	mov    (%eax),%eax
  103896:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103899:	0f 82 05 00 00 00    	jb     1038a4 <malloc+0x54>
            break;
  10389f:	e9 14 00 00 00       	jmp    1038b8 <malloc+0x68>
        }
        last = cur;
  1038a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  1038aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1038ad:	8b 40 08             	mov    0x8(%eax),%eax
  1038b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  1038b3:	e9 cc ff ff ff       	jmp    103884 <malloc+0x34>

    if (cur == 0) {
  1038b8:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  1038bf:	0f 85 bc 00 00 00    	jne    103981 <malloc+0x131>
        uint32_t pgs = size / PAGESIZE;
  1038c5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1038c8:	c1 e8 0c             	shr    $0xc,%eax
  1038cb:	89 45 ec             	mov    %eax,-0x14(%ebp)

        if ((size % PAGESIZE) != 0)
  1038ce:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1038d1:	25 ff 0f 00 00       	and    $0xfff,%eax
  1038d6:	3d 00 00 00 00       	cmp    $0x0,%eax
  1038db:	0f 84 0b 00 00 00    	je     1038ec <malloc+0x9c>
            pgs++;
  1038e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1038e4:	05 01 00 00 00       	add    $0x1,%eax
  1038e9:	89 45 ec             	mov    %eax,-0x14(%ebp)

        void* addr = vmm_alloc_cont(pgs);
  1038ec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1038ef:	89 04 24             	mov    %eax,(%esp)
  1038f2:	e8 69 1e 00 00       	call   105760 <vmm_alloc_cont>
  1038f7:	89 45 e8             	mov    %eax,-0x18(%ebp)

        struct memory_node* fill = pop_unused_node();
  1038fa:	e8 81 04 00 00       	call   103d80 <pop_unused_node>
  1038ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)

        fill->address = (uint32_t) addr;
  103902:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103905:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  103908:	89 41 04             	mov    %eax,0x4(%ecx)
        fill->size = (uint32_t) size;
  10390b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10390e:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  103911:	89 01                	mov    %eax,(%ecx)

        if (pgs * PAGESIZE > size) {
  103913:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103916:	c1 e0 0c             	shl    $0xc,%eax
  103919:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  10391c:	0f 86 3c 00 00 00    	jbe    10395e <malloc+0x10e>
            struct memory_node* free = pop_unused_node();
  103922:	e8 59 04 00 00       	call   103d80 <pop_unused_node>
  103927:	8d 0d 38 94 10 00    	lea    0x109438,%ecx
  10392d:	89 45 e0             	mov    %eax,-0x20(%ebp)

            free->address = fill->address + fill->size;
  103930:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103933:	8b 40 04             	mov    0x4(%eax),%eax
  103936:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  103939:	03 02                	add    (%edx),%eax
  10393b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10393e:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = pgs * PAGESIZE - size;
  103941:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103944:	c1 e0 0c             	shl    $0xc,%eax
  103947:	2b 45 f8             	sub    -0x8(%ebp),%eax
  10394a:	8b 55 e0             	mov    -0x20(%ebp),%edx
  10394d:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  10394f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  103952:	89 0c 24             	mov    %ecx,(%esp)
  103955:	89 44 24 04          	mov    %eax,0x4(%esp)
  103959:	e8 c2 00 00 00       	call   103a20 <append_to_list>
  10395e:	8d 05 34 94 10 00    	lea    0x109434,%eax
        }

        append_to_list(&first_used, fill);
  103964:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  103967:	89 04 24             	mov    %eax,(%esp)
  10396a:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  10396e:	e8 ad 00 00 00       	call   103a20 <append_to_list>

        return (void*) fill->address;
  103973:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  103976:	8b 40 04             	mov    0x4(%eax),%eax
  103979:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10397c:	e9 89 00 00 00       	jmp    103a0a <malloc+0x1ba>
  103981:	8d 05 38 94 10 00    	lea    0x109438,%eax
    } else {
        uint32_t freesize = cur->size - size;
  103987:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10398a:	8b 09                	mov    (%ecx),%ecx
  10398c:	2b 4d f8             	sub    -0x8(%ebp),%ecx
  10398f:	89 4d dc             	mov    %ecx,-0x24(%ebp)

        cur->size = size;
  103992:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103995:	8b 55 f0             	mov    -0x10(%ebp),%edx
  103998:	89 0a                	mov    %ecx,(%edx)

        remove_from_list(&first_free, cur);
  10399a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10399d:	89 04 24             	mov    %eax,(%esp)
  1039a0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1039a4:	e8 a7 00 00 00       	call   103a50 <remove_from_list>
  1039a9:	8d 05 34 94 10 00    	lea    0x109434,%eax
        append_to_list(&first_used, cur);
  1039af:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1039b2:	89 04 24             	mov    %eax,(%esp)
  1039b5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1039b9:	e8 62 00 00 00       	call   103a20 <append_to_list>

        if (freesize > 0) {
  1039be:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  1039c5:	0f 86 36 00 00 00    	jbe    103a01 <malloc+0x1b1>
            struct memory_node* free = pop_unused_node();
  1039cb:	e8 b0 03 00 00       	call   103d80 <pop_unused_node>
  1039d0:	8d 0d 38 94 10 00    	lea    0x109438,%ecx
  1039d6:	89 45 d8             	mov    %eax,-0x28(%ebp)

            free->address = cur->address + cur->size;
  1039d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1039dc:	8b 40 04             	mov    0x4(%eax),%eax
  1039df:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1039e2:	03 02                	add    (%edx),%eax
  1039e4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1039e7:	89 42 04             	mov    %eax,0x4(%edx)
            free->size = freesize;
  1039ea:	8b 45 dc             	mov    -0x24(%ebp),%eax
  1039ed:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1039f0:	89 02                	mov    %eax,(%edx)

            append_to_list(&first_free, free);
  1039f2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1039f5:	89 0c 24             	mov    %ecx,(%esp)
  1039f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  1039fc:	e8 1f 00 00 00       	call   103a20 <append_to_list>
        }

        return (void*) cur->address;
  103a01:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a04:	8b 40 04             	mov    0x4(%eax),%eax
  103a07:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
}
  103a0a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a0d:	83 c4 38             	add    $0x38,%esp
  103a10:	5d                   	pop    %ebp
  103a11:	c3                   	ret    
  103a12:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103a19:	1f 84 00 00 00 00 00 

00103a20 <append_to_list>:
        cur = cur->next;
    }
}

static void append_to_list(struct memory_node** root,
        struct memory_node* element) {
  103a20:	55                   	push   %ebp
  103a21:	89 e5                	mov    %esp,%ebp
  103a23:	83 ec 08             	sub    $0x8,%esp
  103a26:	8b 45 0c             	mov    0xc(%ebp),%eax
  103a29:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103a2c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  103a2f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    element->next = *root;
  103a32:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a35:	8b 00                	mov    (%eax),%eax
  103a37:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103a3a:	89 41 08             	mov    %eax,0x8(%ecx)
    *root = element;
  103a3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103a40:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103a43:	89 01                	mov    %eax,(%ecx)
}
  103a45:	83 c4 08             	add    $0x8,%esp
  103a48:	5d                   	pop    %ebp
  103a49:	c3                   	ret    
  103a4a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103a50 <remove_from_list>:
struct memory_node* first_unused = 0;
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root,
        struct memory_node* element) {
  103a50:	55                   	push   %ebp
  103a51:	89 e5                	mov    %esp,%ebp
  103a53:	83 ec 10             	sub    $0x10,%esp
  103a56:	8b 45 0c             	mov    0xc(%ebp),%eax
  103a59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103a5c:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  103a5f:	89 45 f8             	mov    %eax,-0x8(%ebp)
    struct memory_node* last = 0;
  103a62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    struct memory_node* cur = *root;
  103a69:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103a6c:	8b 00                	mov    (%eax),%eax
  103a6e:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  103a71:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  103a78:	0f 84 4e 00 00 00    	je     103acc <remove_from_list+0x7c>
        if (cur == element) {
  103a7e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a81:	3b 45 f8             	cmp    -0x8(%ebp),%eax
  103a84:	0f 85 2e 00 00 00    	jne    103ab8 <remove_from_list+0x68>
            if (last == 0) {
  103a8a:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103a91:	0f 85 10 00 00 00    	jne    103aa7 <remove_from_list+0x57>
                *root = cur->next;
  103a97:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103a9a:	8b 40 08             	mov    0x8(%eax),%eax
  103a9d:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103aa0:	89 01                	mov    %eax,(%ecx)
                return;
  103aa2:	e9 25 00 00 00       	jmp    103acc <remove_from_list+0x7c>
            } else {
                last->next = cur->next;
  103aa7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103aaa:	8b 40 08             	mov    0x8(%eax),%eax
  103aad:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103ab0:	89 41 08             	mov    %eax,0x8(%ecx)
                return;
  103ab3:	e9 14 00 00 00       	jmp    103acc <remove_from_list+0x7c>
            }
        }
        last = cur;
  103ab8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103abb:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  103abe:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103ac1:	8b 40 08             	mov    0x8(%eax),%eax
  103ac4:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  103ac7:	e9 a5 ff ff ff       	jmp    103a71 <remove_from_list+0x21>
}
  103acc:	83 c4 10             	add    $0x10,%esp
  103acf:	5d                   	pop    %ebp
  103ad0:	c3                   	ret    
  103ad1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103ad8:	0f 1f 84 00 00 00 00 
  103adf:	00 

00103ae0 <calloc>:

        return (void*) cur->address;
    }
}

void* calloc(size_t num, size_t size) {
  103ae0:	55                   	push   %ebp
  103ae1:	89 e5                	mov    %esp,%ebp
  103ae3:	83 ec 28             	sub    $0x28,%esp
  103ae6:	8b 45 0c             	mov    0xc(%ebp),%eax
  103ae9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103aec:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  103aef:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t gsize = num * size;
  103af2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103af5:	0f af 45 f8          	imul   -0x8(%ebp),%eax
  103af9:	89 45 f4             	mov    %eax,-0xc(%ebp)
    void* p = malloc(gsize);
  103afc:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103aff:	89 04 24             	mov    %eax,(%esp)
  103b02:	e8 49 fd ff ff       	call   103850 <malloc>
  103b07:	89 45 f0             	mov    %eax,-0x10(%ebp)

    if (p != 0) {
  103b0a:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  103b11:	0f 84 22 00 00 00    	je     103b39 <calloc+0x59>
  103b17:	b8 00 00 00 00       	mov    $0x0,%eax
        memset(p, 0, gsize);
  103b1c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103b1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  103b22:	89 0c 24             	mov    %ecx,(%esp)
  103b25:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103b2c:	00 
  103b2d:	89 54 24 08          	mov    %edx,0x8(%esp)
  103b31:	89 45 ec             	mov    %eax,-0x14(%ebp)
  103b34:	e8 87 03 00 00       	call   103ec0 <memset>
    }

    return p;
  103b39:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103b3c:	83 c4 28             	add    $0x28,%esp
  103b3f:	5d                   	pop    %ebp
  103b40:	c3                   	ret    
  103b41:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103b48:	0f 1f 84 00 00 00 00 
  103b4f:	00 

00103b50 <realloc>:
}

void* realloc(void* ptr, size_t size) {
  103b50:	55                   	push   %ebp
  103b51:	89 e5                	mov    %esp,%ebp
  103b53:	83 ec 28             	sub    $0x28,%esp
  103b56:	8b 45 0c             	mov    0xc(%ebp),%eax
  103b59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  103b5c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103b5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct memory_node* last = 0;
  103b62:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    struct memory_node* cur = first_used;
  103b69:	a1 34 94 10 00       	mov    0x109434,%eax
  103b6e:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (cur != 0) {
  103b71:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  103b78:	0f 84 8e 00 00 00    	je     103c0c <realloc+0xbc>
        if (cur->address == (uint32_t) ptr) {
  103b7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103b81:	8b 40 04             	mov    0x4(%eax),%eax
  103b84:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103b87:	39 c8                	cmp    %ecx,%eax
  103b89:	0f 85 69 00 00 00    	jne    103bf8 <realloc+0xa8>
            if (size == 0) {
  103b8f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103b96:	0f 85 17 00 00 00    	jne    103bb3 <realloc+0x63>
                free(ptr);
  103b9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103b9f:	89 04 24             	mov    %eax,(%esp)
  103ba2:	e8 79 00 00 00       	call   103c20 <free>
                return 0;
  103ba7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103bae:	e9 60 00 00 00       	jmp    103c13 <realloc+0xc3>
            } else {
                void* new = malloc(size);
  103bb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103bb6:	89 04 24             	mov    %eax,(%esp)
  103bb9:	e8 92 fc ff ff       	call   103850 <malloc>
  103bbe:	89 45 e8             	mov    %eax,-0x18(%ebp)
                memcpy(new, (void*) cur->address, cur->size);
  103bc1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103bc4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  103bc7:	8b 49 04             	mov    0x4(%ecx),%ecx
  103bca:	8b 55 ec             	mov    -0x14(%ebp),%edx
  103bcd:	8b 12                	mov    (%edx),%edx
  103bcf:	89 04 24             	mov    %eax,(%esp)
  103bd2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103bd6:	89 54 24 08          	mov    %edx,0x8(%esp)
  103bda:	e8 41 03 00 00       	call   103f20 <memcpy>
                free((void*) cur->address);
  103bdf:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103be2:	8b 40 04             	mov    0x4(%eax),%eax
  103be5:	89 04 24             	mov    %eax,(%esp)
  103be8:	e8 33 00 00 00       	call   103c20 <free>

                return new;
  103bed:	8b 45 e8             	mov    -0x18(%ebp),%eax
  103bf0:	89 45 fc             	mov    %eax,-0x4(%ebp)
  103bf3:	e9 1b 00 00 00       	jmp    103c13 <realloc+0xc3>
            }
        }
        last = cur;
  103bf8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103bfb:	89 45 f0             	mov    %eax,-0x10(%ebp)
        cur = cur->next;
  103bfe:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103c01:	8b 40 08             	mov    0x8(%eax),%eax
  103c04:	89 45 ec             	mov    %eax,-0x14(%ebp)
    }
  103c07:	e9 65 ff ff ff       	jmp    103b71 <realloc+0x21>
    return 0;
  103c0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  103c13:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103c16:	83 c4 28             	add    $0x28,%esp
  103c19:	5d                   	pop    %ebp
  103c1a:	c3                   	ret    
  103c1b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103c20 <free>:

void free(void* ptr) {
  103c20:	55                   	push   %ebp
  103c21:	89 e5                	mov    %esp,%ebp
  103c23:	83 ec 18             	sub    $0x18,%esp
  103c26:	8b 45 08             	mov    0x8(%ebp),%eax
  103c29:	89 45 fc             	mov    %eax,-0x4(%ebp)
    struct memory_node* last = 0;
  103c2c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    struct memory_node* cur = first_used;
  103c33:	a1 34 94 10 00       	mov    0x109434,%eax
  103c38:	89 45 f4             	mov    %eax,-0xc(%ebp)

    while (cur != 0) {
  103c3b:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103c42:	0f 84 35 00 00 00    	je     103c7d <free+0x5d>
        if (cur->address == (uint32_t) ptr) {
  103c48:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c4b:	8b 40 04             	mov    0x4(%eax),%eax
  103c4e:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  103c51:	39 c8                	cmp    %ecx,%eax
  103c53:	0f 85 10 00 00 00    	jne    103c69 <free+0x49>
            merge_into_frees(cur);
  103c59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c5c:	89 04 24             	mov    %eax,(%esp)
  103c5f:	e8 2c 00 00 00       	call   103c90 <merge_into_frees>
            break;
  103c64:	e9 14 00 00 00       	jmp    103c7d <free+0x5d>
        }
        last = cur;
  103c69:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c6c:	89 45 f8             	mov    %eax,-0x8(%ebp)
        cur = cur->next;
  103c6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103c72:	8b 40 08             	mov    0x8(%eax),%eax
  103c75:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  103c78:	e9 be ff ff ff       	jmp    103c3b <free+0x1b>
}
  103c7d:	83 c4 18             	add    $0x18,%esp
  103c80:	5d                   	pop    %ebp
  103c81:	c3                   	ret    
  103c82:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  103c89:	1f 84 00 00 00 00 00 

00103c90 <merge_into_frees>:
    }

    return ret;
}

static void merge_into_frees(struct memory_node* tf) {
  103c90:	55                   	push   %ebp
  103c91:	89 e5                	mov    %esp,%ebp
  103c93:	56                   	push   %esi
  103c94:	83 ec 14             	sub    $0x14,%esp
  103c97:	8b 45 08             	mov    0x8(%ebp),%eax
  103c9a:	8d 0d 34 94 10 00    	lea    0x109434,%ecx
  103ca0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    remove_from_list(&first_used, tf);
  103ca3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ca6:	89 0c 24             	mov    %ecx,(%esp)
  103ca9:	89 44 24 04          	mov    %eax,0x4(%esp)
  103cad:	e8 9e fd ff ff       	call   103a50 <remove_from_list>

    struct memory_node* last;
    struct memory_node* cur;

    editedList: last = 0;
  103cb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    cur = first_free;
  103cb9:	a1 38 94 10 00       	mov    0x109438,%eax
  103cbe:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (cur != 0) {
  103cc1:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  103cc8:	0f 84 92 00 00 00    	je     103d60 <merge_into_frees+0xd0>
        if (cur->address + cur->size == tf->address) {
  103cce:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103cd1:	8b 40 04             	mov    0x4(%eax),%eax
  103cd4:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103cd7:	03 01                	add    (%ecx),%eax
  103cd9:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103cdc:	3b 41 04             	cmp    0x4(%ecx),%eax
  103cdf:	0f 85 26 00 00 00    	jne    103d0b <merge_into_frees+0x7b>
  103ce5:	8d 05 38 94 10 00    	lea    0x109438,%eax
            tf->address = cur->address;
  103ceb:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103cee:	8b 49 04             	mov    0x4(%ecx),%ecx
  103cf1:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103cf4:	89 4a 04             	mov    %ecx,0x4(%edx)
            remove_from_list(&first_free, cur);
  103cf7:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103cfa:	89 04 24             	mov    %eax,(%esp)
  103cfd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103d01:	e8 4a fd ff ff       	call   103a50 <remove_from_list>
            goto editedList;
  103d06:	e9 a7 ff ff ff       	jmp    103cb2 <merge_into_frees+0x22>
        }

        if (cur->address == tf->address + tf->size) {
  103d0b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d0e:	8b 40 04             	mov    0x4(%eax),%eax
  103d11:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103d14:	8b 49 04             	mov    0x4(%ecx),%ecx
  103d17:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103d1a:	03 0a                	add    (%edx),%ecx
  103d1c:	39 c8                	cmp    %ecx,%eax
  103d1e:	0f 85 28 00 00 00    	jne    103d4c <merge_into_frees+0xbc>
  103d24:	8d 05 38 94 10 00    	lea    0x109438,%eax
            tf->size += cur->size;
  103d2a:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103d2d:	8b 09                	mov    (%ecx),%ecx
  103d2f:	8b 55 f8             	mov    -0x8(%ebp),%edx
  103d32:	8b 32                	mov    (%edx),%esi
  103d34:	01 ce                	add    %ecx,%esi
  103d36:	89 32                	mov    %esi,(%edx)
            remove_from_list(&first_free, cur);
  103d38:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  103d3b:	89 04 24             	mov    %eax,(%esp)
  103d3e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103d42:	e8 09 fd ff ff       	call   103a50 <remove_from_list>
            goto editedList;
  103d47:	e9 66 ff ff ff       	jmp    103cb2 <merge_into_frees+0x22>
        }

        last = cur;
  103d4c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d4f:	89 45 f4             	mov    %eax,-0xc(%ebp)
        cur = cur->next;
  103d52:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103d55:	8b 40 08             	mov    0x8(%eax),%eax
  103d58:	89 45 f0             	mov    %eax,-0x10(%ebp)
    }
  103d5b:	e9 61 ff ff ff       	jmp    103cc1 <merge_into_frees+0x31>
  103d60:	8d 05 38 94 10 00    	lea    0x109438,%eax

    append_to_list(&first_free, tf);
  103d66:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103d69:	89 04 24             	mov    %eax,(%esp)
  103d6c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103d70:	e8 ab fc ff ff       	call   103a20 <append_to_list>
}
  103d75:	83 c4 14             	add    $0x14,%esp
  103d78:	5e                   	pop    %esi
  103d79:	5d                   	pop    %ebp
  103d7a:	c3                   	ret    
  103d7b:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00103d80 <pop_unused_node>:
    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}

static struct memory_node* pop_unused_node() {
  103d80:	55                   	push   %ebp
  103d81:	89 e5                	mov    %esp,%ebp
  103d83:	83 ec 08             	sub    $0x8,%esp
  103d86:	8d 05 30 94 10 00    	lea    0x109430,%eax
    struct memory_node* ret = pop_from_list(&first_unused);
  103d8c:	89 04 24             	mov    %eax,(%esp)
  103d8f:	e8 3c 00 00 00       	call   103dd0 <pop_from_list>
  103d94:	89 45 fc             	mov    %eax,-0x4(%ebp)

    while (ret == 0) {
  103d97:	81 7d fc 00 00 00 00 	cmpl   $0x0,-0x4(%ebp)
  103d9e:	0f 85 1b 00 00 00    	jne    103dbf <pop_unused_node+0x3f>
        allocate_unused_nodes();
  103da4:	e8 77 00 00 00       	call   103e20 <allocate_unused_nodes>
  103da9:	8d 05 30 94 10 00    	lea    0x109430,%eax
        ret = pop_from_list(&first_unused);
  103daf:	89 04 24             	mov    %eax,(%esp)
  103db2:	e8 19 00 00 00       	call   103dd0 <pop_from_list>
  103db7:	89 45 fc             	mov    %eax,-0x4(%ebp)
    }
  103dba:	e9 d8 ff ff ff       	jmp    103d97 <pop_unused_node+0x17>

    return ret;
  103dbf:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103dc2:	83 c4 08             	add    $0x8,%esp
  103dc5:	5d                   	pop    %ebp
  103dc6:	c3                   	ret    
  103dc7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  103dce:	00 00 

00103dd0 <pop_from_list>:
        struct memory_node* element) {
    element->next = *root;
    *root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
  103dd0:	55                   	push   %ebp
  103dd1:	89 e5                	mov    %esp,%ebp
  103dd3:	83 ec 18             	sub    $0x18,%esp
  103dd6:	8b 45 08             	mov    0x8(%ebp),%eax
  103dd9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (*root == 0)
  103ddc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ddf:	81 38 00 00 00 00    	cmpl   $0x0,(%eax)
  103de5:	0f 85 0c 00 00 00    	jne    103df7 <pop_from_list+0x27>
        return 0;
  103deb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103df2:	e9 20 00 00 00       	jmp    103e17 <pop_from_list+0x47>
    struct memory_node* pop = *root;
  103df7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103dfa:	8b 00                	mov    (%eax),%eax
  103dfc:	89 45 f4             	mov    %eax,-0xc(%ebp)
    remove_from_list(root, pop);
  103dff:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103e02:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  103e05:	89 04 24             	mov    %eax,(%esp)
  103e08:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  103e0c:	e8 3f fc ff ff       	call   103a50 <remove_from_list>
    return pop;
  103e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103e14:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  103e17:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103e1a:	83 c4 18             	add    $0x18,%esp
  103e1d:	5d                   	pop    %ebp
  103e1e:	c3                   	ret    
  103e1f:	90                   	nop

00103e20 <allocate_unused_nodes>:

static void allocate_unused_nodes() {
  103e20:	55                   	push   %ebp
  103e21:	89 e5                	mov    %esp,%ebp
  103e23:	83 ec 28             	sub    $0x28,%esp
  103e26:	b8 01 00 00 00       	mov    $0x1,%eax
    struct memory_node* new_nodes = vmm_alloc_cont(1);
  103e2b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  103e32:	89 45 f4             	mov    %eax,-0xc(%ebp)
  103e35:	e8 26 19 00 00       	call   105760 <vmm_alloc_cont>
  103e3a:	b9 00 00 00 00       	mov    $0x0,%ecx
  103e3f:	ba 00 10 00 00       	mov    $0x1000,%edx
  103e44:	89 45 fc             	mov    %eax,-0x4(%ebp)
    memset(new_nodes, 0, PAGESIZE);
  103e47:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103e4a:	89 04 24             	mov    %eax,(%esp)
  103e4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  103e54:	00 
  103e55:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  103e5c:	00 
  103e5d:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103e60:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103e63:	e8 58 00 00 00       	call   103ec0 <memset>

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  103e68:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  103e6f:	81 7d f8 55 01 00 00 	cmpl   $0x155,-0x8(%ebp)
  103e76:	0f 83 30 00 00 00    	jae    103eac <allocate_unused_nodes+0x8c>
  103e7c:	8d 05 30 94 10 00    	lea    0x109430,%eax
        append_to_list(&first_unused, &(new_nodes[i]));
  103e82:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  103e85:	8b 55 fc             	mov    -0x4(%ebp),%edx
  103e88:	69 c9 0c 00 00 00    	imul   $0xc,%ecx,%ecx
  103e8e:	01 ca                	add    %ecx,%edx
  103e90:	89 04 24             	mov    %eax,(%esp)
  103e93:	89 54 24 04          	mov    %edx,0x4(%esp)
  103e97:	e8 84 fb ff ff       	call   103a20 <append_to_list>

static void allocate_unused_nodes() {
    struct memory_node* new_nodes = vmm_alloc_cont(1);
    memset(new_nodes, 0, PAGESIZE);

    for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
  103e9c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103e9f:	05 01 00 00 00       	add    $0x1,%eax
  103ea4:	89 45 f8             	mov    %eax,-0x8(%ebp)
  103ea7:	e9 c3 ff ff ff       	jmp    103e6f <allocate_unused_nodes+0x4f>
        append_to_list(&first_unused, &(new_nodes[i]));
    }
}
  103eac:	83 c4 28             	add    $0x28,%esp
  103eaf:	5d                   	pop    %ebp
  103eb0:	c3                   	ret    
  103eb1:	66 90                	xchg   %ax,%ax
  103eb3:	66 90                	xchg   %ax,%ax
  103eb5:	66 90                	xchg   %ax,%ax
  103eb7:	66 90                	xchg   %ax,%ax
  103eb9:	66 90                	xchg   %ax,%ax
  103ebb:	66 90                	xchg   %ax,%ax
  103ebd:	66 90                	xchg   %ax,%ax
  103ebf:	90                   	nop

00103ec0 <memset>:
#include "vmm.h"
#include "string.h"
#include "stdlib.h"

void* memset(void* buf, int c, size_t n) {
  103ec0:	55                   	push   %ebp
  103ec1:	89 e5                	mov    %esp,%ebp
  103ec3:	83 ec 10             	sub    $0x10,%esp
  103ec6:	8b 45 10             	mov    0x10(%ebp),%eax
  103ec9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103ecc:	8b 55 08             	mov    0x8(%ebp),%edx
  103ecf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  103ed2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103ed5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* p = buf;
  103ed8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103edb:	89 45 f0             	mov    %eax,-0x10(%ebp)

    while (n--) {
  103ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ee1:	89 c1                	mov    %eax,%ecx
  103ee3:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103ee9:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103eec:	3d 00 00 00 00       	cmp    $0x0,%eax
  103ef1:	0f 84 1a 00 00 00    	je     103f11 <memset+0x51>
        *p++ = c;
  103ef7:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103efa:	88 c1                	mov    %al,%cl
  103efc:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103eff:	89 c2                	mov    %eax,%edx
  103f01:	81 c2 01 00 00 00    	add    $0x1,%edx
  103f07:	89 55 f0             	mov    %edx,-0x10(%ebp)
  103f0a:	88 08                	mov    %cl,(%eax)
    }
  103f0c:	e9 cd ff ff ff       	jmp    103ede <memset+0x1e>

    return buf;
  103f11:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f14:	83 c4 10             	add    $0x10,%esp
  103f17:	5d                   	pop    %ebp
  103f18:	c3                   	ret    
  103f19:	0f 1f 80 00 00 00 00 	nopl   0x0(%eax)

00103f20 <memcpy>:
}

void* memcpy(void* dest, const void* src, size_t n) {
  103f20:	55                   	push   %ebp
  103f21:	89 e5                	mov    %esp,%ebp
  103f23:	83 ec 14             	sub    $0x14,%esp
  103f26:	8b 45 10             	mov    0x10(%ebp),%eax
  103f29:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103f2c:	8b 55 08             	mov    0x8(%ebp),%edx
  103f2f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  103f32:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  103f35:	89 45 f4             	mov    %eax,-0xc(%ebp)
    unsigned char* d = dest;
  103f38:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f3b:	89 45 f0             	mov    %eax,-0x10(%ebp)
    const unsigned char* s = src;
  103f3e:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103f41:	89 45 ec             	mov    %eax,-0x14(%ebp)

    while (n--) {
  103f44:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103f47:	89 c1                	mov    %eax,%ecx
  103f49:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  103f4f:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103f52:	3d 00 00 00 00       	cmp    $0x0,%eax
  103f57:	0f 84 25 00 00 00    	je     103f82 <memcpy+0x62>
        *(d++) = *(s++);
  103f5d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  103f60:	89 c1                	mov    %eax,%ecx
  103f62:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103f68:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  103f6b:	8a 10                	mov    (%eax),%dl
  103f6d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  103f70:	89 c1                	mov    %eax,%ecx
  103f72:	81 c1 01 00 00 00    	add    $0x1,%ecx
  103f78:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  103f7b:	88 10                	mov    %dl,(%eax)
    }
  103f7d:	e9 c2 ff ff ff       	jmp    103f44 <memcpy+0x24>

    return dest;
  103f82:	8b 45 fc             	mov    -0x4(%ebp),%eax
  103f85:	83 c4 14             	add    $0x14,%esp
  103f88:	5d                   	pop    %ebp
  103f89:	c3                   	ret    
  103f8a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00103f90 <memcmp>:
}

int memcmp(const void* ptr1, const void* ptr2, size_t num) {
  103f90:	55                   	push   %ebp
  103f91:	89 e5                	mov    %esp,%ebp
  103f93:	83 ec 1c             	sub    $0x1c,%esp
  103f96:	8b 45 10             	mov    0x10(%ebp),%eax
  103f99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  103f9c:	8b 55 08             	mov    0x8(%ebp),%edx
  103f9f:	89 55 f8             	mov    %edx,-0x8(%ebp)
  103fa2:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  103fa5:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (ptr1 == 0)
  103fa8:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  103faf:	0f 85 0c 00 00 00    	jne    103fc1 <memcmp+0x31>
        return -1;
  103fb5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%ebp)
  103fbc:	e9 a7 00 00 00       	jmp    104068 <memcmp+0xd8>
    if (ptr2 == 0)
  103fc1:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  103fc8:	0f 85 0c 00 00 00    	jne    103fda <memcmp+0x4a>
        return 1;
  103fce:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  103fd5:	e9 8e 00 00 00       	jmp    104068 <memcmp+0xd8>
    if (num == 0)
  103fda:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  103fe1:	0f 85 0c 00 00 00    	jne    103ff3 <memcmp+0x63>
        return 0;
  103fe7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  103fee:	e9 75 00 00 00       	jmp    104068 <memcmp+0xd8>

    const uint8_t* pa = ptr1;
  103ff3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  103ff6:	89 45 ec             	mov    %eax,-0x14(%ebp)
    const uint8_t* pb = ptr2;
  103ff9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  103ffc:	89 45 e8             	mov    %eax,-0x18(%ebp)

    for (uint32_t i = 0; i < num; i++) {
  103fff:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  104006:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104009:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10400c:	0f 83 4f 00 00 00    	jae    104061 <memcmp+0xd1>
        if (pa[i] != pb[i]) {
  104012:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104015:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104018:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  10401c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10401f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104022:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  104026:	39 c8                	cmp    %ecx,%eax
  104028:	0f 84 1e 00 00 00    	je     10404c <memcmp+0xbc>
            return pa[i] - pb[i];
  10402e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104031:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104034:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  104038:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  10403b:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10403e:	0f b6 0c 0a          	movzbl (%edx,%ecx,1),%ecx
  104042:	29 c8                	sub    %ecx,%eax
  104044:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104047:	e9 1c 00 00 00       	jmp    104068 <memcmp+0xd8>
        }
    }
  10404c:	e9 00 00 00 00       	jmp    104051 <memcmp+0xc1>
        return 0;

    const uint8_t* pa = ptr1;
    const uint8_t* pb = ptr2;

    for (uint32_t i = 0; i < num; i++) {
  104051:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104054:	05 01 00 00 00       	add    $0x1,%eax
  104059:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10405c:	e9 a5 ff ff ff       	jmp    104006 <memcmp+0x76>
        if (pa[i] != pb[i]) {
            return pa[i] - pb[i];
        }
    }
    return 0;
  104061:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104068:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10406b:	83 c4 1c             	add    $0x1c,%esp
  10406e:	5d                   	pop    %ebp
  10406f:	c3                   	ret    

00104070 <strcmp>:

int strcmp(const char* str1, const char* str2) {
  104070:	55                   	push   %ebp
  104071:	89 e5                	mov    %esp,%ebp
  104073:	56                   	push   %esi
  104074:	83 ec 24             	sub    $0x24,%esp
  104077:	8b 45 0c             	mov    0xc(%ebp),%eax
  10407a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10407d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104080:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int l1 = strlen(str1);
  104083:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104086:	89 e1                	mov    %esp,%ecx
  104088:	89 01                	mov    %eax,(%ecx)
  10408a:	e8 61 00 00 00       	call   1040f0 <strlen>
  10408f:	89 45 f0             	mov    %eax,-0x10(%ebp)
    int l2 = strlen(str2);
  104092:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104095:	89 e1                	mov    %esp,%ecx
  104097:	89 01                	mov    %eax,(%ecx)
  104099:	e8 52 00 00 00       	call   1040f0 <strlen>
  10409e:	89 45 ec             	mov    %eax,-0x14(%ebp)
    l1 = l1 < l2 ? l1 : l2;
  1040a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040a4:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1040a7:	0f 8d 0b 00 00 00    	jge    1040b8 <strcmp+0x48>
  1040ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1040b0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1040b3:	e9 06 00 00 00       	jmp    1040be <strcmp+0x4e>
  1040b8:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1040bb:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1040be:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1040c1:	89 45 f0             	mov    %eax,-0x10(%ebp)

    return memcmp(str1, str2, l1 * sizeof(char));
  1040c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1040c7:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1040ca:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1040cd:	c1 e2 00             	shl    $0x0,%edx
  1040d0:	89 e6                	mov    %esp,%esi
  1040d2:	89 56 08             	mov    %edx,0x8(%esi)
  1040d5:	89 4e 04             	mov    %ecx,0x4(%esi)
  1040d8:	89 06                	mov    %eax,(%esi)
  1040da:	e8 b1 fe ff ff       	call   103f90 <memcmp>
  1040df:	83 c4 24             	add    $0x24,%esp
  1040e2:	5e                   	pop    %esi
  1040e3:	5d                   	pop    %ebp
  1040e4:	c3                   	ret    
  1040e5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1040ec:	00 00 00 00 

001040f0 <strlen>:
}

unsigned int strlen(const char* str) {
  1040f0:	55                   	push   %ebp
  1040f1:	89 e5                	mov    %esp,%ebp
  1040f3:	83 ec 0c             	sub    $0xc,%esp
  1040f6:	8b 45 08             	mov    0x8(%ebp),%eax
  1040f9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if (str == 0)
  1040fc:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104103:	0f 85 0c 00 00 00    	jne    104115 <strlen+0x25>
        return 0;
  104109:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104110:	e9 37 00 00 00       	jmp    10414c <strlen+0x5c>
    int i;
    for (i = 0; str[i] != '\0'; i++)
  104115:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  10411c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10411f:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104122:	0f be 04 01          	movsbl (%ecx,%eax,1),%eax
  104126:	3d 00 00 00 00       	cmp    $0x0,%eax
  10412b:	0f 84 15 00 00 00    	je     104146 <strlen+0x56>
  104131:	e9 00 00 00 00       	jmp    104136 <strlen+0x46>
  104136:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104139:	05 01 00 00 00       	add    $0x1,%eax
  10413e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104141:	e9 d6 ff ff ff       	jmp    10411c <strlen+0x2c>
        ;
    return i;
  104146:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104149:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10414c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10414f:	83 c4 0c             	add    $0xc,%esp
  104152:	5d                   	pop    %ebp
  104153:	c3                   	ret    
  104154:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10415b:	00 00 00 00 00 

00104160 <strcpy>:

char* strcpy(char* dest, const char* src) {
  104160:	55                   	push   %ebp
  104161:	89 e5                	mov    %esp,%ebp
  104163:	56                   	push   %esi
  104164:	83 ec 24             	sub    $0x24,%esp
  104167:	8b 45 0c             	mov    0xc(%ebp),%eax
  10416a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10416d:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104170:	89 45 f4             	mov    %eax,-0xc(%ebp)
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
  104173:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104176:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104179:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10417c:	89 e6                	mov    %esp,%esi
  10417e:	89 16                	mov    %edx,(%esi)
  104180:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104183:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  104186:	e8 65 ff ff ff       	call   1040f0 <strlen>
  10418b:	c1 e0 00             	shl    $0x0,%eax
  10418e:	05 01 00 00 00       	add    $0x1,%eax
  104193:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104196:	89 0c 24             	mov    %ecx,(%esp)
  104199:	8b 55 ec             	mov    -0x14(%ebp),%edx
  10419c:	89 54 24 04          	mov    %edx,0x4(%esp)
  1041a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  1041a4:	e8 77 fd ff ff       	call   103f20 <memcpy>
    return dest;
  1041a9:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041ac:	83 c4 24             	add    $0x24,%esp
  1041af:	5e                   	pop    %esi
  1041b0:	5d                   	pop    %ebp
  1041b1:	c3                   	ret    
  1041b2:	66 66 66 66 66 2e 0f 	data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1041b9:	1f 84 00 00 00 00 00 

001041c0 <strclone>:
}

char* strclone(char* str) {
  1041c0:	55                   	push   %ebp
  1041c1:	89 e5                	mov    %esp,%ebp
  1041c3:	83 ec 18             	sub    $0x18,%esp
  1041c6:	8b 45 08             	mov    0x8(%ebp),%eax
  1041c9:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
  1041cc:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1041cf:	89 e1                	mov    %esp,%ecx
  1041d1:	89 01                	mov    %eax,(%ecx)
  1041d3:	e8 18 ff ff ff       	call   1040f0 <strlen>
  1041d8:	c1 e0 00             	shl    $0x0,%eax
  1041db:	05 01 00 00 00       	add    $0x1,%eax
  1041e0:	89 04 24             	mov    %eax,(%esp)
  1041e3:	e8 68 f6 ff ff       	call   103850 <malloc>
  1041e8:	89 45 f8             	mov    %eax,-0x8(%ebp)
    strcpy(ret, str);
  1041eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1041ee:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1041f1:	89 e2                	mov    %esp,%edx
  1041f3:	89 4a 04             	mov    %ecx,0x4(%edx)
  1041f6:	89 02                	mov    %eax,(%edx)
  1041f8:	e8 63 ff ff ff       	call   104160 <strcpy>

    return ret;
  1041fd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104200:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104203:	89 c8                	mov    %ecx,%eax
  104205:	83 c4 18             	add    $0x18,%esp
  104208:	5d                   	pop    %ebp
  104209:	c3                   	ret    
  10420a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104210 <strtok>:
}

char* sp = NULL; /* the start position of the string */

char* strtok(char* str, const char* delimiters) {
  104210:	55                   	push   %ebp
  104211:	89 e5                	mov    %esp,%ebp
  104213:	83 ec 18             	sub    $0x18,%esp
  104216:	8b 45 0c             	mov    0xc(%ebp),%eax
  104219:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10421c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10421f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(str != 0) {
  104222:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104229:	0f 84 22 00 00 00    	je     104251 <strtok+0x41>
        return strtoknc(strclone(str), delimiters);
  10422f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104232:	89 04 24             	mov    %eax,(%esp)
  104235:	e8 86 ff ff ff       	call   1041c0 <strclone>
  10423a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10423d:	89 04 24             	mov    %eax,(%esp)
  104240:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104244:	e8 37 00 00 00       	call   104280 <strtoknc>
  104249:	89 45 fc             	mov    %eax,-0x4(%ebp)
  10424c:	e9 1e 00 00 00       	jmp    10426f <strtok+0x5f>
  104251:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    return strtoknc(0, delimiters);
  104256:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104259:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104260:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104264:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104267:	e8 14 00 00 00       	call   104280 <strtoknc>
  10426c:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  10426f:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104272:	83 c4 18             	add    $0x18,%esp
  104275:	5d                   	pop    %ebp
  104276:	c3                   	ret    
  104277:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  10427e:	00 00 

00104280 <strtoknc>:

char* strtoknc(char* str, const char* delimiters) {
  104280:	55                   	push   %ebp
  104281:	89 e5                	mov    %esp,%ebp
  104283:	83 ec 28             	sub    $0x28,%esp
  104286:	8b 45 0c             	mov    0xc(%ebp),%eax
  104289:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10428c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10428f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    int i = 0;
  104292:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int len = strlen(delimiters);
  104299:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10429c:	89 e1                	mov    %esp,%ecx
  10429e:	89 01                	mov    %eax,(%ecx)
  1042a0:	e8 4b fe ff ff       	call   1040f0 <strlen>
  1042a5:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check in the delimiters */
    if (len == 0)
  1042a8:	81 7d ec 00 00 00 00 	cmpl   $0x0,-0x14(%ebp)
  1042af:	0f 85 0c 00 00 00    	jne    1042c1 <strtoknc+0x41>
        return 0;
  1042b5:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1042bc:	e9 80 01 00 00       	jmp    104441 <strtoknc+0x1c1>

    /* if the original string has nothing left */
    if (!str && !sp)
  1042c1:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1042c8:	0f 85 1c 00 00 00    	jne    1042ea <strtoknc+0x6a>
  1042ce:	81 3d 3c 94 10 00 00 	cmpl   $0x0,0x10943c
  1042d5:	00 00 00 
  1042d8:	0f 85 0c 00 00 00    	jne    1042ea <strtoknc+0x6a>
        return 0;
  1042de:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  1042e5:	e9 57 01 00 00       	jmp    104441 <strtoknc+0x1c1>

    /* initialize the sp during the first call */
    if (str && !sp)
  1042ea:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1042f1:	0f 84 18 00 00 00    	je     10430f <strtoknc+0x8f>
  1042f7:	81 3d 3c 94 10 00 00 	cmpl   $0x0,0x10943c
  1042fe:	00 00 00 
  104301:	0f 85 08 00 00 00    	jne    10430f <strtoknc+0x8f>
        sp = str;
  104307:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10430a:	a3 3c 94 10 00       	mov    %eax,0x10943c

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
  10430f:	a1 3c 94 10 00       	mov    0x10943c,%eax
  104314:	89 45 e8             	mov    %eax,-0x18(%ebp)
    while (1) {
        for (i = 0; i < len; i++) {
  104317:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  10431e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104321:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  104324:	0f 8d 3d 00 00 00    	jge    104367 <strtoknc+0xe7>
            if (*p_start == delimiters[i]) {
  10432a:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10432d:	0f be 00             	movsbl (%eax),%eax
  104330:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104333:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104336:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  10433a:	39 c8                	cmp    %ecx,%eax
  10433c:	0f 85 10 00 00 00    	jne    104352 <strtoknc+0xd2>
                p_start++;
  104342:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104345:	05 01 00 00 00       	add    $0x1,%eax
  10434a:	89 45 e8             	mov    %eax,-0x18(%ebp)
                break;
  10434d:	e9 15 00 00 00       	jmp    104367 <strtoknc+0xe7>
            }
        }
  104352:	e9 00 00 00 00       	jmp    104357 <strtoknc+0xd7>
        sp = str;

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
  104357:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10435a:	05 01 00 00 00       	add    $0x1,%eax
  10435f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104362:	e9 b7 ff ff ff       	jmp    10431e <strtoknc+0x9e>
                p_start++;
                break;
            }
        }

        if (i == len) {
  104367:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10436a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10436d:	0f 85 0d 00 00 00    	jne    104380 <strtoknc+0x100>
            sp = p_start;
  104373:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104376:	a3 3c 94 10 00       	mov    %eax,0x10943c
            break;
  10437b:	e9 05 00 00 00       	jmp    104385 <strtoknc+0x105>
        }
    }
  104380:	e9 92 ff ff ff       	jmp    104317 <strtoknc+0x97>

    /* return NULL if nothing left */
    if (*sp == '\0') {
  104385:	a1 3c 94 10 00       	mov    0x10943c,%eax
  10438a:	0f be 00             	movsbl (%eax),%eax
  10438d:	3d 00 00 00 00       	cmp    $0x0,%eax
  104392:	0f 85 17 00 00 00    	jne    1043af <strtoknc+0x12f>
        sp = NULL;
  104398:	c7 05 3c 94 10 00 00 	movl   $0x0,0x10943c
  10439f:	00 00 00 
        return sp;
  1043a2:	a1 3c 94 10 00       	mov    0x10943c,%eax
  1043a7:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1043aa:	e9 92 00 00 00       	jmp    104441 <strtoknc+0x1c1>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
  1043af:	e9 00 00 00 00       	jmp    1043b4 <strtoknc+0x134>
  1043b4:	a1 3c 94 10 00       	mov    0x10943c,%eax
  1043b9:	0f be 00             	movsbl (%eax),%eax
  1043bc:	3d 00 00 00 00       	cmp    $0x0,%eax
  1043c1:	0f 84 74 00 00 00    	je     10443b <strtoknc+0x1bb>
        for (i = 0; i < len; i++) {
  1043c7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  1043ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1043d1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1043d4:	0f 8d 3c 00 00 00    	jge    104416 <strtoknc+0x196>
            if (*sp == delimiters[i]) {
  1043da:	a1 3c 94 10 00       	mov    0x10943c,%eax
  1043df:	0f be 00             	movsbl (%eax),%eax
  1043e2:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1043e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1043e8:	0f be 0c 0a          	movsbl (%edx,%ecx,1),%ecx
  1043ec:	39 c8                	cmp    %ecx,%eax
  1043ee:	0f 85 0d 00 00 00    	jne    104401 <strtoknc+0x181>
                *sp = '\0';
  1043f4:	a1 3c 94 10 00       	mov    0x10943c,%eax
  1043f9:	c6 00 00             	movb   $0x0,(%eax)
                break;
  1043fc:	e9 15 00 00 00       	jmp    104416 <strtoknc+0x196>
            }
        }
  104401:	e9 00 00 00 00       	jmp    104406 <strtoknc+0x186>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
  104406:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104409:	05 01 00 00 00       	add    $0x1,%eax
  10440e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104411:	e9 b8 ff ff ff       	jmp    1043ce <strtoknc+0x14e>
                *sp = '\0';
                break;
            }
        }

        sp++;
  104416:	a1 3c 94 10 00       	mov    0x10943c,%eax
  10441b:	05 01 00 00 00       	add    $0x1,%eax
  104420:	a3 3c 94 10 00       	mov    %eax,0x10943c
        if (i < len)
  104425:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104428:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  10442b:	0f 8d 05 00 00 00    	jge    104436 <strtoknc+0x1b6>
            break;
  104431:	e9 05 00 00 00       	jmp    10443b <strtoknc+0x1bb>
    }
  104436:	e9 79 ff ff ff       	jmp    1043b4 <strtoknc+0x134>

    return p_start;
  10443b:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10443e:	89 45 fc             	mov    %eax,-0x4(%ebp)
}
  104441:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104444:	83 c4 28             	add    $0x28,%esp
  104447:	5d                   	pop    %ebp
  104448:	c3                   	ret    
  104449:	66 90                	xchg   %ax,%ax
  10444b:	66 90                	xchg   %ax,%ax
  10444d:	66 90                	xchg   %ax,%ax
  10444f:	90                   	nop

00104450 <vfs_create_dir>:
    }

    return child;
}

uint32_t vfs_create_dir(char* path) {
  104450:	55                   	push   %ebp
  104451:	89 e5                	mov    %esp,%ebp
  104453:	83 ec 08             	sub    $0x8,%esp
  104456:	8b 45 08             	mov    0x8(%ebp),%eax
  104459:	89 45 fc             	mov    %eax,-0x4(%ebp)
    return vfs_create_path(path);
  10445c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10445f:	89 04 24             	mov    %eax,(%esp)
  104462:	e8 09 00 00 00       	call   104470 <vfs_create_path>
  104467:	83 c4 08             	add    $0x8,%esp
  10446a:	5d                   	pop    %ebp
  10446b:	c3                   	ret    
  10446c:	0f 1f 40 00          	nopl   0x0(%eax)

00104470 <vfs_create_path>:
    }

    return 1;
}

static int vfs_create_path(char* path) {
  104470:	55                   	push   %ebp
  104471:	89 e5                	mov    %esp,%ebp
  104473:	83 ec 38             	sub    $0x38,%esp
  104476:	8b 45 08             	mov    0x8(%ebp),%eax
  104479:	8d 0d 98 74 10 00    	lea    0x107498,%ecx
  10447f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  104482:	a1 40 94 10 00       	mov    0x109440,%eax
  104487:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  10448a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    int created = 0;
  104491:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

    sub = strtok(path, "/");
  104498:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10449b:	89 04 24             	mov    %eax,(%esp)
  10449e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1044a2:	e8 69 fd ff ff       	call   104210 <strtok>
  1044a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  1044aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1044ad:	0f be 00             	movsbl (%eax),%eax
  1044b0:	3d 00 00 00 00       	cmp    $0x0,%eax
  1044b5:	0f 85 21 00 00 00    	jne    1044dc <vfs_create_path+0x6c>
  1044bb:	b8 00 00 00 00       	mov    $0x0,%eax
  1044c0:	8d 0d 98 74 10 00    	lea    0x107498,%ecx
  1044c6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1044cd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1044d1:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1044d4:	e8 37 fd ff ff       	call   104210 <strtok>
  1044d9:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  1044dc:	e9 00 00 00 00       	jmp    1044e1 <vfs_create_path+0x71>
  1044e1:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1044e8:	0f 84 e8 00 00 00    	je     1045d6 <vfs_create_path+0x166>
    {
        child = vfs_find_node(parent, sub);
  1044ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1044f1:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1044f4:	89 04 24             	mov    %eax,(%esp)
  1044f7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1044fb:	e8 50 07 00 00       	call   104c50 <vfs_find_node>
  104500:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if(child == 0) {
  104503:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10450a:	0f 85 9a 00 00 00    	jne    1045aa <vfs_create_path+0x13a>
  104510:	b8 10 01 00 00       	mov    $0x110,%eax
            child = malloc(sizeof(struct res_node));
  104515:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  10451c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10451f:	e8 2c f3 ff ff       	call   103850 <malloc>
  104524:	89 45 f0             	mov    %eax,-0x10(%ebp)

            strcpy(child->name, sub);
  104527:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10452a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10452d:	89 e2                	mov    %esp,%edx
  10452f:	89 4a 04             	mov    %ecx,0x4(%edx)
  104532:	89 02                	mov    %eax,(%edx)
  104534:	e8 27 fc ff ff       	call   104160 <strcpy>
            child->res_type = RES_SUBDIR;
  104539:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  10453c:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  104543:	00 00 00 
            child->res_ptr = 0;
  104546:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104549:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  104550:	00 00 00 

            created++;
  104553:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  104556:	81 c1 01 00 00 00    	add    $0x1,%ecx
  10455c:	89 4d ec             	mov    %ecx,-0x14(%ebp)

            if(vfs_insert_node(parent, child)) {
  10455f:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104562:	8b 55 f0             	mov    -0x10(%ebp),%edx
  104565:	89 0c 24             	mov    %ecx,(%esp)
  104568:	89 54 24 04          	mov    %edx,0x4(%esp)
  10456c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  10456f:	e8 6c 07 00 00       	call   104ce0 <vfs_insert_node>
  104574:	3d 00 00 00 00       	cmp    $0x0,%eax
  104579:	0f 84 26 00 00 00    	je     1045a5 <vfs_create_path+0x135>
  10457f:	b8 38 00 00 00       	mov    $0x38,%eax
                show_cod(malloc(sizeof(struct cpu_state)), "Tried to insert VFS node in non RES_SUBDIR parent");
  104584:	c7 04 24 38 00 00 00 	movl   $0x38,(%esp)
  10458b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  10458e:	e8 bd f2 ff ff       	call   103850 <malloc>
  104593:	8d 0d 9a 74 10 00    	lea    0x10749a,%ecx
  104599:	89 04 24             	mov    %eax,(%esp)
  10459c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1045a0:	e8 cb bd ff ff       	call   100370 <show_cod>
            }
        }
  1045a5:	e9 00 00 00 00       	jmp    1045aa <vfs_create_path+0x13a>
  1045aa:	b8 00 00 00 00       	mov    $0x0,%eax
  1045af:	8d 0d 98 74 10 00    	lea    0x107498,%ecx

        parent = child;
  1045b5:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1045b8:	89 55 f4             	mov    %edx,-0xc(%ebp)

        sub = strtok(0, "/");
  1045bb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1045c2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1045c6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1045c9:	e8 42 fc ff ff       	call   104210 <strtok>
  1045ce:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  1045d1:	e9 0b ff ff ff       	jmp    1044e1 <vfs_create_path+0x71>

    return created;
  1045d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1045d9:	83 c4 38             	add    $0x38,%esp
  1045dc:	5d                   	pop    %ebp
  1045dd:	c3                   	ret    
  1045de:	66 90                	xchg   %ax,%ax

001045e0 <vfs_create_kfile>:

uint32_t vfs_create_dir(char* path) {
    return vfs_create_path(path);
}

uint32_t vfs_create_kfile(char* path, struct kfs_driver* driver, uint32_t* params) {
  1045e0:	55                   	push   %ebp
  1045e1:	89 e5                	mov    %esp,%ebp
  1045e3:	83 ec 28             	sub    $0x28,%esp
  1045e6:	8b 45 10             	mov    0x10(%ebp),%eax
  1045e9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1045ec:	8b 55 08             	mov    0x8(%ebp),%edx
  1045ef:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1045f2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1045f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    char* pathc = malloc(strlen(path) + 1);
  1045f8:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1045fb:	89 e1                	mov    %esp,%ecx
  1045fd:	89 01                	mov    %eax,(%ecx)
  1045ff:	e8 ec fa ff ff       	call   1040f0 <strlen>
  104604:	05 01 00 00 00       	add    $0x1,%eax
  104609:	89 04 24             	mov    %eax,(%esp)
  10460c:	e8 3f f2 ff ff       	call   103850 <malloc>
  104611:	89 45 f0             	mov    %eax,-0x10(%ebp)
    strcpy(pathc, path);
  104614:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104617:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10461a:	89 e2                	mov    %esp,%edx
  10461c:	89 4a 04             	mov    %ecx,0x4(%edx)
  10461f:	89 02                	mov    %eax,(%edx)
  104621:	e8 3a fb ff ff       	call   104160 <strcpy>

    uint32_t ret = vfs_create_path(pathc);
  104626:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104629:	89 0c 24             	mov    %ecx,(%esp)
  10462c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  10462f:	e8 3c fe ff ff       	call   104470 <vfs_create_path>
  104634:	89 45 ec             	mov    %eax,-0x14(%ebp)

    static struct res_node* node;
    node = vfs_get_node(path);
  104637:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10463a:	89 04 24             	mov    %eax,(%esp)
  10463d:	e8 4e 00 00 00       	call   104690 <vfs_get_node>
  104642:	a3 4c 94 10 00       	mov    %eax,0x10944c

    node->res_type = RES_KERNDRV;
  104647:	a1 4c 94 10 00       	mov    0x10944c,%eax
  10464c:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%eax)
  104653:	00 00 00 
    node->res_ptr = driver->create(params);
  104656:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104659:	8b 40 14             	mov    0x14(%eax),%eax
  10465c:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10465f:	89 0c 24             	mov    %ecx,(%esp)
  104662:	ff d0                	call   *%eax
  104664:	8b 0d 4c 94 10 00    	mov    0x10944c,%ecx
  10466a:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)
    ((struct res_kfile*) node->res_ptr)->driver = driver;
  104670:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104673:	8b 0d 4c 94 10 00    	mov    0x10944c,%ecx
  104679:	8b 89 04 01 00 00    	mov    0x104(%ecx),%ecx
  10467f:	89 41 04             	mov    %eax,0x4(%ecx)

    return ret;
  104682:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104685:	83 c4 28             	add    $0x28,%esp
  104688:	5d                   	pop    %ebp
  104689:	c3                   	ret    
  10468a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104690 <vfs_get_node>:
    }

    return created;
}

static struct res_node* vfs_get_node(char* path) {
  104690:	55                   	push   %ebp
  104691:	89 e5                	mov    %esp,%ebp
  104693:	83 ec 28             	sub    $0x28,%esp
  104696:	8b 45 08             	mov    0x8(%ebp),%eax
  104699:	8d 0d 98 74 10 00    	lea    0x107498,%ecx
  10469f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    char* sub;
    struct res_node* parent = root;
  1046a2:	a1 40 94 10 00       	mov    0x109440,%eax
  1046a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    struct res_node* child = 0;
  1046aa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    sub = strtok(path, "/");
  1046b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1046b4:	89 04 24             	mov    %eax,(%esp)
  1046b7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1046bb:	e8 50 fb ff ff       	call   104210 <strtok>
  1046c0:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(sub[0] == 0) sub = strtok(0, "/");
  1046c3:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1046c6:	0f be 00             	movsbl (%eax),%eax
  1046c9:	3d 00 00 00 00       	cmp    $0x0,%eax
  1046ce:	0f 85 21 00 00 00    	jne    1046f5 <vfs_get_node+0x65>
  1046d4:	b8 00 00 00 00       	mov    $0x0,%eax
  1046d9:	8d 0d 98 74 10 00    	lea    0x107498,%ecx
  1046df:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  1046e6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1046ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1046ed:	e8 1e fb ff ff       	call   104210 <strtok>
  1046f2:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while (sub != NULL)
  1046f5:	e9 00 00 00 00       	jmp    1046fa <vfs_get_node+0x6a>
  1046fa:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  104701:	0f 84 41 00 00 00    	je     104748 <vfs_get_node+0xb8>
    {
        child = vfs_find_node(parent, sub);
  104707:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10470a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10470d:	89 04 24             	mov    %eax,(%esp)
  104710:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104714:	e8 37 05 00 00       	call   104c50 <vfs_find_node>
  104719:	b9 00 00 00 00       	mov    $0x0,%ecx
  10471e:	8d 15 98 74 10 00    	lea    0x107498,%edx
  104724:	89 45 f0             	mov    %eax,-0x10(%ebp)
        parent = child;
  104727:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10472a:	89 45 f4             	mov    %eax,-0xc(%ebp)
        sub = strtok(0, "/");
  10472d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104734:	89 54 24 04          	mov    %edx,0x4(%esp)
  104738:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  10473b:	e8 d0 fa ff ff       	call   104210 <strtok>
  104740:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
  104743:	e9 b2 ff ff ff       	jmp    1046fa <vfs_get_node+0x6a>

    return child;
  104748:	8b 45 f0             	mov    -0x10(%ebp),%eax
  10474b:	83 c4 28             	add    $0x28,%esp
  10474e:	5d                   	pop    %ebp
  10474f:	c3                   	ret    

00104750 <vfs_open>:
    ((struct res_kfile*) node->res_ptr)->driver = driver;

    return ret;
}

struct res_handle* vfs_open(char* path, uint32_t filemode) {
  104750:	55                   	push   %ebp
  104751:	89 e5                	mov    %esp,%ebp
  104753:	83 ec 28             	sub    $0x28,%esp
  104756:	8b 45 0c             	mov    0xc(%ebp),%eax
  104759:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10475c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  10475f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    static struct res_node* node;

    node = vfs_get_node(path);
  104762:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104765:	89 04 24             	mov    %eax,(%esp)
  104768:	e8 23 ff ff ff       	call   104690 <vfs_get_node>
  10476d:	a3 50 94 10 00       	mov    %eax,0x109450

    if(node->res_type == RES_KERNDRV) {
  104772:	a1 50 94 10 00       	mov    0x109450,%eax
  104777:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  10477e:	00 00 00 
  104781:	0f 85 34 00 00 00    	jne    1047bb <vfs_open+0x6b>
        struct res_kfile* kf = (struct res_kfile*)node->res_ptr;
  104787:	a1 50 94 10 00       	mov    0x109450,%eax
  10478c:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104792:	89 45 f0             	mov    %eax,-0x10(%ebp)
        struct res_handle* handle = kf->driver->open(kf, filemode);
  104795:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104798:	8b 40 04             	mov    0x4(%eax),%eax
  10479b:	8b 40 08             	mov    0x8(%eax),%eax
  10479e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1047a1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1047a4:	89 0c 24             	mov    %ecx,(%esp)
  1047a7:	89 54 24 04          	mov    %edx,0x4(%esp)
  1047ab:	ff d0                	call   *%eax
  1047ad:	89 45 ec             	mov    %eax,-0x14(%ebp)

        return handle;
  1047b0:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1047b3:	89 45 fc             	mov    %eax,-0x4(%ebp)
  1047b6:	e9 07 00 00 00       	jmp    1047c2 <vfs_open+0x72>
    }

    return 0;
  1047bb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  1047c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1047c5:	83 c4 28             	add    $0x28,%esp
  1047c8:	5d                   	pop    %ebp
  1047c9:	c3                   	ret    
  1047ca:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

001047d0 <vfs_close>:

uint32_t vfs_close(struct res_handle* handle) {
  1047d0:	55                   	push   %ebp
  1047d1:	89 e5                	mov    %esp,%ebp
  1047d3:	83 ec 18             	sub    $0x18,%esp
  1047d6:	8b 45 08             	mov    0x8(%ebp),%eax
  1047d9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle->res_type == RES_KERNDRV) {
  1047dc:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1047df:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  1047e5:	0f 85 22 00 00 00    	jne    10480d <vfs_close+0x3d>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  1047eb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1047ee:	8b 40 04             	mov    0x4(%eax),%eax
  1047f1:	89 45 f4             	mov    %eax,-0xc(%ebp)

       return kf->driver->close(handle);
  1047f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  1047f7:	8b 40 04             	mov    0x4(%eax),%eax
  1047fa:	8b 40 0c             	mov    0xc(%eax),%eax
  1047fd:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104800:	89 0c 24             	mov    %ecx,(%esp)
  104803:	ff d0                	call   *%eax
  104805:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104808:	e9 07 00 00 00       	jmp    104814 <vfs_close+0x44>
    }

    return 0;
  10480d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104814:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104817:	83 c4 18             	add    $0x18,%esp
  10481a:	5d                   	pop    %ebp
  10481b:	c3                   	ret    
  10481c:	0f 1f 40 00          	nopl   0x0(%eax)

00104820 <vfs_read>:

uint32_t vfs_read(struct res_handle* handle, void* dest, uint32_t size, uint32_t count) {
  104820:	55                   	push   %ebp
  104821:	89 e5                	mov    %esp,%ebp
  104823:	56                   	push   %esi
  104824:	83 ec 34             	sub    $0x34,%esp
  104827:	8b 45 14             	mov    0x14(%ebp),%eax
  10482a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10482d:	8b 55 0c             	mov    0xc(%ebp),%edx
  104830:	8b 75 08             	mov    0x8(%ebp),%esi
  104833:	89 75 f4             	mov    %esi,-0xc(%ebp)
  104836:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104839:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10483c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10483f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104846:	0f 85 0c 00 00 00    	jne    104858 <vfs_read+0x38>
  10484c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  104853:	e9 94 00 00 00       	jmp    1048ec <vfs_read+0xcc>

    if(handle->res_type == RES_KERNDRV) {
  104858:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10485b:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  104861:	0f 85 7e 00 00 00    	jne    1048e5 <vfs_read+0xc5>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  104867:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10486a:	8b 40 04             	mov    0x4(%eax),%eax
  10486d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rread(handle, dest, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  104870:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104873:	8b 40 04             	mov    0x4(%eax),%eax
  104876:	8b 00                	mov    (%eax),%eax
  104878:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10487b:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10487e:	8b 75 ec             	mov    -0x14(%ebp),%esi
  104881:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  104885:	89 0c 24             	mov    %ecx,(%esp)
  104888:	89 54 24 04          	mov    %edx,0x4(%esp)
  10488c:	89 74 24 08          	mov    %esi,0x8(%esp)
  104890:	ff d0                	call   *%eax
  104892:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  104895:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10489c:	0f 85 1e 00 00 00    	jne    1048c0 <vfs_read+0xa0>
           handle->position += size * count;
  1048a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1048a5:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  1048a9:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1048ac:	8b 51 08             	mov    0x8(%ecx),%edx
  1048af:	01 c2                	add    %eax,%edx
  1048b1:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  1048b4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1048bb:	e9 2c 00 00 00       	jmp    1048ec <vfs_read+0xcc>
       }

       if(res == RW_BLOCK) {
  1048c0:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  1048c7:	0f 85 0c 00 00 00    	jne    1048d9 <vfs_read+0xb9>
           return RW_BLOCK;
  1048cd:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1048d4:	e9 13 00 00 00       	jmp    1048ec <vfs_read+0xcc>
       }

       return RW_ERR_DRIVER;
  1048d9:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  1048e0:	e9 07 00 00 00       	jmp    1048ec <vfs_read+0xcc>
    }

    return RW_ERR_VFS;
  1048e5:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  1048ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1048ef:	83 c4 34             	add    $0x34,%esp
  1048f2:	5e                   	pop    %esi
  1048f3:	5d                   	pop    %ebp
  1048f4:	c3                   	ret    
  1048f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  1048fc:	00 00 00 00 

00104900 <vfs_write>:

uint32_t vfs_write(struct res_handle* handle, void* src,  uint32_t size, uint32_t count) {
  104900:	55                   	push   %ebp
  104901:	89 e5                	mov    %esp,%ebp
  104903:	56                   	push   %esi
  104904:	83 ec 34             	sub    $0x34,%esp
  104907:	8b 45 14             	mov    0x14(%ebp),%eax
  10490a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10490d:	8b 55 0c             	mov    0xc(%ebp),%edx
  104910:	8b 75 08             	mov    0x8(%ebp),%esi
  104913:	89 75 f4             	mov    %esi,-0xc(%ebp)
  104916:	89 55 f0             	mov    %edx,-0x10(%ebp)
  104919:	89 4d ec             	mov    %ecx,-0x14(%ebp)
  10491c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if(handle == 0) return RW_ERR_VFS;
  10491f:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104926:	0f 85 0c 00 00 00    	jne    104938 <vfs_write+0x38>
  10492c:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
  104933:	e9 95 00 00 00       	jmp    1049cd <vfs_write+0xcd>

    if(handle->res_type == RES_KERNDRV) {
  104938:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10493b:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  104941:	0f 85 7f 00 00 00    	jne    1049c6 <vfs_write+0xc6>
       struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  104947:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10494a:	8b 40 04             	mov    0x4(%eax),%eax
  10494d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

       uint32_t res = kf->driver->rwrite(handle, src, size * count); //TODO it's not that easy... it shouldn't be size * count but instead count times size (for loop)
  104950:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104953:	8b 40 04             	mov    0x4(%eax),%eax
  104956:	8b 40 04             	mov    0x4(%eax),%eax
  104959:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10495c:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10495f:	8b 75 ec             	mov    -0x14(%ebp),%esi
  104962:	0f af 75 e8          	imul   -0x18(%ebp),%esi
  104966:	89 0c 24             	mov    %ecx,(%esp)
  104969:	89 54 24 04          	mov    %edx,0x4(%esp)
  10496d:	89 74 24 08          	mov    %esi,0x8(%esp)
  104971:	ff d0                	call   *%eax
  104973:	89 45 e0             	mov    %eax,-0x20(%ebp)

       if(res == RW_OK) {
  104976:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  10497d:	0f 85 1e 00 00 00    	jne    1049a1 <vfs_write+0xa1>
           handle->position += size * count;
  104983:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104986:	0f af 45 e8          	imul   -0x18(%ebp),%eax
  10498a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10498d:	8b 51 08             	mov    0x8(%ecx),%edx
  104990:	01 c2                	add    %eax,%edx
  104992:	89 51 08             	mov    %edx,0x8(%ecx)
           return RW_OK;
  104995:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  10499c:	e9 2c 00 00 00       	jmp    1049cd <vfs_write+0xcd>
       }

       if(res == RW_BLOCK) {
  1049a1:	81 7d e0 01 00 00 00 	cmpl   $0x1,-0x20(%ebp)
  1049a8:	0f 85 0c 00 00 00    	jne    1049ba <vfs_write+0xba>
           return RW_BLOCK;
  1049ae:	c7 45 f8 01 00 00 00 	movl   $0x1,-0x8(%ebp)
  1049b5:	e9 13 00 00 00       	jmp    1049cd <vfs_write+0xcd>
       }

       return RW_ERR_DRIVER;
  1049ba:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)
  1049c1:	e9 07 00 00 00       	jmp    1049cd <vfs_write+0xcd>
    }

    return RW_ERR_VFS;
  1049c6:	c7 45 f8 02 00 00 00 	movl   $0x2,-0x8(%ebp)
}
  1049cd:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1049d0:	83 c4 34             	add    $0x34,%esp
  1049d3:	5e                   	pop    %esi
  1049d4:	5d                   	pop    %ebp
  1049d5:	c3                   	ret    
  1049d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  1049dd:	00 00 00 

001049e0 <vfs_available>:

uint32_t vfs_available(struct res_handle* handle) {
  1049e0:	55                   	push   %ebp
  1049e1:	89 e5                	mov    %esp,%ebp
  1049e3:	83 ec 18             	sub    $0x18,%esp
  1049e6:	8b 45 08             	mov    0x8(%ebp),%eax
  1049e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(handle == 0) return 0;
  1049ec:	81 7d f8 00 00 00 00 	cmpl   $0x0,-0x8(%ebp)
  1049f3:	0f 85 0c 00 00 00    	jne    104a05 <vfs_available+0x25>
  1049f9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104a00:	e9 38 00 00 00       	jmp    104a3d <vfs_available+0x5d>

    if(handle->res_type == RES_KERNDRV) {
  104a05:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a08:	81 38 01 00 00 00    	cmpl   $0x1,(%eax)
  104a0e:	0f 85 22 00 00 00    	jne    104a36 <vfs_available+0x56>
        struct res_kfile* kf = (struct res_kfile*)handle->res_ptr;
  104a14:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a17:	8b 40 04             	mov    0x4(%eax),%eax
  104a1a:	89 45 f4             	mov    %eax,-0xc(%ebp)

        return kf->driver->available(handle);
  104a1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104a20:	8b 40 04             	mov    0x4(%eax),%eax
  104a23:	8b 40 10             	mov    0x10(%eax),%eax
  104a26:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104a29:	89 0c 24             	mov    %ecx,(%esp)
  104a2c:	ff d0                	call   *%eax
  104a2e:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104a31:	e9 07 00 00 00       	jmp    104a3d <vfs_available+0x5d>
    }

    return 0;
  104a36:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104a3d:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104a40:	83 c4 18             	add    $0x18,%esp
  104a43:	5d                   	pop    %ebp
  104a44:	c3                   	ret    
  104a45:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  104a4c:	00 00 00 00 

00104a50 <vfs_exists>:

uint32_t vfs_exists(char* path) {
  104a50:	55                   	push   %ebp
  104a51:	89 e5                	mov    %esp,%ebp
  104a53:	83 ec 18             	sub    $0x18,%esp
  104a56:	8b 45 08             	mov    0x8(%ebp),%eax
  104a59:	89 45 f8             	mov    %eax,-0x8(%ebp)
    if(vfs_get_node(path) != 0) return 1;
  104a5c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104a5f:	89 04 24             	mov    %eax,(%esp)
  104a62:	e8 29 fc ff ff       	call   104690 <vfs_get_node>
  104a67:	3d 00 00 00 00       	cmp    $0x0,%eax
  104a6c:	0f 84 0c 00 00 00    	je     104a7e <vfs_exists+0x2e>
  104a72:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
  104a79:	e9 07 00 00 00       	jmp    104a85 <vfs_exists+0x35>
    return 0;
  104a7e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104a85:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104a88:	83 c4 18             	add    $0x18,%esp
  104a8b:	5d                   	pop    %ebp
  104a8c:	c3                   	ret    
  104a8d:	0f 1f 00             	nopl   (%eax)

00104a90 <vfs_seek>:

void vfs_seek(struct res_handle* handle, uint32_t offset, uint32_t origin) {
  104a90:	55                   	push   %ebp
  104a91:	89 e5                	mov    %esp,%ebp
  104a93:	83 ec 0c             	sub    $0xc,%esp
  104a96:	8b 45 10             	mov    0x10(%ebp),%eax
  104a99:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  104a9c:	8b 55 08             	mov    0x8(%ebp),%edx
  104a9f:	89 55 fc             	mov    %edx,-0x4(%ebp)
  104aa2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104aa5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(origin == SEEK_SET) {
  104aa8:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  104aaf:	0f 85 09 00 00 00    	jne    104abe <vfs_seek+0x2e>
        handle->position = offset;
  104ab5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104ab8:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104abb:	89 41 08             	mov    %eax,0x8(%ecx)
    }

    if(origin == SEEK_CUR) {
  104abe:	81 7d f4 01 00 00 00 	cmpl   $0x1,-0xc(%ebp)
  104ac5:	0f 85 0e 00 00 00    	jne    104ad9 <vfs_seek+0x49>
        handle->position += offset;
  104acb:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104ace:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  104ad1:	8b 51 08             	mov    0x8(%ecx),%edx
  104ad4:	01 c2                	add    %eax,%edx
  104ad6:	89 51 08             	mov    %edx,0x8(%ecx)
    }
}
  104ad9:	83 c4 0c             	add    $0xc,%esp
  104adc:	5d                   	pop    %ebp
  104add:	c3                   	ret    
  104ade:	66 90                	xchg   %ax,%ax

00104ae0 <vfs_init_root>:

void vfs_init_root() {
  104ae0:	55                   	push   %ebp
  104ae1:	89 e5                	mov    %esp,%ebp
    if(root == 0) {
  104ae3:	83 ec 18             	sub    $0x18,%esp
  104ae6:	81 3d 40 94 10 00 00 	cmpl   $0x0,0x109440
  104aed:	00 00 00 
  104af0:	0f 85 6f 00 00 00    	jne    104b65 <vfs_init_root+0x85>
  104af6:	b8 10 01 00 00       	mov    $0x110,%eax
        root = malloc(sizeof(struct res_node));
  104afb:	c7 04 24 10 01 00 00 	movl   $0x110,(%esp)
  104b02:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104b05:	e8 46 ed ff ff       	call   103850 <malloc>
  104b0a:	a3 40 94 10 00       	mov    %eax,0x109440
        root->next = 0;
  104b0f:	a1 40 94 10 00       	mov    0x109440,%eax
  104b14:	c7 80 08 01 00 00 00 	movl   $0x0,0x108(%eax)
  104b1b:	00 00 00 
        root->parent = 0;
  104b1e:	a1 40 94 10 00       	mov    0x109440,%eax
  104b23:	c7 80 0c 01 00 00 00 	movl   $0x0,0x10c(%eax)
  104b2a:	00 00 00 
        strcpy(root->name, "$");
  104b2d:	a1 40 94 10 00       	mov    0x109440,%eax
  104b32:	89 e1                	mov    %esp,%ecx
  104b34:	89 01                	mov    %eax,(%ecx)
  104b36:	c7 41 04 7e 74 10 00 	movl   $0x10747e,0x4(%ecx)
  104b3d:	e8 1e f6 ff ff       	call   104160 <strcpy>
        root->res_ptr = 0;
  104b42:	8b 0d 40 94 10 00    	mov    0x109440,%ecx
  104b48:	c7 81 04 01 00 00 00 	movl   $0x0,0x104(%ecx)
  104b4f:	00 00 00 
        root->res_type = RES_SUBDIR;
  104b52:	8b 0d 40 94 10 00    	mov    0x109440,%ecx
  104b58:	c7 81 00 01 00 00 00 	movl   $0x0,0x100(%ecx)
  104b5f:	00 00 00 
  104b62:	89 45 f8             	mov    %eax,-0x8(%ebp)
    }
}
  104b65:	83 c4 18             	add    $0x18,%esp
  104b68:	5d                   	pop    %ebp
  104b69:	c3                   	ret    
  104b6a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104b70 <vfs_debug_ls>:

void vfs_debug_ls(char* path) {
  104b70:	55                   	push   %ebp
  104b71:	89 e5                	mov    %esp,%ebp
  104b73:	56                   	push   %esi
  104b74:	83 ec 24             	sub    $0x24,%esp
  104b77:	8b 45 08             	mov    0x8(%ebp),%eax
  104b7a:	89 45 f8             	mov    %eax,-0x8(%ebp)
    static struct res_node* node;
    node = vfs_get_node(path);
  104b7d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104b80:	89 04 24             	mov    %eax,(%esp)
  104b83:	e8 08 fb ff ff       	call   104690 <vfs_get_node>
  104b88:	a3 54 94 10 00       	mov    %eax,0x109454
    node = node->res_ptr;
  104b8d:	a1 54 94 10 00       	mov    0x109454,%eax
  104b92:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104b98:	a3 54 94 10 00       	mov    %eax,0x109454

    while(node != 0) {
  104b9d:	81 3d 54 94 10 00 00 	cmpl   $0x0,0x109454
  104ba4:	00 00 00 
  104ba7:	0f 84 90 00 00 00    	je     104c3d <vfs_debug_ls+0xcd>
  104bad:	8d 05 80 74 10 00    	lea    0x107480,%eax
        char* type = "N/A";
  104bb3:	89 45 f4             	mov    %eax,-0xc(%ebp)

        if(node->res_type == RES_SUBDIR) {
  104bb6:	a1 54 94 10 00       	mov    0x109454,%eax
  104bbb:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  104bc2:	00 00 00 
  104bc5:	0f 85 09 00 00 00    	jne    104bd4 <vfs_debug_ls+0x64>
  104bcb:	8d 05 84 74 10 00    	lea    0x107484,%eax
            type = "DIR";
  104bd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        }

        if(node->res_type == RES_KERNDRV) {
  104bd4:	a1 54 94 10 00       	mov    0x109454,%eax
  104bd9:	81 b8 00 01 00 00 01 	cmpl   $0x1,0x100(%eax)
  104be0:	00 00 00 
  104be3:	0f 85 14 00 00 00    	jne    104bfd <vfs_debug_ls+0x8d>
            type = ((struct res_kfile*)node->res_ptr)->driver->drvname;
  104be9:	a1 54 94 10 00       	mov    0x109454,%eax
  104bee:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104bf4:	8b 40 04             	mov    0x4(%eax),%eax
  104bf7:	8b 40 18             	mov    0x18(%eax),%eax
  104bfa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  104bfd:	8d 05 88 74 10 00    	lea    0x107488,%eax
        }

        kprintf("LS %s: %s [%s]\n", path, node->name, type);
  104c03:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104c06:	8b 15 54 94 10 00    	mov    0x109454,%edx
  104c0c:	8b 75 f4             	mov    -0xc(%ebp),%esi
  104c0f:	89 04 24             	mov    %eax,(%esp)
  104c12:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104c16:	89 54 24 08          	mov    %edx,0x8(%esp)
  104c1a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  104c1e:	e8 2d b9 ff ff       	call   100550 <kprintf>

        node = node->next;
  104c23:	8b 0d 54 94 10 00    	mov    0x109454,%ecx
  104c29:	8b 89 08 01 00 00    	mov    0x108(%ecx),%ecx
  104c2f:	89 0d 54 94 10 00    	mov    %ecx,0x109454
    }
  104c35:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104c38:	e9 60 ff ff ff       	jmp    104b9d <vfs_debug_ls+0x2d>
}
  104c3d:	83 c4 24             	add    $0x24,%esp
  104c40:	5e                   	pop    %esi
  104c41:	5d                   	pop    %ebp
  104c42:	c3                   	ret    
  104c43:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  104c4a:	84 00 00 00 00 00 

00104c50 <vfs_find_node>:

struct res_node* root = 0;
struct res_node* current = 0;
struct res_node* temp = 0;

static struct res_node* vfs_find_node(struct res_node* parent, char* name) {
  104c50:	55                   	push   %ebp
  104c51:	89 e5                	mov    %esp,%ebp
  104c53:	83 ec 18             	sub    $0x18,%esp
  104c56:	8b 45 0c             	mov    0xc(%ebp),%eax
  104c59:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104c5c:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104c5f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_type == RES_SUBDIR) {
  104c62:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c65:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  104c6c:	00 00 00 
  104c6f:	0f 85 57 00 00 00    	jne    104ccc <vfs_find_node+0x7c>
        struct res_node* ptr = parent->res_ptr;
  104c75:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104c78:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104c7e:	89 45 f0             	mov    %eax,-0x10(%ebp)

        while(ptr != 0) {
  104c81:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104c88:	0f 84 39 00 00 00    	je     104cc7 <vfs_find_node+0x77>
            if(strcmp(name, ptr->name) == 0) {
  104c8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104c91:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104c94:	89 e2                	mov    %esp,%edx
  104c96:	89 4a 04             	mov    %ecx,0x4(%edx)
  104c99:	89 02                	mov    %eax,(%edx)
  104c9b:	e8 d0 f3 ff ff       	call   104070 <strcmp>
  104ca0:	3d 00 00 00 00       	cmp    $0x0,%eax
  104ca5:	0f 85 0b 00 00 00    	jne    104cb6 <vfs_find_node+0x66>
                return ptr;
  104cab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104cae:	89 45 fc             	mov    %eax,-0x4(%ebp)
  104cb1:	e9 1d 00 00 00       	jmp    104cd3 <vfs_find_node+0x83>
            }

            ptr = ptr->next;
  104cb6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104cb9:	8b 80 08 01 00 00    	mov    0x108(%eax),%eax
  104cbf:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
  104cc2:	e9 ba ff ff ff       	jmp    104c81 <vfs_find_node+0x31>
    }
  104cc7:	e9 00 00 00 00       	jmp    104ccc <vfs_find_node+0x7c>

    return 0;
  104ccc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
}
  104cd3:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104cd6:	83 c4 18             	add    $0x18,%esp
  104cd9:	5d                   	pop    %ebp
  104cda:	c3                   	ret    
  104cdb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00104ce0 <vfs_insert_node>:

static int vfs_insert_node(struct res_node* parent, struct res_node* child) {
  104ce0:	55                   	push   %ebp
  104ce1:	89 e5                	mov    %esp,%ebp
  104ce3:	83 ec 0c             	sub    $0xc,%esp
  104ce6:	8b 45 0c             	mov    0xc(%ebp),%eax
  104ce9:	8b 4d 08             	mov    0x8(%ebp),%ecx
  104cec:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  104cef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(parent->res_ptr == 0) {
  104cf2:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104cf5:	81 b8 04 01 00 00 00 	cmpl   $0x0,0x104(%eax)
  104cfc:	00 00 00 
  104cff:	0f 85 0d 00 00 00    	jne    104d12 <vfs_insert_node+0x32>
        parent->res_type = RES_SUBDIR;
  104d05:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d08:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%eax)
  104d0f:	00 00 00 
    }

    if(parent->res_type == RES_SUBDIR) {
  104d12:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d15:	81 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%eax)
  104d1c:	00 00 00 
  104d1f:	0f 85 36 00 00 00    	jne    104d5b <vfs_insert_node+0x7b>
        child->next = parent->res_ptr;
  104d25:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d28:	8b 80 04 01 00 00    	mov    0x104(%eax),%eax
  104d2e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104d31:	89 81 08 01 00 00    	mov    %eax,0x108(%ecx)
        child->parent = parent;
  104d37:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104d3a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  104d3d:	89 81 0c 01 00 00    	mov    %eax,0x10c(%ecx)
        parent->res_ptr = child;
  104d43:	8b 45 f4             	mov    -0xc(%ebp),%eax
  104d46:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  104d49:	89 81 04 01 00 00    	mov    %eax,0x104(%ecx)

        return 0;
  104d4f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  104d56:	e9 07 00 00 00       	jmp    104d62 <vfs_insert_node+0x82>
    }

    return 1;
  104d5b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
}
  104d62:	8b 45 fc             	mov    -0x4(%ebp),%eax
  104d65:	83 c4 0c             	add    $0xc,%esp
  104d68:	5d                   	pop    %ebp
  104d69:	c3                   	ret    
  104d6a:	66 90                	xchg   %ax,%ax
  104d6c:	66 90                	xchg   %ax,%ax
  104d6e:	66 90                	xchg   %ax,%ax

00104d70 <vmm_get_current_pagedir>:
	}

	vmm_unmap(pagedir_ptr);
}

uint32_t vmm_get_current_pagedir(void) {
  104d70:	55                   	push   %ebp
  104d71:	89 e5                	mov    %esp,%ebp
	return active_pagedir;
  104d73:	a1 58 94 10 00       	mov    0x109458,%eax
  104d78:	5d                   	pop    %ebp
  104d79:	c3                   	ret    
  104d7a:	66 0f 1f 44 00 00    	nopw   0x0(%eax,%eax,1)

00104d80 <vmm_fork_current>:
}

uint32_t vmm_fork_current(void) {
  104d80:	55                   	push   %ebp
  104d81:	89 e5                	mov    %esp,%ebp
  104d83:	56                   	push   %esi
  104d84:	83 ec 34             	sub    $0x34,%esp
  104d87:	8d 45 f8             	lea    -0x8(%ebp),%eax
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  104d8a:	89 04 24             	mov    %eax,(%esp)
  104d8d:	e8 ce 00 00 00       	call   104e60 <vmm_create_vpdraw>
  104d92:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  104d95:	c7 45 f0 00 10 40 20 	movl   $0x20401000,-0x10(%ebp)
  104d9c:	81 7d f0 00 f0 ff ff 	cmpl   $0xfffff000,-0x10(%ebp)
  104da3:	0f 83 98 00 00 00    	jae    104e41 <vmm_fork_current+0xc1>
		if (active_pagetables[i >> 12] & PT_PRESENT) {
  104da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104dac:	c1 e8 0c             	shr    $0xc,%eax
  104daf:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  104db5:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  104db8:	25 01 00 00 00       	and    $0x1,%eax
  104dbd:	3d 00 00 00 00       	cmp    $0x0,%eax
  104dc2:	0f 84 64 00 00 00    	je     104e2c <vmm_fork_current+0xac>
  104dc8:	8d 45 f4             	lea    -0xc(%ebp),%eax
			void* newp = vmm_alloc_user(&paddr);
  104dcb:	89 04 24             	mov    %eax,(%esp)
  104dce:	e8 4d 03 00 00       	call   105120 <vmm_alloc_user>
  104dd3:	b9 00 00 00 00       	mov    $0x0,%ecx
  104dd8:	ba 00 10 00 00       	mov    $0x1000,%edx
  104ddd:	89 45 e8             	mov    %eax,-0x18(%ebp)

			memcpy(newp, (void*) i, 0x1000);
  104de0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104de3:	8b 75 f0             	mov    -0x10(%ebp),%esi
  104de6:	89 04 24             	mov    %eax,(%esp)
  104de9:	89 74 24 04          	mov    %esi,0x4(%esp)
  104ded:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  104df4:	00 
  104df5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  104df8:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  104dfb:	e8 20 f1 ff ff       	call   103f20 <memcpy>
			map_address_context(pdptr, i, paddr, 0);
  104e00:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104e03:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104e06:	8b 55 f4             	mov    -0xc(%ebp),%edx
  104e09:	89 04 24             	mov    %eax,(%esp)
  104e0c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  104e10:	89 54 24 08          	mov    %edx,0x8(%esp)
  104e14:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  104e1b:	00 
  104e1c:	e8 4f 03 00 00       	call   105170 <map_address_context>

			vmm_unmap(newp);
  104e21:	8b 45 e8             	mov    -0x18(%ebp),%eax
  104e24:	89 04 24             	mov    %eax,(%esp)
  104e27:	e8 d4 03 00 00       	call   105200 <vmm_unmap>
		}

	}
  104e2c:	e9 00 00 00 00       	jmp    104e31 <vmm_fork_current+0xb1>

uint32_t vmm_fork_current(void) {
	uint32_t phys_pagedir, paddr, i;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);

	for (i = PROGRAM_BOTTOM; i < 0xFFFFF000; i += 0x1000) {
  104e31:	8b 45 f0             	mov    -0x10(%ebp),%eax
  104e34:	05 00 10 00 00       	add    $0x1000,%eax
  104e39:	89 45 f0             	mov    %eax,-0x10(%ebp)
  104e3c:	e9 5b ff ff ff       	jmp    104d9c <vmm_fork_current+0x1c>
			vmm_unmap(newp);
		}

	}

	vmm_free_pdptr(pdptr);
  104e41:	8b 45 ec             	mov    -0x14(%ebp),%eax
  104e44:	89 04 24             	mov    %eax,(%esp)
  104e47:	e8 24 04 00 00       	call   105270 <vmm_free_pdptr>

	return phys_pagedir;
  104e4c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  104e4f:	83 c4 34             	add    $0x34,%esp
  104e52:	5e                   	pop    %esi
  104e53:	5d                   	pop    %ebp
  104e54:	c3                   	ret    
  104e55:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
  104e5c:	00 00 00 00 

00104e60 <vmm_create_vpdraw>:
uint32_t* active_pagetables = (uint32_t*) (ACTIVE_PAGETBL_VADDR);
struct vmm_context* active_context = (void*) (ACTIVE_CONTEXT_VADDR);

uint32_t active_pagedir = 0;

static uint32_t* vmm_create_vpdraw(uint32_t* pagedir) {
  104e60:	55                   	push   %ebp
  104e61:	89 e5                	mov    %esp,%ebp
  104e63:	53                   	push   %ebx
  104e64:	57                   	push   %edi
  104e65:	56                   	push   %esi
  104e66:	83 ec 4c             	sub    $0x4c,%esp
  104e69:	8b 45 08             	mov    0x8(%ebp),%eax
  104e6c:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  104e6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t phys_context = 0;
  104e72:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct vmm_context* context = vmm_alloc(&phys_context);
  104e79:	89 0c 24             	mov    %ecx,(%esp)
  104e7c:	e8 6f 05 00 00       	call   1053f0 <vmm_alloc>
  104e81:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  104e84:	89 45 e8             	mov    %eax,-0x18(%ebp)

	uint32_t phys_pagedir = 0;
  104e87:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	context->pagedir = vmm_alloc(&phys_pagedir);
  104e8e:	89 0c 24             	mov    %ecx,(%esp)
  104e91:	e8 5a 05 00 00       	call   1053f0 <vmm_alloc>
  104e96:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  104e99:	89 01                	mov    %eax,(%ecx)
	if (pagedir != 0)
  104e9b:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  104ea2:	0f 84 08 00 00 00    	je     104eb0 <vmm_create_vpdraw+0x50>
		*pagedir = phys_pagedir;
  104ea8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  104eab:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  104eae:	89 01                	mov    %eax,(%ecx)
  104eb0:	b8 00 00 00 00       	mov    $0x0,%eax

	uint32_t* pagedir_ptr = vmm_alloc(0);
  104eb5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  104ebc:	89 45 c8             	mov    %eax,-0x38(%ebp)
  104ebf:	e8 2c 05 00 00       	call   1053f0 <vmm_alloc>
  104ec4:	89 45 e0             	mov    %eax,-0x20(%ebp)
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  104ec7:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  104ece:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  104ed5:	0f 83 25 01 00 00    	jae    105000 <vmm_create_vpdraw+0x1a0>
  104edb:	8d 45 dc             	lea    -0x24(%ebp),%eax
		pagedir_ptr[i] = (uint32_t) vmm_alloc(&paddr);
  104ede:	89 04 24             	mov    %eax,(%esp)
  104ee1:	e8 0a 05 00 00       	call   1053f0 <vmm_alloc>
  104ee6:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104ee9:	8b 55 e0             	mov    -0x20(%ebp),%edx
  104eec:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i < PMEM_TABLES) {
  104eef:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  104ef6:	0f 83 4d 00 00 00    	jae    104f49 <vmm_create_vpdraw+0xe9>
			vmm_free((void*) (pagedir_ptr[i]));
  104efc:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104eff:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  104f02:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  104f05:	89 04 24             	mov    %eax,(%esp)
  104f08:	e8 33 05 00 00       	call   105440 <vmm_free>
  104f0d:	b8 00 00 00 00       	mov    $0x0,%eax
			map_address_active(pagedir_ptr[i], kernel_pagetables[i], 0); //Can reuse pagedir_ptr[i] cause of vmm_free
  104f12:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104f15:	8b 55 e0             	mov    -0x20(%ebp),%edx
  104f18:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  104f1b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  104f1e:	8b 14 95 90 94 18 00 	mov    0x189490(,%edx,4),%edx
  104f25:	89 0c 24             	mov    %ecx,(%esp)
  104f28:	89 54 24 04          	mov    %edx,0x4(%esp)
  104f2c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  104f33:	00 
  104f34:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  104f37:	e8 84 05 00 00       	call   1054c0 <map_address_active>
			paddr = kernel_pagetables[i];
  104f3c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104f3f:	8b 04 85 90 94 18 00 	mov    0x189490(,%eax,4),%eax
  104f46:	89 45 dc             	mov    %eax,-0x24(%ebp)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;
  104f49:	8b 45 dc             	mov    -0x24(%ebp),%eax
  104f4c:	0d 01 00 00 00       	or     $0x1,%eax
  104f51:	0d 02 00 00 00       	or     $0x2,%eax
  104f56:	0d 04 00 00 00       	or     $0x4,%eax
  104f5b:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104f5e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  104f61:	8b 12                	mov    (%edx),%edx
  104f63:	89 04 8a             	mov    %eax,(%edx,%ecx,4)

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
  104f66:	81 7d d8 80 00 00 00 	cmpl   $0x80,-0x28(%ebp)
  104f6d:	0f 82 78 00 00 00    	jb     104feb <vmm_create_vpdraw+0x18b>
			for (i2 = 0; i2 < 1024; i2++) {
  104f73:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  104f7a:	81 7d d4 00 04 00 00 	cmpl   $0x400,-0x2c(%ebp)
  104f81:	0f 83 5f 00 00 00    	jae    104fe6 <vmm_create_vpdraw+0x186>
  104f87:	b8 04 00 00 00       	mov    $0x4,%eax
  104f8c:	b9 00 00 00 00       	mov    $0x0,%ecx
  104f91:	ba 00 02 00 00       	mov    $0x200,%edx
				uint32_t vaddr = (i << 22) + (i2 << 12);
  104f96:	8b 75 d8             	mov    -0x28(%ebp),%esi
  104f99:	c1 e6 16             	shl    $0x16,%esi
  104f9c:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  104f9f:	c1 e7 0c             	shl    $0xc,%edi
  104fa2:	01 fe                	add    %edi,%esi
  104fa4:	89 75 d0             	mov    %esi,-0x30(%ebp)

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
  104fa7:	81 7d d0 00 00 80 00 	cmpl   $0x800000,-0x30(%ebp)
  104fae:	0f 97 c3             	seta   %bl
  104fb1:	84 db                	test   %bl,%bl
  104fb3:	0f 44 d1             	cmove  %ecx,%edx
  104fb6:	81 7d d0 00 10 40 20 	cmpl   $0x20401000,-0x30(%ebp)
  104fbd:	0f 97 c3             	seta   %bl
  104fc0:	84 db                	test   %bl,%bl
  104fc2:	0f 44 c1             	cmove  %ecx,%eax
  104fc5:	09 c2                	or     %eax,%edx
  104fc7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104fca:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  104fcd:	8b 75 e0             	mov    -0x20(%ebp),%esi
  104fd0:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  104fd3:	89 14 81             	mov    %edx,(%ecx,%eax,4)
		}

		context->pagedir[i] = paddr | PD_PRESENT | PD_WRITE | PD_PUBLIC;

		if (i >= PMEM_TABLES) { //don't override kernel tables ;)
			for (i2 = 0; i2 < 1024; i2++) {
  104fd6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  104fd9:	05 01 00 00 00       	add    $0x1,%eax
  104fde:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  104fe1:	e9 94 ff ff ff       	jmp    104f7a <vmm_create_vpdraw+0x11a>

				((uint32_t*) (pagedir_ptr[i]))[i2] = (
						(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
  104fe6:	e9 00 00 00 00       	jmp    104feb <vmm_create_vpdraw+0x18b>
	}
  104feb:	e9 00 00 00 00       	jmp    104ff0 <vmm_create_vpdraw+0x190>
		*pagedir = phys_pagedir;

	uint32_t* pagedir_ptr = vmm_alloc(0);
	uint32_t paddr, i, i2;

	for (i = 0; i < 1024; i++) {
  104ff0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  104ff3:	05 01 00 00 00       	add    $0x1,%eax
  104ff8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  104ffb:	e9 ce fe ff ff       	jmp    104ece <vmm_create_vpdraw+0x6e>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  105000:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  105007:	81 7d d8 00 04 00 00 	cmpl   $0x400,-0x28(%ebp)
  10500e:	0f 83 58 00 00 00    	jae    10506c <vmm_create_vpdraw+0x20c>
  105014:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
  105019:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  10501c:	8b 55 e8             	mov    -0x18(%ebp),%edx
  10501f:	8b 12                	mov    (%edx),%edx
  105021:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105024:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  10502a:	89 4d dc             	mov    %ecx,-0x24(%ebp)
		map_address_context(pagedir_ptr,
  10502d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105030:	8b 15 c4 61 10 00    	mov    0x1061c4,%edx
  105036:	8b 75 d8             	mov    -0x28(%ebp),%esi
  105039:	c1 e6 0c             	shl    $0xc,%esi
  10503c:	01 f2                	add    %esi,%edx
  10503e:	8b 75 dc             	mov    -0x24(%ebp),%esi
  105041:	89 0c 24             	mov    %ecx,(%esp)
  105044:	89 54 24 04          	mov    %edx,0x4(%esp)
  105048:	89 74 24 08          	mov    %esi,0x8(%esp)
  10504c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105053:	00 
  105054:	89 45 c0             	mov    %eax,-0x40(%ebp)
  105057:	e8 14 01 00 00       	call   105170 <map_address_context>
						| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
			}
		}
	}

	for (i = 0; i < 1024; i++) {
  10505c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  10505f:	05 01 00 00 00       	add    $0x1,%eax
  105064:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105067:	e9 9b ff ff ff       	jmp    105007 <vmm_create_vpdraw+0x1a7>
  10506c:	b8 00 00 00 00       	mov    $0x0,%eax
		paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(pagedir_ptr,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
  105071:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  105074:	8b 15 c8 61 10 00    	mov    0x1061c8,%edx
  10507a:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10507d:	89 0c 24             	mov    %ecx,(%esp)
  105080:	89 54 24 04          	mov    %edx,0x4(%esp)
  105084:	89 74 24 08          	mov    %esi,0x8(%esp)
  105088:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  10508f:	00 
  105090:	89 45 bc             	mov    %eax,-0x44(%ebp)
  105093:	e8 d8 00 00 00       	call   105170 <map_address_context>
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105098:	c7 45 d8 00 10 00 00 	movl   $0x1000,-0x28(%ebp)
  10509f:	8d 05 00 a0 18 00    	lea    0x18a000,%eax
  1050a5:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  1050a8:	0f 83 39 00 00 00    	jae    1050e7 <vmm_create_vpdraw+0x287>
  1050ae:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(pagedir_ptr, i, i, 0);
  1050b3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  1050b6:	8b 55 d8             	mov    -0x28(%ebp),%edx
  1050b9:	8b 75 d8             	mov    -0x28(%ebp),%esi
  1050bc:	89 0c 24             	mov    %ecx,(%esp)
  1050bf:	89 54 24 04          	mov    %edx,0x4(%esp)
  1050c3:	89 74 24 08          	mov    %esi,0x8(%esp)
  1050c7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  1050ce:	00 
  1050cf:	89 45 b8             	mov    %eax,-0x48(%ebp)
  1050d2:	e8 99 00 00 00       	call   105170 <map_address_context>
	}

	map_address_context(pagedir_ptr, (uint32_t) active_context, phys_context,
			0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  1050d7:	8b 45 d8             	mov    -0x28(%ebp),%eax
  1050da:	05 00 10 00 00       	add    $0x1000,%eax
  1050df:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1050e2:	e9 b8 ff ff ff       	jmp    10509f <vmm_create_vpdraw+0x23f>
		map_address_context(pagedir_ptr, i, i, 0);
	}

	uint32_t* pd_ptr = context->pagedir;
  1050e7:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1050ea:	8b 00                	mov    (%eax),%eax
  1050ec:	89 45 cc             	mov    %eax,-0x34(%ebp)
	context->pagedir = (uint32_t*) phys_pagedir;
  1050ef:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1050f2:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  1050f5:	89 01                	mov    %eax,(%ecx)

	vmm_unmap(pd_ptr);
  1050f7:	8b 45 cc             	mov    -0x34(%ebp),%eax
  1050fa:	89 04 24             	mov    %eax,(%esp)
  1050fd:	e8 fe 00 00 00       	call   105200 <vmm_unmap>
	vmm_unmap(context);
  105102:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105105:	89 04 24             	mov    %eax,(%esp)
  105108:	e8 f3 00 00 00       	call   105200 <vmm_unmap>

	return pagedir_ptr;
  10510d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  105110:	83 c4 4c             	add    $0x4c,%esp
  105113:	5e                   	pop    %esi
  105114:	5f                   	pop    %edi
  105115:	5b                   	pop    %ebx
  105116:	5d                   	pop    %ebp
  105117:	c3                   	ret    
  105118:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  10511f:	00 

00105120 <vmm_alloc_user>:

void* vmm_alloc_ucont(uint32_t cont) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
}

void* vmm_alloc_user(uint32_t* retpaddr) {
  105120:	55                   	push   %ebp
  105121:	89 e5                	mov    %esp,%ebp
  105123:	56                   	push   %esi
  105124:	83 ec 24             	sub    $0x24,%esp
  105127:	8b 45 08             	mov    0x8(%ebp),%eax
  10512a:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  10512f:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  105134:	be 01 00 00 00       	mov    $0x1,%esi
  105139:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
  10513c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10513f:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  105146:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  10514d:	ff 
  10514e:	89 44 24 08          	mov    %eax,0x8(%esp)
  105152:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105159:	00 
  10515a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10515d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105160:	89 55 ec             	mov    %edx,-0x14(%ebp)
  105163:	e8 b8 04 00 00       	call   105620 <vmm_alloc_in_range>
  105168:	83 c4 24             	add    $0x24,%esp
  10516b:	5e                   	pop    %esi
  10516c:	5d                   	pop    %ebp
  10516d:	c3                   	ret    
  10516e:	66 90                	xchg   %ax,%ax

00105170 <map_address_context>:
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}

void map_address_context(uint32_t* pagedir, uint32_t vaddr, uint32_t paddr,
		uint32_t flags) {
  105170:	55                   	push   %ebp
  105171:	89 e5                	mov    %esp,%ebp
  105173:	56                   	push   %esi
  105174:	83 ec 18             	sub    $0x18,%esp
  105177:	8b 45 14             	mov    0x14(%ebp),%eax
  10517a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10517d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105180:	8b 75 08             	mov    0x8(%ebp),%esi
  105183:	89 75 f8             	mov    %esi,-0x8(%ebp)
  105186:	89 55 f4             	mov    %edx,-0xc(%ebp)
  105189:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10518c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32_t pd_entry = vaddr >> 22;
  10518f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105192:	c1 e8 16             	shr    $0x16,%eax
  105195:	89 45 e8             	mov    %eax,-0x18(%ebp)
	uint32_t pt_entry = (vaddr >> 12) % 1024;
  105198:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10519b:	c1 e8 0c             	shr    $0xc,%eax
  10519e:	25 ff 03 00 00       	and    $0x3ff,%eax
  1051a3:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry] = (paddr
  1051a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1051a9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1051ae:	0d 01 00 00 00       	or     $0x1,%eax
  1051b3:	0d 02 00 00 00       	or     $0x2,%eax
  1051b8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1051bb:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  1051c1:	09 c8                	or     %ecx,%eax
  1051c3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1051c6:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1051c9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1051cc:	8b 14 96             	mov    (%esi,%edx,4),%edx
  1051cf:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  1051d5:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  1051d8:	81 e1 04 02 00 00    	and    $0x204,%ecx
  1051de:	09 c8                	or     %ecx,%eax
  1051e0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  1051e3:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1051e6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  1051e9:	8b 14 96             	mov    (%esi,%edx,4),%edx
  1051ec:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  1051f2:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}
  1051f5:	83 c4 18             	add    $0x18,%esp
  1051f8:	5e                   	pop    %esi
  1051f9:	5d                   	pop    %ebp
  1051fa:	c3                   	ret    
  1051fb:	0f 1f 44 00 00       	nopl   0x0(%eax,%eax,1)

00105200 <vmm_unmap>:
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

void vmm_unmap(void* p_vaddr) { //USE ONLY IF YOU KNOW WHAT YOU DO. POTENTIAL MEMORY LEAK!
  105200:	55                   	push   %ebp
  105201:	89 e5                	mov    %esp,%ebp
  105203:	83 ec 08             	sub    $0x8,%esp
  105206:	8b 45 08             	mov    0x8(%ebp),%eax
  105209:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  10520c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10520f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  105212:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105215:	c1 e8 0c             	shr    $0xc,%eax
  105218:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  10521e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105221:	25 01 02 00 00       	and    $0x201,%eax
  105226:	3d 01 02 00 00       	cmp    $0x201,%eax
  10522b:	0f 85 2e 00 00 00    	jne    10525f <vmm_unmap+0x5f>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  105231:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105234:	c1 e8 0c             	shr    $0xc,%eax
  105237:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  10523d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105240:	25 04 00 00 00       	and    $0x4,%eax
  105245:	0d 00 02 00 00       	or     $0x200,%eax
  10524a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  10524d:	c1 e9 0c             	shr    $0xc,%ecx
  105250:	8b 15 c4 61 10 00    	mov    0x1061c4,%edx
  105256:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  105259:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10525c:	0f 01 38             	invlpg (%eax)
	}
}
  10525f:	83 c4 08             	add    $0x8,%esp
  105262:	5d                   	pop    %ebp
  105263:	c3                   	ret    
  105264:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10526b:	00 00 00 00 00 

00105270 <vmm_free_pdptr>:
	vmm_unmap(context);

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
  105270:	55                   	push   %ebp
  105271:	89 e5                	mov    %esp,%ebp
  105273:	83 ec 18             	sub    $0x18,%esp
  105276:	8b 45 08             	mov    0x8(%ebp),%eax
  105279:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (uint32_t i = 0; i < 1024; i++) {
  10527c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  105283:	81 7d f8 00 04 00 00 	cmpl   $0x400,-0x8(%ebp)
  10528a:	0f 83 21 00 00 00    	jae    1052b1 <vmm_free_pdptr+0x41>
		vmm_unmap((void*) pagedir_ptr[i]);
  105290:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105293:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  105296:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105299:	89 04 24             	mov    %eax,(%esp)
  10529c:	e8 5f ff ff ff       	call   105200 <vmm_unmap>

	return pagedir_ptr;
}

static void vmm_free_pdptr(uint32_t* pagedir_ptr) {
	for (uint32_t i = 0; i < 1024; i++) {
  1052a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1052a4:	05 01 00 00 00       	add    $0x1,%eax
  1052a9:	89 45 f8             	mov    %eax,-0x8(%ebp)
  1052ac:	e9 d2 ff ff ff       	jmp    105283 <vmm_free_pdptr+0x13>
		vmm_unmap((void*) pagedir_ptr[i]);
	}

	vmm_unmap(pagedir_ptr);
  1052b1:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1052b4:	89 04 24             	mov    %eax,(%esp)
  1052b7:	e8 44 ff ff ff       	call   105200 <vmm_unmap>
}
  1052bc:	83 c4 18             	add    $0x18,%esp
  1052bf:	5d                   	pop    %ebp
  1052c0:	c3                   	ret    
  1052c1:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  1052c8:	0f 1f 84 00 00 00 00 
  1052cf:	00 

001052d0 <vmm_create_pagedir>:
	vmm_free_pdptr(pdptr);

	return phys_pagedir;
}

uint32_t vmm_create_pagedir() {
  1052d0:	55                   	push   %ebp
  1052d1:	89 e5                	mov    %esp,%ebp
  1052d3:	83 ec 18             	sub    $0x18,%esp
  1052d6:	8d 45 fc             	lea    -0x4(%ebp),%eax
	uint32_t phys_pagedir;
	uint32_t* pdptr = vmm_create_vpdraw(&phys_pagedir);
  1052d9:	89 04 24             	mov    %eax,(%esp)
  1052dc:	e8 7f fb ff ff       	call   104e60 <vmm_create_vpdraw>
  1052e1:	89 45 f8             	mov    %eax,-0x8(%ebp)
	vmm_free_pdptr(pdptr);
  1052e4:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1052e7:	89 04 24             	mov    %eax,(%esp)
  1052ea:	e8 81 ff ff ff       	call   105270 <vmm_free_pdptr>

	return phys_pagedir;
  1052ef:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1052f2:	83 c4 18             	add    $0x18,%esp
  1052f5:	5d                   	pop    %ebp
  1052f6:	c3                   	ret    
  1052f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1052fe:	00 00 

00105300 <vmm_resolve>:
}

uint32_t vmm_resolve(void* vaddr) {
  105300:	55                   	push   %ebp
  105301:	89 e5                	mov    %esp,%ebp
  105303:	50                   	push   %eax
  105304:	8b 45 08             	mov    0x8(%ebp),%eax
  105307:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return active_pagetables[(uint32_t) vaddr >> 12] & 0xFFFFF000;
  10530a:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10530d:	c1 e8 0c             	shr    $0xc,%eax
  105310:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  105316:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105319:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10531e:	83 c4 04             	add    $0x4,%esp
  105321:	5d                   	pop    %ebp
  105322:	c3                   	ret    
  105323:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%eax,%eax,1)
  10532a:	84 00 00 00 00 00 

00105330 <vmm_resolve_ppd>:
}

uint32_t vmm_resolve_ppd(uint32_t pdir, void* vaddr) {
  105330:	55                   	push   %ebp
  105331:	89 e5                	mov    %esp,%ebp
  105333:	83 ec 38             	sub    $0x38,%esp
  105336:	8b 45 0c             	mov    0xc(%ebp),%eax
  105339:	8b 4d 08             	mov    0x8(%ebp),%ecx
  10533c:	ba 00 00 00 00       	mov    $0x0,%edx
  105341:	89 4d fc             	mov    %ecx,-0x4(%ebp)
  105344:	89 45 f8             	mov    %eax,-0x8(%ebp)
	uint32_t pd_entry = (uint32_t) vaddr >> 22;
  105347:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10534a:	c1 e8 16             	shr    $0x16,%eax
  10534d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32_t pt_entry = ((uint32_t) vaddr >> 12) % 1024;
  105350:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105353:	c1 e8 0c             	shr    $0xc,%eax
  105356:	25 ff 03 00 00       	and    $0x3ff,%eax
  10535b:	89 45 f0             	mov    %eax,-0x10(%ebp)

	uint32_t* vpd = vmm_alloc(0);
  10535e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  105365:	89 55 e0             	mov    %edx,-0x20(%ebp)
  105368:	e8 83 00 00 00       	call   1053f0 <vmm_alloc>
  10536d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	vmm_free(vpd);
  105370:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105373:	89 04 24             	mov    %eax,(%esp)
  105376:	e8 c5 00 00 00       	call   105440 <vmm_free>
  10537b:	b8 00 00 00 00       	mov    $0x0,%eax

	map_address_active((uint32_t) vpd, pdir, 0);
  105380:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105383:	8b 55 fc             	mov    -0x4(%ebp),%edx
  105386:	89 0c 24             	mov    %ecx,(%esp)
  105389:	89 54 24 04          	mov    %edx,0x4(%esp)
  10538d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105394:	00 
  105395:	89 45 dc             	mov    %eax,-0x24(%ebp)
  105398:	e8 23 01 00 00       	call   1054c0 <map_address_active>
  10539d:	b8 00 00 00 00       	mov    $0x0,%eax
	uint32_t table = vpd[pd_entry] & 0xFFFFF000;
  1053a2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1053a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1053a8:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  1053ab:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  1053b1:	89 4d e8             	mov    %ecx,-0x18(%ebp)

	map_address_active((uint32_t) vpd, table, 0);
  1053b4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1053b7:	8b 55 e8             	mov    -0x18(%ebp),%edx
  1053ba:	89 0c 24             	mov    %ecx,(%esp)
  1053bd:	89 54 24 04          	mov    %edx,0x4(%esp)
  1053c1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1053c8:	00 
  1053c9:	89 45 d8             	mov    %eax,-0x28(%ebp)
  1053cc:	e8 ef 00 00 00       	call   1054c0 <map_address_active>
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;
  1053d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  1053d4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1053d7:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  1053da:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1053df:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	return addr & 0xFFFFF000;
  1053e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1053e5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1053ea:	83 c4 38             	add    $0x38,%esp
  1053ed:	5d                   	pop    %ebp
  1053ee:	c3                   	ret    
  1053ef:	90                   	nop

001053f0 <vmm_alloc>:

void* vmm_alloc_cont(uint32_t cont) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
}

void* vmm_alloc(uint32_t* retpaddr) {
  1053f0:	55                   	push   %ebp
  1053f1:	89 e5                	mov    %esp,%ebp
  1053f3:	56                   	push   %esi
  1053f4:	83 ec 24             	sub    $0x24,%esp
  1053f7:	8b 45 08             	mov    0x8(%ebp),%eax
  1053fa:	b9 00 00 80 00       	mov    $0x800000,%ecx
  1053ff:	ba 00 00 00 20       	mov    $0x20000000,%edx
  105404:	be 01 00 00 00       	mov    $0x1,%esi
  105409:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
  10540c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10540f:	c7 04 24 00 00 80 00 	movl   $0x800000,(%esp)
  105416:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  10541d:	20 
  10541e:	89 44 24 08          	mov    %eax,0x8(%esp)
  105422:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
  105429:	00 
  10542a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10542d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105430:	89 55 ec             	mov    %edx,-0x14(%ebp)
  105433:	e8 e8 01 00 00       	call   105620 <vmm_alloc_in_range>
  105438:	83 c4 24             	add    $0x24,%esp
  10543b:	5e                   	pop    %esi
  10543c:	5d                   	pop    %ebp
  10543d:	c3                   	ret    
  10543e:	66 90                	xchg   %ax,%ax

00105440 <vmm_free>:
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
}

void vmm_free(void* p_vaddr) {
  105440:	55                   	push   %ebp
  105441:	89 e5                	mov    %esp,%ebp
  105443:	83 ec 18             	sub    $0x18,%esp
  105446:	8b 45 08             	mov    0x8(%ebp),%eax
  105449:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint32_t vaddr = (uint32_t) p_vaddr;
  10544c:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10544f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	if ((active_pagetables[vaddr >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  105452:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105455:	c1 e8 0c             	shr    $0xc,%eax
  105458:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  10545e:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105461:	25 01 02 00 00       	and    $0x201,%eax
  105466:	3d 01 02 00 00       	cmp    $0x201,%eax
  10546b:	0f 85 4a 00 00 00    	jne    1054bb <vmm_free+0x7b>
			== (PT_ALLOCATABLE | PT_PRESENT)) {
		pmm_free((void*) (active_pagetables[vaddr >> 12] & 0xFFFFF000));
  105471:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105474:	c1 e8 0c             	shr    $0xc,%eax
  105477:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  10547d:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105480:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  105485:	89 04 24             	mov    %eax,(%esp)
  105488:	e8 13 ce ff ff       	call   1022a0 <pmm_free>

		active_pagetables[vaddr >> 12] = PT_ALLOCATABLE
  10548d:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105490:	c1 e8 0c             	shr    $0xc,%eax
  105493:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  105499:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10549c:	25 04 00 00 00       	and    $0x4,%eax
  1054a1:	0d 00 02 00 00       	or     $0x200,%eax
  1054a6:	8b 4d f8             	mov    -0x8(%ebp),%ecx
  1054a9:	c1 e9 0c             	shr    $0xc,%ecx
  1054ac:	8b 15 c4 61 10 00    	mov    0x1061c4,%edx
  1054b2:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
				| (active_pagetables[vaddr >> 12] & PT_PUBLIC);
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  1054b5:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1054b8:	0f 01 38             	invlpg (%eax)
	}
}
  1054bb:	83 c4 18             	add    $0x18,%esp
  1054be:	5d                   	pop    %ebp
  1054bf:	c3                   	ret    

001054c0 <map_address_active>:
			& 0xFFFFF000) | PT_PRESENT | PT_WRITE | (flags & 0xFFF)
			| (((uint32_t*) (pagedir[pd_entry] & 0xFFFFF000))[pt_entry]
					& (PT_PUBLIC | PT_ALLOCATABLE));
}

void map_address_active(uint32_t vaddr, uint32_t paddr, uint32_t flags) {
  1054c0:	55                   	push   %ebp
  1054c1:	89 e5                	mov    %esp,%ebp
  1054c3:	83 ec 0c             	sub    $0xc,%esp
  1054c6:	8b 45 10             	mov    0x10(%ebp),%eax
  1054c9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  1054cc:	8b 55 08             	mov    0x8(%ebp),%edx
  1054cf:	89 55 fc             	mov    %edx,-0x4(%ebp)
  1054d2:	89 4d f8             	mov    %ecx,-0x8(%ebp)
  1054d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	active_pagetables[vaddr >> 12] = (paddr & 0xFFFFF000) | PT_PRESENT
  1054d8:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1054db:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  1054e0:	0d 01 00 00 00       	or     $0x1,%eax
  1054e5:	0d 02 00 00 00       	or     $0x2,%eax
  1054ea:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  1054ed:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
  1054f3:	09 c8                	or     %ecx,%eax
  1054f5:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  1054f8:	c1 e9 0c             	shr    $0xc,%ecx
  1054fb:	8b 15 c4 61 10 00    	mov    0x1061c4,%edx
  105501:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  105504:	81 e1 04 02 00 00    	and    $0x204,%ecx
  10550a:	09 c8                	or     %ecx,%eax
  10550c:	8b 4d fc             	mov    -0x4(%ebp),%ecx
  10550f:	c1 e9 0c             	shr    $0xc,%ecx
  105512:	8b 15 c4 61 10 00    	mov    0x1061c4,%edx
  105518:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
			| PT_WRITE | (flags & 0xFFF)
			| (active_pagetables[vaddr >> 12] & (PT_PUBLIC | PT_ALLOCATABLE));
	asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
  10551b:	8b 45 fc             	mov    -0x4(%ebp),%eax
  10551e:	0f 01 38             	invlpg (%eax)
}
  105521:	83 c4 0c             	add    $0xc,%esp
  105524:	5d                   	pop    %ebp
  105525:	c3                   	ret    
  105526:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%eax,%eax,1)
  10552d:	00 00 00 

00105530 <vmm_map_range>:
	uint32_t addr = vpd[pt_entry] & 0xFFFFF000;

	return addr & 0xFFFFF000;
}

void vmm_map_range(void* vaddr, void* paddr, uint32_t length, uint32_t flags) {
  105530:	55                   	push   %ebp
  105531:	89 e5                	mov    %esp,%ebp
  105533:	56                   	push   %esi
  105534:	83 ec 24             	sub    $0x24,%esp
  105537:	8b 45 14             	mov    0x14(%ebp),%eax
  10553a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10553d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105540:	8b 75 08             	mov    0x8(%ebp),%esi
  105543:	89 75 f8             	mov    %esi,-0x8(%ebp)
  105546:	89 55 f4             	mov    %edx,-0xc(%ebp)
  105549:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10554c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((uint32_t) vaddr & 0xFFF)
  10554f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105552:	25 ff 0f 00 00       	and    $0xfff,%eax
  105557:	3d 00 00 00 00       	cmp    $0x0,%eax
  10555c:	0f 84 05 00 00 00    	je     105567 <vmm_map_range+0x37>
		return;
  105562:	e9 5a 00 00 00       	jmp    1055c1 <vmm_map_range+0x91>
	if ((uint32_t) paddr & 0xFFF)
  105567:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10556a:	25 ff 0f 00 00       	and    $0xfff,%eax
  10556f:	3d 00 00 00 00       	cmp    $0x0,%eax
  105574:	0f 84 05 00 00 00    	je     10557f <vmm_map_range+0x4f>
		return;
  10557a:	e9 42 00 00 00       	jmp    1055c1 <vmm_map_range+0x91>

	for (uint32_t i = 0; i < length; i += 0x1000) {
  10557f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  105586:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105589:	3b 45 f0             	cmp    -0x10(%ebp),%eax
  10558c:	0f 83 2f 00 00 00    	jae    1055c1 <vmm_map_range+0x91>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
  105592:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105595:	03 45 e8             	add    -0x18(%ebp),%eax
  105598:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10559b:	03 4d e8             	add    -0x18(%ebp),%ecx
  10559e:	8b 55 ec             	mov    -0x14(%ebp),%edx
  1055a1:	89 04 24             	mov    %eax,(%esp)
  1055a4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  1055a8:	89 54 24 08          	mov    %edx,0x8(%esp)
  1055ac:	e8 0f ff ff ff       	call   1054c0 <map_address_active>
	if ((uint32_t) vaddr & 0xFFF)
		return;
	if ((uint32_t) paddr & 0xFFF)
		return;

	for (uint32_t i = 0; i < length; i += 0x1000) {
  1055b1:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1055b4:	05 00 10 00 00       	add    $0x1000,%eax
  1055b9:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1055bc:	e9 c5 ff ff ff       	jmp    105586 <vmm_map_range+0x56>
		map_address_active((uint32_t) vaddr + i, (uint32_t) paddr + i, flags);
	}
}
  1055c1:	83 c4 24             	add    $0x24,%esp
  1055c4:	5e                   	pop    %esi
  1055c5:	5d                   	pop    %ebp
  1055c6:	c3                   	ret    
  1055c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%eax,%eax,1)
  1055ce:	00 00 

001055d0 <vmm_alloc_ucont>:
	}

	return vaddr;
}

void* vmm_alloc_ucont(uint32_t cont) {
  1055d0:	55                   	push   %ebp
  1055d1:	89 e5                	mov    %esp,%ebp
  1055d3:	56                   	push   %esi
  1055d4:	83 ec 24             	sub    $0x24,%esp
  1055d7:	8b 45 08             	mov    0x8(%ebp),%eax
  1055da:	b9 00 10 40 20       	mov    $0x20401000,%ecx
  1055df:	ba 00 f0 ff ff       	mov    $0xfffff000,%edx
  1055e4:	be 00 00 00 00       	mov    $0x0,%esi
  1055e9:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, 0, cont);
  1055ec:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1055ef:	c7 04 24 00 10 40 20 	movl   $0x20401000,(%esp)
  1055f6:	c7 44 24 04 00 f0 ff 	movl   $0xfffff000,0x4(%esp)
  1055fd:	ff 
  1055fe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105605:	00 
  105606:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10560a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10560d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  105610:	89 55 ec             	mov    %edx,-0x14(%ebp)
  105613:	e8 08 00 00 00       	call   105620 <vmm_alloc_in_range>
  105618:	83 c4 24             	add    $0x24,%esp
  10561b:	5e                   	pop    %esi
  10561c:	5d                   	pop    %ebp
  10561d:	c3                   	ret    
  10561e:	66 90                	xchg   %ax,%ax

00105620 <vmm_alloc_in_range>:
		asm volatile("invlpg %0" : : "m" (*(char*)vaddr));
	}
}

static void* vmm_alloc_in_range(uint32_t low, uint32_t high, uint32_t* retpaddr,
		uint32_t cont) {
  105620:	55                   	push   %ebp
  105621:	89 e5                	mov    %esp,%ebp
  105623:	56                   	push   %esi
  105624:	83 ec 34             	sub    $0x34,%esp
  105627:	8b 45 14             	mov    0x14(%ebp),%eax
  10562a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  10562d:	8b 55 0c             	mov    0xc(%ebp),%edx
  105630:	8b 75 08             	mov    0x8(%ebp),%esi
  105633:	89 75 f8             	mov    %esi,-0x8(%ebp)
  105636:	89 55 f4             	mov    %edx,-0xc(%ebp)
  105639:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  10563c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	void* vaddr = 0;
  10563f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
	uint32_t i = 0;
  105646:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32_t c = 0;
  10564d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  105654:	8b 45 f8             	mov    -0x8(%ebp),%eax
  105657:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  10565c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  10565f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  105662:	3b 45 f4             	cmp    -0xc(%ebp),%eax
  105665:	0f 83 6f 00 00 00    	jae    1056da <vmm_alloc_in_range+0xba>
		if ((active_pagetables[i >> 12] & (PT_ALLOCATABLE | PT_PRESENT))
  10566b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10566e:	c1 e8 0c             	shr    $0xc,%eax
  105671:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  105677:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  10567a:	25 01 02 00 00       	and    $0x201,%eax
  10567f:	3d 00 02 00 00       	cmp    $0x200,%eax
  105684:	0f 85 34 00 00 00    	jne    1056be <vmm_alloc_in_range+0x9e>
				== PT_ALLOCATABLE) {
			if (c == 0)
  10568a:	81 7d e0 00 00 00 00 	cmpl   $0x0,-0x20(%ebp)
  105691:	0f 85 06 00 00 00    	jne    10569d <vmm_alloc_in_range+0x7d>
				vaddr = (void*) i;
  105697:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  10569a:	89 45 e8             	mov    %eax,-0x18(%ebp)
			c++;
  10569d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1056a0:	05 01 00 00 00       	add    $0x1,%eax
  1056a5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (c >= cont)
  1056a8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1056ab:	3b 45 ec             	cmp    -0x14(%ebp),%eax
  1056ae:	0f 82 05 00 00 00    	jb     1056b9 <vmm_alloc_in_range+0x99>
				break;
  1056b4:	e9 21 00 00 00       	jmp    1056da <vmm_alloc_in_range+0xba>
		} else {
  1056b9:	e9 07 00 00 00       	jmp    1056c5 <vmm_alloc_in_range+0xa5>
			c = 0;
  1056be:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
	}
  1056c5:	e9 00 00 00 00       	jmp    1056ca <vmm_alloc_in_range+0xaa>
		uint32_t cont) {
	void* vaddr = 0;
	uint32_t i = 0;
	uint32_t c = 0;

	for (i = (low & 0xFFFFF000); i < high; i += 0x1000) {
  1056ca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  1056cd:	05 00 10 00 00       	add    $0x1000,%eax
  1056d2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1056d5:	e9 85 ff ff ff       	jmp    10565f <vmm_alloc_in_range+0x3f>
		} else {
			c = 0;
		}
	}

	uint32_t off = 0;
  1056da:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

	while (c--) {
  1056e1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  1056e4:	89 c1                	mov    %eax,%ecx
  1056e6:	81 c1 ff ff ff ff    	add    $0xffffffff,%ecx
  1056ec:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  1056ef:	3d 00 00 00 00       	cmp    $0x0,%eax
  1056f4:	0f 84 59 00 00 00    	je     105753 <vmm_alloc_in_range+0x133>
		vmm_alloc_addr(vaddr + off * 0x1000, off == 0 ? retpaddr : 0);
  1056fa:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1056fd:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  105700:	c1 e1 0c             	shl    $0xc,%ecx
  105703:	01 c8                	add    %ecx,%eax
  105705:	81 7d dc 00 00 00 00 	cmpl   $0x0,-0x24(%ebp)
  10570c:	89 45 d8             	mov    %eax,-0x28(%ebp)
  10570f:	0f 85 0b 00 00 00    	jne    105720 <vmm_alloc_in_range+0x100>
  105715:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105718:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  10571b:	e9 0d 00 00 00       	jmp    10572d <vmm_alloc_in_range+0x10d>
  105720:	b8 00 00 00 00       	mov    $0x0,%eax
  105725:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  105728:	e9 00 00 00 00       	jmp    10572d <vmm_alloc_in_range+0x10d>
  10572d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  105730:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  105733:	89 0c 24             	mov    %ecx,(%esp)
  105736:	89 44 24 04          	mov    %eax,0x4(%esp)
  10573a:	e8 71 00 00 00       	call   1057b0 <vmm_alloc_addr>
		off++;
  10573f:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  105742:	81 c1 01 00 00 00    	add    $0x1,%ecx
  105748:	89 4d dc             	mov    %ecx,-0x24(%ebp)
	}
  10574b:	89 45 d0             	mov    %eax,-0x30(%ebp)
  10574e:	e9 8e ff ff ff       	jmp    1056e1 <vmm_alloc_in_range+0xc1>

	return vaddr;
  105753:	8b 45 e8             	mov    -0x18(%ebp),%eax
  105756:	83 c4 34             	add    $0x34,%esp
  105759:	5e                   	pop    %esi
  10575a:	5d                   	pop    %ebp
  10575b:	c3                   	ret    
  10575c:	0f 1f 40 00          	nopl   0x0(%eax)

00105760 <vmm_alloc_cont>:

void* vmm_alloc_user(uint32_t* retpaddr) {
	return vmm_alloc_in_range(PROGRAM_BOTTOM, 0xFFFFF000, retpaddr, 1);
}

void* vmm_alloc_cont(uint32_t cont) {
  105760:	55                   	push   %ebp
  105761:	89 e5                	mov    %esp,%ebp
  105763:	56                   	push   %esi
  105764:	83 ec 24             	sub    $0x24,%esp
  105767:	8b 45 08             	mov    0x8(%ebp),%eax
  10576a:	b9 00 00 80 00       	mov    $0x800000,%ecx
  10576f:	ba 00 00 00 20       	mov    $0x20000000,%edx
  105774:	be 00 00 00 00       	mov    $0x0,%esi
  105779:	89 45 f8             	mov    %eax,-0x8(%ebp)
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, 0, cont);
  10577c:	8b 45 f8             	mov    -0x8(%ebp),%eax
  10577f:	c7 04 24 00 00 80 00 	movl   $0x800000,(%esp)
  105786:	c7 44 24 04 00 00 00 	movl   $0x20000000,0x4(%esp)
  10578d:	20 
  10578e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  105795:	00 
  105796:	89 44 24 0c          	mov    %eax,0xc(%esp)
  10579a:	89 75 f4             	mov    %esi,-0xc(%ebp)
  10579d:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  1057a0:	89 55 ec             	mov    %edx,-0x14(%ebp)
  1057a3:	e8 78 fe ff ff       	call   105620 <vmm_alloc_in_range>
  1057a8:	83 c4 24             	add    $0x24,%esp
  1057ab:	5e                   	pop    %esi
  1057ac:	5d                   	pop    %ebp
  1057ad:	c3                   	ret    
  1057ae:	66 90                	xchg   %ax,%ax

001057b0 <vmm_alloc_addr>:

void* vmm_alloc(uint32_t* retpaddr) {
	return vmm_alloc_in_range(ALLOCATABLE_BOTTOM, USERSPACE_BOTTOM, retpaddr, 1);
}

void* vmm_alloc_addr(void* reqvaddr, uint32_t* retpaddr) {
  1057b0:	55                   	push   %ebp
  1057b1:	89 e5                	mov    %esp,%ebp
  1057b3:	56                   	push   %esi
  1057b4:	83 ec 34             	sub    $0x34,%esp
  1057b7:	8b 45 0c             	mov    0xc(%ebp),%eax
  1057ba:	8b 4d 08             	mov    0x8(%ebp),%ecx
  1057bd:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  1057c0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (reqvaddr == 0) {
  1057c3:	81 7d f4 00 00 00 00 	cmpl   $0x0,-0xc(%ebp)
  1057ca:	0f 85 34 00 00 00    	jne    105804 <vmm_alloc_addr+0x54>
  1057d0:	8d 05 cc 74 10 00    	lea    0x1074cc,%eax
  1057d6:	b9 00 00 00 00       	mov    $0x0,%ecx
		kprintf(
  1057db:	8b 55 f4             	mov    -0xc(%ebp),%edx
  1057de:	89 04 24             	mov    %eax,(%esp)
  1057e1:	89 54 24 04          	mov    %edx,0x4(%esp)
  1057e5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  1057ec:	00 
  1057ed:	89 4d e8             	mov    %ecx,-0x18(%ebp)
  1057f0:	e8 5b ad ff ff       	call   100550 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, 0);
		return 0;
  1057f5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  1057fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  1057ff:	e9 9b 00 00 00       	jmp    10589f <vmm_alloc_addr+0xef>
	}

	if ((active_pagetables[(uint32_t) reqvaddr >> 12]
  105804:	8b 45 f4             	mov    -0xc(%ebp),%eax
  105807:	c1 e8 0c             	shr    $0xc,%eax
  10580a:	8b 0d c4 61 10 00    	mov    0x1061c4,%ecx
  105810:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105813:	25 01 02 00 00       	and    $0x201,%eax
  105818:	3d 00 02 00 00       	cmp    $0x200,%eax
  10581d:	0f 84 37 00 00 00    	je     10585a <vmm_alloc_addr+0xaa>
  105823:	8d 05 cc 74 10 00    	lea    0x1074cc,%eax
			& (PT_ALLOCATABLE | PT_PRESENT)) != PT_ALLOCATABLE) {
		kprintf(
  105829:	8b 4d f4             	mov    -0xc(%ebp),%ecx
  10582c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  10582f:	c1 ea 0c             	shr    $0xc,%edx
  105832:	8b 35 c4 61 10 00    	mov    0x1061c4,%esi
  105838:	8b 14 96             	mov    (%esi,%edx,4),%edx
  10583b:	89 04 24             	mov    %eax,(%esp)
  10583e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105842:	89 54 24 08          	mov    %edx,0x8(%esp)
  105846:	e8 05 ad ff ff       	call   100550 <kprintf>
				"Denied vmm_alloc_addr at %x (Flags: %x) ... this is a potential mm-fault \n",
				reqvaddr, active_pagetables[(uint32_t) reqvaddr >> 12]);
		return 0;
  10584b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
  105852:	89 45 e0             	mov    %eax,-0x20(%ebp)
  105855:	e9 45 00 00 00       	jmp    10589f <vmm_alloc_addr+0xef>
  10585a:	b8 04 02 00 00       	mov    $0x204,%eax
	}

	uint32_t paddr = (uint32_t) pmm_alloc();
  10585f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  105862:	e8 19 c8 ff ff       	call   102080 <pmm_alloc>
  105867:	89 45 ec             	mov    %eax,-0x14(%ebp)
	map_address_active((uint32_t) reqvaddr, paddr, PT_PUBLIC | PT_ALLOCATABLE);
  10586a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10586d:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105870:	89 04 24             	mov    %eax,(%esp)
  105873:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  105877:	c7 44 24 08 04 02 00 	movl   $0x204,0x8(%esp)
  10587e:	00 
  10587f:	e8 3c fc ff ff       	call   1054c0 <map_address_active>

	if (retpaddr != 0)
  105884:	81 7d f0 00 00 00 00 	cmpl   $0x0,-0x10(%ebp)
  10588b:	0f 84 08 00 00 00    	je     105899 <vmm_alloc_addr+0xe9>
		*retpaddr = paddr;
  105891:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105894:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105897:	89 01                	mov    %eax,(%ecx)

	return reqvaddr;
  105899:	8b 45 f4             	mov    -0xc(%ebp),%eax
  10589c:	89 45 f8             	mov    %eax,-0x8(%ebp)
}
  10589f:	8b 45 f8             	mov    -0x8(%ebp),%eax
  1058a2:	83 c4 34             	add    $0x34,%esp
  1058a5:	5e                   	pop    %esi
  1058a6:	5d                   	pop    %ebp
  1058a7:	c3                   	ret    
  1058a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%eax,%eax,1)
  1058af:	00 

001058b0 <vmm_activate_pagedir>:

void vmm_activate_pagedir(uint32_t pdpaddr) {
  1058b0:	55                   	push   %ebp
  1058b1:	89 e5                	mov    %esp,%ebp
  1058b3:	50                   	push   %eax
  1058b4:	8b 45 08             	mov    0x8(%ebp),%eax
  1058b7:	89 45 fc             	mov    %eax,-0x4(%ebp)
	active_pagedir = pdpaddr;
  1058ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1058bd:	a3 58 94 10 00       	mov    %eax,0x109458
	asm volatile("mov %0, %%cr3" : : "r" (pdpaddr));
  1058c2:	8b 45 fc             	mov    -0x4(%ebp),%eax
  1058c5:	0f 22 d8             	mov    %eax,%cr3
}
  1058c8:	83 c4 04             	add    $0x4,%esp
  1058cb:	5d                   	pop    %ebp
  1058cc:	c3                   	ret    
  1058cd:	0f 1f 00             	nopl   (%eax)

001058d0 <vmm_init>:

uint32_t vmm_init(void) {
  1058d0:	55                   	push   %ebp
  1058d1:	89 e5                	mov    %esp,%ebp
	//CREATE CONTEXT ************************************************************

	struct vmm_context* context = pmm_alloc();
  1058d3:	53                   	push   %ebx
  1058d4:	57                   	push   %edi
  1058d5:	56                   	push   %esi
  1058d6:	83 ec 3c             	sub    $0x3c,%esp
  1058d9:	e8 a2 c7 ff ff       	call   102080 <pmm_alloc>
  1058de:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32_t i, i2;

	context->pagedir = pmm_alloc();
  1058e1:	e8 9a c7 ff ff       	call   102080 <pmm_alloc>
  1058e6:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  1058e9:	89 01                	mov    %eax,(%ecx)

	for (i = 0; i < 1024; i++) {
  1058eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1058f2:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  1058f9:	0f 83 d6 00 00 00    	jae    1059d5 <vmm_init+0x105>
		context->pagedir[i] = ((uint32_t) pmm_alloc());
  1058ff:	e8 7c c7 ff ff       	call   102080 <pmm_alloc>
  105904:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  105907:	8b 55 f0             	mov    -0x10(%ebp),%edx
  10590a:	8b 12                	mov    (%edx),%edx
  10590c:	89 04 8a             	mov    %eax,(%edx,%ecx,4)
		if (i < PMEM_TABLES) {
  10590f:	81 7d ec 80 00 00 00 	cmpl   $0x80,-0x14(%ebp)
  105916:	0f 83 15 00 00 00    	jae    105931 <vmm_init+0x61>
			kernel_pagetables[i] = context->pagedir[i];
  10591c:	8b 45 ec             	mov    -0x14(%ebp),%eax
  10591f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105922:	8b 09                	mov    (%ecx),%ecx
  105924:	8b 04 81             	mov    (%ecx,%eax,4),%eax
  105927:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10592a:	89 04 8d 90 94 18 00 	mov    %eax,0x189490(,%ecx,4)
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;
  105931:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105934:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105937:	8b 09                	mov    (%ecx),%ecx
  105939:	8b 14 81             	mov    (%ecx,%eax,4),%edx
  10593c:	81 ca 07 00 00 00    	or     $0x7,%edx
  105942:	89 14 81             	mov    %edx,(%ecx,%eax,4)

		for (i2 = 0; i2 < 1024; i2++) {
  105945:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
  10594c:	81 7d e8 00 04 00 00 	cmpl   $0x400,-0x18(%ebp)
  105953:	0f 83 67 00 00 00    	jae    1059c0 <vmm_init+0xf0>
  105959:	b8 04 00 00 00       	mov    $0x4,%eax
  10595e:	b9 00 00 00 00       	mov    $0x0,%ecx
  105963:	ba 00 02 00 00       	mov    $0x200,%edx
			uint32_t vaddr = (i << 22) + (i2 << 12);
  105968:	8b 75 ec             	mov    -0x14(%ebp),%esi
  10596b:	c1 e6 16             	shl    $0x16,%esi
  10596e:	8b 7d e8             	mov    -0x18(%ebp),%edi
  105971:	c1 e7 0c             	shl    $0xc,%edi
  105974:	01 fe                	add    %edi,%esi
  105976:	89 75 e4             	mov    %esi,-0x1c(%ebp)

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
  105979:	81 7d e4 00 00 80 00 	cmpl   $0x800000,-0x1c(%ebp)
  105980:	0f 97 c3             	seta   %bl
  105983:	84 db                	test   %bl,%bl
  105985:	0f 44 d1             	cmove  %ecx,%edx
  105988:	81 7d e4 00 10 40 20 	cmpl   $0x20401000,-0x1c(%ebp)
  10598f:	0f 97 c3             	seta   %bl
  105992:	84 db                	test   %bl,%bl
  105994:	0f 44 c1             	cmove  %ecx,%eax
  105997:	09 c2                	or     %eax,%edx
  105999:	8b 45 e8             	mov    -0x18(%ebp),%eax
  10599c:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  10599f:	8b 75 f0             	mov    -0x10(%ebp),%esi
  1059a2:	8b 36                	mov    (%esi),%esi
  1059a4:	8b 0c 8e             	mov    (%esi,%ecx,4),%ecx
  1059a7:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  1059ad:	89 14 81             	mov    %edx,(%ecx,%eax,4)
			kernel_pagetables[i] = context->pagedir[i];
		}

		context->pagedir[i] |= PD_PRESENT | PD_WRITE | PD_PUBLIC;

		for (i2 = 0; i2 < 1024; i2++) {
  1059b0:	8b 45 e8             	mov    -0x18(%ebp),%eax
  1059b3:	05 01 00 00 00       	add    $0x1,%eax
  1059b8:	89 45 e8             	mov    %eax,-0x18(%ebp)
  1059bb:	e9 8c ff ff ff       	jmp    10594c <vmm_init+0x7c>

			((uint32_t*) (context->pagedir[i] & 0xFFFFF000))[i2] = (
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}
  1059c0:	e9 00 00 00 00       	jmp    1059c5 <vmm_init+0xf5>
	struct vmm_context* context = pmm_alloc();
	uint32_t i, i2;

	context->pagedir = pmm_alloc();

	for (i = 0; i < 1024; i++) {
  1059c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  1059c8:	05 01 00 00 00       	add    $0x1,%eax
  1059cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
  1059d0:	e9 1d ff ff ff       	jmp    1058f2 <vmm_init+0x22>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  1059d5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  1059dc:	81 7d ec 00 04 00 00 	cmpl   $0x400,-0x14(%ebp)
  1059e3:	0f 83 5a 00 00 00    	jae    105a43 <vmm_init+0x173>
  1059e9:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
  1059ee:	8b 4d ec             	mov    -0x14(%ebp),%ecx
  1059f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
  1059f4:	8b 12                	mov    (%edx),%edx
  1059f6:	8b 0c 8a             	mov    (%edx,%ecx,4),%ecx
  1059f9:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
  1059ff:	89 4d e0             	mov    %ecx,-0x20(%ebp)
		map_address_context(context->pagedir,
  105a02:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105a05:	8b 09                	mov    (%ecx),%ecx
  105a07:	8b 15 c4 61 10 00    	mov    0x1061c4,%edx
  105a0d:	8b 75 ec             	mov    -0x14(%ebp),%esi
  105a10:	c1 e6 0c             	shl    $0xc,%esi
  105a13:	01 f2                	add    %esi,%edx
  105a15:	8b 75 e0             	mov    -0x20(%ebp),%esi
  105a18:	89 0c 24             	mov    %ecx,(%esp)
  105a1b:	89 54 24 04          	mov    %edx,0x4(%esp)
  105a1f:	89 74 24 08          	mov    %esi,0x8(%esp)
  105a23:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105a2a:	00 
  105a2b:	89 45 d8             	mov    %eax,-0x28(%ebp)
  105a2e:	e8 3d f7 ff ff       	call   105170 <map_address_context>
					(vaddr > ALLOCATABLE_BOTTOM) ? PT_ALLOCATABLE : 0)
					| ((vaddr > PROGRAM_BOTTOM) ? PT_PUBLIC : 0);
		}
	}

	for (i = 0; i < 1024; i++) {
  105a33:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105a36:	05 01 00 00 00       	add    $0x1,%eax
  105a3b:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105a3e:	e9 99 ff ff ff       	jmp    1059dc <vmm_init+0x10c>
  105a43:	b8 00 00 00 00       	mov    $0x0,%eax
		uint32_t paddr = context->pagedir[i] & 0xFFFFF000;
		map_address_context(context->pagedir,
				(uint32_t) active_pagetables + i * 0x1000, paddr, 0);
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
  105a48:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105a4b:	8b 09                	mov    (%ecx),%ecx
  105a4d:	8b 15 c8 61 10 00    	mov    0x1061c8,%edx
  105a53:	8b 75 f0             	mov    -0x10(%ebp),%esi
  105a56:	89 0c 24             	mov    %ecx,(%esp)
  105a59:	89 54 24 04          	mov    %edx,0x4(%esp)
  105a5d:	89 74 24 08          	mov    %esi,0x8(%esp)
  105a61:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105a68:	00 
  105a69:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  105a6c:	e8 ff f6 ff ff       	call   105170 <map_address_context>
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105a71:	c7 45 ec 00 10 00 00 	movl   $0x1000,-0x14(%ebp)
  105a78:	8d 05 00 a0 18 00    	lea    0x18a000,%eax
  105a7e:	39 45 ec             	cmp    %eax,-0x14(%ebp)
  105a81:	0f 83 3b 00 00 00    	jae    105ac2 <vmm_init+0x1f2>
  105a87:	b8 00 00 00 00       	mov    $0x0,%eax
		map_address_context(context->pagedir, i, i, 0);
  105a8c:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  105a8f:	8b 09                	mov    (%ecx),%ecx
  105a91:	8b 55 ec             	mov    -0x14(%ebp),%edx
  105a94:	8b 75 ec             	mov    -0x14(%ebp),%esi
  105a97:	89 0c 24             	mov    %ecx,(%esp)
  105a9a:	89 54 24 04          	mov    %edx,0x4(%esp)
  105a9e:	89 74 24 08          	mov    %esi,0x8(%esp)
  105aa2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  105aa9:	00 
  105aaa:	89 45 d0             	mov    %eax,-0x30(%ebp)
  105aad:	e8 be f6 ff ff       	call   105170 <map_address_context>
	}

	map_address_context(context->pagedir, (uint32_t) active_context,
			(uint32_t) context, 0);

	for (i = 0x1000; i < (uint32_t) &kernel_end; i += 0x1000) {
  105ab2:	8b 45 ec             	mov    -0x14(%ebp),%eax
  105ab5:	05 00 10 00 00       	add    $0x1000,%eax
  105aba:	89 45 ec             	mov    %eax,-0x14(%ebp)
  105abd:	e9 b6 ff ff ff       	jmp    105a78 <vmm_init+0x1a8>
		map_address_context(context->pagedir, i, i, 0);
	}

	//END CREATE CONTEXT ********************************************************

	vmm_activate_pagedir((uint32_t) context->pagedir);
  105ac2:	8b 45 f0             	mov    -0x10(%ebp),%eax
  105ac5:	8b 00                	mov    (%eax),%eax
  105ac7:	89 04 24             	mov    %eax,(%esp)
  105aca:	e8 e1 fd ff ff       	call   1058b0 <vmm_activate_pagedir>

	uint32_t cr0;

	asm volatile("mov %%cr0, %0" : "=r" (cr0));
  105acf:	0f 20 c0             	mov    %cr0,%eax
  105ad2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= (1 << 31);
  105ad5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105ad8:	0d 00 00 00 80       	or     $0x80000000,%eax
  105add:	89 45 dc             	mov    %eax,-0x24(%ebp)
	asm volatile("mov %0, %%cr0" : : "r" (cr0));
  105ae0:	8b 45 dc             	mov    -0x24(%ebp),%eax
  105ae3:	0f 22 c0             	mov    %eax,%cr0

	return (uint32_t) active_context->pagedir;
  105ae6:	a1 c8 61 10 00       	mov    0x1061c8,%eax
  105aeb:	8b 00                	mov    (%eax),%eax
  105aed:	83 c4 3c             	add    $0x3c,%esp
  105af0:	5e                   	pop    %esi
  105af1:	5f                   	pop    %edi
  105af2:	5b                   	pop    %ebx
  105af3:	5d                   	pop    %ebp
  105af4:	c3                   	ret    
  105af5:	66 90                	xchg   %ax,%ax
  105af7:	90                   	nop

00105af8 <_start>:
  105af8:	bc 5c 94 11 00       	mov    $0x11945c,%esp
  105afd:	53                   	push   %ebx
  105afe:	e8 0d a5 ff ff       	call   100010 <init>

00105b03 <_stop>:
  105b03:	fa                   	cli    
  105b04:	f4                   	hlt    
  105b05:	eb fc                	jmp    105b03 <_stop>
